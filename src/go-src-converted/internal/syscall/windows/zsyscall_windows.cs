// Code generated by 'go generate'; DO NOT EDIT.

// package windows -- go2cs converted at 2022 March 06 22:13:12 UTC
// import "internal/syscall/windows" ==> using windows = go.@internal.syscall.windows_package
// Original source: C:\Program Files\Go\src\internal\syscall\windows\zsyscall_windows.go
using sysdll = go.@internal.syscall.windows.sysdll_package;
using syscall = go.syscall_package;
using @unsafe = go.@unsafe_package;

namespace go.@internal.syscall;

public static partial class windows_package {

private static unsafe.Pointer _ = default;

// Do the interface allocations only once for common
// Errno values.
private static readonly nint errnoERROR_IO_PENDING = 997;


private static error errERROR_IO_PENDING = error.As(syscall.Errno(errnoERROR_IO_PENDING))!;private static error errERROR_EINVAL = error.As(syscall.EINVAL)!;

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
private static error errnoErr(syscall.Errno e) {

    if (e == 0) 
        return error.As(errERROR_EINVAL)!;
    else if (e == errnoERROR_IO_PENDING) 
        return error.As(errERROR_IO_PENDING)!;
    // TODO: add more here, after collecting data on the common
    // error values see on Windows. (perhaps when running
    // all.bat?)
    return error.As(e)!;

}

private static var modadvapi32 = syscall.NewLazyDLL(sysdll.Add("advapi32.dll"));private static var modiphlpapi = syscall.NewLazyDLL(sysdll.Add("iphlpapi.dll"));private static var modkernel32 = syscall.NewLazyDLL(sysdll.Add("kernel32.dll"));private static var modnetapi32 = syscall.NewLazyDLL(sysdll.Add("netapi32.dll"));private static var modpsapi = syscall.NewLazyDLL(sysdll.Add("psapi.dll"));private static var moduserenv = syscall.NewLazyDLL(sysdll.Add("userenv.dll"));private static var modws2_32 = syscall.NewLazyDLL(sysdll.Add("ws2_32.dll"));private static var procAdjustTokenPrivileges = modadvapi32.NewProc("AdjustTokenPrivileges");private static var procDuplicateTokenEx = modadvapi32.NewProc("DuplicateTokenEx");private static var procImpersonateSelf = modadvapi32.NewProc("ImpersonateSelf");private static var procLookupPrivilegeValueW = modadvapi32.NewProc("LookupPrivilegeValueW");private static var procOpenThreadToken = modadvapi32.NewProc("OpenThreadToken");private static var procRevertToSelf = modadvapi32.NewProc("RevertToSelf");private static var procSetTokenInformation = modadvapi32.NewProc("SetTokenInformation");private static var procSystemFunction036 = modadvapi32.NewProc("SystemFunction036");private static var procGetAdaptersAddresses = modiphlpapi.NewProc("GetAdaptersAddresses");private static var procGetACP = modkernel32.NewProc("GetACP");private static var procGetComputerNameExW = modkernel32.NewProc("GetComputerNameExW");private static var procGetConsoleCP = modkernel32.NewProc("GetConsoleCP");private static var procGetCurrentThread = modkernel32.NewProc("GetCurrentThread");private static var procGetFileInformationByHandleEx = modkernel32.NewProc("GetFileInformationByHandleEx");private static var procGetFinalPathNameByHandleW = modkernel32.NewProc("GetFinalPathNameByHandleW");private static var procGetModuleFileNameW = modkernel32.NewProc("GetModuleFileNameW");private static var procLockFileEx = modkernel32.NewProc("LockFileEx");private static var procMoveFileExW = modkernel32.NewProc("MoveFileExW");private static var procMultiByteToWideChar = modkernel32.NewProc("MultiByteToWideChar");private static var procSetFileInformationByHandle = modkernel32.NewProc("SetFileInformationByHandle");private static var procUnlockFileEx = modkernel32.NewProc("UnlockFileEx");private static var procNetShareAdd = modnetapi32.NewProc("NetShareAdd");private static var procNetShareDel = modnetapi32.NewProc("NetShareDel");private static var procNetUserGetLocalGroups = modnetapi32.NewProc("NetUserGetLocalGroups");private static var procGetProcessMemoryInfo = modpsapi.NewProc("GetProcessMemoryInfo");private static var procCreateEnvironmentBlock = moduserenv.NewProc("CreateEnvironmentBlock");private static var procDestroyEnvironmentBlock = moduserenv.NewProc("DestroyEnvironmentBlock");private static var procGetProfilesDirectoryW = moduserenv.NewProc("GetProfilesDirectoryW");private static var procWSASocketW = modws2_32.NewProc("WSASocketW");

private static (uint, error) adjustTokenPrivileges(syscall.Token token, bool disableAllPrivileges, ptr<TOKEN_PRIVILEGES> _addr_newstate, uint buflen, ptr<TOKEN_PRIVILEGES> _addr_prevstate, ptr<uint> _addr_returnlen) {
    uint ret = default;
    error err = default!;
    ref TOKEN_PRIVILEGES newstate = ref _addr_newstate.val;
    ref TOKEN_PRIVILEGES prevstate = ref _addr_prevstate.val;
    ref uint returnlen = ref _addr_returnlen.val;

    uint _p0 = default;
    if (disableAllPrivileges) {
        _p0 = 1;
    }
    var (r0, _, e1) = syscall.Syscall6(procAdjustTokenPrivileges.Addr(), 6, uintptr(token), uintptr(_p0), uintptr(@unsafe.Pointer(newstate)), uintptr(buflen), uintptr(@unsafe.Pointer(prevstate)), uintptr(@unsafe.Pointer(returnlen)));
    ret = uint32(r0);
    if (true) {
        err = errnoErr(e1);
    }
    return ;

}

public static error DuplicateTokenEx(syscall.Token hExistingToken, uint dwDesiredAccess, ptr<syscall.SecurityAttributes> _addr_lpTokenAttributes, uint impersonationLevel, TokenType tokenType, ptr<syscall.Token> _addr_phNewToken) {
    error err = default!;
    ref syscall.SecurityAttributes lpTokenAttributes = ref _addr_lpTokenAttributes.val;
    ref syscall.Token phNewToken = ref _addr_phNewToken.val;

    var (r1, _, e1) = syscall.Syscall6(procDuplicateTokenEx.Addr(), 6, uintptr(hExistingToken), uintptr(dwDesiredAccess), uintptr(@unsafe.Pointer(lpTokenAttributes)), uintptr(impersonationLevel), uintptr(tokenType), uintptr(@unsafe.Pointer(phNewToken)));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error ImpersonateSelf(uint impersonationlevel) {
    error err = default!;

    var (r1, _, e1) = syscall.Syscall(procImpersonateSelf.Addr(), 1, uintptr(impersonationlevel), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error LookupPrivilegeValue(ptr<ushort> _addr_systemname, ptr<ushort> _addr_name, ptr<LUID> _addr_luid) {
    error err = default!;
    ref ushort systemname = ref _addr_systemname.val;
    ref ushort name = ref _addr_name.val;
    ref LUID luid = ref _addr_luid.val;

    var (r1, _, e1) = syscall.Syscall(procLookupPrivilegeValueW.Addr(), 3, uintptr(@unsafe.Pointer(systemname)), uintptr(@unsafe.Pointer(name)), uintptr(@unsafe.Pointer(luid)));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error OpenThreadToken(syscall.Handle h, uint access, bool openasself, ptr<syscall.Token> _addr_token) {
    error err = default!;
    ref syscall.Token token = ref _addr_token.val;

    uint _p0 = default;
    if (openasself) {
        _p0 = 1;
    }
    var (r1, _, e1) = syscall.Syscall6(procOpenThreadToken.Addr(), 4, uintptr(h), uintptr(access), uintptr(_p0), uintptr(@unsafe.Pointer(token)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error RevertToSelf() {
    error err = default!;

    var (r1, _, e1) = syscall.Syscall(procRevertToSelf.Addr(), 0, 0, 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error SetTokenInformation(syscall.Token tokenHandle, uint tokenInformationClass, System.UIntPtr tokenInformation, uint tokenInformationLength) {
    error err = default!;

    var (r1, _, e1) = syscall.Syscall6(procSetTokenInformation.Addr(), 4, uintptr(tokenHandle), uintptr(tokenInformationClass), uintptr(tokenInformation), uintptr(tokenInformationLength), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error RtlGenRandom(slice<byte> buf) {
    error err = default!;

    ptr<byte> _p0;
    if (len(buf) > 0) {
        _p0 = _addr_buf[0];
    }
    var (r1, _, e1) = syscall.Syscall(procSystemFunction036.Addr(), 2, uintptr(@unsafe.Pointer(_p0)), uintptr(len(buf)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error GetAdaptersAddresses(uint family, uint flags, System.UIntPtr reserved, ptr<IpAdapterAddresses> _addr_adapterAddresses, ptr<uint> _addr_sizePointer) {
    error errcode = default!;
    ref IpAdapterAddresses adapterAddresses = ref _addr_adapterAddresses.val;
    ref uint sizePointer = ref _addr_sizePointer.val;

    var (r0, _, _) = syscall.Syscall6(procGetAdaptersAddresses.Addr(), 5, uintptr(family), uintptr(flags), uintptr(reserved), uintptr(@unsafe.Pointer(adapterAddresses)), uintptr(@unsafe.Pointer(sizePointer)), 0);
    if (r0 != 0) {
        errcode = syscall.Errno(r0);
    }
    return ;

}

public static uint GetACP() {
    uint acp = default;

    var (r0, _, _) = syscall.Syscall(procGetACP.Addr(), 0, 0, 0, 0);
    acp = uint32(r0);
    return ;
}

public static error GetComputerNameEx(uint nameformat, ptr<ushort> _addr_buf, ptr<uint> _addr_n) {
    error err = default!;
    ref ushort buf = ref _addr_buf.val;
    ref uint n = ref _addr_n.val;

    var (r1, _, e1) = syscall.Syscall(procGetComputerNameExW.Addr(), 3, uintptr(nameformat), uintptr(@unsafe.Pointer(buf)), uintptr(@unsafe.Pointer(n)));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static uint GetConsoleCP() {
    uint ccp = default;

    var (r0, _, _) = syscall.Syscall(procGetConsoleCP.Addr(), 0, 0, 0, 0);
    ccp = uint32(r0);
    return ;
}

public static (syscall.Handle, error) GetCurrentThread() {
    syscall.Handle pseudoHandle = default;
    error err = default!;

    var (r0, _, e1) = syscall.Syscall(procGetCurrentThread.Addr(), 0, 0, 0, 0);
    pseudoHandle = syscall.Handle(r0);
    if (pseudoHandle == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error GetFileInformationByHandleEx(syscall.Handle handle, uint @class, ptr<byte> _addr_info, uint bufsize) {
    error err = default!;
    ref byte info = ref _addr_info.val;

    var (r1, _, e1) = syscall.Syscall6(procGetFileInformationByHandleEx.Addr(), 4, uintptr(handle), uintptr(class), uintptr(@unsafe.Pointer(info)), uintptr(bufsize), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static (uint, error) GetFinalPathNameByHandle(syscall.Handle file, ptr<ushort> _addr_filePath, uint filePathSize, uint flags) {
    uint n = default;
    error err = default!;
    ref ushort filePath = ref _addr_filePath.val;

    var (r0, _, e1) = syscall.Syscall6(procGetFinalPathNameByHandleW.Addr(), 4, uintptr(file), uintptr(@unsafe.Pointer(filePath)), uintptr(filePathSize), uintptr(flags), 0, 0);
    n = uint32(r0);
    if (n == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static (uint, error) GetModuleFileName(syscall.Handle module, ptr<ushort> _addr_fn, uint len) {
    uint n = default;
    error err = default!;
    ref ushort fn = ref _addr_fn.val;

    var (r0, _, e1) = syscall.Syscall(procGetModuleFileNameW.Addr(), 3, uintptr(module), uintptr(@unsafe.Pointer(fn)), uintptr(len));
    n = uint32(r0);
    if (n == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error LockFileEx(syscall.Handle file, uint flags, uint reserved, uint bytesLow, uint bytesHigh, ptr<syscall.Overlapped> _addr_overlapped) {
    error err = default!;
    ref syscall.Overlapped overlapped = ref _addr_overlapped.val;

    var (r1, _, e1) = syscall.Syscall6(procLockFileEx.Addr(), 6, uintptr(file), uintptr(flags), uintptr(reserved), uintptr(bytesLow), uintptr(bytesHigh), uintptr(@unsafe.Pointer(overlapped)));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error MoveFileEx(ptr<ushort> _addr_from, ptr<ushort> _addr_to, uint flags) {
    error err = default!;
    ref ushort from = ref _addr_from.val;
    ref ushort to = ref _addr_to.val;

    var (r1, _, e1) = syscall.Syscall(procMoveFileExW.Addr(), 3, uintptr(@unsafe.Pointer(from)), uintptr(@unsafe.Pointer(to)), uintptr(flags));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static (int, error) MultiByteToWideChar(uint codePage, uint dwFlags, ptr<byte> _addr_str, int nstr, ptr<ushort> _addr_wchar, int nwchar) {
    int nwrite = default;
    error err = default!;
    ref byte str = ref _addr_str.val;
    ref ushort wchar = ref _addr_wchar.val;

    var (r0, _, e1) = syscall.Syscall6(procMultiByteToWideChar.Addr(), 6, uintptr(codePage), uintptr(dwFlags), uintptr(@unsafe.Pointer(str)), uintptr(nstr), uintptr(@unsafe.Pointer(wchar)), uintptr(nwchar));
    nwrite = int32(r0);
    if (nwrite == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error SetFileInformationByHandle(syscall.Handle handle, uint fileInformationClass, System.UIntPtr buf, uint bufsize) {
    error err = default!;

    var (r1, _, e1) = syscall.Syscall6(procSetFileInformationByHandle.Addr(), 4, uintptr(handle), uintptr(fileInformationClass), uintptr(buf), uintptr(bufsize), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error UnlockFileEx(syscall.Handle file, uint reserved, uint bytesLow, uint bytesHigh, ptr<syscall.Overlapped> _addr_overlapped) {
    error err = default!;
    ref syscall.Overlapped overlapped = ref _addr_overlapped.val;

    var (r1, _, e1) = syscall.Syscall6(procUnlockFileEx.Addr(), 5, uintptr(file), uintptr(reserved), uintptr(bytesLow), uintptr(bytesHigh), uintptr(@unsafe.Pointer(overlapped)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error NetShareAdd(ptr<ushort> _addr_serverName, uint level, ptr<byte> _addr_buf, ptr<ushort> _addr_parmErr) {
    error neterr = default!;
    ref ushort serverName = ref _addr_serverName.val;
    ref byte buf = ref _addr_buf.val;
    ref ushort parmErr = ref _addr_parmErr.val;

    var (r0, _, _) = syscall.Syscall6(procNetShareAdd.Addr(), 4, uintptr(@unsafe.Pointer(serverName)), uintptr(level), uintptr(@unsafe.Pointer(buf)), uintptr(@unsafe.Pointer(parmErr)), 0, 0);
    if (r0 != 0) {
        neterr = syscall.Errno(r0);
    }
    return ;

}

public static error NetShareDel(ptr<ushort> _addr_serverName, ptr<ushort> _addr_netName, uint reserved) {
    error neterr = default!;
    ref ushort serverName = ref _addr_serverName.val;
    ref ushort netName = ref _addr_netName.val;

    var (r0, _, _) = syscall.Syscall(procNetShareDel.Addr(), 3, uintptr(@unsafe.Pointer(serverName)), uintptr(@unsafe.Pointer(netName)), uintptr(reserved));
    if (r0 != 0) {
        neterr = syscall.Errno(r0);
    }
    return ;

}

public static error NetUserGetLocalGroups(ptr<ushort> _addr_serverName, ptr<ushort> _addr_userName, uint level, uint flags, ptr<ptr<byte>> _addr_buf, uint prefMaxLen, ptr<uint> _addr_entriesRead, ptr<uint> _addr_totalEntries) {
    error neterr = default!;
    ref ushort serverName = ref _addr_serverName.val;
    ref ushort userName = ref _addr_userName.val;
    ref ptr<byte> buf = ref _addr_buf.val;
    ref uint entriesRead = ref _addr_entriesRead.val;
    ref uint totalEntries = ref _addr_totalEntries.val;

    var (r0, _, _) = syscall.Syscall9(procNetUserGetLocalGroups.Addr(), 8, uintptr(@unsafe.Pointer(serverName)), uintptr(@unsafe.Pointer(userName)), uintptr(level), uintptr(flags), uintptr(@unsafe.Pointer(buf)), uintptr(prefMaxLen), uintptr(@unsafe.Pointer(entriesRead)), uintptr(@unsafe.Pointer(totalEntries)), 0);
    if (r0 != 0) {
        neterr = syscall.Errno(r0);
    }
    return ;

}

public static error GetProcessMemoryInfo(syscall.Handle handle, ptr<PROCESS_MEMORY_COUNTERS> _addr_memCounters, uint cb) {
    error err = default!;
    ref PROCESS_MEMORY_COUNTERS memCounters = ref _addr_memCounters.val;

    var (r1, _, e1) = syscall.Syscall(procGetProcessMemoryInfo.Addr(), 3, uintptr(handle), uintptr(@unsafe.Pointer(memCounters)), uintptr(cb));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error CreateEnvironmentBlock(ptr<ptr<ushort>> _addr_block, syscall.Token token, bool inheritExisting) {
    error err = default!;
    ref ptr<ushort> block = ref _addr_block.val;

    uint _p0 = default;
    if (inheritExisting) {
        _p0 = 1;
    }
    var (r1, _, e1) = syscall.Syscall(procCreateEnvironmentBlock.Addr(), 3, uintptr(@unsafe.Pointer(block)), uintptr(token), uintptr(_p0));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error DestroyEnvironmentBlock(ptr<ushort> _addr_block) {
    error err = default!;
    ref ushort block = ref _addr_block.val;

    var (r1, _, e1) = syscall.Syscall(procDestroyEnvironmentBlock.Addr(), 1, uintptr(@unsafe.Pointer(block)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static error GetProfilesDirectory(ptr<ushort> _addr_dir, ptr<uint> _addr_dirLen) {
    error err = default!;
    ref ushort dir = ref _addr_dir.val;
    ref uint dirLen = ref _addr_dirLen.val;

    var (r1, _, e1) = syscall.Syscall(procGetProfilesDirectoryW.Addr(), 2, uintptr(@unsafe.Pointer(dir)), uintptr(@unsafe.Pointer(dirLen)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return ;

}

public static (syscall.Handle, error) WSASocket(int af, int typ, int protocol, ptr<syscall.WSAProtocolInfo> _addr_protinfo, uint group, uint flags) {
    syscall.Handle handle = default;
    error err = default!;
    ref syscall.WSAProtocolInfo protinfo = ref _addr_protinfo.val;

    var (r0, _, e1) = syscall.Syscall6(procWSASocketW.Addr(), 6, uintptr(af), uintptr(typ), uintptr(protocol), uintptr(@unsafe.Pointer(protinfo)), uintptr(group), uintptr(flags));
    handle = syscall.Handle(r0);
    if (handle == syscall.InvalidHandle) {
        err = errnoErr(e1);
    }
    return ;

}

} // end windows_package
