//go:build !nethttpomithttp2
// +build !nethttpomithttp2

// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.
//   $ bundle -o=h2_bundle.go -prefix=http2 -tags=!nethttpomithttp2 golang.org/x/net/http2

// Package http2 implements the HTTP/2 protocol.
//
// This package is low-level and intended to be used directly by very
// few people. Most users will use it indirectly through the automatic
// use by the net/http package (from Go 1.6 and later).
// For use in earlier Go versions see ConfigureServer. (Transport support
// requires Go 1.6 or later)
//
// See https://http2.github.io/ for more information on HTTP/2.
//
// See https://http2.golang.org/ for a test server running this code.
//

// package http -- go2cs converted at 2022 March 13 05:37:08 UTC
// import "net/http" ==> using http = go.net.http_package
// Original source: C:\Program Files\Go\src\net\http\h2_bundle.go
namespace go.net;

using bufio = bufio_package;
using bytes = bytes_package;
using gzip = compress.gzip_package;
using context = context_package;
using rand = crypto.rand_package;
using tls = crypto.tls_package;
using binary = encoding.binary_package;
using errors = errors_package;
using fmt = fmt_package;
using io = io_package;
using ioutil = io.ioutil_package;
using log = log_package;
using math = math_package;
using mathrand = math.rand_package;
using net = net_package;
using httptrace = net.http.httptrace_package;
using textproto = net.textproto_package;
using url = net.url_package;
using os = os_package;
using reflect = reflect_package;
using runtime = runtime_package;
using sort = sort_package;
using strconv = strconv_package;
using strings = strings_package;
using sync = sync_package;
using atomic = sync.atomic_package;
using time = time_package;

using httpguts = golang.org.x.net.http.httpguts_package;
using hpack = golang.org.x.net.http2.hpack_package;
using idna = golang.org.x.net.idna_package;


// asciiEqualFold is strings.EqualFold, ASCII only. It reports whether s and t
// are equal, ASCII-case-insensitively.

using System.Threading;
using System;
public static partial class http_package {

private static bool http2asciiEqualFold(@string s, @string t) {
    if (len(s) != len(t)) {
        return false;
    }
    for (nint i = 0; i < len(s); i++) {
        if (http2lower(s[i]) != http2lower(t[i])) {
            return false;
        }
    }
    return true;
}

// lower returns the ASCII lowercase version of b.
private static byte http2lower(byte b) {
    if ('A' <= b && b <= 'Z') {
        return b + ('a' - 'A');
    }
    return b;
}

// isASCIIPrint returns whether s is ASCII and printable according to
// https://tools.ietf.org/html/rfc20#section-4.2.
private static bool http2isASCIIPrint(@string s) {
    for (nint i = 0; i < len(s); i++) {
        if (s[i] < ' ' || s[i] > '~') {
            return false;
        }
    }
    return true;
}

// asciiToLower returns the lowercase version of s if s is ASCII and printable,
// and whether or not it was.
private static (@string, bool) http2asciiToLower(@string s) {
    @string lower = default;
    bool ok = default;

    if (!http2isASCIIPrint(s)) {
        return ("", false);
    }
    return (strings.ToLower(s), true);
}

// A list of the possible cipher suite ids. Taken from
// https://www.iana.org/assignments/tls-parameters/tls-parameters.txt

private static readonly ushort http2cipher_TLS_NULL_WITH_NULL_NULL = 0x0000;
private static readonly ushort http2cipher_TLS_RSA_WITH_NULL_MD5 = 0x0001;
private static readonly ushort http2cipher_TLS_RSA_WITH_NULL_SHA = 0x0002;
private static readonly ushort http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5 = 0x0003;
private static readonly ushort http2cipher_TLS_RSA_WITH_RC4_128_MD5 = 0x0004;
private static readonly ushort http2cipher_TLS_RSA_WITH_RC4_128_SHA = 0x0005;
private static readonly ushort http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = 0x0006;
private static readonly ushort http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA = 0x0007;
private static readonly ushort http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x0008;
private static readonly ushort http2cipher_TLS_RSA_WITH_DES_CBC_SHA = 0x0009;
private static readonly ushort http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA = 0x000A;
private static readonly ushort http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = 0x000B;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA = 0x000C;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = 0x000D;
private static readonly ushort http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x000E;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA = 0x000F;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = 0x0010;
private static readonly ushort http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = 0x0011;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA = 0x0012;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = 0x0013;
private static readonly ushort http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = 0x0014;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA = 0x0015;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 0x0016;
private static readonly ushort http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = 0x0017;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_RC4_128_MD5 = 0x0018;
private static readonly ushort http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = 0x0019;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA = 0x001A;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = 0x001B; 
// Reserved uint16 =  0x001C-1D
private static readonly ushort http2cipher_TLS_KRB5_WITH_DES_CBC_SHA = 0x001E;
private static readonly ushort http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA = 0x001F;
private static readonly ushort http2cipher_TLS_KRB5_WITH_RC4_128_SHA = 0x0020;
private static readonly ushort http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA = 0x0021;
private static readonly ushort http2cipher_TLS_KRB5_WITH_DES_CBC_MD5 = 0x0022;
private static readonly ushort http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = 0x0023;
private static readonly ushort http2cipher_TLS_KRB5_WITH_RC4_128_MD5 = 0x0024;
private static readonly ushort http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5 = 0x0025;
private static readonly ushort http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = 0x0026;
private static readonly ushort http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = 0x0027;
private static readonly ushort http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA = 0x0028;
private static readonly ushort http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = 0x0029;
private static readonly ushort http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = 0x002A;
private static readonly ushort http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = 0x002B;
private static readonly ushort http2cipher_TLS_PSK_WITH_NULL_SHA = 0x002C;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_NULL_SHA = 0x002D;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_NULL_SHA = 0x002E;
private static readonly ushort http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA = 0x002F;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA = 0x0030;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA = 0x0031;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA = 0x0032;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA = 0x0033;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA = 0x0034;
private static readonly ushort http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA = 0x0035;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA = 0x0036;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA = 0x0037;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA = 0x0038;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA = 0x0039;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA = 0x003A;
private static readonly ushort http2cipher_TLS_RSA_WITH_NULL_SHA256 = 0x003B;
private static readonly ushort http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256 = 0x003C;
private static readonly ushort http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256 = 0x003D;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = 0x003E;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = 0x003F;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = 0x0040;
private static readonly ushort http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0041;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = 0x0042;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0043;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = 0x0044;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = 0x0045;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = 0x0046; 
// Reserved uint16 =  0x0047-4F
// Reserved uint16 =  0x0050-58
// Reserved uint16 =  0x0059-5C
// Unassigned uint16 =  0x005D-5F
// Reserved uint16 =  0x0060-66
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = 0x0067;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = 0x0068;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = 0x0069;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = 0x006A;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = 0x006B;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256 = 0x006C;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256 = 0x006D; 
// Unassigned uint16 =  0x006E-83
private static readonly ushort http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0084;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = 0x0085;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0086;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = 0x0087;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = 0x0088;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = 0x0089;
private static readonly ushort http2cipher_TLS_PSK_WITH_RC4_128_SHA = 0x008A;
private static readonly ushort http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA = 0x008B;
private static readonly ushort http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA = 0x008C;
private static readonly ushort http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA = 0x008D;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA = 0x008E;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = 0x008F;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA = 0x0090;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA = 0x0091;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA = 0x0092;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = 0x0093;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA = 0x0094;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA = 0x0095;
private static readonly ushort http2cipher_TLS_RSA_WITH_SEED_CBC_SHA = 0x0096;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA = 0x0097;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA = 0x0098;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA = 0x0099;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA = 0x009A;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA = 0x009B;
private static readonly ushort http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256 = 0x009C;
private static readonly ushort http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384 = 0x009D;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = 0x009E;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = 0x009F;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = 0x00A0;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = 0x00A1;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = 0x00A2;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = 0x00A3;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = 0x00A4;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = 0x00A5;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256 = 0x00A6;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384 = 0x00A7;
private static readonly ushort http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256 = 0x00A8;
private static readonly ushort http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384 = 0x00A9;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = 0x00AA;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = 0x00AB;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = 0x00AC;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = 0x00AD;
private static readonly ushort http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256 = 0x00AE;
private static readonly ushort http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384 = 0x00AF;
private static readonly ushort http2cipher_TLS_PSK_WITH_NULL_SHA256 = 0x00B0;
private static readonly ushort http2cipher_TLS_PSK_WITH_NULL_SHA384 = 0x00B1;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = 0x00B2;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = 0x00B3;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256 = 0x00B4;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384 = 0x00B5;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = 0x00B6;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = 0x00B7;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256 = 0x00B8;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384 = 0x00B9;
private static readonly ushort http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BA;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BB;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BC;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BD;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BE;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = 0x00BF;
private static readonly ushort http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C0;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C1;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C2;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C3;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C4;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = 0x00C5; 
// Unassigned uint16 =  0x00C6-FE
private static readonly ushort http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV = 0x00FF; 
// Unassigned uint16 =  0x01-55,*
private static readonly ushort http2cipher_TLS_FALLBACK_SCSV = 0x5600; 
// Unassigned                                   uint16 = 0x5601 - 0xC000
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA = 0xC001;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA = 0xC002;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xC003;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = 0xC004;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = 0xC005;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA = 0xC006;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = 0xC007;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = 0xC008;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 0xC009;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 0xC00A;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA = 0xC00B;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA = 0xC00C;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = 0xC00D;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = 0xC00E;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = 0xC00F;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA = 0xC010;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA = 0xC011;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = 0xC012;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 0xC013;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 0xC014;
private static readonly ushort http2cipher_TLS_ECDH_anon_WITH_NULL_SHA = 0xC015;
private static readonly ushort http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA = 0xC016;
private static readonly ushort http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = 0xC017;
private static readonly ushort http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA = 0xC018;
private static readonly ushort http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA = 0xC019;
private static readonly ushort http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = 0xC01A;
private static readonly ushort http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = 0xC01B;
private static readonly ushort http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = 0xC01C;
private static readonly ushort http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA = 0xC01D;
private static readonly ushort http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = 0xC01E;
private static readonly ushort http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = 0xC01F;
private static readonly ushort http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA = 0xC020;
private static readonly ushort http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = 0xC021;
private static readonly ushort http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = 0xC022;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC023;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC024;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC025;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC026;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 0xC027;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 0xC028;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = 0xC029;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = 0xC02A;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02B;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02C;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02D;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02E;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0xC02F;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 0xC030;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = 0xC031;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = 0xC032;
private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA = 0xC033;
private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = 0xC034;
private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = 0xC035;
private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = 0xC036;
private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = 0xC037;
private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = 0xC038;
private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA = 0xC039;
private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256 = 0xC03A;
private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384 = 0xC03B;
private static readonly ushort http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256 = 0xC03C;
private static readonly ushort http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384 = 0xC03D;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = 0xC03E;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = 0xC03F;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = 0xC040;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = 0xC041;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = 0xC042;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = 0xC043;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = 0xC044;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = 0xC045;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = 0xC046;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = 0xC047;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = 0xC048;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = 0xC049;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = 0xC04A;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = 0xC04B;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = 0xC04C;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = 0xC04D;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = 0xC04E;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = 0xC04F;
private static readonly ushort http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256 = 0xC050;
private static readonly ushort http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384 = 0xC051;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = 0xC052;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = 0xC053;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = 0xC054;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = 0xC055;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = 0xC056;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = 0xC057;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = 0xC058;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = 0xC059;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = 0xC05A;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = 0xC05B;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = 0xC05C;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = 0xC05D;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = 0xC05E;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = 0xC05F;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = 0xC060;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = 0xC061;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = 0xC062;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = 0xC063;
private static readonly ushort http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256 = 0xC064;
private static readonly ushort http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384 = 0xC065;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = 0xC066;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = 0xC067;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = 0xC068;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = 0xC069;
private static readonly ushort http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256 = 0xC06A;
private static readonly ushort http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384 = 0xC06B;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = 0xC06C;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = 0xC06D;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = 0xC06E;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = 0xC06F;
private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = 0xC070;
private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = 0xC071;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC072;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC073;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC074;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC075;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC076;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC077;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = 0xC078;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = 0xC079;
private static readonly ushort http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC07A;
private static readonly ushort http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC07B;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC07C;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC07D;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC07E;
private static readonly ushort http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC07F;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = 0xC080;
private static readonly ushort http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = 0xC081;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = 0xC082;
private static readonly ushort http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = 0xC083;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = 0xC084;
private static readonly ushort http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = 0xC085;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC086;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC087;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC088;
private static readonly ushort http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC089;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC08A;
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC08B;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = 0xC08C;
private static readonly ushort http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = 0xC08D;
private static readonly ushort http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 0xC08E;
private static readonly ushort http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 0xC08F;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 0xC090;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 0xC091;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = 0xC092;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = 0xC093;
private static readonly ushort http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC094;
private static readonly ushort http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC095;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC096;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC097;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC098;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC099;
private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = 0xC09A;
private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = 0xC09B;
private static readonly ushort http2cipher_TLS_RSA_WITH_AES_128_CCM = 0xC09C;
private static readonly ushort http2cipher_TLS_RSA_WITH_AES_256_CCM = 0xC09D;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM = 0xC09E;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM = 0xC09F;
private static readonly ushort http2cipher_TLS_RSA_WITH_AES_128_CCM_8 = 0xC0A0;
private static readonly ushort http2cipher_TLS_RSA_WITH_AES_256_CCM_8 = 0xC0A1;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8 = 0xC0A2;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8 = 0xC0A3;
private static readonly ushort http2cipher_TLS_PSK_WITH_AES_128_CCM = 0xC0A4;
private static readonly ushort http2cipher_TLS_PSK_WITH_AES_256_CCM = 0xC0A5;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM = 0xC0A6;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM = 0xC0A7;
private static readonly ushort http2cipher_TLS_PSK_WITH_AES_128_CCM_8 = 0xC0A8;
private static readonly ushort http2cipher_TLS_PSK_WITH_AES_256_CCM_8 = 0xC0A9;
private static readonly ushort http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8 = 0xC0AA;
private static readonly ushort http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8 = 0xC0AB;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM = 0xC0AC;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM = 0xC0AD;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = 0xC0AE;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = 0xC0AF; 
// Unassigned uint16 =  0xC0B0-FF
// Unassigned uint16 =  0xC1-CB,*
// Unassigned uint16 =  0xCC00-A7
private static readonly ushort http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA8;
private static readonly ushort http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA9;
private static readonly ushort http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAA;
private static readonly ushort http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAB;
private static readonly ushort http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAC;
private static readonly ushort http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAD;
private static readonly ushort http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = 0xCCAE;

// isBadCipher reports whether the cipher is blacklisted by the HTTP/2 spec.
// References:
// https://tools.ietf.org/html/rfc7540#appendix-A
// Reject cipher suites from Appendix A.
// "This list includes those cipher suites that do not
// offer an ephemeral key exchange and those that are
// based on the TLS null, stream or block cipher type"
private static bool http2isBadCipher(ushort cipher) {

    if (cipher == http2cipher_TLS_NULL_WITH_NULL_NULL || cipher == http2cipher_TLS_RSA_WITH_NULL_MD5 || cipher == http2cipher_TLS_RSA_WITH_NULL_SHA || cipher == http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5 || cipher == http2cipher_TLS_RSA_WITH_RC4_128_MD5 || cipher == http2cipher_TLS_RSA_WITH_RC4_128_SHA || cipher == http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 || cipher == http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA || cipher == http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA || cipher == http2cipher_TLS_RSA_WITH_DES_CBC_SHA || cipher == http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 || cipher == http2cipher_TLS_DH_anon_WITH_RC4_128_MD5 || cipher == http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA || cipher == http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA || cipher == http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_KRB5_WITH_DES_CBC_SHA || cipher == http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_KRB5_WITH_RC4_128_SHA || cipher == http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA || cipher == http2cipher_TLS_KRB5_WITH_DES_CBC_MD5 || cipher == http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5 || cipher == http2cipher_TLS_KRB5_WITH_RC4_128_MD5 || cipher == http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5 || cipher == http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA || cipher == http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA || cipher == http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA || cipher == http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 || cipher == http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 || cipher == http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5 || cipher == http2cipher_TLS_PSK_WITH_NULL_SHA || cipher == http2cipher_TLS_DHE_PSK_WITH_NULL_SHA || cipher == http2cipher_TLS_RSA_PSK_WITH_NULL_SHA || cipher == http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_RSA_WITH_NULL_SHA256 || cipher == http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA || cipher == http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256 || cipher == http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 || cipher == http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256 || cipher == http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA || cipher == http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA || cipher == http2cipher_TLS_PSK_WITH_RC4_128_SHA || cipher == http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA || cipher == http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA || cipher == http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_RSA_WITH_SEED_CBC_SHA || cipher == http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA || cipher == http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA || cipher == http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA || cipher == http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA || cipher == http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA || cipher == http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_PSK_WITH_NULL_SHA256 || cipher == http2cipher_TLS_PSK_WITH_NULL_SHA384 || cipher == http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256 || cipher == http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384 || cipher == http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256 || cipher == http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384 || cipher == http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 || cipher == http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 || cipher == http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 || cipher == http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA || cipher == http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA || cipher == http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA || cipher == http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA || cipher == http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_ECDH_anon_WITH_NULL_SHA || cipher == http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA || cipher == http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 || cipher == http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA || cipher == http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA || cipher == http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA || cipher == http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA || cipher == http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA || cipher == http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384 || cipher == http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 || cipher == http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 || cipher == http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 || cipher == http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 || cipher == http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 || cipher == http2cipher_TLS_RSA_WITH_AES_128_CCM || cipher == http2cipher_TLS_RSA_WITH_AES_256_CCM || cipher == http2cipher_TLS_RSA_WITH_AES_128_CCM_8 || cipher == http2cipher_TLS_RSA_WITH_AES_256_CCM_8 || cipher == http2cipher_TLS_PSK_WITH_AES_128_CCM || cipher == http2cipher_TLS_PSK_WITH_AES_256_CCM || cipher == http2cipher_TLS_PSK_WITH_AES_128_CCM_8 || cipher == http2cipher_TLS_PSK_WITH_AES_256_CCM_8) 
        return true;
    else 
        return false;
    }

// ClientConnPool manages a pool of HTTP/2 client connections.
private partial interface http2ClientConnPool {
    (ptr<http2ClientConn>, error) GetClientConn(ptr<Request> req, @string addr);
    (ptr<http2ClientConn>, error) MarkDead(ptr<http2ClientConn> _p0);
}

// clientConnPoolIdleCloser is the interface implemented by ClientConnPool
// implementations which can close their idle connections.
private partial interface http2clientConnPoolIdleCloser {
    void closeIdleConnections();
}

private static http2clientConnPoolIdleCloser _ = http2clientConnPoolIdleCloser.As((http2clientConnPool.val)(null))!;private static http2clientConnPoolIdleCloser _ = http2clientConnPoolIdleCloser.As(new http2noDialClientConnPool())!;

// TODO: use singleflight for dialing and addConnCalls?
private partial struct http2clientConnPool {
    public ptr<http2Transport> t;
    public sync.Mutex mu; // TODO: maybe switch to RWMutex
// TODO: add support for sharing conns based on cert names
// (e.g. share conn for googleapis.com and appspot.com)
    public map<@string, slice<ptr<http2ClientConn>>> conns; // key is host:port
    public map<@string, ptr<http2dialCall>> dialing; // currently in-flight dials
    public map<ptr<http2ClientConn>, slice<@string>> keys;
    public map<@string, ptr<http2addConnCall>> addConnCalls; // in-flight addConnIfNeeded calls
}

private static (ptr<http2ClientConn>, error) GetClientConn(this ptr<http2clientConnPool> _addr_p, ptr<Request> _addr_req, @string addr) {
    ptr<http2ClientConn> _p0 = default!;
    error _p0 = default!;
    ref http2clientConnPool p = ref _addr_p.val;
    ref Request req = ref _addr_req.val;

    return _addr_p.getClientConn(req, addr, http2dialOnMiss)!;
}

private static readonly var http2dialOnMiss = true;
private static readonly var http2noDialOnMiss = false;

private static (ptr<http2ClientConn>, error) getClientConn(this ptr<http2clientConnPool> _addr_p, ptr<Request> _addr_req, @string addr, bool dialOnMiss) {
    ptr<http2ClientConn> _p0 = default!;
    error _p0 = default!;
    ref http2clientConnPool p = ref _addr_p.val;
    ref Request req = ref _addr_req.val;
 
    // TODO(dneil): Dial a new connection when t.DisableKeepAlives is set?
    if (http2isConnectionCloseRequest(_addr_req) && dialOnMiss) { 
        // It gets its own connection.
        http2traceGetConn(_addr_req, addr);
        const var singleUse = true;

        var (cc, err) = p.t.dialClientConn(req.Context(), addr, singleUse);
        if (err != null) {
            return (_addr_null!, error.As(err)!);
        }
        return (_addr_cc!, error.As(null!)!);
    }
    while (true) {
        p.mu.Lock();
        {
            var cc__prev2 = cc;

            foreach (var (_, __cc) in p.conns[addr]) {
                cc = __cc;
                if (cc.ReserveNewRequest()) { 
                    // When a connection is presented to us by the net/http package,
                    // the GetConn hook has already been called.
                    // Don't call it a second time here.
                    if (!cc.getConnCalled) {
                        http2traceGetConn(_addr_req, addr);
                    }
                    cc.getConnCalled = false;
                    p.mu.Unlock();
                    return (_addr_cc!, error.As(null!)!);
                }
            }

            cc = cc__prev2;
        }

        if (!dialOnMiss) {
            p.mu.Unlock();
            return (_addr_null!, error.As(http2ErrNoCachedConn)!);
        }
        http2traceGetConn(_addr_req, addr);
        var call = p.getStartDialLocked(req.Context(), addr);
        p.mu.Unlock().Send(call.done);
        if (http2shouldRetryDial(_addr_call, _addr_req)) {
            continue;
        }
        var cc = call.res;
        var err = call.err;
        if (err != null) {
            return (_addr_null!, error.As(err)!);
        }
        if (cc.ReserveNewRequest()) {
            return (_addr_cc!, error.As(null!)!);
        }
    }
}

// dialCall is an in-flight Transport dial call to a host.
private partial struct http2dialCall {
    public http2incomparable _;
    public ptr<http2clientConnPool> p; // the context associated with the request
// that created this dialCall
    public context.Context ctx;
    public channel<object> done; // closed when done
    public ptr<http2ClientConn> res; // valid after done is closed
    public error err; // valid after done is closed
}

// requires p.mu is held.
private static ptr<http2dialCall> getStartDialLocked(this ptr<http2clientConnPool> _addr_p, context.Context ctx, @string addr) {
    ref http2clientConnPool p = ref _addr_p.val;

    {
        var call__prev1 = call;

        var (call, ok) = p.dialing[addr];

        if (ok) { 
            // A dial is already in-flight. Don't start another.
            return _addr_call!;
        }
        call = call__prev1;

    }
    ptr<http2dialCall> call = addr(new http2dialCall(p:p,done:make(chanstruct{}),ctx:ctx));
    if (p.dialing == null) {
        p.dialing = make_map<@string, ptr<http2dialCall>>();
    }
    p.dialing[addr] = call;
    go_(() => call.dial(call.ctx, addr));
    return _addr_call!;
}

// run in its own goroutine.
private static void dial(this ptr<http2dialCall> _addr_c, context.Context ctx, @string addr) {
    ref http2dialCall c = ref _addr_c.val;

    const var singleUse = false; // shared conn
 // shared conn
    c.res, c.err = c.p.t.dialClientConn(ctx, addr, singleUse);
    close(c.done);

    c.p.mu.Lock();
    delete(c.p.dialing, addr);
    if (c.err == null) {
        c.p.addConnLocked(addr, c.res);
    }
    c.p.mu.Unlock();
}

// addConnIfNeeded makes a NewClientConn out of c if a connection for key doesn't
// already exist. It coalesces concurrent calls with the same key.
// This is used by the http1 Transport code when it creates a new connection. Because
// the http1 Transport doesn't de-dup TCP dials to outbound hosts (because it doesn't know
// the protocol), it can get into a situation where it has multiple TLS connections.
// This code decides which ones live or die.
// The return value used is whether c was used.
// c is never closed.
private static (bool, error) addConnIfNeeded(this ptr<http2clientConnPool> _addr_p, @string key, ptr<http2Transport> _addr_t, ptr<tls.Conn> _addr_c) {
    bool used = default;
    error err = default!;
    ref http2clientConnPool p = ref _addr_p.val;
    ref http2Transport t = ref _addr_t.val;
    ref tls.Conn c = ref _addr_c.val;

    p.mu.Lock();
    foreach (var (_, cc) in p.conns[key]) {
        if (cc.CanTakeNewRequest()) {
            p.mu.Unlock();
            return (false, error.As(null!)!);
        }
    }    var (call, dup) = p.addConnCalls[key];
    if (!dup) {
        if (p.addConnCalls == null) {
            p.addConnCalls = make_map<@string, ptr<http2addConnCall>>();
        }
        call = addr(new http2addConnCall(p:p,done:make(chanstruct{}),));
        p.addConnCalls[key] = call;
        go_(() => call.run(t, key, c));
    }
    p.mu.Unlock().Send(call.done);
    if (call.err != null) {
        return (false, error.As(call.err)!);
    }
    return (!dup, error.As(null!)!);
}

private partial struct http2addConnCall {
    public http2incomparable _;
    public ptr<http2clientConnPool> p;
    public channel<object> done; // closed when done
    public error err;
}

private static void run(this ptr<http2addConnCall> _addr_c, ptr<http2Transport> _addr_t, @string key, ptr<tls.Conn> _addr_tc) {
    ref http2addConnCall c = ref _addr_c.val;
    ref http2Transport t = ref _addr_t.val;
    ref tls.Conn tc = ref _addr_tc.val;

    var (cc, err) = t.NewClientConn(tc);

    var p = c.p;
    p.mu.Lock();
    if (err != null) {
        c.err = err;
    }
    else
 {
        cc.getConnCalled = true; // already called by the net/http package
        p.addConnLocked(key, cc);
    }
    delete(p.addConnCalls, key);
    p.mu.Unlock();
    close(c.done);
}

// p.mu must be held
private static void addConnLocked(this ptr<http2clientConnPool> _addr_p, @string key, ptr<http2ClientConn> _addr_cc) {
    ref http2clientConnPool p = ref _addr_p.val;
    ref http2ClientConn cc = ref _addr_cc.val;

    foreach (var (_, v) in p.conns[key]) {
        if (v == cc) {
            return ;
        }
    }    if (p.conns == null) {
        p.conns = make_map<@string, slice<ptr<http2ClientConn>>>();
    }
    if (p.keys == null) {
        p.keys = make_map<ptr<http2ClientConn>, slice<@string>>();
    }
    p.conns[key] = append(p.conns[key], cc);
    p.keys[cc] = append(p.keys[cc], key);
}

private static void MarkDead(this ptr<http2clientConnPool> _addr_p, ptr<http2ClientConn> _addr_cc) => func((defer, _, _) => {
    ref http2clientConnPool p = ref _addr_p.val;
    ref http2ClientConn cc = ref _addr_cc.val;

    p.mu.Lock();
    defer(p.mu.Unlock());
    foreach (var (_, key) in p.keys[cc]) {
        var (vv, ok) = p.conns[key];
        if (!ok) {
            continue;
        }
        var newList = http2filterOutClientConn(vv, _addr_cc);
        if (len(newList) > 0) {
            p.conns[key] = newList;
        }
        else
 {
            delete(p.conns, key);
        }
    }    delete(p.keys, cc);
});

private static void closeIdleConnections(this ptr<http2clientConnPool> _addr_p) => func((defer, _, _) => {
    ref http2clientConnPool p = ref _addr_p.val;

    p.mu.Lock();
    defer(p.mu.Unlock()); 
    // TODO: don't close a cc if it was just added to the pool
    // milliseconds ago and has never been used. There's currently
    // a small race window with the HTTP/1 Transport's integration
    // where it can add an idle conn just before using it, and
    // somebody else can concurrently call CloseIdleConns and
    // break some caller's RoundTrip.
    foreach (var (_, vv) in p.conns) {
        foreach (var (_, cc) in vv) {
            cc.closeIfIdle();
        }
    }
});

private static slice<ptr<http2ClientConn>> http2filterOutClientConn(slice<ptr<http2ClientConn>> @in, ptr<http2ClientConn> _addr_exclude) {
    ref http2ClientConn exclude = ref _addr_exclude.val;

    var @out = in[..(int)0];
    foreach (var (_, v) in in) {
        if (v != exclude) {
            out = append(out, v);
        }
    }    if (len(in) != len(out)) {
        in[len(in) - 1] = null;
    }
    return out;
}

// noDialClientConnPool is an implementation of http2.ClientConnPool
// which never dials. We let the HTTP/1.1 client dial and use its TLS
// connection instead.
private partial struct http2noDialClientConnPool {
    public ref ptr<http2clientConnPool> ptr<http2clientConnPool> => ref ptr<http2clientConnPool>_ptr;
}

private static (ptr<http2ClientConn>, error) GetClientConn(this http2noDialClientConnPool p, ptr<Request> _addr_req, @string addr) {
    ptr<http2ClientConn> _p0 = default!;
    error _p0 = default!;
    ref Request req = ref _addr_req.val;

    return _addr_p.getClientConn(req, addr, http2noDialOnMiss)!;
}

// shouldRetryDial reports whether the current request should
// retry dialing after the call finished unsuccessfully, for example
// if the dial was canceled because of a context cancellation or
// deadline expiry.
private static bool http2shouldRetryDial(ptr<http2dialCall> _addr_call, ptr<Request> _addr_req) {
    ref http2dialCall call = ref _addr_call.val;
    ref Request req = ref _addr_req.val;

    if (call.err == null) { 
        // No error, no need to retry
        return false;
    }
    if (call.ctx == req.Context()) { 
        // If the call has the same context as the request, the dial
        // should not be retried, since any cancellation will have come
        // from this request.
        return false;
    }
    if (!errors.Is(call.err, context.Canceled) && !errors.Is(call.err, context.DeadlineExceeded)) { 
        // If the call error is not because of a context cancellation or a deadline expiry,
        // the dial should not be retried.
        return false;
    }
    return call.ctx.Err() != null;
}

// Buffer chunks are allocated from a pool to reduce pressure on GC.
// The maximum wasted space per dataBuffer is 2x the largest size class,
// which happens when the dataBuffer has multiple chunks and there is
// one unread byte in both the first and last chunks. We use a few size
// classes to minimize overheads for servers that typically receive very
// small request bodies.
//
// TODO: Benchmark to determine if the pools are necessary. The GC may have
// improved enough that we can instead allocate chunks like this:
// make([]byte, max(16<<10, expectedBytesRemaining))
private static nint http2dataChunkSizeClasses = new slice<nint>(new nint[] { 1<<10, 2<<10, 4<<10, 8<<10, 16<<10 });private static array<sync.Pool> http2dataChunkPools = new array<sync.Pool>(new sync.Pool[] { {New:func()interface{}{returnmake([]byte,1<<10)}}, {New:func()interface{}{returnmake([]byte,2<<10)}}, {New:func()interface{}{returnmake([]byte,4<<10)}}, {New:func()interface{}{returnmake([]byte,8<<10)}}, {New:func()interface{}{returnmake([]byte,16<<10)}} });

private static slice<byte> http2getDataBufferChunk(long size) {
    nint i = 0;
    while (i < len(http2dataChunkSizeClasses) - 1) {
        if (size <= int64(http2dataChunkSizeClasses[i])) {
            break;
        i++;
        }
    }
    return http2dataChunkPools[i].Get()._<slice<byte>>();
}

private static void http2putDataBufferChunk(slice<byte> p) => func((_, panic, _) => {
    foreach (var (i, n) in http2dataChunkSizeClasses) {
        if (len(p) == n) {
            http2dataChunkPools[i].Put(p);
            return ;
        }
    }    panic(fmt.Sprintf("unexpected buffer len=%v", len(p)));
});

// dataBuffer is an io.ReadWriter backed by a list of data chunks.
// Each dataBuffer is used to read DATA frames on a single stream.
// The buffer is divided into chunks so the server can limit the
// total memory used by a single connection without limiting the
// request body size on any single stream.
private partial struct http2dataBuffer {
    public slice<slice<byte>> chunks;
    public nint r; // next byte to read is chunks[0][r]
    public nint w; // next byte to write is chunks[len(chunks)-1][w]
    public nint size; // total buffered bytes
    public long expected; // we expect at least this many bytes in future Write calls (ignored if <= 0)
}

private static var http2errReadEmpty = errors.New("read from empty dataBuffer");

// Read copies bytes from the buffer into p.
// It is an error to read when no data is available.
private static (nint, error) Read(this ptr<http2dataBuffer> _addr_b, slice<byte> p) {
    nint _p0 = default;
    error _p0 = default!;
    ref http2dataBuffer b = ref _addr_b.val;

    if (b.size == 0) {
        return (0, error.As(http2errReadEmpty)!);
    }
    nint ntotal = default;
    while (len(p) > 0 && b.size > 0) {
        var readFrom = b.bytesFromFirstChunk();
        var n = copy(p, readFrom);
        p = p[(int)n..];
        ntotal += n;
        b.r += n;
        b.size -= n; 
        // If the first chunk has been consumed, advance to the next chunk.
        if (b.r == len(b.chunks[0])) {
            http2putDataBufferChunk(b.chunks[0]);
            var end = len(b.chunks) - 1;
            copy(b.chunks[..(int)end], b.chunks[(int)1..]);
            b.chunks[end] = null;
            b.chunks = b.chunks[..(int)end];
            b.r = 0;
        }
    }
    return (ntotal, error.As(null!)!);
}

private static slice<byte> bytesFromFirstChunk(this ptr<http2dataBuffer> _addr_b) {
    ref http2dataBuffer b = ref _addr_b.val;

    if (len(b.chunks) == 1) {
        return b.chunks[0][(int)b.r..(int)b.w];
    }
    return b.chunks[0][(int)b.r..];
}

// Len returns the number of bytes of the unread portion of the buffer.
private static nint Len(this ptr<http2dataBuffer> _addr_b) {
    ref http2dataBuffer b = ref _addr_b.val;

    return b.size;
}

// Write appends p to the buffer.
private static (nint, error) Write(this ptr<http2dataBuffer> _addr_b, slice<byte> p) {
    nint _p0 = default;
    error _p0 = default!;
    ref http2dataBuffer b = ref _addr_b.val;

    var ntotal = len(p);
    while (len(p) > 0) { 
        // If the last chunk is empty, allocate a new chunk. Try to allocate
        // enough to fully copy p plus any additional bytes we expect to
        // receive. However, this may allocate less than len(p).
        var want = int64(len(p));
        if (b.expected > want) {
            want = b.expected;
        }
        var chunk = b.lastChunkOrAlloc(want);
        var n = copy(chunk[(int)b.w..], p);
        p = p[(int)n..];
        b.w += n;
        b.size += n;
        b.expected -= int64(n);
    }
    return (ntotal, error.As(null!)!);
}

private static slice<byte> lastChunkOrAlloc(this ptr<http2dataBuffer> _addr_b, long want) {
    ref http2dataBuffer b = ref _addr_b.val;

    if (len(b.chunks) != 0) {
        var last = b.chunks[len(b.chunks) - 1];
        if (b.w < len(last)) {
            return last;
        }
    }
    var chunk = http2getDataBufferChunk(want);
    b.chunks = append(b.chunks, chunk);
    b.w = 0;
    return chunk;
}

// An ErrCode is an unsigned 32-bit error code as defined in the HTTP/2 spec.
private partial struct http2ErrCode { // : uint
}

private static readonly http2ErrCode http2ErrCodeNo = 0x0;
private static readonly http2ErrCode http2ErrCodeProtocol = 0x1;
private static readonly http2ErrCode http2ErrCodeInternal = 0x2;
private static readonly http2ErrCode http2ErrCodeFlowControl = 0x3;
private static readonly http2ErrCode http2ErrCodeSettingsTimeout = 0x4;
private static readonly http2ErrCode http2ErrCodeStreamClosed = 0x5;
private static readonly http2ErrCode http2ErrCodeFrameSize = 0x6;
private static readonly http2ErrCode http2ErrCodeRefusedStream = 0x7;
private static readonly http2ErrCode http2ErrCodeCancel = 0x8;
private static readonly http2ErrCode http2ErrCodeCompression = 0x9;
private static readonly http2ErrCode http2ErrCodeConnect = 0xa;
private static readonly http2ErrCode http2ErrCodeEnhanceYourCalm = 0xb;
private static readonly http2ErrCode http2ErrCodeInadequateSecurity = 0xc;
private static readonly http2ErrCode http2ErrCodeHTTP11Required = 0xd;

private static map http2errCodeName = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<http2ErrCode, @string>{http2ErrCodeNo:"NO_ERROR",http2ErrCodeProtocol:"PROTOCOL_ERROR",http2ErrCodeInternal:"INTERNAL_ERROR",http2ErrCodeFlowControl:"FLOW_CONTROL_ERROR",http2ErrCodeSettingsTimeout:"SETTINGS_TIMEOUT",http2ErrCodeStreamClosed:"STREAM_CLOSED",http2ErrCodeFrameSize:"FRAME_SIZE_ERROR",http2ErrCodeRefusedStream:"REFUSED_STREAM",http2ErrCodeCancel:"CANCEL",http2ErrCodeCompression:"COMPRESSION_ERROR",http2ErrCodeConnect:"CONNECT_ERROR",http2ErrCodeEnhanceYourCalm:"ENHANCE_YOUR_CALM",http2ErrCodeInadequateSecurity:"INADEQUATE_SECURITY",http2ErrCodeHTTP11Required:"HTTP_1_1_REQUIRED",};

private static @string String(this http2ErrCode e) {
    {
        var (s, ok) = http2errCodeName[e];

        if (ok) {
            return s;
        }
    }
    return fmt.Sprintf("unknown error code 0x%x", uint32(e));
}

// ConnectionError is an error that results in the termination of the
// entire connection.
private partial struct http2ConnectionError { // : http2ErrCode
}

private static @string Error(this http2ConnectionError e) {
    return fmt.Sprintf("connection error: %s", http2ErrCode(e));
}

// StreamError is an error that only affects one stream within an
// HTTP/2 connection.
private partial struct http2StreamError {
    public uint StreamID;
    public http2ErrCode Code;
    public error Cause; // optional additional detail
}

// errFromPeer is a sentinel error value for StreamError.Cause to
// indicate that the StreamError was sent from the peer over the wire
// and wasn't locally generated in the Transport.
private static var http2errFromPeer = errors.New("received from peer");

private static http2StreamError http2streamError(uint id, http2ErrCode code) {
    return new http2StreamError(StreamID:id,Code:code);
}

private static @string Error(this http2StreamError e) {
    if (e.Cause != null) {
        return fmt.Sprintf("stream error: stream ID %d; %v; %v", e.StreamID, e.Code, e.Cause);
    }
    return fmt.Sprintf("stream error: stream ID %d; %v", e.StreamID, e.Code);
}

// 6.9.1 The Flow Control Window
// "If a sender receives a WINDOW_UPDATE that causes a flow control
// window to exceed this maximum it MUST terminate either the stream
// or the connection, as appropriate. For streams, [...]; for the
// connection, a GOAWAY frame with a FLOW_CONTROL_ERROR code."
private partial struct http2goAwayFlowError {
}

private static @string Error(this http2goAwayFlowError _p0) {
    return "connection exceeded flow control window size";
}

// connError represents an HTTP/2 ConnectionError error code, along
// with a string (for debugging) explaining why.
//
// Errors of this type are only returned by the frame parser functions
// and converted into ConnectionError(Code), after stashing away
// the Reason into the Framer's errDetail field, accessible via
// the (*Framer).ErrorDetail method.
private partial struct http2connError {
    public http2ErrCode Code; // the ConnectionError error code
    public @string Reason; // additional reason
}

private static @string Error(this http2connError e) {
    return fmt.Sprintf("http2: connection error: %v: %v", e.Code, e.Reason);
}

private partial struct http2pseudoHeaderError { // : @string
}

private static @string Error(this http2pseudoHeaderError e) {
    return fmt.Sprintf("invalid pseudo-header %q", string(e));
}

private partial struct http2duplicatePseudoHeaderError { // : @string
}

private static @string Error(this http2duplicatePseudoHeaderError e) {
    return fmt.Sprintf("duplicate pseudo-header %q", string(e));
}

private partial struct http2headerFieldNameError { // : @string
}

private static @string Error(this http2headerFieldNameError e) {
    return fmt.Sprintf("invalid header field name %q", string(e));
}

private partial struct http2headerFieldValueError { // : @string
}

private static @string Error(this http2headerFieldValueError e) {
    return fmt.Sprintf("invalid header field value %q", string(e));
}

private static var http2errMixPseudoHeaderTypes = errors.New("mix of request and response pseudo headers");private static var http2errPseudoAfterRegular = errors.New("pseudo header field after regular");

// flow is the flow control window's size.
private partial struct http2flow {
    public http2incomparable _; // n is the number of DATA bytes we're allowed to send.
// A flow is kept both on a conn and a per-stream.
    public int n; // conn points to the shared connection-level flow that is
// shared by all streams on that conn. It is nil for the flow
// that's on the conn directly.
    public ptr<http2flow> conn;
}

private static void setConnFlow(this ptr<http2flow> _addr_f, ptr<http2flow> _addr_cf) {
    ref http2flow f = ref _addr_f.val;
    ref http2flow cf = ref _addr_cf.val;

    f.conn = cf;
}

private static int available(this ptr<http2flow> _addr_f) {
    ref http2flow f = ref _addr_f.val;

    var n = f.n;
    if (f.conn != null && f.conn.n < n) {
        n = f.conn.n;
    }
    return n;
}

private static void take(this ptr<http2flow> _addr_f, int n) => func((_, panic, _) => {
    ref http2flow f = ref _addr_f.val;

    if (n > f.available()) {
        panic("internal error: took too much");
    }
    f.n -= n;
    if (f.conn != null) {
        f.conn.n -= n;
    }
});

// add adds n bytes (positive or negative) to the flow control window.
// It returns false if the sum would exceed 2^31-1.
private static bool add(this ptr<http2flow> _addr_f, int n) {
    ref http2flow f = ref _addr_f.val;

    var sum = f.n + n;
    if ((sum > n) == (f.n > 0)) {
        f.n = sum;
        return true;
    }
    return false;
}

private static readonly nint http2frameHeaderLen = 9;



private static var http2padZeros = make_slice<byte>(255); // zeros for padding

// A FrameType is a registered frame type as defined in
// http://http2.github.io/http2-spec/#rfc.section.11.2
private partial struct http2FrameType { // : byte
}

private static readonly http2FrameType http2FrameData = 0x0;
private static readonly http2FrameType http2FrameHeaders = 0x1;
private static readonly http2FrameType http2FramePriority = 0x2;
private static readonly http2FrameType http2FrameRSTStream = 0x3;
private static readonly http2FrameType http2FrameSettings = 0x4;
private static readonly http2FrameType http2FramePushPromise = 0x5;
private static readonly http2FrameType http2FramePing = 0x6;
private static readonly http2FrameType http2FrameGoAway = 0x7;
private static readonly http2FrameType http2FrameWindowUpdate = 0x8;
private static readonly http2FrameType http2FrameContinuation = 0x9;

private static map http2frameName = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<http2FrameType, @string>{http2FrameData:"DATA",http2FrameHeaders:"HEADERS",http2FramePriority:"PRIORITY",http2FrameRSTStream:"RST_STREAM",http2FrameSettings:"SETTINGS",http2FramePushPromise:"PUSH_PROMISE",http2FramePing:"PING",http2FrameGoAway:"GOAWAY",http2FrameWindowUpdate:"WINDOW_UPDATE",http2FrameContinuation:"CONTINUATION",};

private static @string String(this http2FrameType t) {
    {
        var (s, ok) = http2frameName[t];

        if (ok) {
            return s;
        }
    }
    return fmt.Sprintf("UNKNOWN_FRAME_TYPE_%d", uint8(t));
}

// Flags is a bitmask of HTTP/2 flags.
// The meaning of flags varies depending on the frame type.
private partial struct http2Flags { // : byte
}

// Has reports whether f contains all (0 or more) flags in v.
private static bool Has(this http2Flags f, http2Flags v) {
    return (f & v) == v;
}

// Frame-specific FrameHeader flag bits.
 
// Data Frame
private static readonly http2Flags http2FlagDataEndStream = 0x1;
private static readonly http2Flags http2FlagDataPadded = 0x8; 

// Headers Frame
private static readonly http2Flags http2FlagHeadersEndStream = 0x1;
private static readonly http2Flags http2FlagHeadersEndHeaders = 0x4;
private static readonly http2Flags http2FlagHeadersPadded = 0x8;
private static readonly http2Flags http2FlagHeadersPriority = 0x20; 

// Settings Frame
private static readonly http2Flags http2FlagSettingsAck = 0x1; 

// Ping Frame
private static readonly http2Flags http2FlagPingAck = 0x1; 

// Continuation Frame
private static readonly http2Flags http2FlagContinuationEndHeaders = 0x4;

private static readonly http2Flags http2FlagPushPromiseEndHeaders = 0x4;
private static readonly http2Flags http2FlagPushPromisePadded = 0x8;

private static map http2flagName = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<http2FrameType, map<http2Flags, @string>>{http2FrameData:{http2FlagDataEndStream:"END_STREAM",http2FlagDataPadded:"PADDED",},http2FrameHeaders:{http2FlagHeadersEndStream:"END_STREAM",http2FlagHeadersEndHeaders:"END_HEADERS",http2FlagHeadersPadded:"PADDED",http2FlagHeadersPriority:"PRIORITY",},http2FrameSettings:{http2FlagSettingsAck:"ACK",},http2FramePing:{http2FlagPingAck:"ACK",},http2FrameContinuation:{http2FlagContinuationEndHeaders:"END_HEADERS",},http2FramePushPromise:{http2FlagPushPromiseEndHeaders:"END_HEADERS",http2FlagPushPromisePadded:"PADDED",},};

// a frameParser parses a frame given its FrameHeader and payload
// bytes. The length of payload will always equal fh.Length (which
// might be 0).
public delegate  error) http2frameParser(ptr<http2frameCache>,  http2FrameHeader,  slice<byte>,  (http2Frame);

private static map http2frameParsers = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<http2FrameType, http2frameParser>{http2FrameData:http2parseDataFrame,http2FrameHeaders:http2parseHeadersFrame,http2FramePriority:http2parsePriorityFrame,http2FrameRSTStream:http2parseRSTStreamFrame,http2FrameSettings:http2parseSettingsFrame,http2FramePushPromise:http2parsePushPromise,http2FramePing:http2parsePingFrame,http2FrameGoAway:http2parseGoAwayFrame,http2FrameWindowUpdate:http2parseWindowUpdateFrame,http2FrameContinuation:http2parseContinuationFrame,};

private static http2frameParser http2typeFrameParser(http2FrameType t) {
    {
        var f = http2frameParsers[t];

        if (f != null) {
            return f;
        }
    }
    return http2parseUnknownFrame;
}

// A FrameHeader is the 9 byte header of all HTTP/2 frames.
//
// See http://http2.github.io/http2-spec/#FrameHeader
private partial struct http2FrameHeader {
    public bool valid; // caller can access []byte fields in the Frame

// Type is the 1 byte frame type. There are ten standard frame
// types, but extension frame types may be written by WriteRawFrame
// and will be returned by ReadFrame (as UnknownFrame).
    public http2FrameType Type; // Flags are the 1 byte of 8 potential bit flags per frame.
// They are specific to the frame type.
    public http2Flags Flags; // Length is the length of the frame, not including the 9 byte header.
// The maximum size is one byte less than 16MB (uint24), but only
// frames up to 16KB are allowed without peer agreement.
    public uint Length; // StreamID is which stream this frame is for. Certain frames
// are not stream-specific, in which case this field is 0.
    public uint StreamID;
}

// Header returns h. It exists so FrameHeaders can be embedded in other
// specific frame types and implement the Frame interface.
private static http2FrameHeader Header(this http2FrameHeader h) {
    return h;
}

private static @string String(this http2FrameHeader h) {
    ref bytes.Buffer buf = ref heap(out ptr<bytes.Buffer> _addr_buf);
    buf.WriteString("[FrameHeader ");
    h.writeDebug(_addr_buf);
    buf.WriteByte(']');
    return buf.String();
}

private static void writeDebug(this http2FrameHeader h, ptr<bytes.Buffer> _addr_buf) {
    ref bytes.Buffer buf = ref _addr_buf.val;

    buf.WriteString(h.Type.String());
    if (h.Flags != 0) {
        buf.WriteString(" flags=");
        nint set = 0;
        for (var i = uint8(0); i < 8; i++) {
            if (h.Flags & (1 << (int)(i)) == 0) {
                continue;
            }
            set++;
            if (set > 1) {
                buf.WriteByte('|');
            }
            var name = http2flagName[h.Type][http2Flags(1 << (int)(i))];
            if (name != "") {
                buf.WriteString(name);
            }
            else
 {
                fmt.Fprintf(buf, "0x%x", 1 << (int)(i));
            }
        }
    }
    if (h.StreamID != 0) {
        fmt.Fprintf(buf, " stream=%d", h.StreamID);
    }
    fmt.Fprintf(buf, " len=%d", h.Length);
}

private static void checkValid(this ptr<http2FrameHeader> _addr_h) => func((_, panic, _) => {
    ref http2FrameHeader h = ref _addr_h.val;

    if (!h.valid) {
        panic("Frame accessor called on non-owned Frame");
    }
});

private static void invalidate(this ptr<http2FrameHeader> _addr_h) {
    ref http2FrameHeader h = ref _addr_h.val;

    h.valid = false;
}

// frame header bytes.
// Used only by ReadFrameHeader.
private static sync.Pool http2fhBytes = new sync.Pool(New:func()interface{}{buf:=make([]byte,http2frameHeaderLen)return&buf},);

// ReadFrameHeader reads 9 bytes from r and returns a FrameHeader.
// Most users should use Framer.ReadFrame instead.
private static (http2FrameHeader, error) http2ReadFrameHeader(io.Reader r) => func((defer, _, _) => {
    http2FrameHeader _p0 = default;
    error _p0 = default!;

    ptr<slice<byte>> bufp = http2fhBytes.Get()._<ptr<slice<byte>>>();
    defer(http2fhBytes.Put(bufp));
    return http2readFrameHeader(bufp.val, r);
});

private static (http2FrameHeader, error) http2readFrameHeader(slice<byte> buf, io.Reader r) {
    http2FrameHeader _p0 = default;
    error _p0 = default!;

    var (_, err) = io.ReadFull(r, buf[..(int)http2frameHeaderLen]);
    if (err != null) {
        return (new http2FrameHeader(), error.As(err)!);
    }
    return (new http2FrameHeader(Length:(uint32(buf[0])<<16|uint32(buf[1])<<8|uint32(buf[2])),Type:http2FrameType(buf[3]),Flags:http2Flags(buf[4]),StreamID:binary.BigEndian.Uint32(buf[5:])&(1<<31-1),valid:true,), error.As(null!)!);
}

// A Frame is the base interface implemented by all frame types.
// Callers will generally type-assert the specific frame type:
// *HeadersFrame, *SettingsFrame, *WindowUpdateFrame, etc.
//
// Frames are only valid until the next call to Framer.ReadFrame.
private partial interface http2Frame {
    http2FrameHeader Header(); // invalidate is called by Framer.ReadFrame to make this
// frame's buffers as being invalid, since the subsequent
// frame will reuse them.
    http2FrameHeader invalidate();
}

// A Framer reads and writes Frames.
private partial struct http2Framer {
    public io.Reader r;
    public http2Frame lastFrame;
    public error errDetail; // lastHeaderStream is non-zero if the last frame was an
// unfinished HEADERS/CONTINUATION.
    public uint lastHeaderStream;
    public uint maxReadSize;
    public array<byte> headerBuf; // TODO: let getReadBuf be configurable, and use a less memory-pinning
// allocator in server.go to minimize memory pinned for many idle conns.
// Will probably also need to make frame invalidation have a hook too.
    public Func<uint, slice<byte>> getReadBuf;
    public slice<byte> readBuf; // cache for default getReadBuf

    public uint maxWriteSize; // zero means unlimited; TODO: implement

    public io.Writer w;
    public slice<byte> wbuf; // AllowIllegalWrites permits the Framer's Write methods to
// write frames that do not conform to the HTTP/2 spec. This
// permits using the Framer to test other HTTP/2
// implementations' conformance to the spec.
// If false, the Write methods will prefer to return an error
// rather than comply.
    public bool AllowIllegalWrites; // AllowIllegalReads permits the Framer's ReadFrame method
// to return non-compliant frames or frame orders.
// This is for testing and permits using the Framer to test
// other HTTP/2 implementations' conformance to the spec.
// It is not compatible with ReadMetaHeaders.
    public bool AllowIllegalReads; // ReadMetaHeaders if non-nil causes ReadFrame to merge
// HEADERS and CONTINUATION frames together and return
// MetaHeadersFrame instead.
    public ptr<hpack.Decoder> ReadMetaHeaders; // MaxHeaderListSize is the http2 MAX_HEADER_LIST_SIZE.
// It's used only if ReadMetaHeaders is set; 0 means a sane default
// (currently 16MB)
// If the limit is hit, MetaHeadersFrame.Truncated is set true.
    public uint MaxHeaderListSize; // TODO: track which type of frame & with which flags was sent
// last. Then return an error (unless AllowIllegalWrites) if
// we're in the middle of a header block and a
// non-Continuation or Continuation on a different stream is
// attempted to be written.

    public bool logReads;
    public bool logWrites;
    public ptr<http2Framer> debugFramer; // only use for logging written writes
    public ptr<bytes.Buffer> debugFramerBuf;
    public Action<@string, object> debugReadLoggerf;
    public Action<@string, object> debugWriteLoggerf;
    public ptr<http2frameCache> frameCache; // nil if frames aren't reused (default)
}

private static uint maxHeaderListSize(this ptr<http2Framer> _addr_fr) {
    ref http2Framer fr = ref _addr_fr.val;

    if (fr.MaxHeaderListSize == 0) {
        return 16 << 20; // sane default, per docs
    }
    return fr.MaxHeaderListSize;
}

private static void startWrite(this ptr<http2Framer> _addr_f, http2FrameType ftype, http2Flags flags, uint streamID) {
    ref http2Framer f = ref _addr_f.val;
 
    // Write the FrameHeader.
    f.wbuf = append(f.wbuf[..(int)0], 0, 0, 0, byte(ftype), byte(flags), byte(streamID >> 24), byte(streamID >> 16), byte(streamID >> 8), byte(streamID));
}

private static error endWrite(this ptr<http2Framer> _addr_f) {
    ref http2Framer f = ref _addr_f.val;
 
    // Now that we know the final size, fill in the FrameHeader in
    // the space previously reserved for it. Abuse append.
    var length = len(f.wbuf) - http2frameHeaderLen;
    if (length >= (1 << 24)) {
        return error.As(http2ErrFrameTooLarge)!;
    }
    _ = append(f.wbuf[..(int)0], byte(length >> 16), byte(length >> 8), byte(length));
    if (f.logWrites) {
        f.logWrite();
    }
    var (n, err) = f.w.Write(f.wbuf);
    if (err == null && n != len(f.wbuf)) {
        err = io.ErrShortWrite;
    }
    return error.As(err)!;
}

private static void logWrite(this ptr<http2Framer> _addr_f) {
    ref http2Framer f = ref _addr_f.val;

    if (f.debugFramer == null) {
        f.debugFramerBuf = @new<bytes.Buffer>();
        f.debugFramer = http2NewFramer(null, f.debugFramerBuf);
        f.debugFramer.logReads = false; // we log it ourselves, saying "wrote" below
        // Let us read anything, even if we accidentally wrote it
        // in the wrong order:
        f.debugFramer.AllowIllegalReads = true;
    }
    f.debugFramerBuf.Write(f.wbuf);
    var (fr, err) = f.debugFramer.ReadFrame();
    if (err != null) {
        f.debugWriteLoggerf("http2: Framer %p: failed to decode just-written frame", f);
        return ;
    }
    f.debugWriteLoggerf("http2: Framer %p: wrote %v", f, http2summarizeFrame(fr));
}

private static void writeByte(this ptr<http2Framer> _addr_f, byte v) {
    ref http2Framer f = ref _addr_f.val;

    f.wbuf = append(f.wbuf, v);
}

private static void writeBytes(this ptr<http2Framer> _addr_f, slice<byte> v) {
    ref http2Framer f = ref _addr_f.val;

    f.wbuf = append(f.wbuf, v);
}

private static void writeUint16(this ptr<http2Framer> _addr_f, ushort v) {
    ref http2Framer f = ref _addr_f.val;

    f.wbuf = append(f.wbuf, byte(v >> 8), byte(v));
}

private static void writeUint32(this ptr<http2Framer> _addr_f, uint v) {
    ref http2Framer f = ref _addr_f.val;

    f.wbuf = append(f.wbuf, byte(v >> 24), byte(v >> 16), byte(v >> 8), byte(v));
}

private static readonly nint http2minMaxFrameSize = 1 << 14;
private static readonly nint http2maxFrameSize = 1 << 24 - 1;

// SetReuseFrames allows the Framer to reuse Frames.
// If called on a Framer, Frames returned by calls to ReadFrame are only
// valid until the next call to ReadFrame.
private static void SetReuseFrames(this ptr<http2Framer> _addr_fr) {
    ref http2Framer fr = ref _addr_fr.val;

    if (fr.frameCache != null) {
        return ;
    }
    fr.frameCache = addr(new http2frameCache());
}

private partial struct http2frameCache {
    public http2DataFrame dataFrame;
}

private static ptr<http2DataFrame> getDataFrame(this ptr<http2frameCache> _addr_fc) {
    ref http2frameCache fc = ref _addr_fc.val;

    if (fc == null) {
        return addr(new http2DataFrame());
    }
    return _addr__addr_fc.dataFrame!;
}

// NewFramer returns a Framer that writes frames to w and reads them from r.
private static ptr<http2Framer> http2NewFramer(io.Writer w, io.Reader r) {
    ptr<http2Framer> fr = addr(new http2Framer(w:w,r:r,logReads:http2logFrameReads,logWrites:http2logFrameWrites,debugReadLoggerf:log.Printf,debugWriteLoggerf:log.Printf,));
    fr.getReadBuf = size => {
        if (cap(fr.readBuf) >= int(size)) {
            return _addr_fr.readBuf[..(int)size]!;
        }
        fr.readBuf = make_slice<byte>(size);
        return _addr_fr.readBuf!;
    };
    fr.SetMaxReadFrameSize(http2maxFrameSize);
    return _addr_fr!;
}

// SetMaxReadFrameSize sets the maximum size of a frame
// that will be read by a subsequent call to ReadFrame.
// It is the caller's responsibility to advertise this
// limit with a SETTINGS frame.
private static void SetMaxReadFrameSize(this ptr<http2Framer> _addr_fr, uint v) {
    ref http2Framer fr = ref _addr_fr.val;

    if (v > http2maxFrameSize) {
        v = http2maxFrameSize;
    }
    fr.maxReadSize = v;
}

// ErrorDetail returns a more detailed error of the last error
// returned by Framer.ReadFrame. For instance, if ReadFrame
// returns a StreamError with code PROTOCOL_ERROR, ErrorDetail
// will say exactly what was invalid. ErrorDetail is not guaranteed
// to return a non-nil value and like the rest of the http2 package,
// its return value is not protected by an API compatibility promise.
// ErrorDetail is reset after the next call to ReadFrame.
private static error ErrorDetail(this ptr<http2Framer> _addr_fr) {
    ref http2Framer fr = ref _addr_fr.val;

    return error.As(fr.errDetail)!;
}

// ErrFrameTooLarge is returned from Framer.ReadFrame when the peer
// sends a frame that is larger than declared with SetMaxReadFrameSize.
private static var http2ErrFrameTooLarge = errors.New("http2: frame too large");

// terminalReadFrameError reports whether err is an unrecoverable
// error from ReadFrame and no other frames should be read.
private static bool http2terminalReadFrameError(error err) {
    {
        http2StreamError (_, ok) = err._<http2StreamError>();

        if (ok) {
            return false;
        }
    }
    return err != null;
}

// ReadFrame reads a single frame. The returned Frame is only valid
// until the next call to ReadFrame.
//
// If the frame is larger than previously set with SetMaxReadFrameSize, the
// returned error is ErrFrameTooLarge. Other errors may be of type
// ConnectionError, StreamError, or anything else from the underlying
// reader.
private static (http2Frame, error) ReadFrame(this ptr<http2Framer> _addr_fr) {
    http2Frame _p0 = default;
    error _p0 = default!;
    ref http2Framer fr = ref _addr_fr.val;

    fr.errDetail = null;
    if (fr.lastFrame != null) {
        fr.lastFrame.invalidate();
    }
    var (fh, err) = http2readFrameHeader(fr.headerBuf[..], fr.r);
    if (err != null) {
        return (null, error.As(err)!);
    }
    if (fh.Length > fr.maxReadSize) {
        return (null, error.As(http2ErrFrameTooLarge)!);
    }
    var payload = fr.getReadBuf(fh.Length);
    {
        var (_, err) = io.ReadFull(fr.r, payload);

        if (err != null) {
            return (null, error.As(err)!);
        }
    }
    var (f, err) = http2typeFrameParser(fh.Type)(fr.frameCache, fh, payload);
    if (err != null) {
        {
            http2connError (ce, ok) = err._<http2connError>();

            if (ok) {
                return (null, error.As(fr.connError(ce.Code, ce.Reason))!);
            }

        }
        return (null, error.As(err)!);
    }
    {
        var err = fr.checkFrameOrder(f);

        if (err != null) {
            return (null, error.As(err)!);
        }
    }
    if (fr.logReads) {
        fr.debugReadLoggerf("http2: Framer %p: read %v", fr, http2summarizeFrame(f));
    }
    if (fh.Type == http2FrameHeaders && fr.ReadMetaHeaders != null) {
        return fr.readMetaFrame(f._<ptr<http2HeadersFrame>>());
    }
    return (f, error.As(null!)!);
}

// connError returns ConnectionError(code) but first
// stashes away a public reason to the caller can optionally relay it
// to the peer before hanging up on them. This might help others debug
// their implementations.
private static error connError(this ptr<http2Framer> _addr_fr, http2ErrCode code, @string reason) {
    ref http2Framer fr = ref _addr_fr.val;

    fr.errDetail = errors.New(reason);
    return error.As(http2ConnectionError(code))!;
}

// checkFrameOrder reports an error if f is an invalid frame to return
// next from ReadFrame. Mostly it checks whether HEADERS and
// CONTINUATION frames are contiguous.
private static error checkFrameOrder(this ptr<http2Framer> _addr_fr, http2Frame f) {
    ref http2Framer fr = ref _addr_fr.val;

    var last = fr.lastFrame;
    fr.lastFrame = f;
    if (fr.AllowIllegalReads) {
        return error.As(null!)!;
    }
    var fh = f.Header();
    if (fr.lastHeaderStream != 0) {
        if (fh.Type != http2FrameContinuation) {
            return error.As(fr.connError(http2ErrCodeProtocol, fmt.Sprintf("got %s for stream %d; expected CONTINUATION following %s for stream %d", fh.Type, fh.StreamID, last.Header().Type, fr.lastHeaderStream)))!;
        }
        if (fh.StreamID != fr.lastHeaderStream) {
            return error.As(fr.connError(http2ErrCodeProtocol, fmt.Sprintf("got CONTINUATION for stream %d; expected stream %d", fh.StreamID, fr.lastHeaderStream)))!;
        }
    }
    else if (fh.Type == http2FrameContinuation) {
        return error.As(fr.connError(http2ErrCodeProtocol, fmt.Sprintf("unexpected CONTINUATION for stream %d", fh.StreamID)))!;
    }

    if (fh.Type == http2FrameHeaders || fh.Type == http2FrameContinuation) 
        if (fh.Flags.Has(http2FlagHeadersEndHeaders)) {
            fr.lastHeaderStream = 0;
        }
        else
 {
            fr.lastHeaderStream = fh.StreamID;
        }
        return error.As(null!)!;
}

// A DataFrame conveys arbitrary, variable-length sequences of octets
// associated with a stream.
// See http://http2.github.io/http2-spec/#rfc.section.6.1
private partial struct http2DataFrame {
    public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
    public slice<byte> data;
}

private static bool StreamEnded(this ptr<http2DataFrame> _addr_f) {
    ref http2DataFrame f = ref _addr_f.val;

    return f.http2FrameHeader.Flags.Has(http2FlagDataEndStream);
}

// Data returns the frame's data octets, not including any padding
// size byte or padding suffix bytes.
// The caller must not retain the returned memory past the next
// call to ReadFrame.
private static slice<byte> Data(this ptr<http2DataFrame> _addr_f) {
    ref http2DataFrame f = ref _addr_f.val;

    f.checkValid();
    return f.data;
}

private static (http2Frame, error) http2parseDataFrame(ptr<http2frameCache> _addr_fc, http2FrameHeader fh, slice<byte> payload) {
    http2Frame _p0 = default;
    error _p0 = default!;
    ref http2frameCache fc = ref _addr_fc.val;

    if (fh.StreamID == 0) { 
        // DATA frames MUST be associated with a stream. If a
        // DATA frame is received whose stream identifier
        // field is 0x0, the recipient MUST respond with a
        // connection error (Section 5.4.1) of type
        // PROTOCOL_ERROR.
        return (null, error.As(new http2connError(http2ErrCodeProtocol,"DATA frame with stream ID 0"))!);
    }
    var f = fc.getDataFrame();
    f.http2FrameHeader = fh;

    byte padSize = default;
    if (fh.Flags.Has(http2FlagDataPadded)) {
        error err = default!;
        payload, padSize, err = http2readByte(payload);
        if (err != null) {
            return (null, error.As(err)!);
        }
    }
    if (int(padSize) > len(payload)) { 
        // If the length of the padding is greater than the
        // length of the frame payload, the recipient MUST
        // treat this as a connection error.
        // Filed: https://github.com/http2/http2-spec/issues/610
        return (null, error.As(new http2connError(http2ErrCodeProtocol,"pad size larger than data payload"))!);
    }
    f.data = payload[..(int)len(payload) - int(padSize)];
    return (f, error.As(null!)!);
}

private static var http2errStreamID = errors.New("invalid stream ID");private static var http2errDepStreamID = errors.New("invalid dependent stream ID");private static var http2errPadLength = errors.New("pad length too large");private static var http2errPadBytes = errors.New("padding bytes must all be zeros unless AllowIllegalWrites is enabled");

private static bool http2validStreamIDOrZero(uint streamID) {
    return streamID & (1 << 31) == 0;
}

private static bool http2validStreamID(uint streamID) {
    return streamID != 0 && streamID & (1 << 31) == 0;
}

// WriteData writes a DATA frame.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility not to violate the maximum frame size
// and to not call other Write methods concurrently.
private static error WriteData(this ptr<http2Framer> _addr_f, uint streamID, bool endStream, slice<byte> data) {
    ref http2Framer f = ref _addr_f.val;

    return error.As(f.WriteDataPadded(streamID, endStream, data, null))!;
}

// WriteDataPadded writes a DATA frame with optional padding.
//
// If pad is nil, the padding bit is not sent.
// The length of pad must not exceed 255 bytes.
// The bytes of pad must all be zero, unless f.AllowIllegalWrites is set.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility not to violate the maximum frame size
// and to not call other Write methods concurrently.
private static error WriteDataPadded(this ptr<http2Framer> _addr_f, uint streamID, bool endStream, slice<byte> data, slice<byte> pad) {
    ref http2Framer f = ref _addr_f.val;

    if (!http2validStreamID(streamID) && !f.AllowIllegalWrites) {
        return error.As(http2errStreamID)!;
    }
    if (len(pad) > 0) {
        if (len(pad) > 255) {
            return error.As(http2errPadLength)!;
        }
        if (!f.AllowIllegalWrites) {
            foreach (var (_, b) in pad) {
                if (b != 0) { 
                    // "Padding octets MUST be set to zero when sending."
                    return error.As(http2errPadBytes)!;
                }
            }
        }
    }
    http2Flags flags = default;
    if (endStream) {
        flags |= http2FlagDataEndStream;
    }
    if (pad != null) {
        flags |= http2FlagDataPadded;
    }
    f.startWrite(http2FrameData, flags, streamID);
    if (pad != null) {
        f.wbuf = append(f.wbuf, byte(len(pad)));
    }
    f.wbuf = append(f.wbuf, data);
    f.wbuf = append(f.wbuf, pad);
    return error.As(f.endWrite())!;
}

// A SettingsFrame conveys configuration parameters that affect how
// endpoints communicate, such as preferences and constraints on peer
// behavior.
//
// See http://http2.github.io/http2-spec/#SETTINGS
private partial struct http2SettingsFrame {
    public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
    public slice<byte> p;
}

private static (http2Frame, error) http2parseSettingsFrame(ptr<http2frameCache> _addr__, http2FrameHeader fh, slice<byte> p) {
    http2Frame _p0 = default;
    error _p0 = default!;
    ref http2frameCache _ = ref _addr__.val;

    if (fh.Flags.Has(http2FlagSettingsAck) && fh.Length > 0) { 
        // When this (ACK 0x1) bit is set, the payload of the
        // SETTINGS frame MUST be empty. Receipt of a
        // SETTINGS frame with the ACK flag set and a length
        // field value other than 0 MUST be treated as a
        // connection error (Section 5.4.1) of type
        // FRAME_SIZE_ERROR.
        return (null, error.As(http2ConnectionError(http2ErrCodeFrameSize))!);
    }
    if (fh.StreamID != 0) { 
        // SETTINGS frames always apply to a connection,
        // never a single stream. The stream identifier for a
        // SETTINGS frame MUST be zero (0x0).  If an endpoint
        // receives a SETTINGS frame whose stream identifier
        // field is anything other than 0x0, the endpoint MUST
        // respond with a connection error (Section 5.4.1) of
        // type PROTOCOL_ERROR.
        return (null, error.As(http2ConnectionError(http2ErrCodeProtocol))!);
    }
    if (len(p) % 6 != 0) { 
        // Expecting even number of 6 byte settings.
        return (null, error.As(http2ConnectionError(http2ErrCodeFrameSize))!);
    }
    ptr<http2SettingsFrame> f = addr(new http2SettingsFrame(http2FrameHeader:fh,p:p));
    {
        var (v, ok) = f.Value(http2SettingInitialWindowSize);

        if (ok && v > (1 << 31) - 1) { 
            // Values above the maximum flow control window size of 2^31 - 1 MUST
            // be treated as a connection error (Section 5.4.1) of type
            // FLOW_CONTROL_ERROR.
            return (null, error.As(http2ConnectionError(http2ErrCodeFlowControl))!);
        }
    }
    return (f, error.As(null!)!);
}

private static bool IsAck(this ptr<http2SettingsFrame> _addr_f) {
    ref http2SettingsFrame f = ref _addr_f.val;

    return f.http2FrameHeader.Flags.Has(http2FlagSettingsAck);
}

private static (uint, bool) Value(this ptr<http2SettingsFrame> _addr_f, http2SettingID id) {
    uint v = default;
    bool ok = default;
    ref http2SettingsFrame f = ref _addr_f.val;

    f.checkValid();
    for (nint i = 0; i < f.NumSettings(); i++) {
        {
            var s = f.Setting(i);

            if (s.ID == id) {
                return (s.Val, true);
            }

        }
    }
    return (0, false);
}

// Setting returns the setting from the frame at the given 0-based index.
// The index must be >= 0 and less than f.NumSettings().
private static http2Setting Setting(this ptr<http2SettingsFrame> _addr_f, nint i) {
    ref http2SettingsFrame f = ref _addr_f.val;

    var buf = f.p;
    return new http2Setting(ID:http2SettingID(binary.BigEndian.Uint16(buf[i*6:i*6+2])),Val:binary.BigEndian.Uint32(buf[i*6+2:i*6+6]),);
}

private static nint NumSettings(this ptr<http2SettingsFrame> _addr_f) {
    ref http2SettingsFrame f = ref _addr_f.val;

    return len(f.p) / 6;
}

// HasDuplicates reports whether f contains any duplicate setting IDs.
private static bool HasDuplicates(this ptr<http2SettingsFrame> _addr_f) {
    ref http2SettingsFrame f = ref _addr_f.val;

    var num = f.NumSettings();
    if (num == 0) {
        return false;
    }
    if (num < 10) {
        {
            nint i__prev1 = i;

            for (nint i = 0; i < num; i++) {
                var idi = f.Setting(i).ID;
                for (var j = i + 1; j < num; j++) {
                    var idj = f.Setting(j).ID;
                    if (idi == idj) {
                        return true;
                    }
                }
            }


            i = i__prev1;
        }
        return false;
    }
    map seen = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<http2SettingID, bool>{};
    {
        nint i__prev1 = i;

        for (i = 0; i < num; i++) {
            var id = f.Setting(i).ID;
            if (seen[id]) {
                return true;
            }
            seen[id] = true;
        }

        i = i__prev1;
    }
    return false;
}

// ForeachSetting runs fn for each setting.
// It stops and returns the first error.
private static error ForeachSetting(this ptr<http2SettingsFrame> _addr_f, Func<http2Setting, error> fn) {
    ref http2SettingsFrame f = ref _addr_f.val;

    f.checkValid();
    for (nint i = 0; i < f.NumSettings(); i++) {
        {
            var err = fn(f.Setting(i));

            if (err != null) {
                return error.As(err)!;
            }

        }
    }
    return error.As(null!)!;
}

// WriteSettings writes a SETTINGS frame with zero or more settings
// specified and the ACK bit not set.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
private static error WriteSettings(this ptr<http2Framer> _addr_f, params http2Setting[] settings) {
    settings = settings.Clone();
    ref http2Framer f = ref _addr_f.val;

    f.startWrite(http2FrameSettings, 0, 0);
    foreach (var (_, s) in settings) {
        f.writeUint16(uint16(s.ID));
        f.writeUint32(s.Val);
    }    return error.As(f.endWrite())!;
}

// WriteSettingsAck writes an empty SETTINGS frame with the ACK bit set.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
private static error WriteSettingsAck(this ptr<http2Framer> _addr_f) {
    ref http2Framer f = ref _addr_f.val;

    f.startWrite(http2FrameSettings, http2FlagSettingsAck, 0);
    return error.As(f.endWrite())!;
}

// A PingFrame is a mechanism for measuring a minimal round trip time
// from the sender, as well as determining whether an idle connection
// is still functional.
// See http://http2.github.io/http2-spec/#rfc.section.6.7
private partial struct http2PingFrame {
    public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
    public array<byte> Data;
}

private static bool IsAck(this ptr<http2PingFrame> _addr_f) {
    ref http2PingFrame f = ref _addr_f.val;

    return f.Flags.Has(http2FlagPingAck);
}

private static (http2Frame, error) http2parsePingFrame(ptr<http2frameCache> _addr__, http2FrameHeader fh, slice<byte> payload) {
    http2Frame _p0 = default;
    error _p0 = default!;
    ref http2frameCache _ = ref _addr__.val;

    if (len(payload) != 8) {
        return (null, error.As(http2ConnectionError(http2ErrCodeFrameSize))!);
    }
    if (fh.StreamID != 0) {
        return (null, error.As(http2ConnectionError(http2ErrCodeProtocol))!);
    }
    ptr<http2PingFrame> f = addr(new http2PingFrame(http2FrameHeader:fh));
    copy(f.Data[..], payload);
    return (f, error.As(null!)!);
}

private static error WritePing(this ptr<http2Framer> _addr_f, bool ack, array<byte> data) {
    data = data.Clone();
    ref http2Framer f = ref _addr_f.val;

    http2Flags flags = default;
    if (ack) {
        flags = http2FlagPingAck;
    }
    f.startWrite(http2FramePing, flags, 0);
    f.writeBytes(data[..]);
    return error.As(f.endWrite())!;
}

// A GoAwayFrame informs the remote peer to stop creating streams on this connection.
// See http://http2.github.io/http2-spec/#rfc.section.6.8
private partial struct http2GoAwayFrame {
    public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
    public uint LastStreamID;
    public http2ErrCode ErrCode;
    public slice<byte> debugData;
}

// DebugData returns any debug data in the GOAWAY frame. Its contents
// are not defined.
// The caller must not retain the returned memory past the next
// call to ReadFrame.
private static slice<byte> DebugData(this ptr<http2GoAwayFrame> _addr_f) {
    ref http2GoAwayFrame f = ref _addr_f.val;

    f.checkValid();
    return f.debugData;
}

private static (http2Frame, error) http2parseGoAwayFrame(ptr<http2frameCache> _addr__, http2FrameHeader fh, slice<byte> p) {
    http2Frame _p0 = default;
    error _p0 = default!;
    ref http2frameCache _ = ref _addr__.val;

    if (fh.StreamID != 0) {
        return (null, error.As(http2ConnectionError(http2ErrCodeProtocol))!);
    }
    if (len(p) < 8) {
        return (null, error.As(http2ConnectionError(http2ErrCodeFrameSize))!);
    }
    return (addr(new http2GoAwayFrame(http2FrameHeader:fh,LastStreamID:binary.BigEndian.Uint32(p[:4])&(1<<31-1),ErrCode:http2ErrCode(binary.BigEndian.Uint32(p[4:8])),debugData:p[8:],)), error.As(null!)!);
}

private static error WriteGoAway(this ptr<http2Framer> _addr_f, uint maxStreamID, http2ErrCode code, slice<byte> debugData) {
    ref http2Framer f = ref _addr_f.val;

    f.startWrite(http2FrameGoAway, 0, 0);
    f.writeUint32(maxStreamID & (1 << 31 - 1));
    f.writeUint32(uint32(code));
    f.writeBytes(debugData);
    return error.As(f.endWrite())!;
}

// An UnknownFrame is the frame type returned when the frame type is unknown
// or no specific frame type parser exists.
private partial struct http2UnknownFrame {
    public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
    public slice<byte> p;
}

// Payload returns the frame's payload (after the header).  It is not
// valid to call this method after a subsequent call to
// Framer.ReadFrame, nor is it valid to retain the returned slice.
// The memory is owned by the Framer and is invalidated when the next
// frame is read.
private static slice<byte> Payload(this ptr<http2UnknownFrame> _addr_f) {
    ref http2UnknownFrame f = ref _addr_f.val;

    f.checkValid();
    return f.p;
}

private static (http2Frame, error) http2parseUnknownFrame(ptr<http2frameCache> _addr__, http2FrameHeader fh, slice<byte> p) {
    http2Frame _p0 = default;
    error _p0 = default!;
    ref http2frameCache _ = ref _addr__.val;

    return (addr(new http2UnknownFrame(fh,p)), error.As(null!)!);
}

// A WindowUpdateFrame is used to implement flow control.
// See http://http2.github.io/http2-spec/#rfc.section.6.9
private partial struct http2WindowUpdateFrame {
    public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
    public uint Increment; // never read with high bit set
}

private static (http2Frame, error) http2parseWindowUpdateFrame(ptr<http2frameCache> _addr__, http2FrameHeader fh, slice<byte> p) {
    http2Frame _p0 = default;
    error _p0 = default!;
    ref http2frameCache _ = ref _addr__.val;

    if (len(p) != 4) {
        return (null, error.As(http2ConnectionError(http2ErrCodeFrameSize))!);
    }
    var inc = binary.BigEndian.Uint32(p[..(int)4]) & 0x7fffffff; // mask off high reserved bit
    if (inc == 0) { 
        // A receiver MUST treat the receipt of a
        // WINDOW_UPDATE frame with an flow control window
        // increment of 0 as a stream error (Section 5.4.2) of
        // type PROTOCOL_ERROR; errors on the connection flow
        // control window MUST be treated as a connection
        // error (Section 5.4.1).
        if (fh.StreamID == 0) {
            return (null, error.As(http2ConnectionError(http2ErrCodeProtocol))!);
        }
        return (null, error.As(http2streamError(fh.StreamID, http2ErrCodeProtocol))!);
    }
    return (addr(new http2WindowUpdateFrame(http2FrameHeader:fh,Increment:inc,)), error.As(null!)!);
}

// WriteWindowUpdate writes a WINDOW_UPDATE frame.
// The increment value must be between 1 and 2,147,483,647, inclusive.
// If the Stream ID is zero, the window update applies to the
// connection as a whole.
private static error WriteWindowUpdate(this ptr<http2Framer> _addr_f, uint streamID, uint incr) {
    ref http2Framer f = ref _addr_f.val;
 
    // "The legal range for the increment to the flow control window is 1 to 2^31-1 (2,147,483,647) octets."
    if ((incr < 1 || incr > 2147483647) && !f.AllowIllegalWrites) {
        return error.As(errors.New("illegal window increment value"))!;
    }
    f.startWrite(http2FrameWindowUpdate, 0, streamID);
    f.writeUint32(incr);
    return error.As(f.endWrite())!;
}

// A HeadersFrame is used to open a stream and additionally carries a
// header block fragment.
private partial struct http2HeadersFrame {
    public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val; // Priority is set if FlagHeadersPriority is set in the FrameHeader.
    public http2PriorityParam Priority;
    public slice<byte> headerFragBuf; // not owned
}

private static slice<byte> HeaderBlockFragment(this ptr<http2HeadersFrame> _addr_f) {
    ref http2HeadersFrame f = ref _addr_f.val;

    f.checkValid();
    return f.headerFragBuf;
}

private static bool HeadersEnded(this ptr<http2HeadersFrame> _addr_f) {
    ref http2HeadersFrame f = ref _addr_f.val;

    return f.http2FrameHeader.Flags.Has(http2FlagHeadersEndHeaders);
}

private static bool StreamEnded(this ptr<http2HeadersFrame> _addr_f) {
    ref http2HeadersFrame f = ref _addr_f.val;

    return f.http2FrameHeader.Flags.Has(http2FlagHeadersEndStream);
}

private static bool HasPriority(this ptr<http2HeadersFrame> _addr_f) {
    ref http2HeadersFrame f = ref _addr_f.val;

    return f.http2FrameHeader.Flags.Has(http2FlagHeadersPriority);
}

private static (http2Frame, error) http2parseHeadersFrame(ptr<http2frameCache> _addr__, http2FrameHeader fh, slice<byte> p) {
    http2Frame _ = default;
    error err = default!;
    ref http2frameCache _ = ref _addr__.val;

    ptr<http2HeadersFrame> hf = addr(new http2HeadersFrame(http2FrameHeader:fh,));
    if (fh.StreamID == 0) { 
        // HEADERS frames MUST be associated with a stream. If a HEADERS frame
        // is received whose stream identifier field is 0x0, the recipient MUST
        // respond with a connection error (Section 5.4.1) of type
        // PROTOCOL_ERROR.
        return (null, error.As(new http2connError(http2ErrCodeProtocol,"HEADERS frame with stream ID 0"))!);
    }
    byte padLength = default;
    if (fh.Flags.Has(http2FlagHeadersPadded)) {
        p, padLength, err = http2readByte(p);

        if (err != null) {
            return ;
        }
    }
    if (fh.Flags.Has(http2FlagHeadersPriority)) {
        uint v = default;
        p, v, err = http2readUint32(p);
        if (err != null) {
            return (null, error.As(err)!);
        }
        hf.Priority.StreamDep = v & 0x7fffffff;
        hf.Priority.Exclusive = (v != hf.Priority.StreamDep); // high bit was set
        p, hf.Priority.Weight, err = http2readByte(p);
        if (err != null) {
            return (null, error.As(err)!);
        }
    }
    if (len(p) - int(padLength) < 0) {
        return (null, error.As(http2streamError(fh.StreamID, http2ErrCodeProtocol))!);
    }
    hf.headerFragBuf = p[..(int)len(p) - int(padLength)];
    return (hf, error.As(null!)!);
}

// HeadersFrameParam are the parameters for writing a HEADERS frame.
private partial struct http2HeadersFrameParam {
    public uint StreamID; // BlockFragment is part (or all) of a Header Block.
    public slice<byte> BlockFragment; // EndStream indicates that the header block is the last that
// the endpoint will send for the identified stream. Setting
// this flag causes the stream to enter one of "half closed"
// states.
    public bool EndStream; // EndHeaders indicates that this frame contains an entire
// header block and is not followed by any
// CONTINUATION frames.
    public bool EndHeaders; // PadLength is the optional number of bytes of zeros to add
// to this frame.
    public byte PadLength; // Priority, if non-zero, includes stream priority information
// in the HEADER frame.
    public http2PriorityParam Priority;
}

// WriteHeaders writes a single HEADERS frame.
//
// This is a low-level header writing method. Encoding headers and
// splitting them into any necessary CONTINUATION frames is handled
// elsewhere.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
private static error WriteHeaders(this ptr<http2Framer> _addr_f, http2HeadersFrameParam p) {
    ref http2Framer f = ref _addr_f.val;

    if (!http2validStreamID(p.StreamID) && !f.AllowIllegalWrites) {
        return error.As(http2errStreamID)!;
    }
    http2Flags flags = default;
    if (p.PadLength != 0) {
        flags |= http2FlagHeadersPadded;
    }
    if (p.EndStream) {
        flags |= http2FlagHeadersEndStream;
    }
    if (p.EndHeaders) {
        flags |= http2FlagHeadersEndHeaders;
    }
    if (!p.Priority.IsZero()) {
        flags |= http2FlagHeadersPriority;
    }
    f.startWrite(http2FrameHeaders, flags, p.StreamID);
    if (p.PadLength != 0) {
        f.writeByte(p.PadLength);
    }
    if (!p.Priority.IsZero()) {
        var v = p.Priority.StreamDep;
        if (!http2validStreamIDOrZero(v) && !f.AllowIllegalWrites) {
            return error.As(http2errDepStreamID)!;
        }
        if (p.Priority.Exclusive) {
            v |= 1 << 31;
        }
        f.writeUint32(v);
        f.writeByte(p.Priority.Weight);
    }
    f.wbuf = append(f.wbuf, p.BlockFragment);
    f.wbuf = append(f.wbuf, http2padZeros[..(int)p.PadLength]);
    return error.As(f.endWrite())!;
}

// A PriorityFrame specifies the sender-advised priority of a stream.
// See http://http2.github.io/http2-spec/#rfc.section.6.3
private partial struct http2PriorityFrame {
    public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
    public ref http2PriorityParam http2PriorityParam => ref http2PriorityParam_val;
}

// PriorityParam are the stream prioritzation parameters.
private partial struct http2PriorityParam {
    public uint StreamDep; // Exclusive is whether the dependency is exclusive.
    public bool Exclusive; // Weight is the stream's zero-indexed weight. It should be
// set together with StreamDep, or neither should be set. Per
// the spec, "Add one to the value to obtain a weight between
// 1 and 256."
    public byte Weight;
}

private static bool IsZero(this http2PriorityParam p) {
    return p == new http2PriorityParam();
}

private static (http2Frame, error) http2parsePriorityFrame(ptr<http2frameCache> _addr__, http2FrameHeader fh, slice<byte> payload) {
    http2Frame _p0 = default;
    error _p0 = default!;
    ref http2frameCache _ = ref _addr__.val;

    if (fh.StreamID == 0) {
        return (null, error.As(new http2connError(http2ErrCodeProtocol,"PRIORITY frame with stream ID 0"))!);
    }
    if (len(payload) != 5) {
        return (null, error.As(new http2connError(http2ErrCodeFrameSize,fmt.Sprintf("PRIORITY frame payload size was %d; want 5",len(payload))))!);
    }
    var v = binary.BigEndian.Uint32(payload[..(int)4]);
    var streamID = v & 0x7fffffff; // mask off high bit
    return (addr(new http2PriorityFrame(http2FrameHeader:fh,http2PriorityParam:http2PriorityParam{Weight:payload[4],StreamDep:streamID,Exclusive:streamID!=v,},)), error.As(null!)!);
}

// WritePriority writes a PRIORITY frame.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
private static error WritePriority(this ptr<http2Framer> _addr_f, uint streamID, http2PriorityParam p) {
    ref http2Framer f = ref _addr_f.val;

    if (!http2validStreamID(streamID) && !f.AllowIllegalWrites) {
        return error.As(http2errStreamID)!;
    }
    if (!http2validStreamIDOrZero(p.StreamDep)) {
        return error.As(http2errDepStreamID)!;
    }
    f.startWrite(http2FramePriority, 0, streamID);
    var v = p.StreamDep;
    if (p.Exclusive) {
        v |= 1 << 31;
    }
    f.writeUint32(v);
    f.writeByte(p.Weight);
    return error.As(f.endWrite())!;
}

// A RSTStreamFrame allows for abnormal termination of a stream.
// See http://http2.github.io/http2-spec/#rfc.section.6.4
private partial struct http2RSTStreamFrame {
    public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
    public http2ErrCode ErrCode;
}

private static (http2Frame, error) http2parseRSTStreamFrame(ptr<http2frameCache> _addr__, http2FrameHeader fh, slice<byte> p) {
    http2Frame _p0 = default;
    error _p0 = default!;
    ref http2frameCache _ = ref _addr__.val;

    if (len(p) != 4) {
        return (null, error.As(http2ConnectionError(http2ErrCodeFrameSize))!);
    }
    if (fh.StreamID == 0) {
        return (null, error.As(http2ConnectionError(http2ErrCodeProtocol))!);
    }
    return (addr(new http2RSTStreamFrame(fh,http2ErrCode(binary.BigEndian.Uint32(p[:4])))), error.As(null!)!);
}

// WriteRSTStream writes a RST_STREAM frame.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
private static error WriteRSTStream(this ptr<http2Framer> _addr_f, uint streamID, http2ErrCode code) {
    ref http2Framer f = ref _addr_f.val;

    if (!http2validStreamID(streamID) && !f.AllowIllegalWrites) {
        return error.As(http2errStreamID)!;
    }
    f.startWrite(http2FrameRSTStream, 0, streamID);
    f.writeUint32(uint32(code));
    return error.As(f.endWrite())!;
}

// A ContinuationFrame is used to continue a sequence of header block fragments.
// See http://http2.github.io/http2-spec/#rfc.section.6.10
private partial struct http2ContinuationFrame {
    public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
    public slice<byte> headerFragBuf;
}

private static (http2Frame, error) http2parseContinuationFrame(ptr<http2frameCache> _addr__, http2FrameHeader fh, slice<byte> p) {
    http2Frame _p0 = default;
    error _p0 = default!;
    ref http2frameCache _ = ref _addr__.val;

    if (fh.StreamID == 0) {
        return (null, error.As(new http2connError(http2ErrCodeProtocol,"CONTINUATION frame with stream ID 0"))!);
    }
    return (addr(new http2ContinuationFrame(fh,p)), error.As(null!)!);
}

private static slice<byte> HeaderBlockFragment(this ptr<http2ContinuationFrame> _addr_f) {
    ref http2ContinuationFrame f = ref _addr_f.val;

    f.checkValid();
    return f.headerFragBuf;
}

private static bool HeadersEnded(this ptr<http2ContinuationFrame> _addr_f) {
    ref http2ContinuationFrame f = ref _addr_f.val;

    return f.http2FrameHeader.Flags.Has(http2FlagContinuationEndHeaders);
}

// WriteContinuation writes a CONTINUATION frame.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
private static error WriteContinuation(this ptr<http2Framer> _addr_f, uint streamID, bool endHeaders, slice<byte> headerBlockFragment) {
    ref http2Framer f = ref _addr_f.val;

    if (!http2validStreamID(streamID) && !f.AllowIllegalWrites) {
        return error.As(http2errStreamID)!;
    }
    http2Flags flags = default;
    if (endHeaders) {
        flags |= http2FlagContinuationEndHeaders;
    }
    f.startWrite(http2FrameContinuation, flags, streamID);
    f.wbuf = append(f.wbuf, headerBlockFragment);
    return error.As(f.endWrite())!;
}

// A PushPromiseFrame is used to initiate a server stream.
// See http://http2.github.io/http2-spec/#rfc.section.6.6
private partial struct http2PushPromiseFrame {
    public ref http2FrameHeader http2FrameHeader => ref http2FrameHeader_val;
    public uint PromiseID;
    public slice<byte> headerFragBuf; // not owned
}

private static slice<byte> HeaderBlockFragment(this ptr<http2PushPromiseFrame> _addr_f) {
    ref http2PushPromiseFrame f = ref _addr_f.val;

    f.checkValid();
    return f.headerFragBuf;
}

private static bool HeadersEnded(this ptr<http2PushPromiseFrame> _addr_f) {
    ref http2PushPromiseFrame f = ref _addr_f.val;

    return f.http2FrameHeader.Flags.Has(http2FlagPushPromiseEndHeaders);
}

private static (http2Frame, error) http2parsePushPromise(ptr<http2frameCache> _addr__, http2FrameHeader fh, slice<byte> p) {
    http2Frame _ = default;
    error err = default!;
    ref http2frameCache _ = ref _addr__.val;

    ptr<http2PushPromiseFrame> pp = addr(new http2PushPromiseFrame(http2FrameHeader:fh,));
    if (pp.StreamID == 0) { 
        // PUSH_PROMISE frames MUST be associated with an existing,
        // peer-initiated stream. The stream identifier of a
        // PUSH_PROMISE frame indicates the stream it is associated
        // with. If the stream identifier field specifies the value
        // 0x0, a recipient MUST respond with a connection error
        // (Section 5.4.1) of type PROTOCOL_ERROR.
        return (null, error.As(http2ConnectionError(http2ErrCodeProtocol))!);
    }
    byte padLength = default;
    if (fh.Flags.Has(http2FlagPushPromisePadded)) {
        p, padLength, err = http2readByte(p);

        if (err != null) {
            return ;
        }
    }
    p, pp.PromiseID, err = http2readUint32(p);
    if (err != null) {
        return ;
    }
    pp.PromiseID = pp.PromiseID & (1 << 31 - 1);

    if (int(padLength) > len(p)) { 
        // like the DATA frame, error out if padding is longer than the body.
        return (null, error.As(http2ConnectionError(http2ErrCodeProtocol))!);
    }
    pp.headerFragBuf = p[..(int)len(p) - int(padLength)];
    return (pp, error.As(null!)!);
}

// PushPromiseParam are the parameters for writing a PUSH_PROMISE frame.
private partial struct http2PushPromiseParam {
    public uint StreamID; // PromiseID is the required Stream ID which this
// Push Promises
    public uint PromiseID; // BlockFragment is part (or all) of a Header Block.
    public slice<byte> BlockFragment; // EndHeaders indicates that this frame contains an entire
// header block and is not followed by any
// CONTINUATION frames.
    public bool EndHeaders; // PadLength is the optional number of bytes of zeros to add
// to this frame.
    public byte PadLength;
}

// WritePushPromise writes a single PushPromise Frame.
//
// As with Header Frames, This is the low level call for writing
// individual frames. Continuation frames are handled elsewhere.
//
// It will perform exactly one Write to the underlying Writer.
// It is the caller's responsibility to not call other Write methods concurrently.
private static error WritePushPromise(this ptr<http2Framer> _addr_f, http2PushPromiseParam p) {
    ref http2Framer f = ref _addr_f.val;

    if (!http2validStreamID(p.StreamID) && !f.AllowIllegalWrites) {
        return error.As(http2errStreamID)!;
    }
    http2Flags flags = default;
    if (p.PadLength != 0) {
        flags |= http2FlagPushPromisePadded;
    }
    if (p.EndHeaders) {
        flags |= http2FlagPushPromiseEndHeaders;
    }
    f.startWrite(http2FramePushPromise, flags, p.StreamID);
    if (p.PadLength != 0) {
        f.writeByte(p.PadLength);
    }
    if (!http2validStreamID(p.PromiseID) && !f.AllowIllegalWrites) {
        return error.As(http2errStreamID)!;
    }
    f.writeUint32(p.PromiseID);
    f.wbuf = append(f.wbuf, p.BlockFragment);
    f.wbuf = append(f.wbuf, http2padZeros[..(int)p.PadLength]);
    return error.As(f.endWrite())!;
}

// WriteRawFrame writes a raw frame. This can be used to write
// extension frames unknown to this package.
private static error WriteRawFrame(this ptr<http2Framer> _addr_f, http2FrameType t, http2Flags flags, uint streamID, slice<byte> payload) {
    ref http2Framer f = ref _addr_f.val;

    f.startWrite(t, flags, streamID);
    f.writeBytes(payload);
    return error.As(f.endWrite())!;
}

private static (slice<byte>, byte, error) http2readByte(slice<byte> p) {
    slice<byte> remain = default;
    byte b = default;
    error err = default!;

    if (len(p) == 0) {
        return (null, 0, error.As(io.ErrUnexpectedEOF)!);
    }
    return (p[(int)1..], p[0], error.As(null!)!);
}

private static (slice<byte>, uint, error) http2readUint32(slice<byte> p) {
    slice<byte> remain = default;
    uint v = default;
    error err = default!;

    if (len(p) < 4) {
        return (null, 0, error.As(io.ErrUnexpectedEOF)!);
    }
    return (p[(int)4..], binary.BigEndian.Uint32(p[..(int)4]), error.As(null!)!);
}

private partial interface http2streamEnder {
    bool StreamEnded();
}

private partial interface http2headersEnder {
    bool HeadersEnded();
}

private partial interface http2headersOrContinuation {
    slice<byte> HeaderBlockFragment();
}

// A MetaHeadersFrame is the representation of one HEADERS frame and
// zero or more contiguous CONTINUATION frames and the decoding of
// their HPACK-encoded contents.
//
// This type of frame does not appear on the wire and is only returned
// by the Framer when Framer.ReadMetaHeaders is set.
private partial struct http2MetaHeadersFrame {
    public ref ptr<http2HeadersFrame> ptr<http2HeadersFrame> => ref ptr<http2HeadersFrame>_ptr; // Fields are the fields contained in the HEADERS and
// CONTINUATION frames. The underlying slice is owned by the
// Framer and must not be retained after the next call to
// ReadFrame.
//
// Fields are guaranteed to be in the correct http2 order and
// not have unknown pseudo header fields or invalid header
// field names or values. Required pseudo header fields may be
// missing, however. Use the MetaHeadersFrame.Pseudo accessor
// method access pseudo headers.
    public slice<hpack.HeaderField> Fields; // Truncated is whether the max header list size limit was hit
// and Fields is incomplete. The hpack decoder state is still
// valid, however.
    public bool Truncated;
}

// PseudoValue returns the given pseudo header field's value.
// The provided pseudo field should not contain the leading colon.
private static @string PseudoValue(this ptr<http2MetaHeadersFrame> _addr_mh, @string pseudo) {
    ref http2MetaHeadersFrame mh = ref _addr_mh.val;

    foreach (var (_, hf) in mh.Fields) {
        if (!hf.IsPseudo()) {
            return "";
        }
        if (hf.Name[(int)1..] == pseudo) {
            return hf.Value;
        }
    }    return "";
}

// RegularFields returns the regular (non-pseudo) header fields of mh.
// The caller does not own the returned slice.
private static slice<hpack.HeaderField> RegularFields(this ptr<http2MetaHeadersFrame> _addr_mh) {
    ref http2MetaHeadersFrame mh = ref _addr_mh.val;

    foreach (var (i, hf) in mh.Fields) {
        if (!hf.IsPseudo()) {
            return mh.Fields[(int)i..];
        }
    }    return null;
}

// PseudoFields returns the pseudo header fields of mh.
// The caller does not own the returned slice.
private static slice<hpack.HeaderField> PseudoFields(this ptr<http2MetaHeadersFrame> _addr_mh) {
    ref http2MetaHeadersFrame mh = ref _addr_mh.val;

    foreach (var (i, hf) in mh.Fields) {
        if (!hf.IsPseudo()) {
            return mh.Fields[..(int)i];
        }
    }    return mh.Fields;
}

private static error checkPseudos(this ptr<http2MetaHeadersFrame> _addr_mh) {
    ref http2MetaHeadersFrame mh = ref _addr_mh.val;

    bool isRequest = default;    bool isResponse = default;

    var pf = mh.PseudoFields();
    foreach (var (i, hf) in pf) {
        switch (hf.Name) {
            case ":method": 

            case ":path": 

            case ":scheme": 

            case ":authority": 
                isRequest = true;
                break;
            case ":status": 
                isResponse = true;
                break;
            default: 
                return error.As(http2pseudoHeaderError(hf.Name))!;
                break;
        } 
        // Check for duplicates.
        // This would be a bad algorithm, but N is 4.
        // And this doesn't allocate.
        foreach (var (_, hf2) in pf[..(int)i]) {
            if (hf.Name == hf2.Name) {
                return error.As(http2duplicatePseudoHeaderError(hf.Name))!;
            }
        }
    }    if (isRequest && isResponse) {
        return error.As(http2errMixPseudoHeaderTypes)!;
    }
    return error.As(null!)!;
}

private static nint maxHeaderStringLen(this ptr<http2Framer> _addr_fr) {
    ref http2Framer fr = ref _addr_fr.val;

    var v = fr.maxHeaderListSize();
    if (uint32(int(v)) == v) {
        return int(v);
    }
    return 0;
}

// readMetaFrame returns 0 or more CONTINUATION frames from fr and
// merge them into the provided hf and returns a MetaHeadersFrame
// with the decoded hpack values.
private static (ptr<http2MetaHeadersFrame>, error) readMetaFrame(this ptr<http2Framer> _addr_fr, ptr<http2HeadersFrame> _addr_hf) => func((defer, _, _) => {
    ptr<http2MetaHeadersFrame> _p0 = default!;
    error _p0 = default!;
    ref http2Framer fr = ref _addr_fr.val;
    ref http2HeadersFrame hf = ref _addr_hf.val;

    if (fr.AllowIllegalReads) {
        return (_addr_null!, error.As(errors.New("illegal use of AllowIllegalReads with ReadMetaHeaders"))!);
    }
    ptr<http2MetaHeadersFrame> mh = addr(new http2MetaHeadersFrame(http2HeadersFrame:hf,));
    var remainSize = fr.maxHeaderListSize();
    bool sawRegular = default;

    error invalid = default!; // pseudo header field errors
    var hdec = fr.ReadMetaHeaders;
    hdec.SetEmitEnabled(true);
    hdec.SetMaxStringLength(fr.maxHeaderStringLen());
    hdec.SetEmitFunc(hf => {
        if (http2VerboseLogs && fr.logReads) {
            fr.debugReadLoggerf("http2: decoded hpack field %+v", hf);
        }
        if (!httpguts.ValidHeaderFieldValue(hf.Value)) {
            invalid = error.As(http2headerFieldValueError(hf.Value))!;
        }
        var isPseudo = strings.HasPrefix(hf.Name, ":");
        if (isPseudo) {
            if (sawRegular) {
                invalid = error.As(http2errPseudoAfterRegular)!;
            }
        }
        else
 {
            sawRegular = true;
            if (!http2validWireHeaderFieldName(hf.Name)) {
                invalid = error.As(http2headerFieldNameError(hf.Name))!;
            }
        }
        if (invalid != null) {
            hdec.SetEmitEnabled(false);
            return ;
        }
        var size = hf.Size();
        if (size > remainSize) {
            hdec.SetEmitEnabled(false);
            mh.Truncated = true;
            return ;
        }
        remainSize -= size;

        mh.Fields = append(mh.Fields, hf);
    }); 
    // Lose reference to MetaHeadersFrame:
    defer(hdec.SetEmitFunc(hf => {
    }));

    http2headersOrContinuation hc = http2headersOrContinuation.As(hf)!;
    while (true) {
        var frag = hc.HeaderBlockFragment();
        {
            var err__prev1 = err;

            var (_, err) = hdec.Write(frag);

            if (err != null) {
                return (_addr_null!, error.As(http2ConnectionError(http2ErrCodeCompression))!);
            }

            err = err__prev1;

        }

        if (hc.HeadersEnded()) {
            break;
        }
        {
            var err__prev1 = err;

            var (f, err) = fr.ReadFrame();

            if (err != null) {
                return (_addr_null!, error.As(err)!);
            }
            else
 {
                hc = http2headersOrContinuation.As(f._<ptr<http2ContinuationFrame>>())!; // guaranteed by checkFrameOrder
            }

            err = err__prev1;

        }
    }

    mh.http2HeadersFrame.headerFragBuf = null;
    mh.http2HeadersFrame.invalidate();

    {
        var err__prev1 = err;

        var err = hdec.Close();

        if (err != null) {
            return (_addr_null!, error.As(http2ConnectionError(http2ErrCodeCompression))!);
        }
        err = err__prev1;

    }
    if (invalid != null) {
        fr.errDetail = invalid;
        if (http2VerboseLogs) {
            log.Printf("http2: invalid header: %v", invalid);
        }
        return (_addr_null!, error.As(new http2StreamError(mh.StreamID,http2ErrCodeProtocol,invalid))!);
    }
    {
        var err__prev1 = err;

        err = mh.checkPseudos();

        if (err != null) {
            fr.errDetail = err;
            if (http2VerboseLogs) {
                log.Printf("http2: invalid pseudo headers: %v", err);
            }
            return (_addr_null!, error.As(new http2StreamError(mh.StreamID,http2ErrCodeProtocol,err))!);
        }
        err = err__prev1;

    }
    return (_addr_mh!, error.As(null!)!);
});

private static @string http2summarizeFrame(http2Frame f) {
    ref bytes.Buffer buf = ref heap(out ptr<bytes.Buffer> _addr_buf);
    f.Header().writeDebug(_addr_buf);
    switch (f.type()) {
        case ptr<http2SettingsFrame> f:
            nint n = 0;
            f.ForeachSetting(s => {
                n++;
                if (n == 1) {
                    buf.WriteString(", settings:");
                }
                fmt.Fprintf(_addr_buf, " %v=%v,", s.ID, s.Val);
                return null;
            });
            if (n > 0) {
                buf.Truncate(buf.Len() - 1); // remove trailing comma
            }
            break;
        case ptr<http2DataFrame> f:
            var data = f.Data();
            const nint max = 256;

            if (len(data) > max) {
                data = data[..(int)max];
            }
            fmt.Fprintf(_addr_buf, " data=%q", data);
            if (len(f.Data()) > max) {
                fmt.Fprintf(_addr_buf, " (%d bytes omitted)", len(f.Data()) - max);
            }
            break;
        case ptr<http2WindowUpdateFrame> f:
            if (f.StreamID == 0) {
                buf.WriteString(" (conn)");
            }
            fmt.Fprintf(_addr_buf, " incr=%v", f.Increment);
            break;
        case ptr<http2PingFrame> f:
            fmt.Fprintf(_addr_buf, " ping=%q", f.Data[..]);
            break;
        case ptr<http2GoAwayFrame> f:
            fmt.Fprintf(_addr_buf, " LastStreamID=%v ErrCode=%v Debug=%q", f.LastStreamID, f.ErrCode, f.debugData);
            break;
        case ptr<http2RSTStreamFrame> f:
            fmt.Fprintf(_addr_buf, " ErrCode=%v", f.ErrCode);
            break;
    }
    return buf.String();
}

private static bool http2traceHasWroteHeaderField(ptr<httptrace.ClientTrace> _addr_trace) {
    ref httptrace.ClientTrace trace = ref _addr_trace.val;

    return trace != null && trace.WroteHeaderField != null;
}

private static void http2traceWroteHeaderField(ptr<httptrace.ClientTrace> _addr_trace, @string k, @string v) {
    ref httptrace.ClientTrace trace = ref _addr_trace.val;

    if (trace != null && trace.WroteHeaderField != null) {
        trace.WroteHeaderField(k, new slice<@string>(new @string[] { v }));
    }
}

private static Func<nint, textproto.MIMEHeader, error> http2traceGot1xxResponseFunc(ptr<httptrace.ClientTrace> _addr_trace) {
    ref httptrace.ClientTrace trace = ref _addr_trace.val;

    if (trace != null) {
        return trace.Got1xxResponse;
    }
    return null;
}

// dialTLSWithContext uses tls.Dialer, added in Go 1.15, to open a TLS
// connection.
private static (ptr<tls.Conn>, error) dialTLSWithContext(this ptr<http2Transport> _addr_t, context.Context ctx, @string network, @string addr, ptr<tls.Config> _addr_cfg) {
    ptr<tls.Conn> _p0 = default!;
    error _p0 = default!;
    ref http2Transport t = ref _addr_t.val;
    ref tls.Config cfg = ref _addr_cfg.val;

    ptr<tls.Dialer> dialer = addr(new tls.Dialer(Config:cfg,));
    var (cn, err) = dialer.DialContext(ctx, network, addr);
    if (err != null) {
        return (_addr_null!, error.As(err)!);
    }
    ptr<tls.Conn> tlsCn = cn._<ptr<tls.Conn>>(); // DialContext comment promises this will always succeed
    return (_addr_tlsCn!, error.As(null!)!);
}

private static var http2DebugGoroutines = os.Getenv("DEBUG_HTTP2_GOROUTINES") == "1";

private partial struct http2goroutineLock { // : ulong
}

private static http2goroutineLock http2newGoroutineLock() {
    if (!http2DebugGoroutines) {
        return 0;
    }
    return http2goroutineLock(http2curGoroutineID());
}

private static void check(this http2goroutineLock g) => func((_, panic, _) => {
    if (!http2DebugGoroutines) {
        return ;
    }
    if (http2curGoroutineID() != uint64(g)) {
        panic("running on the wrong goroutine");
    }
});

private static void checkNotOn(this http2goroutineLock g) => func((_, panic, _) => {
    if (!http2DebugGoroutines) {
        return ;
    }
    if (http2curGoroutineID() == uint64(g)) {
        panic("running on the wrong goroutine");
    }
});

private static slice<byte> http2goroutineSpace = (slice<byte>)"goroutine ";

private static ulong http2curGoroutineID() => func((defer, panic, _) => {
    ptr<slice<byte>> bp = http2littleBuf.Get()._<ptr<slice<byte>>>();
    defer(http2littleBuf.Put(bp));
    var b = bp.val;
    b = b[..(int)runtime.Stack(b, false)]; 
    // Parse the 4707 out of "goroutine 4707 ["
    b = bytes.TrimPrefix(b, http2goroutineSpace);
    var i = bytes.IndexByte(b, ' ');
    if (i < 0) {
        panic(fmt.Sprintf("No space found in %q", b));
    }
    b = b[..(int)i];
    var (n, err) = http2parseUintBytes(b, 10, 64);
    if (err != null) {
        panic(fmt.Sprintf("Failed to parse goroutine ID out of %q: %v", b, err));
    }
    return n;
});

private static sync.Pool http2littleBuf = new sync.Pool(New:func()interface{}{buf:=make([]byte,64)return&buf},);

// parseUintBytes is like strconv.ParseUint, but using a []byte.
private static (ulong, error) http2parseUintBytes(slice<byte> s, nint @base, nint bitSize) {
    ulong n = default;
    error err = default!;

    ulong cutoff = default;    ulong maxVal = default;



    if (bitSize == 0) {
        bitSize = int(strconv.IntSize);
    }
    var s0 = s;

    if (len(s) < 1) 
        err = strconv.ErrSyntax;
        goto Error;
    else if (2 <= base && base <= 36)     else if (base == 0) 
        // Look for octal, hex prefix.

        if (s[0] == '0' && len(s) > 1 && (s[1] == 'x' || s[1] == 'X')) 
            base = 16;
            s = s[(int)2..];
            if (len(s) < 1) {
                err = strconv.ErrSyntax;
                goto Error;
            }
        else if (s[0] == '0') 
            base = 8;
        else 
            base = 10;
            else 
        err = errors.New("invalid base " + strconv.Itoa(base));
        goto Error;
        n = 0;
    cutoff = http2cutoff64(base);
    maxVal = 1 << (int)(uint(bitSize)) - 1;

    for (nint i = 0; i < len(s); i++) {
        byte v = default;
        var d = s[i];

        if ('0' <= d && d <= '9') 
            v = d - '0';
        else if ('a' <= d && d <= 'z') 
            v = d - 'a' + 10;
        else if ('A' <= d && d <= 'Z') 
            v = d - 'A' + 10;
        else 
            n = 0;
            err = strconv.ErrSyntax;
            goto Error;
                if (int(v) >= base) {
            n = 0;
            err = strconv.ErrSyntax;
            goto Error;
        }
        if (n >= cutoff) { 
            // n*base overflows
            n = 1 << 64 - 1;
            err = strconv.ErrRange;
            goto Error;
        }
        n *= uint64(base);

        var n1 = n + uint64(v);
        if (n1 < n || n1 > maxVal) { 
            // n+v overflows
            n = 1 << 64 - 1;
            err = strconv.ErrRange;
            goto Error;
        }
        n = n1;
    }

    return (n, error.As(null!)!);

Error:
    return (n, error.As(addr(new strconv.NumError(Func:"ParseUint",Num:string(s0),Err:err))!)!);
}

// Return the first number n such that n*base >= 1<<64.
private static ulong http2cutoff64(nint @base) {
    if (base < 2) {
        return 0;
    }
    return (1 << 64 - 1) / uint64(base) + 1;
}

private static sync.Once http2commonBuildOnce = default;private static map<@string, @string> http2commonLowerHeader = default;private static map<@string, @string> http2commonCanonHeader = default;

private static void http2buildCommonHeaderMapsOnce() {
    http2commonBuildOnce.Do(http2buildCommonHeaderMaps);
}

private static void http2buildCommonHeaderMaps() {
    @string common = new slice<@string>(new @string[] { "accept", "accept-charset", "accept-encoding", "accept-language", "accept-ranges", "age", "access-control-allow-origin", "allow", "authorization", "cache-control", "content-disposition", "content-encoding", "content-language", "content-length", "content-location", "content-range", "content-type", "cookie", "date", "etag", "expect", "expires", "from", "host", "if-match", "if-modified-since", "if-none-match", "if-unmodified-since", "last-modified", "link", "location", "max-forwards", "proxy-authenticate", "proxy-authorization", "range", "referer", "refresh", "retry-after", "server", "set-cookie", "strict-transport-security", "trailer", "transfer-encoding", "user-agent", "vary", "via", "www-authenticate" });
    http2commonLowerHeader = make_map<@string, @string>(len(common));
    http2commonCanonHeader = make_map<@string, @string>(len(common));
    foreach (var (_, v) in common) {
        var chk = CanonicalHeaderKey(v);
        http2commonLowerHeader[chk] = v;
        http2commonCanonHeader[v] = chk;
    }
}

private static (@string, bool) http2lowerHeader(@string v) {
    @string lower = default;
    bool ascii = default;

    http2buildCommonHeaderMapsOnce();
    {
        var (s, ok) = http2commonLowerHeader[v];

        if (ok) {
            return (s, true);
        }
    }
    return http2asciiToLower(v);
}

private static bool http2VerboseLogs = default;private static bool http2logFrameWrites = default;private static bool http2logFrameReads = default;private static bool http2inTests = default;

private static void init() {
    var e = os.Getenv("GODEBUG");
    if (strings.Contains(e, "http2debug=1")) {
        http2VerboseLogs = true;
    }
    if (strings.Contains(e, "http2debug=2")) {
        http2VerboseLogs = true;
        http2logFrameWrites = true;
        http2logFrameReads = true;
    }
}

 
// ClientPreface is the string that must be sent by new
// connections from clients.
private static readonly @string http2ClientPreface = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"; 

// SETTINGS_MAX_FRAME_SIZE default
// http://http2.github.io/http2-spec/#rfc.section.6.5.2
private static readonly nint http2initialMaxFrameSize = 16384; 

// NextProtoTLS is the NPN/ALPN protocol negotiated during
// HTTP/2's TLS setup.
private static readonly @string http2NextProtoTLS = "h2"; 

// http://http2.github.io/http2-spec/#SettingValues
private static readonly nint http2initialHeaderTableSize = 4096;

private static readonly nint http2initialWindowSize = 65535; // 6.9.2 Initial Flow Control Window Size

private static readonly nint http2defaultMaxReadFrameSize = 1 << 20;

private static slice<byte> http2clientPreface = (slice<byte>)http2ClientPreface;

private partial struct http2streamState { // : nint
}

// HTTP/2 stream states.
//
// See http://tools.ietf.org/html/rfc7540#section-5.1.
//
// For simplicity, the server code merges "reserved (local)" into
// "half-closed (remote)". This is one less state transition to track.
// The only downside is that we send PUSH_PROMISEs slightly less
// liberally than allowable. More discussion here:
// https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html
//
// "reserved (remote)" is omitted since the client code does not
// support server push.
private static readonly http2streamState http2stateIdle = iota;
private static readonly var http2stateOpen = 0;
private static readonly var http2stateHalfClosedLocal = 1;
private static readonly var http2stateHalfClosedRemote = 2;
private static readonly var http2stateClosed = 3;

private static array<@string> http2stateName = new array<@string>(InitKeyedValues<@string>((http2stateIdle, "Idle"), (http2stateOpen, "Open"), (http2stateHalfClosedLocal, "HalfClosedLocal"), (http2stateHalfClosedRemote, "HalfClosedRemote"), (http2stateClosed, "Closed")));

private static @string String(this http2streamState st) {
    return http2stateName[st];
}

// Setting is a setting parameter: which setting it is, and its value.
private partial struct http2Setting {
    public http2SettingID ID; // Val is the value.
    public uint Val;
}

private static @string String(this http2Setting s) {
    return fmt.Sprintf("[%v = %d]", s.ID, s.Val);
}

// Valid reports whether the setting is valid.
private static error Valid(this http2Setting s) { 
    // Limits and error codes from 6.5.2 Defined SETTINGS Parameters

    if (s.ID == http2SettingEnablePush) 
        if (s.Val != 1 && s.Val != 0) {
            return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
        }
    else if (s.ID == http2SettingInitialWindowSize) 
        if (s.Val > 1 << 31 - 1) {
            return error.As(http2ConnectionError(http2ErrCodeFlowControl))!;
        }
    else if (s.ID == http2SettingMaxFrameSize) 
        if (s.Val < 16384 || s.Val > 1 << 24 - 1) {
            return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
        }
        return error.As(null!)!;
}

// A SettingID is an HTTP/2 setting as defined in
// http://http2.github.io/http2-spec/#iana-settings
private partial struct http2SettingID { // : ushort
}

private static readonly http2SettingID http2SettingHeaderTableSize = 0x1;
private static readonly http2SettingID http2SettingEnablePush = 0x2;
private static readonly http2SettingID http2SettingMaxConcurrentStreams = 0x3;
private static readonly http2SettingID http2SettingInitialWindowSize = 0x4;
private static readonly http2SettingID http2SettingMaxFrameSize = 0x5;
private static readonly http2SettingID http2SettingMaxHeaderListSize = 0x6;

private static map http2settingName = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<http2SettingID, @string>{http2SettingHeaderTableSize:"HEADER_TABLE_SIZE",http2SettingEnablePush:"ENABLE_PUSH",http2SettingMaxConcurrentStreams:"MAX_CONCURRENT_STREAMS",http2SettingInitialWindowSize:"INITIAL_WINDOW_SIZE",http2SettingMaxFrameSize:"MAX_FRAME_SIZE",http2SettingMaxHeaderListSize:"MAX_HEADER_LIST_SIZE",};

private static @string String(this http2SettingID s) {
    {
        var (v, ok) = http2settingName[s];

        if (ok) {
            return v;
        }
    }
    return fmt.Sprintf("UNKNOWN_SETTING_%d", uint16(s));
}

// validWireHeaderFieldName reports whether v is a valid header field
// name (key). See httpguts.ValidHeaderName for the base rules.
//
// Further, http2 says:
//   "Just as in HTTP/1.x, header field names are strings of ASCII
//   characters that are compared in a case-insensitive
//   fashion. However, header field names MUST be converted to
//   lowercase prior to their encoding in HTTP/2. "
private static bool http2validWireHeaderFieldName(@string v) {
    if (len(v) == 0) {
        return false;
    }
    foreach (var (_, r) in v) {
        if (!httpguts.IsTokenRune(r)) {
            return false;
        }
        if ('A' <= r && r <= 'Z') {
            return false;
        }
    }    return true;
}

private static @string http2httpCodeString(nint code) {
    switch (code) {
        case 200: 
            return "200";
            break;
        case 404: 
            return "404";
            break;
    }
    return strconv.Itoa(code);
}

// from pkg io
private partial interface http2stringWriter {
    (nint, error) WriteString(@string s);
}

// A gate lets two goroutines coordinate their activities.
private partial struct http2gate { // : channel<object>
}

private static void Done(this http2gate g) {
    g.Send(/* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ struct{}{});
}

private static void Wait(this http2gate g) {
    g.Receive();
}

// A closeWaiter is like a sync.WaitGroup but only goes 1 to 0 (open to closed).
private partial struct http2closeWaiter { // : channel<object>
}

// Init makes a closeWaiter usable.
// It exists because so a closeWaiter value can be placed inside a
// larger struct and have the Mutex and Cond's memory in the same
// allocation.
private static void Init(this ptr<http2closeWaiter> _addr_cw) {
    ref http2closeWaiter cw = ref _addr_cw.val;

    cw.val = make_channel<object>();
}

// Close marks the closeWaiter as closed and unblocks any waiters.
private static void Close(this http2closeWaiter cw) {
    close(cw);
}

// Wait waits for the closeWaiter to become closed.
private static void Wait(this http2closeWaiter cw) {
    cw.Receive();
}

// bufferedWriter is a buffered writer that writes to w.
// Its buffered writer is lazily allocated as needed, to minimize
// idle memory usage with many connections.
private partial struct http2bufferedWriter {
    public http2incomparable _;
    public io.Writer w; // immutable
    public ptr<bufio.Writer> bw; // non-nil when data is buffered
}

private static ptr<http2bufferedWriter> http2newBufferedWriter(io.Writer w) {
    return addr(new http2bufferedWriter(w:w));
}

// bufWriterPoolBufferSize is the size of bufio.Writer's
// buffers created using bufWriterPool.
//
// TODO: pick a less arbitrary value? this is a bit under
// (3 x typical 1500 byte MTU) at least. Other than that,
// not much thought went into it.
private static readonly nint http2bufWriterPoolBufferSize = 4 << 10;



private static sync.Pool http2bufWriterPool = new sync.Pool(New:func()interface{}{returnbufio.NewWriterSize(nil,http2bufWriterPoolBufferSize)},);

private static nint Available(this ptr<http2bufferedWriter> _addr_w) {
    ref http2bufferedWriter w = ref _addr_w.val;

    if (w.bw == null) {
        return http2bufWriterPoolBufferSize;
    }
    return w.bw.Available();
}

private static (nint, error) Write(this ptr<http2bufferedWriter> _addr_w, slice<byte> p) {
    nint n = default;
    error err = default!;
    ref http2bufferedWriter w = ref _addr_w.val;

    if (w.bw == null) {
        ptr<bufio.Writer> bw = http2bufWriterPool.Get()._<ptr<bufio.Writer>>();
        bw.Reset(w.w);
        w.bw = bw;
    }
    return w.bw.Write(p);
}

private static error Flush(this ptr<http2bufferedWriter> _addr_w) {
    ref http2bufferedWriter w = ref _addr_w.val;

    var bw = w.bw;
    if (bw == null) {
        return error.As(null!)!;
    }
    var err = bw.Flush();
    bw.Reset(null);
    http2bufWriterPool.Put(bw);
    w.bw = null;
    return error.As(err)!;
}

private static uint http2mustUint31(int v) => func((_, panic, _) => {
    if (v < 0 || v > 2147483647) {
        panic("out of range");
    }
    return uint32(v);
});

// bodyAllowedForStatus reports whether a given response status code
// permits a body. See RFC 7230, section 3.3.
private static bool http2bodyAllowedForStatus(nint status) {

    if (status >= 100 && status <= 199) 
        return false;
    else if (status == 204) 
        return false;
    else if (status == 304) 
        return false;
        return true;
}

private partial struct http2httpError {
    public http2incomparable _;
    public @string msg;
    public bool timeout;
}

private static @string Error(this ptr<http2httpError> _addr_e) {
    ref http2httpError e = ref _addr_e.val;

    return e.msg;
}

private static bool Timeout(this ptr<http2httpError> _addr_e) {
    ref http2httpError e = ref _addr_e.val;

    return e.timeout;
}

private static bool Temporary(this ptr<http2httpError> _addr_e) {
    ref http2httpError e = ref _addr_e.val;

    return true;
}

private static error http2errTimeout = error.As(addr(new http2httpError(msg:"http2: timeout awaiting response headers",timeout:true)))!;

private partial interface http2connectionStater {
    tls.ConnectionState ConnectionState();
}

private static sync.Pool http2sorterPool = new sync.Pool(New:func()interface{}{returnnew(http2sorter)});

private partial struct http2sorter {
    public slice<@string> v; // owned by sorter
}

private static nint Len(this ptr<http2sorter> _addr_s) {
    ref http2sorter s = ref _addr_s.val;

    return len(s.v);
}

private static void Swap(this ptr<http2sorter> _addr_s, nint i, nint j) {
    ref http2sorter s = ref _addr_s.val;

    (s.v[i], s.v[j]) = (s.v[j], s.v[i]);
}

private static bool Less(this ptr<http2sorter> _addr_s, nint i, nint j) {
    ref http2sorter s = ref _addr_s.val;

    return s.v[i] < s.v[j];
}

// Keys returns the sorted keys of h.
//
// The returned slice is only valid until s used again or returned to
// its pool.
private static slice<@string> Keys(this ptr<http2sorter> _addr_s, Header h) {
    ref http2sorter s = ref _addr_s.val;

    var keys = s.v[..(int)0];
    foreach (var (k) in h) {
        keys = append(keys, k);
    }    s.v = keys;
    sort.Sort(s);
    return keys;
}

private static void SortStrings(this ptr<http2sorter> _addr_s, slice<@string> ss) {
    ref http2sorter s = ref _addr_s.val;
 
    // Our sorter works on s.v, which sorter owns, so
    // stash it away while we sort the user's buffer.
    var save = s.v;
    s.v = ss;
    sort.Sort(s);
    s.v = save;
}

// validPseudoPath reports whether v is a valid :path pseudo-header
// value. It must be either:
//
//     *) a non-empty string starting with '/'
//     *) the string '*', for OPTIONS requests.
//
// For now this is only used a quick check for deciding when to clean
// up Opaque URLs before sending requests from the Transport.
// See golang.org/issue/16847
//
// We used to enforce that the path also didn't start with "//", but
// Google's GFE accepts such paths and Chrome sends them, so ignore
// that part of the spec. See golang.org/issue/19103.
private static bool http2validPseudoPath(@string v) {
    return (len(v) > 0 && v[0] == '/') || v == "*";
}

// incomparable is a zero-width, non-comparable type. Adding it to a struct
// makes that struct also non-comparable, and generally doesn't add
// any size (as long as it's first).
private partial struct http2incomparable { // : array<Action>
}

// pipe is a goroutine-safe io.Reader/io.Writer pair. It's like
// io.Pipe except there are no PipeReader/PipeWriter halves, and the
// underlying buffer is an interface. (io.Pipe is always unbuffered)
private partial struct http2pipe {
    public sync.Mutex mu;
    public sync.Cond c; // c.L lazily initialized to &p.mu
    public http2pipeBuffer b; // nil when done reading
    public nint unread; // bytes unread when done
    public error err; // read error once empty. non-nil means closed.
    public error breakErr; // immediate read error (caller doesn't see rest of b)
    public channel<object> donec; // closed on error
    public Action readFn; // optional code to run in Read before error
}

private partial interface http2pipeBuffer {
    nint Len();
}

// setBuffer initializes the pipe buffer.
// It has no effect if the pipe is already closed.
private static void setBuffer(this ptr<http2pipe> _addr_p, http2pipeBuffer b) => func((defer, _, _) => {
    ref http2pipe p = ref _addr_p.val;

    p.mu.Lock();
    defer(p.mu.Unlock());
    if (p.err != null || p.breakErr != null) {
        return ;
    }
    p.b = b;
});

private static nint Len(this ptr<http2pipe> _addr_p) => func((defer, _, _) => {
    ref http2pipe p = ref _addr_p.val;

    p.mu.Lock();
    defer(p.mu.Unlock());
    if (p.b == null) {
        return p.unread;
    }
    return p.b.Len();
});

// Read waits until data is available and copies bytes
// from the buffer into p.
private static (nint, error) Read(this ptr<http2pipe> _addr_p, slice<byte> d) => func((defer, _, _) => {
    nint n = default;
    error err = default!;
    ref http2pipe p = ref _addr_p.val;

    p.mu.Lock();
    defer(p.mu.Unlock());
    if (p.c.L == null) {
        p.c.L = _addr_p.mu;
    }
    while (true) {
        if (p.breakErr != null) {
            return (0, error.As(p.breakErr)!);
        }
        if (p.b != null && p.b.Len() > 0) {
            return p.b.Read(d);
        }
        if (p.err != null) {
            if (p.readFn != null) {
                p.readFn(); // e.g. copy trailers
                p.readFn = null; // not sticky like p.err
            }
            p.b = null;
            return (0, error.As(p.err)!);
        }
        p.c.Wait();
    }
});

private static var http2errClosedPipeWrite = errors.New("write on closed buffer");

// Write copies bytes from p into the buffer and wakes a reader.
// It is an error to write more data than the buffer can hold.
private static (nint, error) Write(this ptr<http2pipe> _addr_p, slice<byte> d) => func((defer, _, _) => {
    nint n = default;
    error err = default!;
    ref http2pipe p = ref _addr_p.val;

    p.mu.Lock();
    defer(p.mu.Unlock());
    if (p.c.L == null) {
        p.c.L = _addr_p.mu;
    }
    defer(p.c.Signal());
    if (p.err != null) {
        return (0, error.As(http2errClosedPipeWrite)!);
    }
    if (p.breakErr != null) {
        p.unread += len(d);
        return (len(d), error.As(null!)!); // discard when there is no reader
    }
    return p.b.Write(d);
});

// CloseWithError causes the next Read (waking up a current blocked
// Read if needed) to return the provided err after all data has been
// read.
//
// The error must be non-nil.
private static void CloseWithError(this ptr<http2pipe> _addr_p, error err) {
    ref http2pipe p = ref _addr_p.val;

    p.closeWithError(_addr_p.err, err, null);
}

// BreakWithError causes the next Read (waking up a current blocked
// Read if needed) to return the provided err immediately, without
// waiting for unread data.
private static void BreakWithError(this ptr<http2pipe> _addr_p, error err) {
    ref http2pipe p = ref _addr_p.val;

    p.closeWithError(_addr_p.breakErr, err, null);
}

// closeWithErrorAndCode is like CloseWithError but also sets some code to run
// in the caller's goroutine before returning the error.
private static void closeWithErrorAndCode(this ptr<http2pipe> _addr_p, error err, Action fn) {
    ref http2pipe p = ref _addr_p.val;

    p.closeWithError(_addr_p.err, err, fn);
}

private static void closeWithError(this ptr<http2pipe> _addr_p, ptr<error> _addr_dst, error err, Action fn) => func((defer, panic, _) => {
    ref http2pipe p = ref _addr_p.val;
    ref error dst = ref _addr_dst.val;

    if (err == null) {
        panic("err must be non-nil");
    }
    p.mu.Lock();
    defer(p.mu.Unlock());
    if (p.c.L == null) {
        p.c.L = _addr_p.mu;
    }
    defer(p.c.Signal());
    if (dst != null.val) { 
        // Already been done.
        return ;
    }
    p.readFn = fn;
    if (dst == _addr_p.breakErr) {
        if (p.b != null) {
            p.unread += p.b.Len();
        }
        p.b = null;
    }
    dst = error.As(err)!;
    p.closeDoneLocked();
});

// requires p.mu be held.
private static void closeDoneLocked(this ptr<http2pipe> _addr_p) {
    ref http2pipe p = ref _addr_p.val;

    if (p.donec == null) {
        return ;
    }
    close(p.donec);
}

// Err returns the error (if any) first set by BreakWithError or CloseWithError.
private static error Err(this ptr<http2pipe> _addr_p) => func((defer, _, _) => {
    ref http2pipe p = ref _addr_p.val;

    p.mu.Lock();
    defer(p.mu.Unlock());
    if (p.breakErr != null) {
        return error.As(p.breakErr)!;
    }
    return error.As(p.err)!;
});

// Done returns a channel which is closed if and when this pipe is closed
// with CloseWithError.
private static channel<object> Done(this ptr<http2pipe> _addr_p) => func((defer, _, _) => {
    ref http2pipe p = ref _addr_p.val;

    p.mu.Lock();
    defer(p.mu.Unlock());
    if (p.donec == null) {
        p.donec = make_channel<object>();
        if (p.err != null || p.breakErr != null) { 
            // Already hit an error.
            p.closeDoneLocked();
        }
    }
    return p.donec;
});

private static readonly nint http2prefaceTimeout = 10 * time.Second;
private static readonly nint http2firstSettingsTimeout = 2 * time.Second; // should be in-flight with preface anyway
private static readonly nint http2handlerChunkWriteSize = 4 << 10;
private static readonly nint http2defaultMaxStreams = 250; // TODO: make this 100 as the GFE seems to?
private static readonly nint http2maxQueuedControlFrames = 10000;

private static var http2errClientDisconnected = errors.New("client disconnected");private static var http2errClosedBody = errors.New("body closed by handler");private static var http2errHandlerComplete = errors.New("http2: request body closed due to handler exiting");private static var http2errStreamClosed = errors.New("http2: stream closed");

private static sync.Pool http2responseWriterStatePool = new sync.Pool(New:func()interface{}{rws:=&http2responseWriterState{}rws.bw=bufio.NewWriterSize(http2chunkWriter{rws},http2handlerChunkWriteSize)returnrws},);

// Test hooks.
private static Action http2testHookOnConn = default;private static Action<ptr<http2serverConn>> http2testHookGetServerConn = default;private static ptr<sync.Mutex> http2testHookOnPanicMu;private static Func<ptr<http2serverConn>, object, bool> http2testHookOnPanic = default;

// Server is an HTTP/2 server.
private partial struct http2Server {
    public nint MaxHandlers; // MaxConcurrentStreams optionally specifies the number of
// concurrent streams that each client may have open at a
// time. This is unrelated to the number of http.Handler goroutines
// which may be active globally, which is MaxHandlers.
// If zero, MaxConcurrentStreams defaults to at least 100, per
// the HTTP/2 spec's recommendations.
    public uint MaxConcurrentStreams; // MaxReadFrameSize optionally specifies the largest frame
// this server is willing to read. A valid value is between
// 16k and 16M, inclusive. If zero or otherwise invalid, a
// default value is used.
    public uint MaxReadFrameSize; // PermitProhibitedCipherSuites, if true, permits the use of
// cipher suites prohibited by the HTTP/2 spec.
    public bool PermitProhibitedCipherSuites; // IdleTimeout specifies how long until idle clients should be
// closed with a GOAWAY frame. PING frames are not considered
// activity for the purposes of IdleTimeout.
    public time.Duration IdleTimeout; // MaxUploadBufferPerConnection is the size of the initial flow
// control window for each connections. The HTTP/2 spec does not
// allow this to be smaller than 65535 or larger than 2^32-1.
// If the value is outside this range, a default value will be
// used instead.
    public int MaxUploadBufferPerConnection; // MaxUploadBufferPerStream is the size of the initial flow control
// window for each stream. The HTTP/2 spec does not allow this to
// be larger than 2^32-1. If the value is zero or larger than the
// maximum, a default value will be used instead.
    public int MaxUploadBufferPerStream; // NewWriteScheduler constructs a write scheduler for a connection.
// If nil, a default scheduler is chosen.
    public Func<http2WriteScheduler> NewWriteScheduler; // Internal state. This is a pointer (rather than embedded directly)
// so that we don't embed a Mutex in this struct, which will make the
// struct non-copyable, which might break some callers.
    public ptr<http2serverInternalState> state;
}

private static int initialConnRecvWindowSize(this ptr<http2Server> _addr_s) {
    ref http2Server s = ref _addr_s.val;

    if (s.MaxUploadBufferPerConnection > http2initialWindowSize) {
        return s.MaxUploadBufferPerConnection;
    }
    return 1 << 20;
}

private static int initialStreamRecvWindowSize(this ptr<http2Server> _addr_s) {
    ref http2Server s = ref _addr_s.val;

    if (s.MaxUploadBufferPerStream > 0) {
        return s.MaxUploadBufferPerStream;
    }
    return 1 << 20;
}

private static uint maxReadFrameSize(this ptr<http2Server> _addr_s) {
    ref http2Server s = ref _addr_s.val;

    {
        var v = s.MaxReadFrameSize;

        if (v >= http2minMaxFrameSize && v <= http2maxFrameSize) {
            return v;
        }
    }
    return http2defaultMaxReadFrameSize;
}

private static uint maxConcurrentStreams(this ptr<http2Server> _addr_s) {
    ref http2Server s = ref _addr_s.val;

    {
        var v = s.MaxConcurrentStreams;

        if (v > 0) {
            return v;
        }
    }
    return http2defaultMaxStreams;
}

// maxQueuedControlFrames is the maximum number of control frames like
// SETTINGS, PING and RST_STREAM that will be queued for writing before
// the connection is closed to prevent memory exhaustion attacks.
private static nint maxQueuedControlFrames(this ptr<http2Server> _addr_s) {
    ref http2Server s = ref _addr_s.val;
 
    // TODO: if anybody asks, add a Server field, and remember to define the
    // behavior of negative values.
    return http2maxQueuedControlFrames;
}

private partial struct http2serverInternalState {
    public sync.Mutex mu;
}

private static void registerConn(this ptr<http2serverInternalState> _addr_s, ptr<http2serverConn> _addr_sc) {
    ref http2serverInternalState s = ref _addr_s.val;
    ref http2serverConn sc = ref _addr_sc.val;

    if (s == null) {
        return ; // if the Server was used without calling ConfigureServer
    }
    s.mu.Lock();
    s.activeConns[sc] = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ struct{}{};
    s.mu.Unlock();
}

private static void unregisterConn(this ptr<http2serverInternalState> _addr_s, ptr<http2serverConn> _addr_sc) {
    ref http2serverInternalState s = ref _addr_s.val;
    ref http2serverConn sc = ref _addr_sc.val;

    if (s == null) {
        return ; // if the Server was used without calling ConfigureServer
    }
    s.mu.Lock();
    delete(s.activeConns, sc);
    s.mu.Unlock();
}

private static void startGracefulShutdown(this ptr<http2serverInternalState> _addr_s) {
    ref http2serverInternalState s = ref _addr_s.val;

    if (s == null) {
        return ; // if the Server was used without calling ConfigureServer
    }
    s.mu.Lock();
    foreach (var (sc) in s.activeConns) {
        sc.startGracefulShutdown();
    }    s.mu.Unlock();
}

// ConfigureServer adds HTTP/2 support to a net/http Server.
//
// The configuration conf may be nil.
//
// ConfigureServer must be called before s begins serving.
private static error http2ConfigureServer(ptr<Server> _addr_s, ptr<http2Server> _addr_conf) => func((_, panic, _) => {
    ref Server s = ref _addr_s.val;
    ref http2Server conf = ref _addr_conf.val;

    if (s == null) {
        panic("nil *http.Server");
    }
    if (conf == null) {
        conf = @new<http2Server>();
    }
    conf.state = addr(new http2serverInternalState(activeConns:make(map[*http2serverConn]struct{})));
    {
        var h1 = s;
        var h2 = conf;

        if (h2.IdleTimeout == 0) {
            if (h1.IdleTimeout != 0) {
                h2.IdleTimeout = h1.IdleTimeout;
            }
            else
 {
                h2.IdleTimeout = h1.ReadTimeout;
            }
        }
    }
    s.RegisterOnShutdown(conf.state.startGracefulShutdown);

    if (s.TLSConfig == null) {
        s.TLSConfig = @new<tls.Config>();
    }
    else if (s.TLSConfig.CipherSuites != null && s.TLSConfig.MinVersion < tls.VersionTLS13) { 
        // If they already provided a TLS 1.01.2 CipherSuite list, return an
        // error if it is missing ECDHE_RSA_WITH_AES_128_GCM_SHA256 or
        // ECDHE_ECDSA_WITH_AES_128_GCM_SHA256.
        var haveRequired = false;
        foreach (var (_, cs) in s.TLSConfig.CipherSuites) {

            if (cs == tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 || cs == tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256) 
                haveRequired = true;
                    }        if (!haveRequired) {
            return error.As(fmt.Errorf("http2: TLSConfig.CipherSuites is missing an HTTP/2-required AES_128_GCM_SHA256 cipher (need at least one of TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 or TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)"))!;
        }
    }
    s.TLSConfig.PreferServerCipherSuites = true;

    if (!http2strSliceContains(s.TLSConfig.NextProtos, http2NextProtoTLS)) {
        s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, http2NextProtoTLS);
    }
    if (!http2strSliceContains(s.TLSConfig.NextProtos, "http/1.1")) {
        s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, "http/1.1");
    }
    if (s.TLSNextProto == null) {
        s.TLSNextProto = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<@string, Action<ptr<Server>, ptr<tls.Conn>, Handler>>{};
    }
    Action<ptr<Server>, ptr<tls.Conn>, Handler> protoHandler = (hs, c, h) => {
        if (http2testHookOnConn != null) {
            http2testHookOnConn();
        }
        context.Context ctx = default;
        private partial interface baseContexter {
            context.Context BaseContext();
        }
        {
            baseContexter (bc, ok) = baseContexter.As(h._<baseContexter>())!;

            if (ok) {
                ctx = bc.BaseContext();
            }

        }
        conf.ServeConn(c, addr(new http2ServeConnOpts(Context:ctx,Handler:h,BaseConfig:hs,)));
    };
    s.TLSNextProto[http2NextProtoTLS] = protoHandler;
    return error.As(null!)!;
});

// ServeConnOpts are options for the Server.ServeConn method.
private partial struct http2ServeConnOpts {
    public context.Context Context; // BaseConfig optionally sets the base configuration
// for values. If nil, defaults are used.
    public ptr<Server> BaseConfig; // Handler specifies which handler to use for processing
// requests. If nil, BaseConfig.Handler is used. If BaseConfig
// or BaseConfig.Handler is nil, http.DefaultServeMux is used.
    public Handler Handler;
}

private static context.Context context(this ptr<http2ServeConnOpts> _addr_o) {
    ref http2ServeConnOpts o = ref _addr_o.val;

    if (o != null && o.Context != null) {
        return o.Context;
    }
    return context.Background();
}

private static ptr<Server> baseConfig(this ptr<http2ServeConnOpts> _addr_o) {
    ref http2ServeConnOpts o = ref _addr_o.val;

    if (o != null && o.BaseConfig != null) {
        return _addr_o.BaseConfig!;
    }
    return @new<Server>();
}

private static Handler handler(this ptr<http2ServeConnOpts> _addr_o) {
    ref http2ServeConnOpts o = ref _addr_o.val;

    if (o != null) {
        if (o.Handler != null) {
            return o.Handler;
        }
        if (o.BaseConfig != null && o.BaseConfig.Handler != null) {
            return o.BaseConfig.Handler;
        }
    }
    return DefaultServeMux;
}

// ServeConn serves HTTP/2 requests on the provided connection and
// blocks until the connection is no longer readable.
//
// ServeConn starts speaking HTTP/2 assuming that c has not had any
// reads or writes. It writes its initial settings frame and expects
// to be able to read the preface and settings frame from the
// client. If c has a ConnectionState method like a *tls.Conn, the
// ConnectionState is used to verify the TLS ciphersuite and to set
// the Request.TLS field in Handlers.
//
// ServeConn does not support h2c by itself. Any h2c support must be
// implemented in terms of providing a suitably-behaving net.Conn.
//
// The opts parameter is optional. If nil, default values are used.
private static void ServeConn(this ptr<http2Server> _addr_s, net.Conn c, ptr<http2ServeConnOpts> _addr_opts) => func((defer, _, _) => {
    ref http2Server s = ref _addr_s.val;
    ref http2ServeConnOpts opts = ref _addr_opts.val;

    var (baseCtx, cancel) = http2serverConnBaseContext(c, _addr_opts);
    defer(cancel());

    ptr<http2serverConn> sc = addr(new http2serverConn(srv:s,hs:opts.baseConfig(),conn:c,baseCtx:baseCtx,remoteAddrStr:c.RemoteAddr().String(),bw:http2newBufferedWriter(c),handler:opts.handler(),streams:make(map[uint32]*http2stream),readFrameCh:make(chanhttp2readFrameResult),wantWriteFrameCh:make(chanhttp2FrameWriteRequest,8),serveMsgCh:make(chaninterface{},8),wroteFrameCh:make(chanhttp2frameWriteResult,1),bodyReadCh:make(chanhttp2bodyReadMsg),doneServing:make(chanstruct{}),clientMaxStreams:math.MaxUint32,advMaxStreams:s.maxConcurrentStreams(),initialStreamSendWindowSize:http2initialWindowSize,maxFrameSize:http2initialMaxFrameSize,headerTableSize:http2initialHeaderTableSize,serveG:http2newGoroutineLock(),pushEnabled:true,));

    s.state.registerConn(sc);
    defer(s.state.unregisterConn(sc)); 

    // The net/http package sets the write deadline from the
    // http.Server.WriteTimeout during the TLS handshake, but then
    // passes the connection off to us with the deadline already set.
    // Write deadlines are set per stream in serverConn.newStream.
    // Disarm the net.Conn write deadline here.
    if (sc.hs.WriteTimeout != 0) {
        sc.conn.SetWriteDeadline(new time.Time());
    }
    if (s.NewWriteScheduler != null) {
        sc.writeSched = s.NewWriteScheduler();
    }
    else
 {
        sc.writeSched = http2NewRandomWriteScheduler();
    }
    sc.flow.add(http2initialWindowSize);
    sc.inflow.add(http2initialWindowSize);
    sc.hpackEncoder = hpack.NewEncoder(_addr_sc.headerWriteBuf);

    var fr = http2NewFramer(sc.bw, c);
    fr.ReadMetaHeaders = hpack.NewDecoder(http2initialHeaderTableSize, null);
    fr.MaxHeaderListSize = sc.maxHeaderListSize();
    fr.SetMaxReadFrameSize(s.maxReadFrameSize());
    sc.framer = fr;

    {
        http2connectionStater (tc, ok) = http2connectionStater.As(c._<http2connectionStater>())!;

        if (ok) {
            sc.tlsState = @new<tls.ConnectionState>();
            sc.tlsState.val = tc.ConnectionState(); 
            // 9.2 Use of TLS Features
            // An implementation of HTTP/2 over TLS MUST use TLS
            // 1.2 or higher with the restrictions on feature set
            // and cipher suite described in this section. Due to
            // implementation limitations, it might not be
            // possible to fail TLS negotiation. An endpoint MUST
            // immediately terminate an HTTP/2 connection that
            // does not meet the TLS requirements described in
            // this section with a connection error (Section
            // 5.4.1) of type INADEQUATE_SECURITY.
            if (sc.tlsState.Version < tls.VersionTLS12) {
                sc.rejectConn(http2ErrCodeInadequateSecurity, "TLS version too low");
                return ;
            }
            if (sc.tlsState.ServerName == "") { 
                // Client must use SNI, but we don't enforce that anymore,
                // since it was causing problems when connecting to bare IP
                // addresses during development.
                //
                // TODO: optionally enforce? Or enforce at the time we receive
                // a new request, and verify the ServerName matches the :authority?
                // But that precludes proxy situations, perhaps.
                //
                // So for now, do nothing here again.
            }
            if (!s.PermitProhibitedCipherSuites && http2isBadCipher(sc.tlsState.CipherSuite)) { 
                // "Endpoints MAY choose to generate a connection error
                // (Section 5.4.1) of type INADEQUATE_SECURITY if one of
                // the prohibited cipher suites are negotiated."
                //
                // We choose that. In my opinion, the spec is weak
                // here. It also says both parties must support at least
                // TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 so there's no
                // excuses here. If we really must, we could allow an
                // "AllowInsecureWeakCiphers" option on the server later.
                // Let's see how it plays out first.
                sc.rejectConn(http2ErrCodeInadequateSecurity, fmt.Sprintf("Prohibited TLS 1.2 Cipher Suite: %x", sc.tlsState.CipherSuite));
                return ;
            }
        }
    }

    {
        var hook = http2testHookGetServerConn;

        if (hook != null) {
            hook(sc);
        }
    }
    sc.serve();
});

private static (context.Context, Action) http2serverConnBaseContext(net.Conn c, ptr<http2ServeConnOpts> _addr_opts) {
    context.Context ctx = default;
    Action cancel = default;
    ref http2ServeConnOpts opts = ref _addr_opts.val;

    ctx, cancel = context.WithCancel(opts.context());
    ctx = context.WithValue(ctx, LocalAddrContextKey, c.LocalAddr());
    {
        var hs = opts.baseConfig();

        if (hs != null) {
            ctx = context.WithValue(ctx, ServerContextKey, hs);
        }
    }
    return ;
}

private static void rejectConn(this ptr<http2serverConn> _addr_sc, http2ErrCode err, @string debug) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.vlogf("http2: server rejecting conn: %v, %s", err, debug); 
    // ignoring errors. hanging up anyway.
    sc.framer.WriteGoAway(0, err, (slice<byte>)debug);
    sc.bw.Flush();
    sc.conn.Close();
}

private partial struct http2serverConn {
    public ptr<http2Server> srv;
    public ptr<Server> hs;
    public net.Conn conn;
    public ptr<http2bufferedWriter> bw; // writing to conn
    public Handler handler;
    public context.Context baseCtx;
    public ptr<http2Framer> framer;
    public channel<object> doneServing; // closed when serverConn.serve ends
    public channel<http2readFrameResult> readFrameCh; // written by serverConn.readFrames
    public channel<http2FrameWriteRequest> wantWriteFrameCh; // from handlers -> serve
    public channel<http2frameWriteResult> wroteFrameCh; // from writeFrameAsync -> serve, tickles more frame writes
    public channel<http2bodyReadMsg> bodyReadCh; // from handlers -> serve
    public channel<object> serveMsgCh; // misc messages & code to send to / run on the serve loop
    public http2flow flow; // conn-wide (not stream-specific) outbound flow control
    public http2flow inflow; // conn-wide inbound flow control
    public ptr<tls.ConnectionState> tlsState; // shared by all handlers, like net/http
    public @string remoteAddrStr;
    public http2WriteScheduler writeSched; // Everything following is owned by the serve loop; use serveG.check():
    public http2goroutineLock serveG; // used to verify funcs are on serve()
    public bool pushEnabled;
    public bool sawFirstSettings; // got the initial SETTINGS frame after the preface
    public bool needToSendSettingsAck;
    public nint unackedSettings; // how many SETTINGS have we sent without ACKs?
    public nint queuedControlFrames; // control frames in the writeSched queue
    public uint clientMaxStreams; // SETTINGS_MAX_CONCURRENT_STREAMS from client (our PUSH_PROMISE limit)
    public uint advMaxStreams; // our SETTINGS_MAX_CONCURRENT_STREAMS advertised the client
    public uint curClientStreams; // number of open streams initiated by the client
    public uint curPushedStreams; // number of open streams initiated by server push
    public uint maxClientStreamID; // max ever seen from client (odd), or 0 if there have been no client requests
    public uint maxPushPromiseID; // ID of the last push promise (even), or 0 if there have been no pushes
    public map<uint, ptr<http2stream>> streams;
    public int initialStreamSendWindowSize;
    public int maxFrameSize;
    public uint headerTableSize;
    public uint peerMaxHeaderListSize; // zero means unknown (default)
    public map<@string, @string> canonHeader; // http2-lower-case -> Go-Canonical-Case
    public bool writingFrame; // started writing a frame (on serve goroutine or separate)
    public bool writingFrameAsync; // started a frame on its own goroutine but haven't heard back on wroteFrameCh
    public bool needsFrameFlush; // last frame write wasn't a flush
    public bool inGoAway; // we've started to or sent GOAWAY
    public bool inFrameScheduleLoop; // whether we're in the scheduleFrameWrite loop
    public bool needToSendGoAway; // we need to schedule a GOAWAY frame write
    public http2ErrCode goAwayCode;
    public ptr<time.Timer> shutdownTimer; // nil until used
    public ptr<time.Timer> idleTimer; // nil if unused

// Owned by the writeFrameAsync goroutine:
    public bytes.Buffer headerWriteBuf;
    public ptr<hpack.Encoder> hpackEncoder; // Used by startGracefulShutdown.
    public sync.Once shutdownOnce;
}

private static uint maxHeaderListSize(this ptr<http2serverConn> _addr_sc) {
    ref http2serverConn sc = ref _addr_sc.val;

    var n = sc.hs.MaxHeaderBytes;
    if (n <= 0) {
        n = DefaultMaxHeaderBytes;
    }
    const nint perFieldOverhead = 32; // per http2 spec
 // per http2 spec
    const nint typicalHeaders = 10; // conservative
 // conservative
    return uint32(n + typicalHeaders * perFieldOverhead);
}

private static uint curOpenStreams(this ptr<http2serverConn> _addr_sc) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check();
    return sc.curClientStreams + sc.curPushedStreams;
}

// stream represents a stream. This is the minimal metadata needed by
// the serve goroutine. Most of the actual stream state is owned by
// the http.Handler's goroutine in the responseWriter. Because the
// responseWriter's responseWriterState is recycled at the end of a
// handler, this struct intentionally has no pointer to the
// *responseWriter{,State} itself, as the Handler ending nils out the
// responseWriter's state field.
private partial struct http2stream {
    public ptr<http2serverConn> sc;
    public uint id;
    public ptr<http2pipe> body; // non-nil if expecting DATA frames
    public http2closeWaiter cw; // closed wait stream transitions to closed state
    public context.Context ctx;
    public Action cancelCtx; // owned by serverConn's serve loop:
    public long bodyBytes; // body bytes seen so far
    public long declBodyBytes; // or -1 if undeclared
    public http2flow flow; // limits writing from Handler to client
    public http2flow inflow; // what the client is allowed to POST/etc to us
    public http2streamState state;
    public bool resetQueued; // RST_STREAM queued for write; set by sc.resetStream
    public bool gotTrailerHeader; // HEADER frame for trailers was seen
    public bool wroteHeaders; // whether we wrote headers (not status 100)
    public ptr<time.Timer> writeDeadline; // nil if unused

    public Header trailer; // accumulated trailers
    public Header reqTrailer; // handler's Request.Trailer
}

private static ptr<http2Framer> Framer(this ptr<http2serverConn> _addr_sc) {
    ref http2serverConn sc = ref _addr_sc.val;

    return _addr_sc.framer!;
}

private static error CloseConn(this ptr<http2serverConn> _addr_sc) {
    ref http2serverConn sc = ref _addr_sc.val;

    return error.As(sc.conn.Close())!;
}

private static error Flush(this ptr<http2serverConn> _addr_sc) {
    ref http2serverConn sc = ref _addr_sc.val;

    return error.As(sc.bw.Flush())!;
}

private static (ptr<hpack.Encoder>, ptr<bytes.Buffer>) HeaderEncoder(this ptr<http2serverConn> _addr_sc) {
    ptr<hpack.Encoder> _p0 = default!;
    ptr<bytes.Buffer> _p0 = default!;
    ref http2serverConn sc = ref _addr_sc.val;

    return (_addr_sc.hpackEncoder!, _addr__addr_sc.headerWriteBuf!);
}

private static (http2streamState, ptr<http2stream>) state(this ptr<http2serverConn> _addr_sc, uint streamID) {
    http2streamState _p0 = default;
    ptr<http2stream> _p0 = default!;
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check(); 
    // http://tools.ietf.org/html/rfc7540#section-5.1
    {
        var (st, ok) = sc.streams[streamID];

        if (ok) {
            return (st.state, _addr_st!);
        }
    } 
    // "The first use of a new stream identifier implicitly closes all
    // streams in the "idle" state that might have been initiated by
    // that peer with a lower-valued stream identifier. For example, if
    // a client sends a HEADERS frame on stream 7 without ever sending a
    // frame on stream 5, then stream 5 transitions to the "closed"
    // state when the first frame for stream 7 is sent or received."
    if (streamID % 2 == 1) {
        if (streamID <= sc.maxClientStreamID) {
            return (http2stateClosed, _addr_null!);
        }
    }
    else
 {
        if (streamID <= sc.maxPushPromiseID) {
            return (http2stateClosed, _addr_null!);
        }
    }
    return (http2stateIdle, _addr_null!);
}

// setConnState calls the net/http ConnState hook for this connection, if configured.
// Note that the net/http package does StateNew and StateClosed for us.
// There is currently no plan for StateHijacked or hijacking HTTP/2 connections.
private static void setConnState(this ptr<http2serverConn> _addr_sc, ConnState state) {
    ref http2serverConn sc = ref _addr_sc.val;

    if (sc.hs.ConnState != null) {
        sc.hs.ConnState(sc.conn, state);
    }
}

private static void vlogf(this ptr<http2serverConn> _addr_sc, @string format, params object[] args) {
    args = args.Clone();
    ref http2serverConn sc = ref _addr_sc.val;

    if (http2VerboseLogs) {
        sc.logf(format, args);
    }
}

private static void logf(this ptr<http2serverConn> _addr_sc, @string format, params object[] args) {
    args = args.Clone();
    ref http2serverConn sc = ref _addr_sc.val;

    {
        var lg = sc.hs.ErrorLog;

        if (lg != null) {
            lg.Printf(format, args);
        }
        else
 {
            log.Printf(format, args);
        }
    }
}

// errno returns v's underlying uintptr, else 0.
//
// TODO: remove this helper function once http2 can use build
// tags. See comment in isClosedConnError.
private static System.UIntPtr http2errno(error v) {
    {
        var rv = reflect.ValueOf(v);

        if (rv.Kind() == reflect.Uintptr) {
            return uintptr(rv.Uint());
        }
    }
    return 0;
}

// isClosedConnError reports whether err is an error from use of a closed
// network connection.
private static bool http2isClosedConnError(error err) {
    if (err == null) {
        return false;
    }
    var str = err.Error();
    if (strings.Contains(str, "use of closed network connection")) {
        return true;
    }
    if (runtime.GOOS == "windows") {
        {
            ptr<net.OpError> (oe, ok) = err._<ptr<net.OpError>>();

            if (ok && oe.Op == "read") {
                {
                    ptr<os.SyscallError> (se, ok) = oe.Err._<ptr<os.SyscallError>>();

                    if (ok && se.Syscall == "wsarecv") {
                        const nint WSAECONNABORTED = 10053;

                        const nint WSAECONNRESET = 10054;

                        {
                            var n = http2errno(se.Err);

                            if (n == WSAECONNRESET || n == WSAECONNABORTED) {
                                return true;
                            }

                        }
                    }

                }
            }

        }
    }
    return false;
}

private static void condlogf(this ptr<http2serverConn> _addr_sc, error err, @string format, params object[] args) {
    args = args.Clone();
    ref http2serverConn sc = ref _addr_sc.val;

    if (err == null) {
        return ;
    }
    if (err == io.EOF || err == io.ErrUnexpectedEOF || http2isClosedConnError(err) || err == http2errPrefaceTimeout) { 
        // Boring, expected errors.
        sc.vlogf(format, args);
    }
    else
 {
        sc.logf(format, args);
    }
}

private static @string canonicalHeader(this ptr<http2serverConn> _addr_sc, @string v) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check();
    http2buildCommonHeaderMapsOnce();
    var (cv, ok) = http2commonCanonHeader[v];
    if (ok) {
        return cv;
    }
    cv, ok = sc.canonHeader[v];
    if (ok) {
        return cv;
    }
    if (sc.canonHeader == null) {
        sc.canonHeader = make_map<@string, @string>();
    }
    cv = CanonicalHeaderKey(v);
    sc.canonHeader[v] = cv;
    return cv;
}

private partial struct http2readFrameResult {
    public http2Frame f; // valid until readMore is called
    public error err; // readMore should be called once the consumer no longer needs or
// retains f. After readMore, f is invalid and more frames can be
// read.
    public Action readMore;
}

// readFrames is the loop that reads incoming frames.
// It takes care to only read one frame at a time, blocking until the
// consumer is done with the frame.
// It's run on its own goroutine.
private static void readFrames(this ptr<http2serverConn> _addr_sc) {
    ref http2serverConn sc = ref _addr_sc.val;

    var gate = make(http2gate);
    var gateDone = gate.Done;
    while (true) {
        var (f, err) = sc.framer.ReadFrame();
        return ;
        return ;
        if (http2terminalReadFrameError(err)) {
            return ;
        }
    }
}

// frameWriteResult is the message passed from writeFrameAsync to the serve goroutine.
private partial struct http2frameWriteResult {
    public http2incomparable _;
    public http2FrameWriteRequest wr; // what was written (or attempted)
    public error err; // result of the writeFrame call
}

// writeFrameAsync runs in its own goroutine and writes a single frame
// and then reports when it's done.
// At most one goroutine can be running writeFrameAsync at a time per
// serverConn.
private static void writeFrameAsync(this ptr<http2serverConn> _addr_sc, http2FrameWriteRequest wr) {
    ref http2serverConn sc = ref _addr_sc.val;

    var err = wr.write.writeFrame(sc);
    sc.wroteFrameCh.Send(new http2frameWriteResult(wr:wr,err:err));
}

private static void closeAllStreamsOnConnClose(this ptr<http2serverConn> _addr_sc) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check();
    foreach (var (_, st) in sc.streams) {
        sc.closeStream(st, http2errClientDisconnected);
    }
}

private static void stopShutdownTimer(this ptr<http2serverConn> _addr_sc) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check();
    {
        var t = sc.shutdownTimer;

        if (t != null) {
            t.Stop();
        }
    }
}

private static void notePanic(this ptr<http2serverConn> _addr_sc) => func((defer, panic, _) => {
    ref http2serverConn sc = ref _addr_sc.val;
 
    // Note: this is for serverConn.serve panicking, not http.Handler code.
    if (http2testHookOnPanicMu != null) {
        http2testHookOnPanicMu.Lock();
        defer(http2testHookOnPanicMu.Unlock());
    }
    if (http2testHookOnPanic != null) {
        {
            var e = recover();

            if (e != null) {
                if (http2testHookOnPanic(sc, e)) {
                    panic(e);
                }
            }

        }
    }
});

private static void serve(this ptr<http2serverConn> _addr_sc) => func((defer, panic, _) => {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check();
    defer(sc.notePanic());
    defer(sc.conn.Close());
    defer(sc.closeAllStreamsOnConnClose());
    defer(sc.stopShutdownTimer());
    defer(close(sc.doneServing)); // unblocks handlers trying to send

    if (http2VerboseLogs) {
        sc.vlogf("http2: server connection from %v on %p", sc.conn.RemoteAddr(), sc.hs);
    }
    sc.writeFrame(new http2FrameWriteRequest(write:http2writeSettings{{http2SettingMaxFrameSize,sc.srv.maxReadFrameSize()},{http2SettingMaxConcurrentStreams,sc.advMaxStreams},{http2SettingMaxHeaderListSize,sc.maxHeaderListSize()},{http2SettingInitialWindowSize,uint32(sc.srv.initialStreamRecvWindowSize())},},));
    sc.unackedSettings++; 

    // Each connection starts with intialWindowSize inflow tokens.
    // If a higher value is configured, we add more tokens.
    {
        var diff = sc.srv.initialConnRecvWindowSize() - http2initialWindowSize;

        if (diff > 0) {
            sc.sendWindowUpdate(null, int(diff));
        }
    }

    {
        var err = sc.readPreface();

        if (err != null) {
            sc.condlogf(err, "http2: server: error reading preface from client %v: %v", sc.conn.RemoteAddr(), err);
            return ;
        }
    } 
    // Now that we've got the preface, get us out of the
    // "StateNew" state. We can't go directly to idle, though.
    // Active means we read some data and anticipate a request. We'll
    // do another Active when we get a HEADERS frame.
    sc.setConnState(StateActive);
    sc.setConnState(StateIdle);

    if (sc.srv.IdleTimeout != 0) {
        sc.idleTimer = time.AfterFunc(sc.srv.IdleTimeout, sc.onIdleTimer);
        defer(sc.idleTimer.Stop());
    }
    go_(() => sc.readFrames()); // closed by defer sc.conn.Close above

    var settingsTimer = time.AfterFunc(http2firstSettingsTimeout, sc.onSettingsTimer);
    defer(settingsTimer.Stop());

    nint loopNum = 0;
    while (true) {
        loopNum++;
        {
            http2StreamError (se, ok) = wr.write._<http2StreamError>();

            if (ok) {
                sc.resetStream(se);
                break;
            }

        }
        sc.writeFrame(wr);
        sc.wroteFrame(res);
        if (sc.writingFrameAsync) {
            sc.wroteFrame(wroteRes);
        }
        if (!sc.processFrameFromReader(res)) {
            return ;
        }
        res.readMore();
        if (settingsTimer != null) {
            settingsTimer.Stop();
            settingsTimer = null;
        }
        sc.noteBodyRead(m.st, m.n);
        switch (msg.type()) {
            case Action<nint> v:
                v(loopNum); // for testing
                break;
            case ptr<http2serverMessage> v:

                if (v == http2settingsTimerMsg) 
                    sc.logf("timeout waiting for SETTINGS frames from %v", sc.conn.RemoteAddr());
                    return ;
                else if (v == http2idleTimerMsg) 
                    sc.vlogf("connection is idle");
                    sc.goAway(http2ErrCodeNo);
                else if (v == http2shutdownTimerMsg) 
                    sc.vlogf("GOAWAY close timer fired; closing conn from %v", sc.conn.RemoteAddr());
                    return ;
                else if (v == http2gracefulShutdownMsg) 
                    sc.startGracefulShutdownInternal();
                else 
                    panic("unknown timer");
                                break;
            case ptr<http2startPushRequest> v:
                sc.startPush(v);
                break;
            default:
            {
                var v = msg.type();
                panic(fmt.Sprintf("unexpected type %T", v));
                break;
            }
        }
        if (sc.queuedControlFrames > sc.srv.maxQueuedControlFrames()) {
            sc.vlogf("http2: too many control frames in send queue, closing connection");
            return ;
        }
        var sentGoAway = sc.inGoAway && !sc.needToSendGoAway && !sc.writingFrame;
        var gracefulShutdownComplete = sc.goAwayCode == http2ErrCodeNo && sc.curOpenStreams() == 0;
        if (sentGoAway && sc.shutdownTimer == null && (sc.goAwayCode != http2ErrCodeNo || gracefulShutdownComplete)) {
            sc.shutDownIn(http2goAwayTimeout);
        }
    }
});

private static void awaitGracefulShutdown(this ptr<http2serverConn> _addr_sc, channel<object> sharedCh, channel<object> privateCh) {
    ref http2serverConn sc = ref _addr_sc.val;

    close(privateCh);
}

private partial struct http2serverMessage { // : nint
}

// Message values sent to serveMsgCh.
private static ptr<http2serverMessage> http2settingsTimerMsg = @new<http2serverMessage>();private static ptr<http2serverMessage> http2idleTimerMsg = @new<http2serverMessage>();private static ptr<http2serverMessage> http2shutdownTimerMsg = @new<http2serverMessage>();private static ptr<http2serverMessage> http2gracefulShutdownMsg = @new<http2serverMessage>();

private static void onSettingsTimer(this ptr<http2serverConn> _addr_sc) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.sendServeMsg(http2settingsTimerMsg);
}

private static void onIdleTimer(this ptr<http2serverConn> _addr_sc) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.sendServeMsg(http2idleTimerMsg);
}

private static void onShutdownTimer(this ptr<http2serverConn> _addr_sc) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.sendServeMsg(http2shutdownTimerMsg);
}

private static void sendServeMsg(this ptr<http2serverConn> _addr_sc, object msg) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.checkNotOn(); // NOT
}

private static var http2errPrefaceTimeout = errors.New("timeout waiting for client preface");

// readPreface reads the ClientPreface greeting from the peer or
// returns errPrefaceTimeout on timeout, or an error if the greeting
// is invalid.
private static error readPreface(this ptr<http2serverConn> _addr_sc) => func((defer, _, _) => {
    ref http2serverConn sc = ref _addr_sc.val;

    var errc = make_channel<error>(1);
    go_(() => () => { 
        // Read the client preface
        var buf = make_slice<byte>(len(http2ClientPreface));
        {
            var (_, err) = io.ReadFull(sc.conn, buf);

            if (err != null) {
                errc.Send(err);
            }
            else if (!bytes.Equal(buf, http2clientPreface)) {
                errc.Send(fmt.Errorf("bogus greeting %q", buf));
            }
            else
 {
                errc.Send(null);
            }

        }
    }());
    var timer = time.NewTimer(http2prefaceTimeout); // TODO: configurable on *Server?
    defer(timer.Stop());
    return error.As(http2errPrefaceTimeout)!;
    if (err == null) {
        if (http2VerboseLogs) {
            sc.vlogf("http2: server: client %v said hello", sc.conn.RemoteAddr());
        }
    }
    return error.As(err)!;
});

private static sync.Pool http2errChanPool = new sync.Pool(New:func()interface{}{returnmake(chanerror,1)},);

private static sync.Pool http2writeDataPool = new sync.Pool(New:func()interface{}{returnnew(http2writeData)},);

// writeDataFromHandler writes DATA response frames from a handler on
// the given stream.
private static error writeDataFromHandler(this ptr<http2serverConn> _addr_sc, ptr<http2stream> _addr_stream, slice<byte> data, bool endStream) {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2stream stream = ref _addr_stream.val;

    channel<error> ch = http2errChanPool.Get()._<channel<error>>();
    ptr<http2writeData> writeArg = http2writeDataPool.Get()._<ptr<http2writeData>>();
    writeArg.val = new http2writeData(stream.id,data,endStream);
    var err = sc.writeFrameFromHandler(new http2FrameWriteRequest(write:writeArg,stream:stream,done:ch,));
    if (err != null) {
        return error.As(err)!;
    }
    bool frameWriteDone = default; // the frame write is done (successfully or not)
    frameWriteDone = true;
    return error.As(http2errClientDisconnected)!;
    frameWriteDone = true;
    return error.As(http2errStreamClosed)!;
    http2errChanPool.Put(ch);
    if (frameWriteDone) {
        http2writeDataPool.Put(writeArg);
    }
    return error.As(err)!;
}

// writeFrameFromHandler sends wr to sc.wantWriteFrameCh, but aborts
// if the connection has gone away.
//
// This must not be run from the serve goroutine itself, else it might
// deadlock writing to sc.wantWriteFrameCh (which is only mildly
// buffered and is read by serve itself). If you're on the serve
// goroutine, call writeFrame instead.
private static error writeFrameFromHandler(this ptr<http2serverConn> _addr_sc, http2FrameWriteRequest wr) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.checkNotOn(); // NOT
    return error.As(null!)!;
    return error.As(http2errClientDisconnected)!;
}

// writeFrame schedules a frame to write and sends it if there's nothing
// already being written.
//
// There is no pushback here (the serve goroutine never blocks). It's
// the http.Handlers that block, waiting for their previous frames to
// make it onto the wire
//
// If you're not on the serve goroutine, use writeFrameFromHandler instead.
private static void writeFrame(this ptr<http2serverConn> _addr_sc, http2FrameWriteRequest wr) => func((_, panic, _) => {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check(); 

    // If true, wr will not be written and wr.done will not be signaled.
    bool ignoreWrite = default; 

    // We are not allowed to write frames on closed streams. RFC 7540 Section
    // 5.1.1 says: "An endpoint MUST NOT send frames other than PRIORITY on
    // a closed stream." Our server never sends PRIORITY, so that exception
    // does not apply.
    //
    // The serverConn might close an open stream while the stream's handler
    // is still running. For example, the server might close a stream when it
    // receives bad data from the client. If this happens, the handler might
    // attempt to write a frame after the stream has been closed (since the
    // handler hasn't yet been notified of the close). In this case, we simply
    // ignore the frame. The handler will notice that the stream is closed when
    // it waits for the frame to be written.
    //
    // As an exception to this rule, we allow sending RST_STREAM after close.
    // This allows us to immediately reject new streams without tracking any
    // state for those streams (except for the queued RST_STREAM frame). This
    // may result in duplicate RST_STREAMs in some cases, but the client should
    // ignore those.
    if (wr.StreamID() != 0) {
        http2StreamError (_, isReset) = wr.write._<http2StreamError>();
        {
            var (state, _) = sc.state(wr.StreamID());

            if (state == http2stateClosed && !isReset) {
                ignoreWrite = true;
            }

        }
    }
    switch (wr.write.type()) {
        case ptr<http2writeResHeaders> _:
            wr.stream.wroteHeaders = true;
            break;
        case http2write100ContinueHeadersFrame _:
            if (wr.stream.wroteHeaders) { 
                // We do not need to notify wr.done because this frame is
                // never written with wr.done != nil.
                if (wr.done != null) {
                    panic("wr.done != nil for write100ContinueHeadersFrame");
                }
                ignoreWrite = true;
            }
            break;

    }

    if (!ignoreWrite) {
        if (wr.isControl()) {
            sc.queuedControlFrames++; 
            // For extra safety, detect wraparounds, which should not happen,
            // and pull the plug.
            if (sc.queuedControlFrames < 0) {
                sc.conn.Close();
            }
        }
        sc.writeSched.Push(wr);
    }
    sc.scheduleFrameWrite();
});

// startFrameWrite starts a goroutine to write wr (in a separate
// goroutine since that might block on the network), and updates the
// serve goroutine's state about the world, updated from info in wr.
private static void startFrameWrite(this ptr<http2serverConn> _addr_sc, http2FrameWriteRequest wr) => func((_, panic, _) => {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check();
    if (sc.writingFrame) {
        panic("internal error: can only be writing one frame at a time");
    }
    var st = wr.stream;
    if (st != null) {

        if (st.state == http2stateHalfClosedLocal) 
            switch (wr.write.type()) {
                case http2StreamError _:
                    break;
                case http2handlerPanicRST _:
                    break;
                case http2writeWindowUpdate _:
                    break;
                default:
                {
                    panic(fmt.Sprintf("internal error: attempt to send frame on a half-closed-local stream: %v", wr));
                    break;
                }
            }
        else if (st.state == http2stateClosed) 
            panic(fmt.Sprintf("internal error: attempt to send frame on a closed stream: %v", wr));
            }
    {
        ptr<http2writePushPromise> (wpp, ok) = wr.write._<ptr<http2writePushPromise>>();

        if (ok) {
            error err = default!;
            wpp.promisedID, err = wpp.allocatePromisedID();
            if (err != null) {
                sc.writingFrameAsync = false;
                wr.replyToWriter(err);
                return ;
            }
        }
    }

    sc.writingFrame = true;
    sc.needsFrameFlush = true;
    if (wr.write.staysWithinBuffer(sc.bw.Available())) {
        sc.writingFrameAsync = false;
        err = wr.write.writeFrame(sc);
        sc.wroteFrame(new http2frameWriteResult(wr:wr,err:err));
    }
    else
 {
        sc.writingFrameAsync = true;
        go_(() => sc.writeFrameAsync(wr));
    }
});

// errHandlerPanicked is the error given to any callers blocked in a read from
// Request.Body when the main goroutine panics. Since most handlers read in the
// main ServeHTTP goroutine, this will show up rarely.
private static var http2errHandlerPanicked = errors.New("http2: handler panicked");

// wroteFrame is called on the serve goroutine with the result of
// whatever happened on writeFrameAsync.
private static void wroteFrame(this ptr<http2serverConn> _addr_sc, http2frameWriteResult res) => func((_, panic, _) => {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check();
    if (!sc.writingFrame) {
        panic("internal error: expected to be already writing a frame");
    }
    sc.writingFrame = false;
    sc.writingFrameAsync = false;

    var wr = res.wr;

    if (http2writeEndsStream(wr.write)) {
        var st = wr.stream;
        if (st == null) {
            panic("internal error: expecting non-nil stream");
        }

        if (st.state == http2stateOpen) 
            // Here we would go to stateHalfClosedLocal in
            // theory, but since our handler is done and
            // the net/http package provides no mechanism
            // for closing a ResponseWriter while still
            // reading data (see possible TODO at top of
            // this file), we go into closed state here
            // anyway, after telling the peer we're
            // hanging up on them. We'll transition to
            // stateClosed after the RST_STREAM frame is
            // written.
            st.state = http2stateHalfClosedLocal; 
            // Section 8.1: a server MAY request that the client abort
            // transmission of a request without error by sending a
            // RST_STREAM with an error code of NO_ERROR after sending
            // a complete response.
            sc.resetStream(http2streamError(st.id, http2ErrCodeNo));
        else if (st.state == http2stateHalfClosedRemote) 
            sc.closeStream(st, http2errHandlerComplete);
            }
    else
 {
        switch (wr.write.type()) {
            case http2StreamError v:
                {
                    var st__prev2 = st;

                    var (st, ok) = sc.streams[v.StreamID];

                    if (ok) {
                        sc.closeStream(st, v);
                    }

                    st = st__prev2;

                }
                break;
            case http2handlerPanicRST v:
                sc.closeStream(wr.stream, http2errHandlerPanicked);
                break;
        }
    }
    wr.replyToWriter(res.err);

    sc.scheduleFrameWrite();
});

// scheduleFrameWrite tickles the frame writing scheduler.
//
// If a frame is already being written, nothing happens. This will be called again
// when the frame is done being written.
//
// If a frame isn't being written and we need to send one, the best frame
// to send is selected by writeSched.
//
// If a frame isn't being written and there's nothing else to send, we
// flush the write buffer.
private static void scheduleFrameWrite(this ptr<http2serverConn> _addr_sc) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check();
    if (sc.writingFrame || sc.inFrameScheduleLoop) {
        return ;
    }
    sc.inFrameScheduleLoop = true;
    while (!sc.writingFrameAsync) {
        if (sc.needToSendGoAway) {
            sc.needToSendGoAway = false;
            sc.startFrameWrite(new http2FrameWriteRequest(write:&http2writeGoAway{maxStreamID:sc.maxClientStreamID,code:sc.goAwayCode,},));
            continue;
        }
        if (sc.needToSendSettingsAck) {
            sc.needToSendSettingsAck = false;
            sc.startFrameWrite(new http2FrameWriteRequest(write:http2writeSettingsAck{}));
            continue;
        }
        if (!sc.inGoAway || sc.goAwayCode == http2ErrCodeNo) {
            {
                var (wr, ok) = sc.writeSched.Pop();

                if (ok) {
                    if (wr.isControl()) {
                        sc.queuedControlFrames--;
                    }
                    sc.startFrameWrite(wr);
                    continue;
                }

            }
        }
        if (sc.needsFrameFlush) {
            sc.startFrameWrite(new http2FrameWriteRequest(write:http2flushFrameWriter{}));
            sc.needsFrameFlush = false; // after startFrameWrite, since it sets this true
            continue;
        }
        break;
    }
    sc.inFrameScheduleLoop = false;
}

// startGracefulShutdown gracefully shuts down a connection. This
// sends GOAWAY with ErrCodeNo to tell the client we're gracefully
// shutting down. The connection isn't closed until all current
// streams are done.
//
// startGracefulShutdown returns immediately; it does not wait until
// the connection has shut down.
private static void startGracefulShutdown(this ptr<http2serverConn> _addr_sc) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.checkNotOn(); // NOT
    sc.shutdownOnce.Do(() => {
        sc.sendServeMsg(http2gracefulShutdownMsg);
    });
}

// After sending GOAWAY with an error code (non-graceful shutdown), the
// connection will close after goAwayTimeout.
//
// If we close the connection immediately after sending GOAWAY, there may
// be unsent data in our kernel receive buffer, which will cause the kernel
// to send a TCP RST on close() instead of a FIN. This RST will abort the
// connection immediately, whether or not the client had received the GOAWAY.
//
// Ideally we should delay for at least 1 RTT + epsilon so the client has
// a chance to read the GOAWAY and stop sending messages. Measuring RTT
// is hard, so we approximate with 1 second. See golang.org/issue/18701.
//
// This is a var so it can be shorter in tests, where all requests uses the
// loopback interface making the expected RTT very small.
//
// TODO: configurable?
private static nint http2goAwayTimeout = 1 * time.Second;

private static void startGracefulShutdownInternal(this ptr<http2serverConn> _addr_sc) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.goAway(http2ErrCodeNo);
}

private static void goAway(this ptr<http2serverConn> _addr_sc, http2ErrCode code) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check();
    if (sc.inGoAway) {
        return ;
    }
    sc.inGoAway = true;
    sc.needToSendGoAway = true;
    sc.goAwayCode = code;
    sc.scheduleFrameWrite();
}

private static void shutDownIn(this ptr<http2serverConn> _addr_sc, time.Duration d) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check();
    sc.shutdownTimer = time.AfterFunc(d, sc.onShutdownTimer);
}

private static void resetStream(this ptr<http2serverConn> _addr_sc, http2StreamError se) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check();
    sc.writeFrame(new http2FrameWriteRequest(write:se));
    {
        var (st, ok) = sc.streams[se.StreamID];

        if (ok) {
            st.resetQueued = true;
        }
    }
}

// processFrameFromReader processes the serve loop's read from readFrameCh from the
// frame-reading goroutine.
// processFrameFromReader returns whether the connection should be kept open.
private static bool processFrameFromReader(this ptr<http2serverConn> _addr_sc, http2readFrameResult res) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check();
    var err = res.err;
    if (err != null) {
        if (err == http2ErrFrameTooLarge) {
            sc.goAway(http2ErrCodeFrameSize);
            return true; // goAway will close the loop
        }
        var clientGone = err == io.EOF || err == io.ErrUnexpectedEOF || http2isClosedConnError(err);
        if (clientGone) { 
            // TODO: could we also get into this state if
            // the peer does a half close
            // (e.g. CloseWrite) because they're done
            // sending frames but they're still wanting
            // our open replies?  Investigate.
            // TODO: add CloseWrite to crypto/tls.Conn first
            // so we have a way to test this? I suppose
            // just for testing we could have a non-TLS mode.
            return false;
        }
    }
    else
 {
        var f = res.f;
        if (http2VerboseLogs) {
            sc.vlogf("http2: server read frame %v", http2summarizeFrame(f));
        }
        err = sc.processFrame(f);
        if (err == null) {
            return true;
        }
    }
    switch (err.type()) {
        case http2StreamError ev:
            sc.resetStream(ev);
            return true;
            break;
        case http2goAwayFlowError ev:
            sc.goAway(http2ErrCodeFlowControl);
            return true;
            break;
        case http2ConnectionError ev:
            sc.logf("http2: server connection error from %v: %v", sc.conn.RemoteAddr(), ev);
            sc.goAway(http2ErrCode(ev));
            return true; // goAway will handle shutdown
            break;
        default:
        {
            var ev = err.type();
            if (res.err != null) {
                sc.vlogf("http2: server closing client connection; error reading frame from client %s: %v", sc.conn.RemoteAddr(), err);
            }
            else
 {
                sc.logf("http2: server closing client connection: %v", err);
            }
            return false;
            break;
        }
    }
}

private static error processFrame(this ptr<http2serverConn> _addr_sc, http2Frame f) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check(); 

    // First frame received must be SETTINGS.
    if (!sc.sawFirstSettings) {
        {
            ptr<http2SettingsFrame> (_, ok) = f._<ptr<http2SettingsFrame>>();

            if (!ok) {
                return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
            }

        }
        sc.sawFirstSettings = true;
    }
    switch (f.type()) {
        case ptr<http2SettingsFrame> f:
            return error.As(sc.processSettings(f))!;
            break;
        case ptr<http2MetaHeadersFrame> f:
            return error.As(sc.processHeaders(f))!;
            break;
        case ptr<http2WindowUpdateFrame> f:
            return error.As(sc.processWindowUpdate(f))!;
            break;
        case ptr<http2PingFrame> f:
            return error.As(sc.processPing(f))!;
            break;
        case ptr<http2DataFrame> f:
            return error.As(sc.processData(f))!;
            break;
        case ptr<http2RSTStreamFrame> f:
            return error.As(sc.processResetStream(f))!;
            break;
        case ptr<http2PriorityFrame> f:
            return error.As(sc.processPriority(f))!;
            break;
        case ptr<http2GoAwayFrame> f:
            return error.As(sc.processGoAway(f))!;
            break;
        case ptr<http2PushPromiseFrame> f:
            return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
            break;
        default:
        {
            var f = f.type();
            sc.vlogf("http2: server ignoring frame: %v", f.Header());
            return error.As(null!)!;
            break;
        }
    }
}

private static error processPing(this ptr<http2serverConn> _addr_sc, ptr<http2PingFrame> _addr_f) {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2PingFrame f = ref _addr_f.val;

    sc.serveG.check();
    if (f.IsAck()) { 
        // 6.7 PING: " An endpoint MUST NOT respond to PING frames
        // containing this flag."
        return error.As(null!)!;
    }
    if (f.StreamID != 0) { 
        // "PING frames are not associated with any individual
        // stream. If a PING frame is received with a stream
        // identifier field value other than 0x0, the recipient MUST
        // respond with a connection error (Section 5.4.1) of type
        // PROTOCOL_ERROR."
        return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
    }
    if (sc.inGoAway && sc.goAwayCode != http2ErrCodeNo) {
        return error.As(null!)!;
    }
    sc.writeFrame(new http2FrameWriteRequest(write:http2writePingAck{f}));
    return error.As(null!)!;
}

private static error processWindowUpdate(this ptr<http2serverConn> _addr_sc, ptr<http2WindowUpdateFrame> _addr_f) {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2WindowUpdateFrame f = ref _addr_f.val;

    sc.serveG.check();

    if (f.StreamID != 0) // stream-level flow control
        var (state, st) = sc.state(f.StreamID);
        if (state == http2stateIdle) { 
            // Section 5.1: "Receiving any frame other than HEADERS
            // or PRIORITY on a stream in this state MUST be
            // treated as a connection error (Section 5.4.1) of
            // type PROTOCOL_ERROR."
            return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
        }
        if (st == null) { 
            // "WINDOW_UPDATE can be sent by a peer that has sent a
            // frame bearing the END_STREAM flag. This means that a
            // receiver could receive a WINDOW_UPDATE frame on a "half
            // closed (remote)" or "closed" stream. A receiver MUST
            // NOT treat this as an error, see Section 5.1."
            return error.As(null!)!;
        }
        if (!st.flow.add(int32(f.Increment))) {
            return error.As(http2streamError(f.StreamID, http2ErrCodeFlowControl))!;
        }
    else // connection-level flow control
        if (!sc.flow.add(int32(f.Increment))) {
            return error.As(new http2goAwayFlowError())!;
        }
        sc.scheduleFrameWrite();
    return error.As(null!)!;
}

private static error processResetStream(this ptr<http2serverConn> _addr_sc, ptr<http2RSTStreamFrame> _addr_f) {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2RSTStreamFrame f = ref _addr_f.val;

    sc.serveG.check();

    var (state, st) = sc.state(f.StreamID);
    if (state == http2stateIdle) { 
        // 6.4 "RST_STREAM frames MUST NOT be sent for a
        // stream in the "idle" state. If a RST_STREAM frame
        // identifying an idle stream is received, the
        // recipient MUST treat this as a connection error
        // (Section 5.4.1) of type PROTOCOL_ERROR.
        return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
    }
    if (st != null) {
        st.cancelCtx();
        sc.closeStream(st, http2streamError(f.StreamID, f.ErrCode));
    }
    return error.As(null!)!;
}

private static void closeStream(this ptr<http2serverConn> _addr_sc, ptr<http2stream> _addr_st, error err) => func((_, panic, _) => {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2stream st = ref _addr_st.val;

    sc.serveG.check();
    if (st.state == http2stateIdle || st.state == http2stateClosed) {
        panic(fmt.Sprintf("invariant; can't close stream in state %v", st.state));
    }
    st.state = http2stateClosed;
    if (st.writeDeadline != null) {
        st.writeDeadline.Stop();
    }
    if (st.isPushed()) {
        sc.curPushedStreams--;
    }
    else
 {
        sc.curClientStreams--;
    }
    delete(sc.streams, st.id);
    if (len(sc.streams) == 0) {
        sc.setConnState(StateIdle);
        if (sc.srv.IdleTimeout != 0) {
            sc.idleTimer.Reset(sc.srv.IdleTimeout);
        }
        if (http2h1ServerKeepAlivesDisabled(_addr_sc.hs)) {
            sc.startGracefulShutdownInternal();
        }
    }
    {
        var p = st.body;

        if (p != null) { 
            // Return any buffered unread bytes worth of conn-level flow control.
            // See golang.org/issue/16481
            sc.sendWindowUpdate(null, p.Len());

            p.CloseWithError(err);
        }
    }
    st.cw.Close(); // signals Handler's CloseNotifier, unblocks writes, etc
    sc.writeSched.CloseStream(st.id);
});

private static error processSettings(this ptr<http2serverConn> _addr_sc, ptr<http2SettingsFrame> _addr_f) {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2SettingsFrame f = ref _addr_f.val;

    sc.serveG.check();
    if (f.IsAck()) {
        sc.unackedSettings--;
        if (sc.unackedSettings < 0) { 
            // Why is the peer ACKing settings we never sent?
            // The spec doesn't mention this case, but
            // hang up on them anyway.
            return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
        }
        return error.As(null!)!;
    }
    if (f.NumSettings() > 100 || f.HasDuplicates()) { 
        // This isn't actually in the spec, but hang up on
        // suspiciously large settings frames or those with
        // duplicate entries.
        return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
    }
    {
        var err = f.ForeachSetting(sc.processSetting);

        if (err != null) {
            return error.As(err)!;
        }
    } 
    // TODO: judging by RFC 7540, Section 6.5.3 each SETTINGS frame should be
    // acknowledged individually, even if multiple are received before the ACK.
    sc.needToSendSettingsAck = true;
    sc.scheduleFrameWrite();
    return error.As(null!)!;
}

private static error processSetting(this ptr<http2serverConn> _addr_sc, http2Setting s) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check();
    {
        var err = s.Valid();

        if (err != null) {
            return error.As(err)!;
        }
    }
    if (http2VerboseLogs) {
        sc.vlogf("http2: server processing setting %v", s);
    }

    if (s.ID == http2SettingHeaderTableSize) 
        sc.headerTableSize = s.Val;
        sc.hpackEncoder.SetMaxDynamicTableSize(s.Val);
    else if (s.ID == http2SettingEnablePush) 
        sc.pushEnabled = s.Val != 0;
    else if (s.ID == http2SettingMaxConcurrentStreams) 
        sc.clientMaxStreams = s.Val;
    else if (s.ID == http2SettingInitialWindowSize) 
        return error.As(sc.processSettingInitialWindowSize(s.Val))!;
    else if (s.ID == http2SettingMaxFrameSize) 
        sc.maxFrameSize = int32(s.Val); // the maximum valid s.Val is < 2^31
    else if (s.ID == http2SettingMaxHeaderListSize) 
        sc.peerMaxHeaderListSize = s.Val;
    else 
        // Unknown setting: "An endpoint that receives a SETTINGS
        // frame with any unknown or unsupported identifier MUST
        // ignore that setting."
        if (http2VerboseLogs) {
            sc.vlogf("http2: server ignoring unknown setting %v", s);
        }
        return error.As(null!)!;
}

private static error processSettingInitialWindowSize(this ptr<http2serverConn> _addr_sc, uint val) {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check(); 
    // Note: val already validated to be within range by
    // processSetting's Valid call.

    // "A SETTINGS frame can alter the initial flow control window
    // size for all current streams. When the value of
    // SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST
    // adjust the size of all stream flow control windows that it
    // maintains by the difference between the new value and the
    // old value."
    var old = sc.initialStreamSendWindowSize;
    sc.initialStreamSendWindowSize = int32(val);
    var growth = int32(val) - old; // may be negative
    foreach (var (_, st) in sc.streams) {
        if (!st.flow.add(growth)) { 
            // 6.9.2 Initial Flow Control Window Size
            // "An endpoint MUST treat a change to
            // SETTINGS_INITIAL_WINDOW_SIZE that causes any flow
            // control window to exceed the maximum size as a
            // connection error (Section 5.4.1) of type
            // FLOW_CONTROL_ERROR."
            return error.As(http2ConnectionError(http2ErrCodeFlowControl))!;
        }
    }    return error.As(null!)!;
}

private static error processData(this ptr<http2serverConn> _addr_sc, ptr<http2DataFrame> _addr_f) => func((_, panic, _) => {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2DataFrame f = ref _addr_f.val;

    sc.serveG.check();
    var id = f.Header().StreamID;
    if (sc.inGoAway && (sc.goAwayCode != http2ErrCodeNo || id > sc.maxClientStreamID)) { 
        // Discard all DATA frames if the GOAWAY is due to an
        // error, or:
        //
        // Section 6.8: After sending a GOAWAY frame, the sender
        // can discard frames for streams initiated by the
        // receiver with identifiers higher than the identified
        // last stream.
        return error.As(null!)!;
    }
    var data = f.Data();
    var (state, st) = sc.state(id);
    if (id == 0 || state == http2stateIdle) { 
        // Section 6.1: "DATA frames MUST be associated with a
        // stream. If a DATA frame is received whose stream
        // identifier field is 0x0, the recipient MUST respond
        // with a connection error (Section 5.4.1) of type
        // PROTOCOL_ERROR."
        //
        // Section 5.1: "Receiving any frame other than HEADERS
        // or PRIORITY on a stream in this state MUST be
        // treated as a connection error (Section 5.4.1) of
        // type PROTOCOL_ERROR."
        return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
    }
    if (st == null || state != http2stateOpen || st.gotTrailerHeader || st.resetQueued) { 
        // This includes sending a RST_STREAM if the stream is
        // in stateHalfClosedLocal (which currently means that
        // the http.Handler returned, so it's done reading &
        // done writing). Try to stop the client from sending
        // more DATA.

        // But still enforce their connection-level flow control,
        // and return any flow control bytes since we're not going
        // to consume them.
        if (sc.inflow.available() < int32(f.Length)) {
            return error.As(http2streamError(id, http2ErrCodeFlowControl))!;
        }
        sc.inflow.take(int32(f.Length));
        sc.sendWindowUpdate(null, int(f.Length)); // conn-level

        if (st != null && st.resetQueued) { 
            // Already have a stream error in flight. Don't send another.
            return error.As(null!)!;
        }
        return error.As(http2streamError(id, http2ErrCodeStreamClosed))!;
    }
    if (st.body == null) {
        panic("internal error: should have a body in this state");
    }
    if (st.declBodyBytes != -1 && st.bodyBytes + int64(len(data)) > st.declBodyBytes) {
        st.body.CloseWithError(fmt.Errorf("sender tried to send more than declared Content-Length of %d bytes", st.declBodyBytes)); 
        // RFC 7540, sec 8.1.2.6: A request or response is also malformed if the
        // value of a content-length header field does not equal the sum of the
        // DATA frame payload lengths that form the body.
        return error.As(http2streamError(id, http2ErrCodeProtocol))!;
    }
    if (f.Length > 0) { 
        // Check whether the client has flow control quota.
        if (st.inflow.available() < int32(f.Length)) {
            return error.As(http2streamError(id, http2ErrCodeFlowControl))!;
        }
        st.inflow.take(int32(f.Length));

        if (len(data) > 0) {
            var (wrote, err) = st.body.Write(data);
            if (err != null) {
                sc.sendWindowUpdate(null, int(f.Length) - wrote);
                return error.As(http2streamError(id, http2ErrCodeStreamClosed))!;
            }
            if (wrote != len(data)) {
                panic("internal error: bad Writer");
            }
            st.bodyBytes += int64(len(data));
        }
        {
            var pad = int32(f.Length) - int32(len(data));

            if (pad > 0) {
                sc.sendWindowUpdate32(null, pad);
                sc.sendWindowUpdate32(st, pad);
            }

        }
    }
    if (f.StreamEnded()) {
        st.endStream();
    }
    return error.As(null!)!;
});

private static error processGoAway(this ptr<http2serverConn> _addr_sc, ptr<http2GoAwayFrame> _addr_f) {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2GoAwayFrame f = ref _addr_f.val;

    sc.serveG.check();
    if (f.ErrCode != http2ErrCodeNo) {
        sc.logf("http2: received GOAWAY %+v, starting graceful shutdown", f);
    }
    else
 {
        sc.vlogf("http2: received GOAWAY %+v, starting graceful shutdown", f);
    }
    sc.startGracefulShutdownInternal(); 
    // http://tools.ietf.org/html/rfc7540#section-6.8
    // We should not create any new streams, which means we should disable push.
    sc.pushEnabled = false;
    return error.As(null!)!;
}

// isPushed reports whether the stream is server-initiated.
private static bool isPushed(this ptr<http2stream> _addr_st) {
    ref http2stream st = ref _addr_st.val;

    return st.id % 2 == 0;
}

// endStream closes a Request.Body's pipe. It is called when a DATA
// frame says a request body is over (or after trailers).
private static void endStream(this ptr<http2stream> _addr_st) {
    ref http2stream st = ref _addr_st.val;

    var sc = st.sc;
    sc.serveG.check();

    if (st.declBodyBytes != -1 && st.declBodyBytes != st.bodyBytes) {
        st.body.CloseWithError(fmt.Errorf("request declared a Content-Length of %d but only wrote %d bytes", st.declBodyBytes, st.bodyBytes));
    }
    else
 {
        st.body.closeWithErrorAndCode(io.EOF, st.copyTrailersToHandlerRequest);
        st.body.CloseWithError(io.EOF);
    }
    st.state = http2stateHalfClosedRemote;
}

// copyTrailersToHandlerRequest is run in the Handler's goroutine in
// its Request.Body.Read just before it gets io.EOF.
private static void copyTrailersToHandlerRequest(this ptr<http2stream> _addr_st) {
    ref http2stream st = ref _addr_st.val;

    foreach (var (k, vv) in st.trailer) {
        {
            var (_, ok) = st.reqTrailer[k];

            if (ok) { 
                // Only copy it over it was pre-declared.
                st.reqTrailer[k] = vv;
            }

        }
    }
}

// onWriteTimeout is run on its own goroutine (from time.AfterFunc)
// when the stream's WriteTimeout has fired.
private static void onWriteTimeout(this ptr<http2stream> _addr_st) {
    ref http2stream st = ref _addr_st.val;

    st.sc.writeFrameFromHandler(new http2FrameWriteRequest(write:http2streamError(st.id,http2ErrCodeInternal)));
}

private static error processHeaders(this ptr<http2serverConn> _addr_sc, ptr<http2MetaHeadersFrame> _addr_f) {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2MetaHeadersFrame f = ref _addr_f.val;

    sc.serveG.check();
    var id = f.StreamID;
    if (sc.inGoAway) { 
        // Ignore.
        return error.As(null!)!;
    }
    if (id % 2 != 1) {
        return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
    }
    {
        var st__prev1 = st;

        var st = sc.streams[f.StreamID];

        if (st != null) {
            if (st.resetQueued) { 
                // We're sending RST_STREAM to close the stream, so don't bother
                // processing this frame.
                return error.As(null!)!;
            } 
            // RFC 7540, sec 5.1: If an endpoint receives additional frames, other than
            // WINDOW_UPDATE, PRIORITY, or RST_STREAM, for a stream that is in
            // this state, it MUST respond with a stream error (Section 5.4.2) of
            // type STREAM_CLOSED.
            if (st.state == http2stateHalfClosedRemote) {
                return error.As(http2streamError(id, http2ErrCodeStreamClosed))!;
            }
            return error.As(st.processTrailerHeaders(f))!;
        }
        st = st__prev1;

    } 

    // [...] The identifier of a newly established stream MUST be
    // numerically greater than all streams that the initiating
    // endpoint has opened or reserved. [...]  An endpoint that
    // receives an unexpected stream identifier MUST respond with
    // a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
    if (id <= sc.maxClientStreamID) {
        return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
    }
    sc.maxClientStreamID = id;

    if (sc.idleTimer != null) {
        sc.idleTimer.Stop();
    }
    if (sc.curClientStreams + 1 > sc.advMaxStreams) {
        if (sc.unackedSettings == 0) { 
            // They should know better.
            return error.As(http2streamError(id, http2ErrCodeProtocol))!;
        }
        return error.As(http2streamError(id, http2ErrCodeRefusedStream))!;
    }
    var initialState = http2stateOpen;
    if (f.StreamEnded()) {
        initialState = http2stateHalfClosedRemote;
    }
    st = sc.newStream(id, 0, initialState);

    if (f.HasPriority()) {
        {
            var err__prev2 = err;

            var err = http2checkPriority(f.StreamID, f.Priority);

            if (err != null) {
                return error.As(err)!;
            }

            err = err__prev2;

        }
        sc.writeSched.AdjustStream(st.id, f.Priority);
    }
    var (rw, req, err) = sc.newWriterAndRequest(st, f);
    if (err != null) {
        return error.As(err)!;
    }
    st.reqTrailer = req.Trailer;
    if (st.reqTrailer != null) {
        st.trailer = make(Header);
    }
    st.body = req.Body._<ptr<http2requestBody>>().pipe; // may be nil
    st.declBodyBytes = req.ContentLength;

    var handler = sc.handler.ServeHTTP;
    if (f.Truncated) { 
        // Their header list was too long. Send a 431 error.
        handler = http2handleHeaderListTooLong;
    }    {
        var err__prev2 = err;

        err = http2checkValidHTTP2RequestHeaders(req.Header);


        else if (err != null) {
            handler = http2new400Handler(err);
        }
        err = err__prev2;

    } 

    // The net/http package sets the read deadline from the
    // http.Server.ReadTimeout during the TLS handshake, but then
    // passes the connection off to us with the deadline already
    // set. Disarm it here after the request headers are read,
    // similar to how the http1 server works. Here it's
    // technically more like the http1 Server's ReadHeaderTimeout
    // (in Go 1.8), though. That's a more sane option anyway.
    if (sc.hs.ReadTimeout != 0) {
        sc.conn.SetReadDeadline(new time.Time());
    }
    go_(() => sc.runHandler(rw, req, handler));
    return error.As(null!)!;
}

private static error processTrailerHeaders(this ptr<http2stream> _addr_st, ptr<http2MetaHeadersFrame> _addr_f) {
    ref http2stream st = ref _addr_st.val;
    ref http2MetaHeadersFrame f = ref _addr_f.val;

    var sc = st.sc;
    sc.serveG.check();
    if (st.gotTrailerHeader) {
        return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
    }
    st.gotTrailerHeader = true;
    if (!f.StreamEnded()) {
        return error.As(http2streamError(st.id, http2ErrCodeProtocol))!;
    }
    if (len(f.PseudoFields()) > 0) {
        return error.As(http2streamError(st.id, http2ErrCodeProtocol))!;
    }
    if (st.trailer != null) {
        foreach (var (_, hf) in f.RegularFields()) {
            var key = sc.canonicalHeader(hf.Name);
            if (!httpguts.ValidTrailerHeader(key)) { 
                // TODO: send more details to the peer somehow. But http2 has
                // no way to send debug data at a stream level. Discuss with
                // HTTP folk.
                return error.As(http2streamError(st.id, http2ErrCodeProtocol))!;
            }
            st.trailer[key] = append(st.trailer[key], hf.Value);
        }
    }
    st.endStream();
    return error.As(null!)!;
}

private static error http2checkPriority(uint streamID, http2PriorityParam p) {
    if (streamID == p.StreamDep) { 
        // Section 5.3.1: "A stream cannot depend on itself. An endpoint MUST treat
        // this as a stream error (Section 5.4.2) of type PROTOCOL_ERROR."
        // Section 5.3.3 says that a stream can depend on one of its dependencies,
        // so it's only self-dependencies that are forbidden.
        return error.As(http2streamError(streamID, http2ErrCodeProtocol))!;
    }
    return error.As(null!)!;
}

private static error processPriority(this ptr<http2serverConn> _addr_sc, ptr<http2PriorityFrame> _addr_f) {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2PriorityFrame f = ref _addr_f.val;

    if (sc.inGoAway) {
        return error.As(null!)!;
    }
    {
        var err = http2checkPriority(f.StreamID, f.http2PriorityParam);

        if (err != null) {
            return error.As(err)!;
        }
    }
    sc.writeSched.AdjustStream(f.StreamID, f.http2PriorityParam);
    return error.As(null!)!;
}

private static ptr<http2stream> newStream(this ptr<http2serverConn> _addr_sc, uint id, uint pusherID, http2streamState state) => func((_, panic, _) => {
    ref http2serverConn sc = ref _addr_sc.val;

    sc.serveG.check();
    if (id == 0) {
        panic("internal error: cannot create stream with id 0");
    }
    var (ctx, cancelCtx) = context.WithCancel(sc.baseCtx);
    ptr<http2stream> st = addr(new http2stream(sc:sc,id:id,state:state,ctx:ctx,cancelCtx:cancelCtx,));
    st.cw.Init();
    st.flow.conn = _addr_sc.flow; // link to conn-level counter
    st.flow.add(sc.initialStreamSendWindowSize);
    st.inflow.conn = _addr_sc.inflow; // link to conn-level counter
    st.inflow.add(sc.srv.initialStreamRecvWindowSize());
    if (sc.hs.WriteTimeout != 0) {
        st.writeDeadline = time.AfterFunc(sc.hs.WriteTimeout, st.onWriteTimeout);
    }
    sc.streams[id] = st;
    sc.writeSched.OpenStream(st.id, new http2OpenStreamOptions(PusherID:pusherID));
    if (st.isPushed()) {
        sc.curPushedStreams++;
    }
    else
 {
        sc.curClientStreams++;
    }
    if (sc.curOpenStreams() == 1) {
        sc.setConnState(StateActive);
    }
    return _addr_st!;
});

private static (ptr<http2responseWriter>, ptr<Request>, error) newWriterAndRequest(this ptr<http2serverConn> _addr_sc, ptr<http2stream> _addr_st, ptr<http2MetaHeadersFrame> _addr_f) {
    ptr<http2responseWriter> _p0 = default!;
    ptr<Request> _p0 = default!;
    error _p0 = default!;
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2stream st = ref _addr_st.val;
    ref http2MetaHeadersFrame f = ref _addr_f.val;

    sc.serveG.check();

    http2requestParam rp = new http2requestParam(method:f.PseudoValue("method"),scheme:f.PseudoValue("scheme"),authority:f.PseudoValue("authority"),path:f.PseudoValue("path"),);

    var isConnect = rp.method == "CONNECT";
    if (isConnect) {
        if (rp.path != "" || rp.scheme != "" || rp.authority == "") {
            return (_addr_null!, _addr_null!, error.As(http2streamError(f.StreamID, http2ErrCodeProtocol))!);
        }
    }
    else if (rp.method == "" || rp.path == "" || (rp.scheme != "https" && rp.scheme != "http")) { 
        // See 8.1.2.6 Malformed Requests and Responses:
        //
        // Malformed requests or responses that are detected
        // MUST be treated as a stream error (Section 5.4.2)
        // of type PROTOCOL_ERROR."
        //
        // 8.1.2.3 Request Pseudo-Header Fields
        // "All HTTP/2 requests MUST include exactly one valid
        // value for the :method, :scheme, and :path
        // pseudo-header fields"
        return (_addr_null!, _addr_null!, error.As(http2streamError(f.StreamID, http2ErrCodeProtocol))!);
    }
    var bodyOpen = !f.StreamEnded();
    if (rp.method == "HEAD" && bodyOpen) { 
        // HEAD requests can't have bodies
        return (_addr_null!, _addr_null!, error.As(http2streamError(f.StreamID, http2ErrCodeProtocol))!);
    }
    rp.header = make(Header);
    foreach (var (_, hf) in f.RegularFields()) {
        rp.header.Add(sc.canonicalHeader(hf.Name), hf.Value);
    }    if (rp.authority == "") {
        rp.authority = rp.header.Get("Host");
    }
    var (rw, req, err) = sc.newWriterAndRequestNoBody(st, rp);
    if (err != null) {
        return (_addr_null!, _addr_null!, error.As(err)!);
    }
    if (bodyOpen) {
        {
            var (vv, ok) = rp.header["Content-Length"];

            if (ok) {
                {
                    var (cl, err) = strconv.ParseUint(vv[0], 10, 63);

                    if (err == null) {
                        req.ContentLength = int64(cl);
                    }
                    else
 {
                        req.ContentLength = 0;
                    }

                }
            }
            else
 {
                req.ContentLength = -1;
            }

        }
        req.Body._<ptr<http2requestBody>>().pipe = addr(new http2pipe(b:&http2dataBuffer{expected:req.ContentLength},));
    }
    return (_addr_rw!, _addr_req!, error.As(null!)!);
}

private partial struct http2requestParam {
    public @string method;
    public @string scheme;
    public @string authority;
    public @string path;
    public Header header;
}

private static (ptr<http2responseWriter>, ptr<Request>, error) newWriterAndRequestNoBody(this ptr<http2serverConn> _addr_sc, ptr<http2stream> _addr_st, http2requestParam rp) {
    ptr<http2responseWriter> _p0 = default!;
    ptr<Request> _p0 = default!;
    error _p0 = default!;
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2stream st = ref _addr_st.val;

    sc.serveG.check();

    ptr<tls.ConnectionState> tlsState; // nil if not scheme https
    if (rp.scheme == "https") {
        tlsState = sc.tlsState;
    }
    var needsContinue = rp.header.Get("Expect") == "100-continue";
    if (needsContinue) {
        rp.header.Del("Expect");
    }
    {
        var cookies = rp.header["Cookie"];

        if (len(cookies) > 1) {
            rp.header.Set("Cookie", strings.Join(cookies, "; "));
        }
    } 

    // Setup Trailers
    Header trailer = default;
    foreach (var (_, v) in rp.header["Trailer"]) {
        foreach (var (_, key) in strings.Split(v, ",")) {
            key = CanonicalHeaderKey(textproto.TrimString(key));
            switch (key) {
                case "Transfer-Encoding": 

                case "Trailer": 

                case "Content-Length": 

                    break;
                default: 
                    if (trailer == null) {
                        trailer = make(Header);
                    }
                    trailer[key] = null;
                    break;
            }
        }
    }    delete(rp.header, "Trailer");

    ptr<url.URL> url_;
    @string requestURI = default;
    if (rp.method == "CONNECT") {
        url_ = addr(new url.URL(Host:rp.authority));
        requestURI = rp.authority; // mimic HTTP/1 server behavior
    }
    else
 {
        error err = default!;
        url_, err = url.ParseRequestURI(rp.path);
        if (err != null) {
            return (_addr_null!, _addr_null!, error.As(http2streamError(st.id, http2ErrCodeProtocol))!);
        }
        requestURI = rp.path;
    }
    ptr<http2requestBody> body = addr(new http2requestBody(conn:sc,stream:st,needsContinue:needsContinue,));
    ptr<Request> req = addr(new Request(Method:rp.method,URL:url_,RemoteAddr:sc.remoteAddrStr,Header:rp.header,RequestURI:requestURI,Proto:"HTTP/2.0",ProtoMajor:2,ProtoMinor:0,TLS:tlsState,Host:rp.authority,Body:body,Trailer:trailer,));
    req = req.WithContext(st.ctx);

    ptr<http2responseWriterState> rws = http2responseWriterStatePool.Get()._<ptr<http2responseWriterState>>();
    var bwSave = rws.bw;
    rws.val = new http2responseWriterState(); // zero all the fields
    rws.conn = sc;
    rws.bw = bwSave;
    rws.bw.Reset(new http2chunkWriter(rws));
    rws.stream = st;
    rws.req = req;
    rws.body = body;

    ptr<http2responseWriter> rw = addr(new http2responseWriter(rws:rws));
    return (_addr_rw!, _addr_req!, error.As(null!)!);
}

// Run on its own goroutine.
private static void runHandler(this ptr<http2serverConn> _addr_sc, ptr<http2responseWriter> _addr_rw, ptr<Request> _addr_req, Action<ResponseWriter, ptr<Request>> handler) => func((defer, _, _) => {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2responseWriter rw = ref _addr_rw.val;
    ref Request req = ref _addr_req.val;

    var didPanic = true;
    defer(() => {
        rw.rws.stream.cancelCtx();
        if (didPanic) {
            var e = recover();
            sc.writeFrameFromHandler(new http2FrameWriteRequest(write:http2handlerPanicRST{rw.rws.stream.id},stream:rw.rws.stream,)); 
            // Same as net/http:
            if (e != null && e != ErrAbortHandler) {
                const nint size = 64 << 10;

                var buf = make_slice<byte>(size);
                buf = buf[..(int)runtime.Stack(buf, false)];
                sc.logf("http2: panic serving %v: %v\n%s", sc.conn.RemoteAddr(), e, buf);
            }
            return ;
        }
        rw.handlerDone();
    }());
    handler(rw, req);
    didPanic = false;
});

private static void http2handleHeaderListTooLong(ResponseWriter w, ptr<Request> _addr_r) {
    ref Request r = ref _addr_r.val;
 
    // 10.5.1 Limits on Header Block Size:
    // .. "A server that receives a larger header block than it is
    // willing to handle can send an HTTP 431 (Request Header Fields Too
    // Large) status code"
    const nint statusRequestHeaderFieldsTooLarge = 431; // only in Go 1.6+
 // only in Go 1.6+
    w.WriteHeader(statusRequestHeaderFieldsTooLarge);
    io.WriteString(w, "<h1>HTTP Error 431</h1><p>Request Header Field(s) Too Large</p>");
}

// called from handler goroutines.
// h may be nil.
private static error writeHeaders(this ptr<http2serverConn> _addr_sc, ptr<http2stream> _addr_st, ptr<http2writeResHeaders> _addr_headerData) {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2stream st = ref _addr_st.val;
    ref http2writeResHeaders headerData = ref _addr_headerData.val;

    sc.serveG.checkNotOn(); // NOT on
    channel<error> errc = default;
    if (headerData.h != null) { 
        // If there's a header map (which we don't own), so we have to block on
        // waiting for this frame to be written, so an http.Flush mid-handler
        // writes out the correct value of keys, before a handler later potentially
        // mutates it.
        errc = http2errChanPool.Get()._<channel<error>>();
    }
    {
        var err__prev1 = err;

        var err = sc.writeFrameFromHandler(new http2FrameWriteRequest(write:headerData,stream:st,done:errc,));

        if (err != null) {
            return error.As(err)!;
        }
        err = err__prev1;

    }
    if (errc != null) {
        http2errChanPool.Put(errc);
        return error.As(err)!;
        return error.As(http2errClientDisconnected)!;
        return error.As(http2errStreamClosed)!;
    }
    return error.As(null!)!;
}

// called from handler goroutines.
private static void write100ContinueHeaders(this ptr<http2serverConn> _addr_sc, ptr<http2stream> _addr_st) {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2stream st = ref _addr_st.val;

    sc.writeFrameFromHandler(new http2FrameWriteRequest(write:http2write100ContinueHeadersFrame{st.id},stream:st,));
}

// A bodyReadMsg tells the server loop that the http.Handler read n
// bytes of the DATA from the client on the given stream.
private partial struct http2bodyReadMsg {
    public ptr<http2stream> st;
    public nint n;
}

// called from handler goroutines.
// Notes that the handler for the given stream ID read n bytes of its body
// and schedules flow control tokens to be sent.
private static void noteBodyReadFromHandler(this ptr<http2serverConn> _addr_sc, ptr<http2stream> _addr_st, nint n, error err) {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2stream st = ref _addr_st.val;

    sc.serveG.checkNotOn(); // NOT on
    if (n > 0) {
    }
}

private static void noteBodyRead(this ptr<http2serverConn> _addr_sc, ptr<http2stream> _addr_st, nint n) {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2stream st = ref _addr_st.val;

    sc.serveG.check();
    sc.sendWindowUpdate(null, n); // conn-level
    if (st.state != http2stateHalfClosedRemote && st.state != http2stateClosed) { 
        // Don't send this WINDOW_UPDATE if the stream is closed
        // remotely.
        sc.sendWindowUpdate(st, n);
    }
}

// st may be nil for conn-level
private static void sendWindowUpdate(this ptr<http2serverConn> _addr_sc, ptr<http2stream> _addr_st, nint n) {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2stream st = ref _addr_st.val;

    sc.serveG.check(); 
    // "The legal range for the increment to the flow control
    // window is 1 to 2^31-1 (2,147,483,647) octets."
    // A Go Read call on 64-bit machines could in theory read
    // a larger Read than this. Very unlikely, but we handle it here
    // rather than elsewhere for now.
    const nint maxUint31 = 1 << 31 - 1;

    while (n >= maxUint31) {
        sc.sendWindowUpdate32(st, maxUint31);
        n -= maxUint31;
    }
    sc.sendWindowUpdate32(st, int32(n));
}

// st may be nil for conn-level
private static void sendWindowUpdate32(this ptr<http2serverConn> _addr_sc, ptr<http2stream> _addr_st, int n) => func((_, panic, _) => {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2stream st = ref _addr_st.val;

    sc.serveG.check();
    if (n == 0) {
        return ;
    }
    if (n < 0) {
        panic("negative update");
    }
    uint streamID = default;
    if (st != null) {
        streamID = st.id;
    }
    sc.writeFrame(new http2FrameWriteRequest(write:http2writeWindowUpdate{streamID:streamID,n:uint32(n)},stream:st,));
    bool ok = default;
    if (st == null) {
        ok = sc.inflow.add(n);
    }
    else
 {
        ok = st.inflow.add(n);
    }
    if (!ok) {
        panic("internal error; sent too many window updates without decrements?");
    }
});

// requestBody is the Handler's Request.Body type.
// Read and Close may be called concurrently.
private partial struct http2requestBody {
    public http2incomparable _;
    public ptr<http2stream> stream;
    public ptr<http2serverConn> conn;
    public bool closed; // for use by Close only
    public bool sawEOF; // for use by Read only
    public ptr<http2pipe> pipe; // non-nil if we have a HTTP entity message body
    public bool needsContinue; // need to send a 100-continue
}

private static error Close(this ptr<http2requestBody> _addr_b) {
    ref http2requestBody b = ref _addr_b.val;

    if (b.pipe != null && !b.closed) {
        b.pipe.BreakWithError(http2errClosedBody);
    }
    b.closed = true;
    return error.As(null!)!;
}

private static (nint, error) Read(this ptr<http2requestBody> _addr_b, slice<byte> p) {
    nint n = default;
    error err = default!;
    ref http2requestBody b = ref _addr_b.val;

    if (b.needsContinue) {
        b.needsContinue = false;
        b.conn.write100ContinueHeaders(b.stream);
    }
    if (b.pipe == null || b.sawEOF) {
        return (0, error.As(io.EOF)!);
    }
    n, err = b.pipe.Read(p);
    if (err == io.EOF) {
        b.sawEOF = true;
    }
    if (b.conn == null && http2inTests) {
        return ;
    }
    b.conn.noteBodyReadFromHandler(b.stream, n, err);
    return ;
}

// responseWriter is the http.ResponseWriter implementation. It's
// intentionally small (1 pointer wide) to minimize garbage. The
// responseWriterState pointer inside is zeroed at the end of a
// request (in handlerDone) and calls on the responseWriter thereafter
// simply crash (caller's mistake), but the much larger responseWriterState
// and buffers are reused between multiple requests.
private partial struct http2responseWriter {
    public ptr<http2responseWriterState> rws;
}

// Optional http.ResponseWriter interfaces implemented.
private static CloseNotifier _ = (http2responseWriter.val)(null);private static Flusher _ = (http2responseWriter.val)(null);private static http2stringWriter _ = http2stringWriter.As((http2responseWriter.val)(null))!;

private partial struct http2responseWriterState {
    public ptr<http2stream> stream;
    public ptr<Request> req;
    public ptr<http2requestBody> body; // to close at end of request, if DATA frames didn't
    public ptr<http2serverConn> conn; // TODO: adjust buffer writing sizes based on server config, frame size updates from peer, etc
    public ptr<bufio.Writer> bw; // writing to a chunkWriter{this *responseWriterState}

// mutated by http.Handler goroutine:
    public Header handlerHeader; // nil until called
    public Header snapHeader; // snapshot of handlerHeader at WriteHeader time
    public slice<@string> trailers; // set in writeChunk
    public nint status; // status code passed to WriteHeader
    public bool wroteHeader; // WriteHeader called (explicitly or implicitly). Not necessarily sent to user yet.
    public bool sentHeader; // have we sent the header frame?
    public bool handlerDone; // handler has finished
    public bool dirty; // a Write failed; don't reuse this responseWriterState

    public long sentContentLen; // non-zero if handler set a Content-Length header
    public long wroteBytes;
    public sync.Mutex closeNotifierMu; // guards closeNotifierCh
    public channel<bool> closeNotifierCh; // nil until first used
}

private partial struct http2chunkWriter {
    public ptr<http2responseWriterState> rws;
}

private static (nint, error) Write(this http2chunkWriter cw, slice<byte> p) {
    nint n = default;
    error err = default!;

    return cw.rws.writeChunk(p);
}

private static bool hasTrailers(this ptr<http2responseWriterState> _addr_rws) {
    ref http2responseWriterState rws = ref _addr_rws.val;

    return len(rws.trailers) > 0;
}

private static bool hasNonemptyTrailers(this ptr<http2responseWriterState> _addr_rws) {
    ref http2responseWriterState rws = ref _addr_rws.val;

    foreach (var (_, trailer) in rws.trailers) {
        {
            var (_, ok) = rws.handlerHeader[trailer];

            if (ok) {
                return true;
            }

        }
    }    return false;
}

// declareTrailer is called for each Trailer header when the
// response header is written. It notes that a header will need to be
// written in the trailers at the end of the response.
private static void declareTrailer(this ptr<http2responseWriterState> _addr_rws, @string k) {
    ref http2responseWriterState rws = ref _addr_rws.val;

    k = CanonicalHeaderKey(k);
    if (!httpguts.ValidTrailerHeader(k)) { 
        // Forbidden by RFC 7230, section 4.1.2.
        rws.conn.logf("ignoring invalid trailer %q", k);
        return ;
    }
    if (!http2strSliceContains(rws.trailers, k)) {
        rws.trailers = append(rws.trailers, k);
    }
}

// writeChunk writes chunks from the bufio.Writer. But because
// bufio.Writer may bypass its chunking, sometimes p may be
// arbitrarily large.
//
// writeChunk is also responsible (on the first chunk) for sending the
// HEADER response.
private static (nint, error) writeChunk(this ptr<http2responseWriterState> _addr_rws, slice<byte> p) {
    nint n = default;
    error err = default!;
    ref http2responseWriterState rws = ref _addr_rws.val;

    if (!rws.wroteHeader) {
        rws.writeHeader(200);
    }
    var isHeadResp = rws.req.Method == "HEAD";
    if (!rws.sentHeader) {
        rws.sentHeader = true;
        @string ctype = default;        @string clen = default;

        clen = rws.snapHeader.Get("Content-Length");

        if (clen != "") {
            rws.snapHeader.Del("Content-Length");
            {
                var (cl, err) = strconv.ParseUint(clen, 10, 63);

                if (err == null) {
                    rws.sentContentLen = int64(cl);
                }
                else
 {
                    clen = "";
                }

            }
        }
        if (clen == "" && rws.handlerDone && http2bodyAllowedForStatus(rws.status) && (len(p) > 0 || !isHeadResp)) {
            clen = strconv.Itoa(len(p));
        }
        var (_, hasContentType) = rws.snapHeader["Content-Type"]; 
        // If the Content-Encoding is non-blank, we shouldn't
        // sniff the body. See Issue golang.org/issue/31753.
        var ce = rws.snapHeader.Get("Content-Encoding");
        var hasCE = len(ce) > 0;
        if (!hasCE && !hasContentType && http2bodyAllowedForStatus(rws.status) && len(p) > 0) {
            ctype = DetectContentType(p);
        }
        @string date = default;
        {
            var (_, ok) = rws.snapHeader["Date"];

            if (!ok) { 
                // TODO(bradfitz): be faster here, like net/http? measure.
                date = time.Now().UTC().Format(TimeFormat);
            }

        }

        {
            var v__prev1 = v;

            foreach (var (_, __v) in rws.snapHeader["Trailer"]) {
                v = __v;
                http2foreachHeaderElement(v, rws.declareTrailer);
            } 

            // "Connection" headers aren't allowed in HTTP/2 (RFC 7540, 8.1.2.2),
            // but respect "Connection" == "close" to mean sending a GOAWAY and tearing
            // down the TCP connection when idle, like we do for HTTP/1.
            // TODO: remove more Connection-specific header fields here, in addition
            // to "Connection".

            v = v__prev1;
        }

        {
            (_, ok) = rws.snapHeader["Connection"];

            if (ok) {
                var v = rws.snapHeader.Get("Connection");
                delete(rws.snapHeader, "Connection");
                if (v == "close") {
                    rws.conn.startGracefulShutdown();
                }
            }

        }

        var endStream = (rws.handlerDone && !rws.hasTrailers() && len(p) == 0) || isHeadResp;
        err = rws.conn.writeHeaders(rws.stream, addr(new http2writeResHeaders(streamID:rws.stream.id,httpResCode:rws.status,h:rws.snapHeader,endStream:endStream,contentType:ctype,contentLength:clen,date:date,)));
        if (err != null) {
            rws.dirty = true;
            return (0, error.As(err)!);
        }
        if (endStream) {
            return (0, error.As(null!)!);
        }
    }
    if (isHeadResp) {
        return (len(p), error.As(null!)!);
    }
    if (len(p) == 0 && !rws.handlerDone) {
        return (0, error.As(null!)!);
    }
    if (rws.handlerDone) {
        rws.promoteUndeclaredTrailers();
    }
    var hasNonemptyTrailers = rws.hasNonemptyTrailers();
    endStream = rws.handlerDone && !hasNonemptyTrailers;
    if (len(p) > 0 || endStream) { 
        // only send a 0 byte DATA frame if we're ending the stream.
        {
            var err = rws.conn.writeDataFromHandler(rws.stream, p, endStream);

            if (err != null) {
                rws.dirty = true;
                return (0, error.As(err)!);
            }

        }
    }
    if (rws.handlerDone && hasNonemptyTrailers) {
        err = rws.conn.writeHeaders(rws.stream, addr(new http2writeResHeaders(streamID:rws.stream.id,h:rws.handlerHeader,trailers:rws.trailers,endStream:true,)));
        if (err != null) {
            rws.dirty = true;
        }
        return (len(p), error.As(err)!);
    }
    return (len(p), error.As(null!)!);
}

// TrailerPrefix is a magic prefix for ResponseWriter.Header map keys
// that, if present, signals that the map entry is actually for
// the response trailers, and not the response headers. The prefix
// is stripped after the ServeHTTP call finishes and the values are
// sent in the trailers.
//
// This mechanism is intended only for trailers that are not known
// prior to the headers being written. If the set of trailers is fixed
// or known before the header is written, the normal Go trailers mechanism
// is preferred:
//    https://golang.org/pkg/net/http/#ResponseWriter
//    https://golang.org/pkg/net/http/#example_ResponseWriter_trailers
private static readonly @string http2TrailerPrefix = "Trailer:";

// promoteUndeclaredTrailers permits http.Handlers to set trailers
// after the header has already been flushed. Because the Go
// ResponseWriter interface has no way to set Trailers (only the
// Header), and because we didn't want to expand the ResponseWriter
// interface, and because nobody used trailers, and because RFC 7230
// says you SHOULD (but not must) predeclare any trailers in the
// header, the official ResponseWriter rules said trailers in Go must
// be predeclared, and then we reuse the same ResponseWriter.Header()
// map to mean both Headers and Trailers. When it's time to write the
// Trailers, we pick out the fields of Headers that were declared as
// trailers. That worked for a while, until we found the first major
// user of Trailers in the wild: gRPC (using them only over http2),
// and gRPC libraries permit setting trailers mid-stream without
// predeclaring them. So: change of plans. We still permit the old
// way, but we also permit this hack: if a Header() key begins with
// "Trailer:", the suffix of that key is a Trailer. Because ':' is an
// invalid token byte anyway, there is no ambiguity. (And it's already
// filtered out) It's mildly hacky, but not terrible.
//
// This method runs after the Handler is done and promotes any Header
// fields to be trailers.


// promoteUndeclaredTrailers permits http.Handlers to set trailers
// after the header has already been flushed. Because the Go
// ResponseWriter interface has no way to set Trailers (only the
// Header), and because we didn't want to expand the ResponseWriter
// interface, and because nobody used trailers, and because RFC 7230
// says you SHOULD (but not must) predeclare any trailers in the
// header, the official ResponseWriter rules said trailers in Go must
// be predeclared, and then we reuse the same ResponseWriter.Header()
// map to mean both Headers and Trailers. When it's time to write the
// Trailers, we pick out the fields of Headers that were declared as
// trailers. That worked for a while, until we found the first major
// user of Trailers in the wild: gRPC (using them only over http2),
// and gRPC libraries permit setting trailers mid-stream without
// predeclaring them. So: change of plans. We still permit the old
// way, but we also permit this hack: if a Header() key begins with
// "Trailer:", the suffix of that key is a Trailer. Because ':' is an
// invalid token byte anyway, there is no ambiguity. (And it's already
// filtered out) It's mildly hacky, but not terrible.
//
// This method runs after the Handler is done and promotes any Header
// fields to be trailers.
private static void promoteUndeclaredTrailers(this ptr<http2responseWriterState> _addr_rws) {
    ref http2responseWriterState rws = ref _addr_rws.val;

    foreach (var (k, vv) in rws.handlerHeader) {
        if (!strings.HasPrefix(k, http2TrailerPrefix)) {
            continue;
        }
        var trailerKey = strings.TrimPrefix(k, http2TrailerPrefix);
        rws.declareTrailer(trailerKey);
        rws.handlerHeader[CanonicalHeaderKey(trailerKey)] = vv;
    }    if (len(rws.trailers) > 1) {
        ptr<http2sorter> sorter = http2sorterPool.Get()._<ptr<http2sorter>>();
        sorter.SortStrings(rws.trailers);
        http2sorterPool.Put(sorter);
    }
}

private static void Flush(this ptr<http2responseWriter> _addr_w) => func((_, panic, _) => {
    ref http2responseWriter w = ref _addr_w.val;

    var rws = w.rws;
    if (rws == null) {
        panic("Header called after Handler finished");
    }
    if (rws.bw.Buffered() > 0) {
        {
            var err = rws.bw.Flush();

            if (err != null) { 
                // Ignore the error. The frame writer already knows.
                return ;
            }

        }
    }
    else
 { 
        // The bufio.Writer won't call chunkWriter.Write
        // (writeChunk with zero bytes, so we have to do it
        // ourselves to force the HTTP response header and/or
        // final DATA frame (with END_STREAM) to be sent.
        rws.writeChunk(null);
    }
});

private static channel<bool> CloseNotify(this ptr<http2responseWriter> _addr_w) => func((_, panic, _) => {
    ref http2responseWriter w = ref _addr_w.val;

    var rws = w.rws;
    if (rws == null) {
        panic("CloseNotify called after Handler finished");
    }
    rws.closeNotifierMu.Lock();
    var ch = rws.closeNotifierCh;
    if (ch == null) {
        ch = make_channel<bool>(1);
        rws.closeNotifierCh = ch;
        var cw = rws.stream.cw;
        go_(() => () => {
            cw.Wait(); // wait for close
            ch.Send(true);
        }());
    }
    rws.closeNotifierMu.Unlock();
    return ch;
});

private static Header Header(this ptr<http2responseWriter> _addr_w) => func((_, panic, _) => {
    ref http2responseWriter w = ref _addr_w.val;

    var rws = w.rws;
    if (rws == null) {
        panic("Header called after Handler finished");
    }
    if (rws.handlerHeader == null) {
        rws.handlerHeader = make(Header);
    }
    return rws.handlerHeader;
});

// checkWriteHeaderCode is a copy of net/http's checkWriteHeaderCode.
private static void http2checkWriteHeaderCode(nint code) => func((_, panic, _) => { 
    // Issue 22880: require valid WriteHeader status codes.
    // For now we only enforce that it's three digits.
    // In the future we might block things over 599 (600 and above aren't defined
    // at http://httpwg.org/specs/rfc7231.html#status.codes)
    // and we might block under 200 (once we have more mature 1xx support).
    // But for now any three digits.
    //
    // We used to send "HTTP/1.1 000 0" on the wire in responses but there's
    // no equivalent bogus thing we can realistically send in HTTP/2,
    // so we'll consistently panic instead and help people find their bugs
    // early. (We can't return an error from WriteHeader even if we wanted to.)
    if (code < 100 || code > 999) {
        panic(fmt.Sprintf("invalid WriteHeader code %v", code));
    }
});

private static void WriteHeader(this ptr<http2responseWriter> _addr_w, nint code) => func((_, panic, _) => {
    ref http2responseWriter w = ref _addr_w.val;

    var rws = w.rws;
    if (rws == null) {
        panic("WriteHeader called after Handler finished");
    }
    rws.writeHeader(code);
});

private static void writeHeader(this ptr<http2responseWriterState> _addr_rws, nint code) {
    ref http2responseWriterState rws = ref _addr_rws.val;

    if (!rws.wroteHeader) {
        http2checkWriteHeaderCode(code);
        rws.wroteHeader = true;
        rws.status = code;
        if (len(rws.handlerHeader) > 0) {
            rws.snapHeader = http2cloneHeader(rws.handlerHeader);
        }
    }
}

private static Header http2cloneHeader(Header h) {
    var h2 = make(Header, len(h));
    foreach (var (k, vv) in h) {
        var vv2 = make_slice<@string>(len(vv));
        copy(vv2, vv);
        h2[k] = vv2;
    }    return h2;
}

// The Life Of A Write is like this:
//
// * Handler calls w.Write or w.WriteString ->
// * -> rws.bw (*bufio.Writer) ->
// * (Handler might call Flush)
// * -> chunkWriter{rws}
// * -> responseWriterState.writeChunk(p []byte)
// * -> responseWriterState.writeChunk (most of the magic; see comment there)
private static (nint, error) Write(this ptr<http2responseWriter> _addr_w, slice<byte> p) {
    nint n = default;
    error err = default!;
    ref http2responseWriter w = ref _addr_w.val;

    return w.write(len(p), p, "");
}

private static (nint, error) WriteString(this ptr<http2responseWriter> _addr_w, @string s) {
    nint n = default;
    error err = default!;
    ref http2responseWriter w = ref _addr_w.val;

    return w.write(len(s), null, s);
}

// either dataB or dataS is non-zero.
private static (nint, error) write(this ptr<http2responseWriter> _addr_w, nint lenData, slice<byte> dataB, @string dataS) => func((_, panic, _) => {
    nint n = default;
    error err = default!;
    ref http2responseWriter w = ref _addr_w.val;

    var rws = w.rws;
    if (rws == null) {
        panic("Write called after Handler finished");
    }
    if (!rws.wroteHeader) {
        w.WriteHeader(200);
    }
    if (!http2bodyAllowedForStatus(rws.status)) {
        return (0, error.As(ErrBodyNotAllowed)!);
    }
    rws.wroteBytes += int64(len(dataB)) + int64(len(dataS)); // only one can be set
    if (rws.sentContentLen != 0 && rws.wroteBytes > rws.sentContentLen) { 
        // TODO: send a RST_STREAM
        return (0, error.As(errors.New("http2: handler wrote more than declared Content-Length"))!);
    }
    if (dataB != null) {
        return rws.bw.Write(dataB);
    }
    else
 {
        return rws.bw.WriteString(dataS);
    }
});

private static void handlerDone(this ptr<http2responseWriter> _addr_w) {
    ref http2responseWriter w = ref _addr_w.val;

    var rws = w.rws;
    var dirty = rws.dirty;
    rws.handlerDone = true;
    w.Flush();
    w.rws = null;
    if (!dirty) { 
        // Only recycle the pool if all prior Write calls to
        // the serverConn goroutine completed successfully. If
        // they returned earlier due to resets from the peer
        // there might still be write goroutines outstanding
        // from the serverConn referencing the rws memory. See
        // issue 20704.
        http2responseWriterStatePool.Put(rws);
    }
}

// Push errors.
private static var http2ErrRecursivePush = errors.New("http2: recursive push not allowed");private static var http2ErrPushLimitReached = errors.New("http2: push would exceed peer's SETTINGS_MAX_CONCURRENT_STREAMS");

private static Pusher _ = (http2responseWriter.val)(null);

private static error Push(this ptr<http2responseWriter> _addr_w, @string target, ptr<PushOptions> _addr_opts) {
    ref http2responseWriter w = ref _addr_w.val;
    ref PushOptions opts = ref _addr_opts.val;

    var st = w.rws.stream;
    var sc = st.sc;
    sc.serveG.checkNotOn(); 

    // No recursive pushes: "PUSH_PROMISE frames MUST only be sent on a peer-initiated stream."
    // http://tools.ietf.org/html/rfc7540#section-6.6
    if (st.isPushed()) {
        return error.As(http2ErrRecursivePush)!;
    }
    if (opts == null) {
        opts = @new<PushOptions>();
    }
    if (opts.Method == "") {
        opts.Method = "GET";
    }
    if (opts.Header == null) {
        opts.Header = new Header();
    }
    @string wantScheme = "http";
    if (w.rws.req.TLS != null) {
        wantScheme = "https";
    }
    var (u, err) = url.Parse(target);
    if (err != null) {
        return error.As(err)!;
    }
    if (u.Scheme == "") {
        if (!strings.HasPrefix(target, "/")) {
            return error.As(fmt.Errorf("target must be an absolute URL or an absolute path: %q", target))!;
        }
        u.Scheme = wantScheme;
        u.Host = w.rws.req.Host;
    }
    else
 {
        if (u.Scheme != wantScheme) {
            return error.As(fmt.Errorf("cannot push URL with scheme %q from request with scheme %q", u.Scheme, wantScheme))!;
        }
        if (u.Host == "") {
            return error.As(errors.New("URL must have a host"))!;
        }
    }
    foreach (var (k) in opts.Header) {
        if (strings.HasPrefix(k, ":")) {
            return error.As(fmt.Errorf("promised request headers cannot include pseudo header %q", k))!;
        }
        if (http2asciiEqualFold(k, "content-length") || http2asciiEqualFold(k, "content-encoding") || http2asciiEqualFold(k, "trailer") || http2asciiEqualFold(k, "te") || http2asciiEqualFold(k, "expect") || http2asciiEqualFold(k, "host")) {
            return error.As(fmt.Errorf("promised request headers cannot include %q", k))!;
        }
    }    {
        var err__prev1 = err;

        var err = http2checkValidHTTP2RequestHeaders(opts.Header);

        if (err != null) {
            return error.As(err)!;
        }
        err = err__prev1;

    } 

    // The RFC effectively limits promised requests to GET and HEAD:
    // "Promised requests MUST be cacheable [GET, HEAD, or POST], and MUST be safe [GET or HEAD]"
    // http://tools.ietf.org/html/rfc7540#section-8.2
    if (opts.Method != "GET" && opts.Method != "HEAD") {
        return error.As(fmt.Errorf("method %q must be GET or HEAD", opts.Method))!;
    }
    ptr<http2startPushRequest> msg = addr(new http2startPushRequest(parent:st,method:opts.Method,url:u,header:http2cloneHeader(opts.Header),done:http2errChanPool.Get().(chanerror),));

    return error.As(http2errClientDisconnected)!;
    return error.As(http2errStreamClosed)!;
    return error.As(http2errClientDisconnected)!;
    return error.As(http2errStreamClosed)!;
    http2errChanPool.Put(msg.done);
    return error.As(err)!;
}

private partial struct http2startPushRequest {
    public ptr<http2stream> parent;
    public @string method;
    public ptr<url.URL> url;
    public Header header;
    public channel<error> done;
}

private static void startPush(this ptr<http2serverConn> _addr_sc, ptr<http2startPushRequest> _addr_msg) => func((_, panic, _) => {
    ref http2serverConn sc = ref _addr_sc.val;
    ref http2startPushRequest msg = ref _addr_msg.val;

    sc.serveG.check(); 

    // http://tools.ietf.org/html/rfc7540#section-6.6.
    // PUSH_PROMISE frames MUST only be sent on a peer-initiated stream that
    // is in either the "open" or "half-closed (remote)" state.
    if (msg.parent.state != http2stateOpen && msg.parent.state != http2stateHalfClosedRemote) { 
        // responseWriter.Push checks that the stream is peer-initiated.
        msg.done.Send(http2errStreamClosed);
        return ;
    }
    if (!sc.pushEnabled) {
        msg.done.Send(ErrNotSupported);
        return ;
    }
    Func<(uint, error)> allocatePromisedID = () => {
        sc.serveG.check(); 

        // Check this again, just in case. Technically, we might have received
        // an updated SETTINGS by the time we got around to writing this frame.
        if (!sc.pushEnabled) {
            return (0, ErrNotSupported);
        }
        if (sc.curPushedStreams + 1 > sc.clientMaxStreams) {
            return (0, http2ErrPushLimitReached);
        }
        if (sc.maxPushPromiseID + 2 >= 1 << 31) {
            sc.startGracefulShutdownInternal();
            return (0, http2ErrPushLimitReached);
        }
        sc.maxPushPromiseID += 2;
        var promisedID = sc.maxPushPromiseID; 

        // http://tools.ietf.org/html/rfc7540#section-8.2.
        // Strictly speaking, the new stream should start in "reserved (local)", then
        // transition to "half closed (remote)" after sending the initial HEADERS, but
        // we start in "half closed (remote)" for simplicity.
        // See further comments at the definition of stateHalfClosedRemote.
        var promised = sc.newStream(promisedID, msg.parent.id, http2stateHalfClosedRemote);
        var (rw, req, err) = sc.newWriterAndRequestNoBody(promised, new http2requestParam(method:msg.method,scheme:msg.url.Scheme,authority:msg.url.Host,path:msg.url.RequestURI(),header:http2cloneHeader(msg.header),));
        if (err != null) { 
            // Should not happen, since we've already validated msg.url.
            panic(fmt.Sprintf("newWriterAndRequestNoBody(%+v): %v", msg.url, err));
        }
        go_(() => sc.runHandler(rw, req, sc.handler.ServeHTTP));
        return (promisedID, null);
    };

    sc.writeFrame(new http2FrameWriteRequest(write:&http2writePushPromise{streamID:msg.parent.id,method:msg.method,url:msg.url,h:msg.header,allocatePromisedID:allocatePromisedID,},stream:msg.parent,done:msg.done,));
});

// foreachHeaderElement splits v according to the "#rule" construction
// in RFC 7230 section 7 and calls fn for each non-empty element.
private static void http2foreachHeaderElement(@string v, Action<@string> fn) {
    v = textproto.TrimString(v);
    if (v == "") {
        return ;
    }
    if (!strings.Contains(v, ",")) {
        fn(v);
        return ;
    }
    foreach (var (_, f) in strings.Split(v, ",")) {
        f = textproto.TrimString(f);

        if (f != "") {
            fn(f);
        }
    }
}

// From http://httpwg.org/specs/rfc7540.html#rfc.section.8.1.2.2
private static @string http2connHeaders = new slice<@string>(new @string[] { "Connection", "Keep-Alive", "Proxy-Connection", "Transfer-Encoding", "Upgrade" });

// checkValidHTTP2RequestHeaders checks whether h is a valid HTTP/2 request,
// per RFC 7540 Section 8.1.2.2.
// The returned error is reported to users.
private static error http2checkValidHTTP2RequestHeaders(Header h) {
    foreach (var (_, k) in http2connHeaders) {
        {
            var (_, ok) = h[k];

            if (ok) {
                return error.As(fmt.Errorf("request header %q is not valid in HTTP/2", k))!;
            }

        }
    }    var te = h["Te"];
    if (len(te) > 0 && (len(te) > 1 || (te[0] != "trailers" && te[0] != ""))) {
        return error.As(errors.New("request header \"TE\" may only be \"trailers\" in HTTP/2"))!;
    }
    return error.As(null!)!;
}

private static HandlerFunc http2new400Handler(error err) {
    return (w, r) => {
        Error(w, err.Error(), StatusBadRequest);
    };
}

// h1ServerKeepAlivesDisabled reports whether hs has its keep-alives
// disabled. See comments on h1ServerShutdownChan above for why
// the code is written this way.
private static bool http2h1ServerKeepAlivesDisabled(ptr<Server> _addr_hs) {
    ref Server hs = ref _addr_hs.val;

    var x = hs;
    public partial interface I {
        bool doKeepAlives();
    }
    {
        I (hs, ok) = I.As(x._<I>())!;

        if (ok) {
            return !hs.doKeepAlives();
        }
    }
    return false;
}

 
// transportDefaultConnFlow is how many connection-level flow control
// tokens we give the server at start-up, past the default 64k.
private static readonly nint http2transportDefaultConnFlow = 1 << 30; 

// transportDefaultStreamFlow is how many stream-level flow
// control tokens we announce to the peer, and how many bytes
// we buffer per stream.
private static readonly nint http2transportDefaultStreamFlow = 4 << 20; 

// transportDefaultStreamMinRefresh is the minimum number of bytes we'll send
// a stream-level WINDOW_UPDATE for at a time.
private static readonly nint http2transportDefaultStreamMinRefresh = 4 << 10;

private static readonly @string http2defaultUserAgent = "Go-http-client/2.0"; 

// initialMaxConcurrentStreams is a connections maxConcurrentStreams until
// it's received servers initial SETTINGS frame, which corresponds with the
// spec's minimum recommended value.
private static readonly nint http2initialMaxConcurrentStreams = 100; 

// defaultMaxConcurrentStreams is a connections default maxConcurrentStreams
// if the server doesn't include one in its initial SETTINGS frame.
private static readonly nint http2defaultMaxConcurrentStreams = 1000;

// Transport is an HTTP/2 Transport.
//
// A Transport internally caches connections to servers. It is safe
// for concurrent use by multiple goroutines.
private partial struct http2Transport {
    public Func<@string, @string, ptr<tls.Config>, (net.Conn, error)> DialTLS; // TLSClientConfig specifies the TLS configuration to use with
// tls.Client. If nil, the default configuration is used.
    public ptr<tls.Config> TLSClientConfig; // ConnPool optionally specifies an alternate connection pool to use.
// If nil, the default is used.
    public http2ClientConnPool ConnPool; // DisableCompression, if true, prevents the Transport from
// requesting compression with an "Accept-Encoding: gzip"
// request header when the Request contains no existing
// Accept-Encoding value. If the Transport requests gzip on
// its own and gets a gzipped response, it's transparently
// decoded in the Response.Body. However, if the user
// explicitly requested gzip it is not automatically
// uncompressed.
    public bool DisableCompression; // AllowHTTP, if true, permits HTTP/2 requests using the insecure,
// plain-text "http" scheme. Note that this does not enable h2c support.
    public bool AllowHTTP; // MaxHeaderListSize is the http2 SETTINGS_MAX_HEADER_LIST_SIZE to
// send in the initial settings frame. It is how many bytes
// of response headers are allowed. Unlike the http2 spec, zero here
// means to use a default limit (currently 10MB). If you actually
// want to advertise an unlimited value to the peer, Transport
// interprets the highest possible value here (0xffffffff or 1<<32-1)
// to mean no limit.
    public uint MaxHeaderListSize; // StrictMaxConcurrentStreams controls whether the server's
// SETTINGS_MAX_CONCURRENT_STREAMS should be respected
// globally. If false, new TCP connections are created to the
// server as needed to keep each under the per-connection
// SETTINGS_MAX_CONCURRENT_STREAMS limit. If true, the
// server's SETTINGS_MAX_CONCURRENT_STREAMS is interpreted as
// a global limit and callers of RoundTrip block when needed,
// waiting for their turn.
    public bool StrictMaxConcurrentStreams; // ReadIdleTimeout is the timeout after which a health check using ping
// frame will be carried out if no frame is received on the connection.
// Note that a ping response will is considered a received frame, so if
// there is no other traffic on the connection, the health check will
// be performed every ReadIdleTimeout interval.
// If zero, no health check is performed.
    public time.Duration ReadIdleTimeout; // PingTimeout is the timeout after which the connection will be closed
// if a response to Ping is not received.
// Defaults to 15s.
    public time.Duration PingTimeout; // t1, if non-nil, is the standard library Transport using
// this transport. Its settings are used (but not its
// RoundTrip method, etc).
    public ptr<Transport> t1;
    public sync.Once connPoolOnce;
    public http2ClientConnPool connPoolOrDef; // non-nil version of ConnPool
}

private static uint maxHeaderListSize(this ptr<http2Transport> _addr_t) {
    ref http2Transport t = ref _addr_t.val;

    if (t.MaxHeaderListSize == 0) {
        return 10 << 20;
    }
    if (t.MaxHeaderListSize == 0xffffffff) {
        return 0;
    }
    return t.MaxHeaderListSize;
}

private static bool disableCompression(this ptr<http2Transport> _addr_t) {
    ref http2Transport t = ref _addr_t.val;

    return t.DisableCompression || (t.t1 != null && t.t1.DisableCompression);
}

private static time.Duration pingTimeout(this ptr<http2Transport> _addr_t) {
    ref http2Transport t = ref _addr_t.val;

    if (t.PingTimeout == 0) {
        return 15 * time.Second;
    }
    return t.PingTimeout;
}

// ConfigureTransport configures a net/http HTTP/1 Transport to use HTTP/2.
// It returns an error if t1 has already been HTTP/2-enabled.
//
// Use ConfigureTransports instead to configure the HTTP/2 Transport.
private static error http2ConfigureTransport(ptr<Transport> _addr_t1) {
    ref Transport t1 = ref _addr_t1.val;

    var (_, err) = http2ConfigureTransports(_addr_t1);
    return error.As(err)!;
}

// ConfigureTransports configures a net/http HTTP/1 Transport to use HTTP/2.
// It returns a new HTTP/2 Transport for further configuration.
// It returns an error if t1 has already been HTTP/2-enabled.
private static (ptr<http2Transport>, error) http2ConfigureTransports(ptr<Transport> _addr_t1) {
    ptr<http2Transport> _p0 = default!;
    error _p0 = default!;
    ref Transport t1 = ref _addr_t1.val;

    return _addr_http2configureTransports(_addr_t1)!;
}

private static (ptr<http2Transport>, error) http2configureTransports(ptr<Transport> _addr_t1) {
    ptr<http2Transport> _p0 = default!;
    error _p0 = default!;
    ref Transport t1 = ref _addr_t1.val;

    ptr<http2clientConnPool> connPool = @new<http2clientConnPool>();
    ptr<http2Transport> t2 = addr(new http2Transport(ConnPool:http2noDialClientConnPool{connPool},t1:t1,));
    connPool.t = t2;
    {
        var err = http2registerHTTPSProtocol(_addr_t1, new http2noDialH2RoundTripper(t2));

        if (err != null) {
            return (_addr_null!, error.As(err)!);
        }
    }
    if (t1.TLSClientConfig == null) {
        t1.TLSClientConfig = @new<tls.Config>();
    }
    if (!http2strSliceContains(t1.TLSClientConfig.NextProtos, "h2")) {
        t1.TLSClientConfig.NextProtos = append(new slice<@string>(new @string[] { "h2" }), t1.TLSClientConfig.NextProtos);
    }
    if (!http2strSliceContains(t1.TLSClientConfig.NextProtos, "http/1.1")) {
        t1.TLSClientConfig.NextProtos = append(t1.TLSClientConfig.NextProtos, "http/1.1");
    }
    Func<@string, ptr<tls.Conn>, RoundTripper> upgradeFn = (authority, c) => {
        var addr = http2authorityAddr("https", authority);
        {
            var (used, err) = connPool.addConnIfNeeded(addr, t2, c);

            if (err != null) {
                go_(() => c.Close());
                return _addr_new http2erringRoundTripper(err)!;
            }
            else if (!used) { 
                // Turns out we don't need this c.
                // For example, two goroutines made requests to the same host
                // at the same time, both kicking off TCP dials. (since protocol
                // was unknown)
                go_(() => c.Close());
            }

        }
        return _addr_t2!;
    };
    {
        var m = t1.TLSNextProto;

        if (len(m) == 0) {
            t1.TLSNextProto = /* TODO: Fix this in ScannerBase_Expression::ExitCompositeLit */ new map<@string, Func<@string, ptr<tls.Conn>, RoundTripper>>{"h2":upgradeFn,};
        }
        else
 {
            m["h2"] = upgradeFn;
        }
    }
    return (_addr_t2!, error.As(null!)!);
}

private static http2ClientConnPool connPool(this ptr<http2Transport> _addr_t) {
    ref http2Transport t = ref _addr_t.val;

    t.connPoolOnce.Do(t.initConnPool);
    return t.connPoolOrDef;
}

private static void initConnPool(this ptr<http2Transport> _addr_t) {
    ref http2Transport t = ref _addr_t.val;

    if (t.ConnPool != null) {
        t.connPoolOrDef = t.ConnPool;
    }
    else
 {
        t.connPoolOrDef = addr(new http2clientConnPool(t:t));
    }
}

// ClientConn is the state of a single HTTP/2 client connection to an
// HTTP/2 server.
private partial struct http2ClientConn {
    public ptr<http2Transport> t;
    public net.Conn tconn; // usually *tls.Conn, except specialized impls
    public ptr<tls.ConnectionState> tlsState; // nil only for specialized impls
    public uint reused; // whether conn is being reused; atomic
    public bool singleUse; // whether being used for a single http.Request
    public bool getConnCalled; // used by clientConnPool

// readLoop goroutine fields:
    public channel<object> readerDone; // closed on error
    public error readerErr; // set before readerDone is closed

    public time.Duration idleTimeout; // or 0 for never
    public ptr<time.Timer> idleTimer;
    public sync.Mutex mu; // guards following
    public ptr<sync.Cond> cond; // hold mu; broadcast on flow/closed changes
    public http2flow flow; // our conn-level flow control quota (cs.flow is per stream)
    public http2flow inflow; // peer's conn-level flow control
    public bool doNotReuse; // whether conn is marked to not be reused for any future requests
    public bool closing;
    public bool closed;
    public bool seenSettings; // true if we've seen a settings frame, false otherwise
    public bool wantSettingsAck; // we sent a SETTINGS frame and haven't heard back
    public ptr<http2GoAwayFrame> goAway; // if non-nil, the GoAwayFrame we received
    public @string goAwayDebug; // goAway frame's debug data, retained as a string
    public map<uint, ptr<http2clientStream>> streams; // client-initiated
    public nint streamsReserved; // incr by ReserveNewRequest; decr on RoundTrip
    public uint nextStreamID;
    public nint pendingRequests; // requests blocked and waiting to be sent because len(streams) == maxConcurrentStreams
    public map<array<byte>, channel<object>> pings; // in flight ping data to notification channel
    public ptr<bufio.Reader> br;
    public time.Time lastActive;
    public time.Time lastIdle; // time last idle
// Settings from peer: (also guarded by wmu)
    public uint maxFrameSize;
    public uint maxConcurrentStreams;
    public ulong peerMaxHeaderListSize;
    public uint initialWindowSize; // reqHeaderMu is a 1-element semaphore channel controlling access to sending new requests.
// Write to reqHeaderMu to lock it, read from it to unlock.
// Lock reqmu BEFORE mu or wmu.
    public channel<object> reqHeaderMu; // wmu is held while writing.
// Acquire BEFORE mu when holding both, to avoid blocking mu on network writes.
// Only acquire both at the same time when changing peer settings.
    public sync.Mutex wmu;
    public ptr<bufio.Writer> bw;
    public ptr<http2Framer> fr;
    public error werr; // first write error that has occurred
    public bytes.Buffer hbuf; // HPACK encoder writes into this
    public ptr<hpack.Encoder> henc;
}

// clientStream is the state for a single HTTP/2 stream. One of these
// is created for each Transport.RoundTrip call.
private partial struct http2clientStream {
    public ptr<http2ClientConn> cc; // Fields of Request that we may access even after the response body is closed.
    public context.Context ctx;
    public channel<object> reqCancel;
    public ptr<httptrace.ClientTrace> trace; // or nil
    public uint ID;
    public http2pipe bufPipe; // buffered pipe with the flow-controlled response payload
    public bool requestedGzip;
    public bool isHead;
    public sync.Once abortOnce;
    public channel<object> abort; // closed to signal stream should end immediately
    public error abortErr; // set if abort is closed

    public channel<object> peerClosed; // closed when the peer sends an END_STREAM flag
    public channel<object> donec; // closed after the stream is in the closed state
    public channel<object> on100; // buffered; written to if a 100 is received

    public channel<object> respHeaderRecv; // closed when headers are received
    public ptr<Response> res; // set if respHeaderRecv is closed

    public http2flow flow; // guarded by cc.mu
    public http2flow inflow; // guarded by cc.mu
    public long bytesRemain; // -1 means unknown; owned by transportResponseBody.Read
    public error readErr; // sticky read error; owned by transportResponseBody.Read

    public io.ReadCloser reqBody;
    public long reqBodyContentLength; // -1 means unknown
    public bool reqBodyClosed; // body has been closed; guarded by cc.mu

// owned by writeRequest:
    public bool sentEndStream; // sent an END_STREAM flag to the peer
    public bool sentHeaders; // owned by clientConnReadLoop:
    public bool firstByte; // got the first response byte
    public bool pastHeaders; // got first MetaHeadersFrame (actual headers)
    public bool pastTrailers; // got optional second MetaHeadersFrame (trailers)
    public byte num1xx; // number of 1xx responses seen
    public bool readClosed; // peer sent an END_STREAM flag
    public bool readAborted; // read loop reset the stream

    public Header trailer; // accumulated trailers
    public ptr<Header> resTrailer; // client's Response.Trailer
}

private static Func<nint, textproto.MIMEHeader, error> http2got1xxFuncForTests = default;

// get1xxTraceFunc returns the value of request's httptrace.ClientTrace.Got1xxResponse func,
// if any. It returns nil if not set or if the Go version is too old.
private static Func<nint, textproto.MIMEHeader, error> get1xxTraceFunc(this ptr<http2clientStream> _addr_cs) {
    ref http2clientStream cs = ref _addr_cs.val;

    {
        var fn = http2got1xxFuncForTests;

        if (fn != null) {
            return fn;
        }
    }
    return http2traceGot1xxResponseFunc(_addr_cs.trace);
}

private static void abortStream(this ptr<http2clientStream> _addr_cs, error err) => func((defer, _, _) => {
    ref http2clientStream cs = ref _addr_cs.val;

    cs.cc.mu.Lock();
    defer(cs.cc.mu.Unlock());
    cs.abortStreamLocked(err);
});

private static void abortStreamLocked(this ptr<http2clientStream> _addr_cs, error err) {
    ref http2clientStream cs = ref _addr_cs.val;

    cs.abortOnce.Do(() => {
        cs.abortErr = err;
        close(cs.abort);
    });
    if (cs.reqBody != null && !cs.reqBodyClosed) {
        cs.reqBody.Close();
        cs.reqBodyClosed = true;
    }
    if (cs.cc.cond != null) { 
        // Wake up writeRequestBody if it is waiting on flow control.
        cs.cc.cond.Broadcast();
    }
}

private static void abortRequestBodyWrite(this ptr<http2clientStream> _addr_cs) => func((defer, _, _) => {
    ref http2clientStream cs = ref _addr_cs.val;

    var cc = cs.cc;
    cc.mu.Lock();
    defer(cc.mu.Unlock());
    if (cs.reqBody != null && !cs.reqBodyClosed) {
        cs.reqBody.Close();
        cs.reqBodyClosed = true;
        cc.cond.Broadcast();
    }
});

private partial struct http2stickyErrWriter {
    public io.Writer w;
    public ptr<error> err;
}

private static (nint, error) Write(this http2stickyErrWriter sew, slice<byte> p) {
    nint n = default;
    error err = default!;

    if (sew.err != null.val) {
        return (0, error.As(sew.err.val)!);
    }
    n, err = sew.w.Write(p);
    sew.err.val = err;
    return ;
}

// noCachedConnError is the concrete type of ErrNoCachedConn, which
// needs to be detected by net/http regardless of whether it's its
// bundled version (in h2_bundle.go with a rewritten type name) or
// from a user's x/net/http2. As such, as it has a unique method name
// (IsHTTP2NoCachedConnError) that net/http sniffs for via func
// isNoCachedConnError.
private partial struct http2noCachedConnError {
}

private static void IsHTTP2NoCachedConnError(this http2noCachedConnError _p0) {
}

private static @string Error(this http2noCachedConnError _p0) {
    return "http2: no cached connection was available";
}

// isNoCachedConnError reports whether err is of type noCachedConnError
// or its equivalent renamed type in net/http2's h2_bundle.go. Both types
// may coexist in the same running program.
private static bool http2isNoCachedConnError(error err) {
    return ok;
}

private static error http2ErrNoCachedConn = error.As(new http2noCachedConnError())!;

// RoundTripOpt are options for the Transport.RoundTripOpt method.
private partial struct http2RoundTripOpt {
    public bool OnlyCachedConn;
}

private static (ptr<Response>, error) RoundTrip(this ptr<http2Transport> _addr_t, ptr<Request> _addr_req) {
    ptr<Response> _p0 = default!;
    error _p0 = default!;
    ref http2Transport t = ref _addr_t.val;
    ref Request req = ref _addr_req.val;

    return _addr_t.RoundTripOpt(req, new http2RoundTripOpt())!;
}

// authorityAddr returns a given authority (a host/IP, or host:port / ip:port)
// and returns a host:port. The port 443 is added if needed.
private static @string http2authorityAddr(@string scheme, @string authority) {
    @string addr = default;

    var (host, port, err) = net.SplitHostPort(authority);
    if (err != null) { // authority didn't have a port
        port = "443";
        if (scheme == "http") {
            port = "80";
        }
        host = authority;
    }
    {
        var (a, err) = idna.ToASCII(host);

        if (err == null) {
            host = a;
        }
    } 
    // IPv6 address literal, without a port:
    if (strings.HasPrefix(host, "[") && strings.HasSuffix(host, "]")) {
        return host + ":" + port;
    }
    return net.JoinHostPort(host, port);
}

// RoundTripOpt is like RoundTrip, but takes options.
private static (ptr<Response>, error) RoundTripOpt(this ptr<http2Transport> _addr_t, ptr<Request> _addr_req, http2RoundTripOpt opt) {
    ptr<Response> _p0 = default!;
    error _p0 = default!;
    ref http2Transport t = ref _addr_t.val;
    ref Request req = ref _addr_req.val;

    if (!(req.URL.Scheme == "https" || (req.URL.Scheme == "http" && t.AllowHTTP))) {
        return (_addr_null!, error.As(errors.New("http2: unsupported scheme"))!);
    }
    var addr = http2authorityAddr(req.URL.Scheme, req.URL.Host);
    for (nint retry = 0; ; retry++) {
        var (cc, err) = t.connPool().GetClientConn(req, addr);
        if (err != null) {
            t.vlogf("http2: Transport failed to get client conn for %s: %v", addr, err);
            return (_addr_null!, error.As(err)!);
        }
        var reused = !atomic.CompareAndSwapUint32(_addr_cc.reused, 0, 1);
        http2traceGotConn(_addr_req, _addr_cc, reused);
        var (res, err) = cc.RoundTrip(req);
        if (err != null && retry <= 6) {
            req, err = http2shouldRetryRequest(_addr_req, err);

            if (err == null) { 
                // After the first retry, do exponential backoff with 10% jitter.
                if (retry == 0) {
                    continue;
                }
                var backoff = float64(uint(1) << (int)((uint(retry) - 1)));
                backoff += backoff * (0.1F * mathrand.Float64());
                continue;
                err = req.Context().Err();
            }
        }
        if (err != null) {
            t.vlogf("RoundTrip failure: %v", err);
            return (_addr_null!, error.As(err)!);
        }
        return (_addr_res!, error.As(null!)!);
    }
}

// CloseIdleConnections closes any connections which were previously
// connected from previous requests but are now sitting idle.
// It does not interrupt any connections currently in use.
private static void CloseIdleConnections(this ptr<http2Transport> _addr_t) {
    ref http2Transport t = ref _addr_t.val;

    {
        http2clientConnPoolIdleCloser (cp, ok) = http2clientConnPoolIdleCloser.As(t.connPool()._<http2clientConnPoolIdleCloser>())!;

        if (ok) {
            cp.closeIdleConnections();
        }
    }
}

private static var http2errClientConnClosed = errors.New("http2: client conn is closed");private static var http2errClientConnUnusable = errors.New("http2: client conn not usable");private static var http2errClientConnGotGoAway = errors.New("http2: Transport received Server's graceful shutdown GOAWAY");

// shouldRetryRequest is called by RoundTrip when a request fails to get
// response headers. It is always called with a non-nil error.
// It returns either a request to retry (either the same request, or a
// modified clone), or an error if the request can't be replayed.
private static (ptr<Request>, error) http2shouldRetryRequest(ptr<Request> _addr_req, error err) {
    ptr<Request> _p0 = default!;
    error _p0 = default!;
    ref Request req = ref _addr_req.val;

    if (!http2canRetryError(err)) {
        return (_addr_null!, error.As(err)!);
    }
    if (req.Body == null || req.Body == NoBody) {
        return (_addr_req!, error.As(null!)!);
    }
    if (req.GetBody != null) {
        var (body, err) = req.GetBody();
        if (err != null) {
            return (_addr_null!, error.As(err)!);
        }
        ref Request newReq = ref heap(req, out ptr<Request> _addr_newReq);
        newReq.Body = body;
        return (_addr__addr_newReq!, error.As(null!)!);
    }
    if (err == http2errClientConnUnusable) {
        return (_addr_req!, error.As(null!)!);
    }
    return (_addr_null!, error.As(fmt.Errorf("http2: Transport: cannot retry err [%v] after Request.Body was written; define Request.GetBody to avoid this error", err))!);
}

private static bool http2canRetryError(error err) {
    if (err == http2errClientConnUnusable || err == http2errClientConnGotGoAway) {
        return true;
    }
    {
        http2StreamError (se, ok) = err._<http2StreamError>();

        if (ok) {
            if (se.Code == http2ErrCodeProtocol && se.Cause == http2errFromPeer) { 
                // See golang/go#47635, golang/go#42777
                return true;
            }
            return se.Code == http2ErrCodeRefusedStream;
        }
    }
    return false;
}

private static (ptr<http2ClientConn>, error) dialClientConn(this ptr<http2Transport> _addr_t, context.Context ctx, @string addr, bool singleUse) {
    ptr<http2ClientConn> _p0 = default!;
    error _p0 = default!;
    ref http2Transport t = ref _addr_t.val;

    var (host, _, err) = net.SplitHostPort(addr);
    if (err != null) {
        return (_addr_null!, error.As(err)!);
    }
    var (tconn, err) = t.dialTLS(ctx)("tcp", addr, t.newTLSConfig(host));
    if (err != null) {
        return (_addr_null!, error.As(err)!);
    }
    return _addr_t.newClientConn(tconn, singleUse)!;
}

private static ptr<tls.Config> newTLSConfig(this ptr<http2Transport> _addr_t, @string host) {
    ref http2Transport t = ref _addr_t.val;

    ptr<tls.Config> cfg = @new<tls.Config>();
    if (t.TLSClientConfig != null) {
        cfg.val = t.TLSClientConfig.Clone().val;
    }
    if (!http2strSliceContains(cfg.NextProtos, http2NextProtoTLS)) {
        cfg.NextProtos = append(new slice<@string>(new @string[] { http2NextProtoTLS }), cfg.NextProtos);
    }
    if (cfg.ServerName == "") {
        cfg.ServerName = host;
    }
    return _addr_cfg!;
}

private static Func<@string, @string, ptr<tls.Config>, (net.Conn, error)> dialTLS(this ptr<http2Transport> _addr_t, context.Context ctx) {
    ref http2Transport t = ref _addr_t.val;

    if (t.DialTLS != null) {
        return t.DialTLS;
    }
    return (network, addr, cfg) => {
        var (tlsCn, err) = t.dialTLSWithContext(ctx, network, addr, cfg);
        if (err != null) {
            return (null, err);
        }
        var state = tlsCn.ConnectionState();
        {
            var p = state.NegotiatedProtocol;

            if (p != http2NextProtoTLS) {
                return (null, fmt.Errorf("http2: unexpected ALPN protocol %q; want %q", p, http2NextProtoTLS));
            }

        }
        if (!state.NegotiatedProtocolIsMutual) {
            return (null, errors.New("http2: could not negotiate protocol mutually"));
        }
        return (tlsCn, null);
    };
}

// disableKeepAlives reports whether connections should be closed as
// soon as possible after handling the first request.
private static bool disableKeepAlives(this ptr<http2Transport> _addr_t) {
    ref http2Transport t = ref _addr_t.val;

    return t.t1 != null && t.t1.DisableKeepAlives;
}

private static time.Duration expectContinueTimeout(this ptr<http2Transport> _addr_t) {
    ref http2Transport t = ref _addr_t.val;

    if (t.t1 == null) {
        return 0;
    }
    return t.t1.ExpectContinueTimeout;
}

private static (ptr<http2ClientConn>, error) NewClientConn(this ptr<http2Transport> _addr_t, net.Conn c) {
    ptr<http2ClientConn> _p0 = default!;
    error _p0 = default!;
    ref http2Transport t = ref _addr_t.val;

    return _addr_t.newClientConn(c, t.disableKeepAlives())!;
}

private static (ptr<http2ClientConn>, error) newClientConn(this ptr<http2Transport> _addr_t, net.Conn c, bool singleUse) {
    ptr<http2ClientConn> _p0 = default!;
    error _p0 = default!;
    ref http2Transport t = ref _addr_t.val;

    ptr<http2ClientConn> cc = addr(new http2ClientConn(t:t,tconn:c,readerDone:make(chanstruct{}),nextStreamID:1,maxFrameSize:16<<10,initialWindowSize:65535,maxConcurrentStreams:http2initialMaxConcurrentStreams,peerMaxHeaderListSize:0xffffffffffffffff,streams:make(map[uint32]*http2clientStream),singleUse:singleUse,wantSettingsAck:true,pings:make(map[[8]byte]chanstruct{}),reqHeaderMu:make(chanstruct{},1),));
    {
        var d = t.idleConnTimeout();

        if (d != 0) {
            cc.idleTimeout = d;
            cc.idleTimer = time.AfterFunc(d, cc.onIdleTimeout);
        }
    }
    if (http2VerboseLogs) {
        t.vlogf("http2: Transport creating client conn %p to %v", cc, c.RemoteAddr());
    }
    cc.cond = sync.NewCond(_addr_cc.mu);
    cc.flow.add(int32(http2initialWindowSize)); 

    // TODO: adjust this writer size to account for frame size +
    // MTU + crypto/tls record padding.
    cc.bw = bufio.NewWriter(new http2stickyErrWriter(c,&cc.werr));
    cc.br = bufio.NewReader(c);
    cc.fr = http2NewFramer(cc.bw, cc.br);
    cc.fr.ReadMetaHeaders = hpack.NewDecoder(http2initialHeaderTableSize, null);
    cc.fr.MaxHeaderListSize = t.maxHeaderListSize(); 

    // TODO: SetMaxDynamicTableSize, SetMaxDynamicTableSizeLimit on
    // henc in response to SETTINGS frames?
    cc.henc = hpack.NewEncoder(_addr_cc.hbuf);

    if (t.AllowHTTP) {
        cc.nextStreamID = 3;
    }
    {
        http2connectionStater (cs, ok) = http2connectionStater.As(c._<http2connectionStater>())!;

        if (ok) {
            ref var state = ref heap(cs.ConnectionState(), out ptr<var> _addr_state);
            _addr_cc.tlsState = _addr_state;
            cc.tlsState = ref _addr_cc.tlsState.val;
        }
    }

    http2Setting initialSettings = new slice<http2Setting>(new http2Setting[] { {ID:http2SettingEnablePush,Val:0}, {ID:http2SettingInitialWindowSize,Val:http2transportDefaultStreamFlow} });
    {
        var max = t.maxHeaderListSize();

        if (max != 0) {
            initialSettings = append(initialSettings, new http2Setting(ID:http2SettingMaxHeaderListSize,Val:max));
        }
    }

    cc.bw.Write(http2clientPreface);
    cc.fr.WriteSettings(initialSettings);
    cc.fr.WriteWindowUpdate(0, http2transportDefaultConnFlow);
    cc.inflow.add(http2transportDefaultConnFlow + http2initialWindowSize);
    cc.bw.Flush();
    if (cc.werr != null) {
        cc.Close();
        return (_addr_null!, error.As(cc.werr)!);
    }
    go_(() => cc.readLoop());
    return (_addr_cc!, error.As(null!)!);
}

private static void healthCheck(this ptr<http2ClientConn> _addr_cc) => func((defer, _, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;

    var pingTimeout = cc.t.pingTimeout(); 
    // We don't need to periodically ping in the health check, because the readLoop of ClientConn will
    // trigger the healthCheck again if there is no frame received.
    var (ctx, cancel) = context.WithTimeout(context.Background(), pingTimeout);
    defer(cancel());
    var err = cc.Ping(ctx);
    if (err != null) {
        cc.closeForLostPing();
        cc.t.connPool().MarkDead(cc);
        return ;
    }
});

// SetDoNotReuse marks cc as not reusable for future HTTP requests.
private static void SetDoNotReuse(this ptr<http2ClientConn> _addr_cc) => func((defer, _, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;

    cc.mu.Lock();
    defer(cc.mu.Unlock());
    cc.doNotReuse = true;
});

private static void setGoAway(this ptr<http2ClientConn> _addr_cc, ptr<http2GoAwayFrame> _addr_f) => func((defer, _, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;
    ref http2GoAwayFrame f = ref _addr_f.val;

    cc.mu.Lock();
    defer(cc.mu.Unlock());

    var old = cc.goAway;
    cc.goAway = f; 

    // Merge the previous and current GoAway error frames.
    if (cc.goAwayDebug == "") {
        cc.goAwayDebug = string(f.DebugData());
    }
    if (old != null && old.ErrCode != http2ErrCodeNo) {
        cc.goAway.ErrCode = old.ErrCode;
    }
    var last = f.LastStreamID;
    foreach (var (streamID, cs) in cc.streams) {
        if (streamID > last) {
            cs.abortStreamLocked(http2errClientConnGotGoAway);
        }
    }
});

// CanTakeNewRequest reports whether the connection can take a new request,
// meaning it has not been closed or received or sent a GOAWAY.
//
// If the caller is going to immediately make a new request on this
// connection, use ReserveNewRequest instead.
private static bool CanTakeNewRequest(this ptr<http2ClientConn> _addr_cc) => func((defer, _, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;

    cc.mu.Lock();
    defer(cc.mu.Unlock());
    return cc.canTakeNewRequestLocked();
});

// ReserveNewRequest is like CanTakeNewRequest but also reserves a
// concurrent stream in cc. The reservation is decremented on the
// next call to RoundTrip.
private static bool ReserveNewRequest(this ptr<http2ClientConn> _addr_cc) => func((defer, _, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;

    cc.mu.Lock();
    defer(cc.mu.Unlock());
    {
        var st = cc.idleStateLocked();

        if (!st.canTakeNewRequest) {
            return false;
        }
    }
    cc.streamsReserved++;
    return true;
});

// clientConnIdleState describes the suitability of a client
// connection to initiate a new RoundTrip request.
private partial struct http2clientConnIdleState {
    public bool canTakeNewRequest;
}

private static http2clientConnIdleState idleState(this ptr<http2ClientConn> _addr_cc) => func((defer, _, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;

    cc.mu.Lock();
    defer(cc.mu.Unlock());
    return cc.idleStateLocked();
});

private static http2clientConnIdleState idleStateLocked(this ptr<http2ClientConn> _addr_cc) {
    http2clientConnIdleState st = default;
    ref http2ClientConn cc = ref _addr_cc.val;

    if (cc.singleUse && cc.nextStreamID > 1) {
        return ;
    }
    bool maxConcurrentOkay = default;
    if (cc.t.StrictMaxConcurrentStreams) { 
        // We'll tell the caller we can take a new request to
        // prevent the caller from dialing a new TCP
        // connection, but then we'll block later before
        // writing it.
        maxConcurrentOkay = true;
    }
    else
 {
        maxConcurrentOkay = int64(len(cc.streams) + cc.streamsReserved + 1) <= int64(cc.maxConcurrentStreams);
    }
    st.canTakeNewRequest = cc.goAway == null && !cc.closed && !cc.closing && maxConcurrentOkay && !cc.doNotReuse && int64(cc.nextStreamID) + 2 * int64(cc.pendingRequests) < math.MaxInt32 && !cc.tooIdleLocked();
    return ;
}

private static bool canTakeNewRequestLocked(this ptr<http2ClientConn> _addr_cc) {
    ref http2ClientConn cc = ref _addr_cc.val;

    var st = cc.idleStateLocked();
    return st.canTakeNewRequest;
}

// tooIdleLocked reports whether this connection has been been sitting idle
// for too much wall time.
private static bool tooIdleLocked(this ptr<http2ClientConn> _addr_cc) {
    ref http2ClientConn cc = ref _addr_cc.val;
 
    // The Round(0) strips the monontonic clock reading so the
    // times are compared based on their wall time. We don't want
    // to reuse a connection that's been sitting idle during
    // VM/laptop suspend if monotonic time was also frozen.
    return cc.idleTimeout != 0 && !cc.lastIdle.IsZero() && time.Since(cc.lastIdle.Round(0)) > cc.idleTimeout;
}

// onIdleTimeout is called from a time.AfterFunc goroutine. It will
// only be called when we're idle, but because we're coming from a new
// goroutine, there could be a new request coming in at the same time,
// so this simply calls the synchronized closeIfIdle to shut down this
// connection. The timer could just call closeIfIdle, but this is more
// clear.
private static void onIdleTimeout(this ptr<http2ClientConn> _addr_cc) {
    ref http2ClientConn cc = ref _addr_cc.val;

    cc.closeIfIdle();
}

private static void closeIfIdle(this ptr<http2ClientConn> _addr_cc) {
    ref http2ClientConn cc = ref _addr_cc.val;

    cc.mu.Lock();
    if (len(cc.streams) > 0 || cc.streamsReserved > 0) {
        cc.mu.Unlock();
        return ;
    }
    cc.closed = true;
    var nextID = cc.nextStreamID; 
    // TODO: do clients send GOAWAY too? maybe? Just Close:
    cc.mu.Unlock();

    if (http2VerboseLogs) {
        cc.vlogf("http2: Transport closing idle conn %p (forSingleUse=%v, maxStream=%v)", cc, cc.singleUse, nextID - 2);
    }
    cc.tconn.Close();
}

private static bool isDoNotReuseAndIdle(this ptr<http2ClientConn> _addr_cc) => func((defer, _, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;

    cc.mu.Lock();
    defer(cc.mu.Unlock());
    return cc.doNotReuse && len(cc.streams) == 0;
});

private static Action http2shutdownEnterWaitStateHook = () => {
};

// Shutdown gracefully closes the client connection, waiting for running streams to complete.
private static error Shutdown(this ptr<http2ClientConn> _addr_cc, context.Context ctx) => func((defer, _, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;

    {
        var err__prev1 = err;

        var err = cc.sendGoAway();

        if (err != null) {
            return error.As(err)!;
        }
        err = err__prev1;

    } 
    // Wait for all in-flight streams to complete or connection to close
    var done = make_channel<error>(1);
    var cancelled = false; // guarded by cc.mu
    go_(() => () => {
        cc.mu.Lock();
        defer(cc.mu.Unlock());
        while (true) {
            if (len(cc.streams) == 0 || cc.closed) {
                cc.closed = true;
                done.Send(cc.tconn.Close());
                break;
            }
            if (cancelled) {
                break;
            }
            cc.cond.Wait();
        }
    }());
    http2shutdownEnterWaitStateHook();
    return error.As(err)!;
    cc.mu.Lock(); 
    // Free the goroutine above
    cancelled = true;
    cc.cond.Broadcast();
    cc.mu.Unlock();
    return error.As(ctx.Err())!;
});

private static error sendGoAway(this ptr<http2ClientConn> _addr_cc) => func((defer, _, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;

    cc.mu.Lock();
    var closing = cc.closing;
    cc.closing = true;
    var maxStreamID = cc.nextStreamID;
    cc.mu.Unlock();
    if (closing) { 
        // GOAWAY sent already
        return error.As(null!)!;
    }
    cc.wmu.Lock();
    defer(cc.wmu.Unlock()); 
    // Send a graceful shutdown frame to server
    {
        var err__prev1 = err;

        var err = cc.fr.WriteGoAway(maxStreamID, http2ErrCodeNo, null);

        if (err != null) {
            return error.As(err)!;
        }
        err = err__prev1;

    }
    {
        var err__prev1 = err;

        err = cc.bw.Flush();

        if (err != null) {
            return error.As(err)!;
        }
        err = err__prev1;

    } 
    // Prevent new requests
    return error.As(null!)!;
});

// closes the client connection immediately. In-flight requests are interrupted.
// err is sent to streams.
private static error closeForError(this ptr<http2ClientConn> _addr_cc, error err) => func((defer, _, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;

    cc.mu.Lock();
    cc.closed = true;
    foreach (var (_, cs) in cc.streams) {
        cs.abortStreamLocked(err);
    }    defer(cc.cond.Broadcast());
    defer(cc.mu.Unlock());
    return error.As(cc.tconn.Close())!;
});

// Close closes the client connection immediately.
//
// In-flight requests are interrupted. For a graceful shutdown, use Shutdown instead.
private static error Close(this ptr<http2ClientConn> _addr_cc) {
    ref http2ClientConn cc = ref _addr_cc.val;

    var err = errors.New("http2: client connection force closed via ClientConn.Close");
    return error.As(cc.closeForError(err))!;
}

// closes the client connection immediately. In-flight requests are interrupted.
private static error closeForLostPing(this ptr<http2ClientConn> _addr_cc) {
    ref http2ClientConn cc = ref _addr_cc.val;

    var err = errors.New("http2: client connection lost");
    return error.As(cc.closeForError(err))!;
}

// errRequestCanceled is a copy of net/http's errRequestCanceled because it's not
// exported. At least they'll be DeepEqual for h1-vs-h2 comparisons tests.
private static var http2errRequestCanceled = errors.New("net/http: request canceled");

private static (@string, error) http2commaSeparatedTrailers(ptr<Request> _addr_req) {
    @string _p0 = default;
    error _p0 = default!;
    ref Request req = ref _addr_req.val;

    var keys = make_slice<@string>(0, len(req.Trailer));
    foreach (var (k) in req.Trailer) {
        k = CanonicalHeaderKey(k);
        switch (k) {
            case "Transfer-Encoding": 

            case "Trailer": 

            case "Content-Length": 
                return ("", error.As(fmt.Errorf("invalid Trailer key %q", k))!);
                break;
        }
        keys = append(keys, k);
    }    if (len(keys) > 0) {
        sort.Strings(keys);
        return (strings.Join(keys, ","), error.As(null!)!);
    }
    return ("", error.As(null!)!);
}

private static time.Duration responseHeaderTimeout(this ptr<http2ClientConn> _addr_cc) {
    ref http2ClientConn cc = ref _addr_cc.val;

    if (cc.t.t1 != null) {
        return cc.t.t1.ResponseHeaderTimeout;
    }
    return 0;
}

// checkConnHeaders checks whether req has any invalid connection-level headers.
// per RFC 7540 section 8.1.2.2: Connection-Specific Header Fields.
// Certain headers are special-cased as okay but not transmitted later.
private static error http2checkConnHeaders(ptr<Request> _addr_req) {
    ref Request req = ref _addr_req.val;

    {
        var v = req.Header.Get("Upgrade");

        if (v != "") {
            return error.As(fmt.Errorf("http2: invalid Upgrade request header: %q", req.Header["Upgrade"]))!;
        }
    }
    {
        var vv__prev1 = vv;

        var vv = req.Header["Transfer-Encoding"];

        if (len(vv) > 0 && (len(vv) > 1 || vv[0] != "" && vv[0] != "chunked")) {
            return error.As(fmt.Errorf("http2: invalid Transfer-Encoding request header: %q", vv))!;
        }
        vv = vv__prev1;

    }
    {
        var vv__prev1 = vv;

        vv = req.Header["Connection"];

        if (len(vv) > 0 && (len(vv) > 1 || vv[0] != "" && !http2asciiEqualFold(vv[0], "close") && !http2asciiEqualFold(vv[0], "keep-alive"))) {
            return error.As(fmt.Errorf("http2: invalid Connection request header: %q", vv))!;
        }
        vv = vv__prev1;

    }
    return error.As(null!)!;
}

// actualContentLength returns a sanitized version of
// req.ContentLength, where 0 actually means zero (not unknown) and -1
// means unknown.
private static long http2actualContentLength(ptr<Request> _addr_req) {
    ref Request req = ref _addr_req.val;

    if (req.Body == null || req.Body == NoBody) {
        return 0;
    }
    if (req.ContentLength != 0) {
        return req.ContentLength;
    }
    return -1;
}

private static void decrStreamReservations(this ptr<http2ClientConn> _addr_cc) => func((defer, _, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;

    cc.mu.Lock();
    defer(cc.mu.Unlock());
    cc.decrStreamReservationsLocked();
});

private static void decrStreamReservationsLocked(this ptr<http2ClientConn> _addr_cc) {
    ref http2ClientConn cc = ref _addr_cc.val;

    if (cc.streamsReserved > 0) {
        cc.streamsReserved--;
    }
}

private static (ptr<Response>, error) RoundTrip(this ptr<http2ClientConn> _addr_cc, ptr<Request> _addr_req) {
    ptr<Response> _p0 = default!;
    error _p0 = default!;
    ref http2ClientConn cc = ref _addr_cc.val;
    ref Request req = ref _addr_req.val;

    var ctx = req.Context();
    ptr<http2clientStream> cs = addr(new http2clientStream(cc:cc,ctx:ctx,reqCancel:req.Cancel,isHead:req.Method=="HEAD",reqBody:req.Body,reqBodyContentLength:http2actualContentLength(req),trace:httptrace.ContextClientTrace(ctx),peerClosed:make(chanstruct{}),abort:make(chanstruct{}),respHeaderRecv:make(chanstruct{}),donec:make(chanstruct{}),));
    go_(() => cs.doRequest(req));

    Func<error> waitDone = () => {
        return _addr_null!;
        return _addr_ctx.Err()!;
        return _addr_http2errRequestCanceled!;
    };

    while (true) {
        var res = cs.res;
        if (res.StatusCode > 299) { 
            // On error or status code 3xx, 4xx, 5xx, etc abort any
            // ongoing write, assuming that the server doesn't care
            // about our request body. If the server replied with 1xx or
            // 2xx, however, then assume the server DOES potentially
            // want our body (e.g. full-duplex streaming:
            // golang.org/issue/13444). If it turns out the server
            // doesn't, they'll RST_STREAM us soon enough. This is a
            // heuristic to avoid adding knobs to Transport. Hopefully
            // we can keep it.
            cs.abortRequestBodyWrite();
        }
        res.Request = req;
        res.TLS = cc.tlsState;
        if (res.Body == http2noBody && http2actualContentLength(_addr_req) == 0) { 
            // If there isn't a request or response body still being
            // written, then wait for the stream to be closed before
            // RoundTrip returns.
            {
                var err__prev2 = err;

                var err = waitDone();

                if (err != null) {
                    return (_addr_null!, error.As(err)!);
                }

                err = err__prev2;

            }
        }
        return (_addr_res!, error.As(null!)!);
        waitDone();
        return (_addr_null!, error.As(cs.abortErr)!);
        err = ctx.Err();
        cs.abortStream(err);
        return (_addr_null!, error.As(err)!);
        cs.abortStream(http2errRequestCanceled);
        return (_addr_null!, error.As(http2errRequestCanceled)!);
    }
}

// writeRequest runs for the duration of the request lifetime.
//
// It sends the request and performs post-request cleanup (closing Request.Body, etc.).
private static void doRequest(this ptr<http2clientStream> _addr_cs, ptr<Request> _addr_req) {
    ref http2clientStream cs = ref _addr_cs.val;
    ref Request req = ref _addr_req.val;

    var err = cs.writeRequest(req);
    cs.cleanupWriteRequest(err);
}

// writeRequest sends a request.
//
// It returns nil after the request is written, the response read,
// and the request stream is half-closed by the peer.
//
// It returns non-nil if the request ends otherwise.
// If the returned error is StreamError, the error Code may be used in resetting the stream.
private static error writeRequest(this ptr<http2clientStream> _addr_cs, ptr<Request> _addr_req) => func((defer, panic, _) => {
    error err = default!;
    ref http2clientStream cs = ref _addr_cs.val;
    ref Request req = ref _addr_req.val;

    var cc = cs.cc;
    var ctx = cs.ctx;

    {
        var err__prev1 = err;

        var err = http2checkConnHeaders(_addr_req);

        if (err != null) {
            return error.As(err)!;
        }
        err = err__prev1;

    } 

    // Acquire the new-request lock by writing to reqHeaderMu.
    // This lock guards the critical section covering allocating a new stream ID
    // (requires mu) and creating the stream (requires wmu).
    if (cc.reqHeaderMu == null) {
        panic("RoundTrip on uninitialized ClientConn"); // for tests
    }
    return error.As(http2errRequestCanceled)!;
    return error.As(ctx.Err())!;
    cc.mu.Lock();
    if (cc.idleTimer != null) {
        cc.idleTimer.Stop();
    }
    cc.decrStreamReservationsLocked();
    {
        var err__prev1 = err;

        err = cc.awaitOpenSlotForStreamLocked(cs);

        if (err != null) {
            cc.mu.Unlock().Send(cc.reqHeaderMu);
            return error.As(err)!;
        }
        err = err__prev1;

    }
    cc.addStreamLocked(cs); // assigns stream ID
    cc.mu.Unlock(); 

    // TODO(bradfitz): this is a copy of the logic in net/http. Unify somewhere?
    if (!cc.t.disableCompression() && req.Header.Get("Accept-Encoding") == "" && req.Header.Get("Range") == "" && !cs.isHead) { 
        // Request gzip only, not deflate. Deflate is ambiguous and
        // not as universally supported anyway.
        // See: https://zlib.net/zlib_faq.html#faq39
        //
        // Note that we don't request this for HEAD requests,
        // due to a bug in nginx:
        //   http://trac.nginx.org/nginx/ticket/358
        //   https://golang.org/issue/5522
        //
        // We don't request gzip if the request is for a range, since
        // auto-decoding a portion of a gzipped document will just fail
        // anyway. See https://golang.org/issue/8923
        cs.requestedGzip = true;
    }
    var continueTimeout = cc.t.expectContinueTimeout();
    if (continueTimeout != 0 && !httpguts.HeaderValuesContainsToken(req.Header["Expect"], "100-continue")) {
        continueTimeout = 0;
        cs.on100 = make_channel<object>(1);
    }
    err = cs.encodeAndWriteHeaders(req);
    cc.reqHeaderMu.Receive();
    if (err != null) {
        return error.As(err)!;
    }
    var hasBody = cs.reqBodyContentLength != 0;
    if (!hasBody) {
        cs.sentEndStream = true;
    }
    else
 {
        if (continueTimeout != 0) {
            http2traceWait100Continue(_addr_cs.trace);
            var timer = time.NewTimer(continueTimeout);
            err = null;
            err = null;
            err = cs.abortErr;
            err = ctx.Err();
            err = http2errRequestCanceled;
            timer.Stop();
            if (err != null) {
                http2traceWroteRequest(_addr_cs.trace, err);
                return error.As(err)!;
            }
        }
        err = cs.writeRequestBody(req);

        if (err != null) {
            if (err != http2errStopReqBodyWrite) {
                http2traceWroteRequest(_addr_cs.trace, err);
                return error.As(err)!;
            }
        }
        else
 {
            cs.sentEndStream = true;
        }
    }
    http2traceWroteRequest(_addr_cs.trace, err);

    channel<time.Time> respHeaderTimer = default;
    channel<object> respHeaderRecv = default;
    {
        var d = cc.responseHeaderTimeout();

        if (d != 0) {
            timer = time.NewTimer(d);
            defer(timer.Stop());
            respHeaderTimer = timer.C;
            respHeaderRecv = cs.respHeaderRecv;
        }
    } 
    // Wait until the peer half-closes its end of the stream,
    // or until the request is aborted (via context, error, or otherwise),
    // whichever comes first.
    while (true) {
        return error.As(null!)!;
        return error.As(http2errTimeout)!;
        respHeaderTimer = null; // keep waiting for END_STREAM
        return error.As(cs.abortErr)!;
        return error.As(ctx.Err())!;
        return error.As(http2errRequestCanceled)!;
    }
});

private static error encodeAndWriteHeaders(this ptr<http2clientStream> _addr_cs, ptr<Request> _addr_req) => func((defer, _, _) => {
    ref http2clientStream cs = ref _addr_cs.val;
    ref Request req = ref _addr_req.val;

    var cc = cs.cc;
    var ctx = cs.ctx;

    cc.wmu.Lock();
    defer(cc.wmu.Unlock()); 

    // If the request was canceled while waiting for cc.mu, just quit.
    return error.As(cs.abortErr)!;
    return error.As(ctx.Err())!;
    return error.As(http2errRequestCanceled)!;
    var (trailers, err) = http2commaSeparatedTrailers(_addr_req);
    if (err != null) {
        return error.As(err)!;
    }
    var hasTrailers = trailers != "";
    var contentLen = http2actualContentLength(_addr_req);
    var hasBody = contentLen != 0;
    var (hdrs, err) = cc.encodeHeaders(req, cs.requestedGzip, trailers, contentLen);
    if (err != null) {
        return error.As(err)!;
    }
    var endStream = !hasBody && !hasTrailers;
    cs.sentHeaders = true;
    err = cc.writeHeaders(cs.ID, endStream, int(cc.maxFrameSize), hdrs);
    http2traceWroteHeaders(_addr_cs.trace);
    return error.As(err)!;
});

// cleanupWriteRequest performs post-request tasks.
//
// If err (the result of writeRequest) is non-nil and the stream is not closed,
// cleanupWriteRequest will send a reset to the peer.
private static void cleanupWriteRequest(this ptr<http2clientStream> _addr_cs, error err) {
    ref http2clientStream cs = ref _addr_cs.val;

    var cc = cs.cc;

    if (cs.ID == 0) { 
        // We were canceled before creating the stream, so return our reservation.
        cc.decrStreamReservations();
    }
    cc.mu.Lock();
    var bodyClosed = cs.reqBodyClosed;
    cs.reqBodyClosed = true;
    cc.mu.Unlock();
    if (!bodyClosed && cs.reqBody != null) {
        cs.reqBody.Close();
    }
    if (err != null && cs.sentEndStream) { 
        // If the connection is closed immediately after the response is read,
        // we may be aborted before finishing up here. If the stream was closed
        // cleanly on both sides, there is no error.
        err = null;
    }
    if (err != null) {
        cs.abortStream(err); // possibly redundant, but harmless
        if (cs.sentHeaders) {
            {
                http2StreamError (se, ok) = err._<http2StreamError>();

                if (ok) {
                    if (se.Cause != http2errFromPeer) {
                        cc.writeStreamReset(cs.ID, se.Code, err);
                    }
                }
                else
 {
                    cc.writeStreamReset(cs.ID, http2ErrCodeCancel, err);
                }

            }
        }
        cs.bufPipe.CloseWithError(err); // no-op if already closed
    }
    else
 {
        if (cs.sentHeaders && !cs.sentEndStream) {
            cc.writeStreamReset(cs.ID, http2ErrCodeNo, null);
        }
        cs.bufPipe.CloseWithError(http2errRequestCanceled);
    }
    if (cs.ID != 0) {
        cc.forgetStreamID(cs.ID);
    }
    cc.wmu.Lock();
    var werr = cc.werr;
    cc.wmu.Unlock();
    if (werr != null) {
        cc.Close();
    }
    close(cs.donec);
}

// awaitOpenSlotForStream waits until len(streams) < maxConcurrentStreams.
// Must hold cc.mu.
private static error awaitOpenSlotForStreamLocked(this ptr<http2ClientConn> _addr_cc, ptr<http2clientStream> _addr_cs) {
    ref http2ClientConn cc = ref _addr_cc.val;
    ref http2clientStream cs = ref _addr_cs.val;

    while (true) {
        cc.lastActive = time.Now();
        if (cc.closed || !cc.canTakeNewRequestLocked()) {
            return error.As(http2errClientConnUnusable)!;
        }
        cc.lastIdle = new time.Time();
        if (int64(len(cc.streams)) < int64(cc.maxConcurrentStreams)) {
            return error.As(null!)!;
        }
        cc.pendingRequests++;
        cc.cond.Wait();
        cc.pendingRequests--;
        return error.As(cs.abortErr)!;
    }
}

// requires cc.wmu be held
private static error writeHeaders(this ptr<http2ClientConn> _addr_cc, uint streamID, bool endStream, nint maxFrameSize, slice<byte> hdrs) {
    ref http2ClientConn cc = ref _addr_cc.val;

    var first = true; // first frame written (HEADERS is first, then CONTINUATION)
    while (len(hdrs) > 0 && cc.werr == null) {
        var chunk = hdrs;
        if (len(chunk) > maxFrameSize) {
            chunk = chunk[..(int)maxFrameSize];
        }
        hdrs = hdrs[(int)len(chunk)..];
        var endHeaders = len(hdrs) == 0;
        if (first) {
            cc.fr.WriteHeaders(new http2HeadersFrameParam(StreamID:streamID,BlockFragment:chunk,EndStream:endStream,EndHeaders:endHeaders,));
            first = false;
        }
        else
 {
            cc.fr.WriteContinuation(streamID, endHeaders, chunk);
        }
    }
    cc.bw.Flush();
    return error.As(cc.werr)!;
}

// internal error values; they don't escape to callers
 
// abort request body write; don't send cancel
private static var http2errStopReqBodyWrite = errors.New("http2: aborting request body write");private static var http2errStopReqBodyWriteAndCancel = errors.New("http2: canceling request");private static var http2errReqBodyTooLong = errors.New("http2: request body larger than specified content length");

// frameScratchBufferLen returns the length of a buffer to use for
// outgoing request bodies to read/write to/from.
//
// It returns max(1, min(peer's advertised max frame size,
// Request.ContentLength+1, 512KB)).
private static nint frameScratchBufferLen(this ptr<http2clientStream> _addr_cs, nint maxFrameSize) {
    ref http2clientStream cs = ref _addr_cs.val;

    const nint max = 512 << 10;

    var n = int64(maxFrameSize);
    if (n > max) {
        n = max;
    }
    {
        var cl = cs.reqBodyContentLength;

        if (cl != -1 && cl + 1 < n) { 
            // Add an extra byte past the declared content-length to
            // give the caller's Request.Body io.Reader a chance to
            // give us more bytes than they declared, so we can catch it
            // early.
            n = cl + 1;
        }
    }
    if (n < 1) {
        return 1;
    }
    return int(n); // doesn't truncate; max is 512K
}

private static sync.Pool http2bufPool = default; // of *[]byte

private static error writeRequestBody(this ptr<http2clientStream> _addr_cs, ptr<Request> _addr_req) => func((defer, _, _) => {
    error err = default!;
    ref http2clientStream cs = ref _addr_cs.val;
    ref Request req = ref _addr_req.val;

    var cc = cs.cc;
    var body = cs.reqBody;
    var sentEnd = false; // whether we sent the final DATA frame w/ END_STREAM

    var hasTrailers = req.Trailer != null;
    var remainLen = cs.reqBodyContentLength;
    var hasContentLen = remainLen != -1;

    cc.mu.Lock();
    var maxFrameSize = int(cc.maxFrameSize);
    cc.mu.Unlock(); 

    // Scratch buffer for reading into & writing from.
    var scratchLen = cs.frameScratchBufferLen(maxFrameSize);
    ref slice<byte> buf = ref heap(out ptr<slice<byte>> _addr_buf);
    {
        ptr<slice<byte>> (bp, ok) = http2bufPool.Get()._<ptr<slice<byte>>>();

        if (ok && len(bp.val) >= scratchLen) {
            defer(http2bufPool.Put(bp));
            buf = bp.val;
        }
        else
 {
            buf = make_slice<byte>(scratchLen);
            defer(http2bufPool.Put(_addr_buf));
        }
    }

    bool sawEOF = default;
    while (!sawEOF) {
        var (n, err) = body.Read(buf[..(int)len(buf)]);
        if (hasContentLen) {
            remainLen -= int64(n);
            if (remainLen == 0 && err == null) { 
                // The request body's Content-Length was predeclared and
                // we just finished reading it all, but the underlying io.Reader
                // returned the final chunk with a nil error (which is one of
                // the two valid things a Reader can do at EOF). Because we'd prefer
                // to send the END_STREAM bit early, double-check that we're actually
                // at EOF. Subsequent reads should return (0, EOF) at this point.
                // If either value is different, we return an error in one of two ways below.
                array<byte> scratch = new array<byte>(1);
                nint n1 = default;
                n1, err = body.Read(scratch[..]);
                remainLen -= int64(n1);
            }
            if (remainLen < 0) {
                err = http2errReqBodyTooLong;
                return error.As(err)!;
            }
        }
        if (err == io.EOF) {
            sawEOF = true;
            err = null;
        }
        else if (err != null) {
            return error.As(err)!;
        }
        var remain = buf[..(int)n];
        while (len(remain) > 0 && err == null) {
            int allowed = default;
            allowed, err = cs.awaitFlowControl(len(remain));
            if (err != null) {
                return error.As(err)!;
            }
            cc.wmu.Lock();
            var data = remain[..(int)allowed];
            remain = remain[(int)allowed..];
            sentEnd = sawEOF && len(remain) == 0 && !hasTrailers;
            err = cc.fr.WriteData(cs.ID, sentEnd, data);
            if (err == null) { 
                // TODO(bradfitz): this flush is for latency, not bandwidth.
                // Most requests won't need this. Make this opt-in or
                // opt-out?  Use some heuristic on the body type? Nagel-like
                // timers?  Based on 'n'? Only last chunk of this for loop,
                // unless flow control tokens are low? For now, always.
                // If we change this, see comment below.
                err = cc.bw.Flush();
            }
            cc.wmu.Unlock();
        }
        if (err != null) {
            return error.As(err)!;
        }
    }

    if (sentEnd) { 
        // Already sent END_STREAM (which implies we have no
        // trailers) and flushed, because currently all
        // WriteData frames above get a flush. So we're done.
        return error.As(null!)!;
    }
    cc.mu.Lock();
    var trailer = req.Trailer;
    err = cs.abortErr;
    cc.mu.Unlock();
    if (err != null) {
        return error.As(err)!;
    }
    cc.wmu.Lock();
    defer(cc.wmu.Unlock());
    slice<byte> trls = default;
    if (len(trailer) > 0) {
        trls, err = cc.encodeTrailers(trailer);
        if (err != null) {
            return error.As(err)!;
        }
    }
    if (len(trls) > 0) {
        err = cc.writeHeaders(cs.ID, true, maxFrameSize, trls);
    }
    else
 {
        err = cc.fr.WriteData(cs.ID, true, null);
    }
    {
        var ferr = cc.bw.Flush();

        if (ferr != null && err == null) {
            err = ferr;
        }
    }
    return error.As(err)!;
});

// awaitFlowControl waits for [1, min(maxBytes, cc.cs.maxFrameSize)] flow
// control tokens from the server.
// It returns either the non-zero number of tokens taken or an error
// if the stream is dead.
private static (int, error) awaitFlowControl(this ptr<http2clientStream> _addr_cs, nint maxBytes) => func((defer, _, _) => {
    int taken = default;
    error err = default!;
    ref http2clientStream cs = ref _addr_cs.val;

    var cc = cs.cc;
    var ctx = cs.ctx;
    cc.mu.Lock();
    defer(cc.mu.Unlock());
    while (true) {
        if (cc.closed) {
            return (0, error.As(http2errClientConnClosed)!);
        }
        if (cs.reqBodyClosed) {
            return (0, error.As(http2errStopReqBodyWrite)!);
        }
        return (0, error.As(cs.abortErr)!);
        return (0, error.As(ctx.Err())!);
        return (0, error.As(http2errRequestCanceled)!);
        {
            var a = cs.flow.available();

            if (a > 0) {
                var take = a;
                if (int(take) > maxBytes) {
                    take = int32(maxBytes); // can't truncate int; take is int32
                }
                if (take > int32(cc.maxFrameSize)) {
                    take = int32(cc.maxFrameSize);
                }
                cs.flow.take(take);
                return (take, error.As(null!)!);
            }

        }
        cc.cond.Wait();
    }
});

private static var http2errNilRequestURL = errors.New("http2: Request.URI is nil");

// requires cc.wmu be held.
private static (slice<byte>, error) encodeHeaders(this ptr<http2ClientConn> _addr_cc, ptr<Request> _addr_req, bool addGzipHeader, @string trailers, long contentLength) {
    slice<byte> _p0 = default;
    error _p0 = default!;
    ref http2ClientConn cc = ref _addr_cc.val;
    ref Request req = ref _addr_req.val;

    cc.hbuf.Reset();
    if (req.URL == null) {
        return (null, error.As(http2errNilRequestURL)!);
    }
    var host = req.Host;
    if (host == "") {
        host = req.URL.Host;
    }
    var (host, err) = httpguts.PunycodeHostPort(host);
    if (err != null) {
        return (null, error.As(err)!);
    }
    @string path = default;
    if (req.Method != "CONNECT") {
        path = req.URL.RequestURI();
        if (!http2validPseudoPath(path)) {
            var orig = path;
            path = strings.TrimPrefix(path, req.URL.Scheme + "://" + host);
            if (!http2validPseudoPath(path)) {
                if (req.URL.Opaque != "") {
                    return (null, error.As(fmt.Errorf("invalid request :path %q from URL.Opaque = %q", orig, req.URL.Opaque))!);
                }
                else
 {
                    return (null, error.As(fmt.Errorf("invalid request :path %q", orig))!);
                }
            }
        }
    }
    {
        var k__prev1 = k;
        var vv__prev1 = vv;

        foreach (var (__k, __vv) in req.Header) {
            k = __k;
            vv = __vv;
            if (!httpguts.ValidHeaderFieldName(k)) {
                return (null, error.As(fmt.Errorf("invalid HTTP header name %q", k))!);
            }
            {
                var v__prev2 = v;

                foreach (var (_, __v) in vv) {
                    v = __v;
                    if (!httpguts.ValidHeaderFieldValue(v)) {
                        return (null, error.As(fmt.Errorf("invalid HTTP header value %q for header %q", v, k))!);
                    }
                }

                v = v__prev2;
            }
        }
        k = k__prev1;
        vv = vv__prev1;
    }

    Action<Action<@string, @string>> enumerateHeaders = f => { 
        // 8.1.2.3 Request Pseudo-Header Fields
        // The :path pseudo-header field includes the path and query parts of the
        // target URI (the path-absolute production and optionally a '?' character
        // followed by the query production (see Sections 3.3 and 3.4 of
        // [RFC3986]).
        f(":authority", host);
        var m = req.Method;
        if (m == "") {
            m = MethodGet;
        }
        f(":method", m);
        if (req.Method != "CONNECT") {
            f(":path", path);
            f(":scheme", req.URL.Scheme);
        }
        if (trailers != "") {
            f("trailer", trailers);
        }
        bool didUA = default;
        {
            var k__prev1 = k;
            var vv__prev1 = vv;

            foreach (var (__k, __vv) in req.Header) {
                k = __k;
                vv = __vv;
                if (http2asciiEqualFold(k, "host") || http2asciiEqualFold(k, "content-length")) { 
                    // Host is :authority, already sent.
                    // Content-Length is automatic, set below.
                    continue;
                }
                else if (http2asciiEqualFold(k, "connection") || http2asciiEqualFold(k, "proxy-connection") || http2asciiEqualFold(k, "transfer-encoding") || http2asciiEqualFold(k, "upgrade") || http2asciiEqualFold(k, "keep-alive")) { 
                    // Per 8.1.2.2 Connection-Specific Header
                    // Fields, don't send connection-specific
                    // fields. We have already checked if any
                    // are error-worthy so just ignore the rest.
                    continue;
                }
                else if (http2asciiEqualFold(k, "user-agent")) { 
                    // Match Go's http1 behavior: at most one
                    // User-Agent. If set to nil or empty string,
                    // then omit it. Otherwise if not mentioned,
                    // include the default (below).
                    didUA = true;
                    if (len(vv) < 1) {
                        continue;
                    }
                    vv = vv[..(int)1];
                    if (vv[0] == "") {
                        continue;
                    }
                }
                else if (http2asciiEqualFold(k, "cookie")) { 
                    // Per 8.1.2.5 To allow for better compression efficiency, the
                    // Cookie header field MAY be split into separate header fields,
                    // each with one or more cookie-pairs.
                    {
                        var v__prev2 = v;

                        foreach (var (_, __v) in vv) {
                            v = __v;
                            while (true) {
                                var p = strings.IndexByte(v, ';');
                                if (p < 0) {
                                    break;
                                }
                                f("cookie", v[..(int)p]);
                                p++; 
                                // strip space after semicolon if any.
                                while (p + 1 <= len(v) && v[p] == ' ') {
                                    p++;
                                }

                                v = v[(int)p..];
                            }

                            if (len(v) > 0) {
                                f("cookie", v);
                            }
                        }

                        v = v__prev2;
                    }

                    continue;
                }
                {
                    var v__prev2 = v;

                    foreach (var (_, __v) in vv) {
                        v = __v;
                        f(k, v);
                    }

                    v = v__prev2;
                }
            }

            k = k__prev1;
            vv = vv__prev1;
        }

        if (http2shouldSendReqContentLength(req.Method, contentLength)) {
            f("content-length", strconv.FormatInt(contentLength, 10));
        }
        if (addGzipHeader) {
            f("accept-encoding", "gzip");
        }
        if (!didUA) {
            f("user-agent", http2defaultUserAgent);
        }
    }; 

    // Do a first pass over the headers counting bytes to ensure
    // we don't exceed cc.peerMaxHeaderListSize. This is done as a
    // separate pass before encoding the headers to prevent
    // modifying the hpack state.
    var hlSize = uint64(0);
    enumerateHeaders((name, value) => {
        hpack.HeaderField hf = new hpack.HeaderField(Name:name,Value:value);
        hlSize += uint64(hf.Size());
    });

    if (hlSize > cc.peerMaxHeaderListSize) {
        return (null, error.As(http2errRequestHeaderListSize)!);
    }
    var trace = httptrace.ContextClientTrace(req.Context());
    var traceHeaders = http2traceHasWroteHeaderField(_addr_trace); 

    // Header list size is ok. Write the headers.
    enumerateHeaders((name, value) => {
        var (name, ascii) = http2asciiToLower(name);
        if (!ascii) { 
            // Skip writing invalid headers. Per RFC 7540, Section 8.1.2, header
            // field names have to be ASCII characters (just as in HTTP/1.x).
            return ;
        }
        cc.writeHeader(name, value);
        if (traceHeaders) {
            http2traceWroteHeaderField(_addr_trace, name, value);
        }
    });

    return (cc.hbuf.Bytes(), error.As(null!)!);
}

// shouldSendReqContentLength reports whether the http2.Transport should send
// a "content-length" request header. This logic is basically a copy of the net/http
// transferWriter.shouldSendContentLength.
// The contentLength is the corrected contentLength (so 0 means actually 0, not unknown).
// -1 means unknown.
private static bool http2shouldSendReqContentLength(@string method, long contentLength) {
    if (contentLength > 0) {
        return true;
    }
    if (contentLength < 0) {
        return false;
    }
    switch (method) {
        case "POST": 

        case "PUT": 

        case "PATCH": 
            return true;
            break;
        default: 
            return false;
            break;
    }
}

// requires cc.wmu be held.
private static (slice<byte>, error) encodeTrailers(this ptr<http2ClientConn> _addr_cc, Header trailer) {
    slice<byte> _p0 = default;
    error _p0 = default!;
    ref http2ClientConn cc = ref _addr_cc.val;

    cc.hbuf.Reset();

    var hlSize = uint64(0);
    {
        var k__prev1 = k;
        var vv__prev1 = vv;

        foreach (var (__k, __vv) in trailer) {
            k = __k;
            vv = __vv;
            {
                var v__prev2 = v;

                foreach (var (_, __v) in vv) {
                    v = __v;
                    hpack.HeaderField hf = new hpack.HeaderField(Name:k,Value:v);
                    hlSize += uint64(hf.Size());
                }

                v = v__prev2;
            }
        }
        k = k__prev1;
        vv = vv__prev1;
    }

    if (hlSize > cc.peerMaxHeaderListSize) {
        return (null, error.As(http2errRequestHeaderListSize)!);
    }
    {
        var k__prev1 = k;
        var vv__prev1 = vv;

        foreach (var (__k, __vv) in trailer) {
            k = __k;
            vv = __vv;
            var (lowKey, ascii) = http2asciiToLower(k);
            if (!ascii) { 
                // Skip writing invalid headers. Per RFC 7540, Section 8.1.2, header
                // field names have to be ASCII characters (just as in HTTP/1.x).
                continue;
            } 
            // Transfer-Encoding, etc.. have already been filtered at the
            // start of RoundTrip
            {
                var v__prev2 = v;

                foreach (var (_, __v) in vv) {
                    v = __v;
                    cc.writeHeader(lowKey, v);
                }

                v = v__prev2;
            }
        }
        k = k__prev1;
        vv = vv__prev1;
    }

    return (cc.hbuf.Bytes(), error.As(null!)!);
}

private static void writeHeader(this ptr<http2ClientConn> _addr_cc, @string name, @string value) {
    ref http2ClientConn cc = ref _addr_cc.val;

    if (http2VerboseLogs) {
        log.Printf("http2: Transport encoding header %q = %q", name, value);
    }
    cc.henc.WriteField(new hpack.HeaderField(Name:name,Value:value));
}

private partial struct http2resAndError {
    public http2incomparable _;
    public ptr<Response> res;
    public error err;
}

// requires cc.mu be held.
private static void addStreamLocked(this ptr<http2ClientConn> _addr_cc, ptr<http2clientStream> _addr_cs) => func((_, panic, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;
    ref http2clientStream cs = ref _addr_cs.val;

    cs.flow.add(int32(cc.initialWindowSize));
    cs.flow.setConnFlow(_addr_cc.flow);
    cs.inflow.add(http2transportDefaultStreamFlow);
    cs.inflow.setConnFlow(_addr_cc.inflow);
    cs.ID = cc.nextStreamID;
    cc.nextStreamID += 2;
    cc.streams[cs.ID] = cs;
    if (cs.ID == 0) {
        panic("assigned stream ID 0");
    }
});

private static void forgetStreamID(this ptr<http2ClientConn> _addr_cc, uint id) => func((defer, panic, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;

    cc.mu.Lock();
    var slen = len(cc.streams);
    delete(cc.streams, id);
    if (len(cc.streams) != slen - 1) {
        panic("forgetting unknown stream id");
    }
    cc.lastActive = time.Now();
    if (len(cc.streams) == 0 && cc.idleTimer != null) {
        cc.idleTimer.Reset(cc.idleTimeout);
        cc.lastIdle = time.Now();
    }
    cc.cond.Broadcast();

    var closeOnIdle = cc.singleUse || cc.doNotReuse || cc.t.disableKeepAlives();
    if (closeOnIdle && cc.streamsReserved == 0 && len(cc.streams) == 0) {
        if (http2VerboseLogs) {
            cc.vlogf("http2: Transport closing idle conn %p (forSingleUse=%v, maxStream=%v)", cc, cc.singleUse, cc.nextStreamID - 2);
        }
        cc.closed = true;
        defer(cc.tconn.Close());
    }
    cc.mu.Unlock();
});

// clientConnReadLoop is the state owned by the clientConn's frame-reading readLoop.
private partial struct http2clientConnReadLoop {
    public http2incomparable _;
    public ptr<http2ClientConn> cc;
}

// readLoop runs in its own goroutine and reads and dispatches frames.
private static void readLoop(this ptr<http2ClientConn> _addr_cc) => func((defer, _, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;

    ptr<http2clientConnReadLoop> rl = addr(new http2clientConnReadLoop(cc:cc));
    defer(rl.cleanup());
    cc.readerErr = rl.run();
    {
        http2ConnectionError (ce, ok) = cc.readerErr._<http2ConnectionError>();

        if (ok) {
            cc.wmu.Lock();
            cc.fr.WriteGoAway(0, http2ErrCode(ce), null);
            cc.wmu.Unlock();
        }
    }
});

// GoAwayError is returned by the Transport when the server closes the
// TCP connection after sending a GOAWAY frame.
private partial struct http2GoAwayError {
    public uint LastStreamID;
    public http2ErrCode ErrCode;
    public @string DebugData;
}

private static @string Error(this http2GoAwayError e) {
    return fmt.Sprintf("http2: server sent GOAWAY and closed the connection; LastStreamID=%v, ErrCode=%v, debug=%q", e.LastStreamID, e.ErrCode, e.DebugData);
}

private static bool http2isEOFOrNetReadError(error err) {
    if (err == io.EOF) {
        return true;
    }
    ptr<net.OpError> (ne, ok) = err._<ptr<net.OpError>>();
    return ok && ne.Op == "read";
}

private static void cleanup(this ptr<http2clientConnReadLoop> _addr_rl) => func((defer, _, _) => {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;

    var cc = rl.cc;
    defer(cc.tconn.Close());
    defer(cc.t.connPool().MarkDead(cc));
    defer(close(cc.readerDone));

    if (cc.idleTimer != null) {
        cc.idleTimer.Stop();
    }
    var err = cc.readerErr;
    cc.mu.Lock();
    if (cc.goAway != null && http2isEOFOrNetReadError(err)) {
        err = new http2GoAwayError(LastStreamID:cc.goAway.LastStreamID,ErrCode:cc.goAway.ErrCode,DebugData:cc.goAwayDebug,);
    }
    else if (err == io.EOF) {
        err = io.ErrUnexpectedEOF;
    }
    cc.closed = true;
    foreach (var (_, cs) in cc.streams) {
        cs.abortStreamLocked(err);
    }    cc.cond.Broadcast();
    cc.mu.Unlock();
});

private static error run(this ptr<http2clientConnReadLoop> _addr_rl) => func((defer, _, _) => {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;

    var cc = rl.cc;
    var gotSettings = false;
    var readIdleTimeout = cc.t.ReadIdleTimeout;
    ptr<time.Timer> t;
    if (readIdleTimeout != 0) {
        t = time.AfterFunc(readIdleTimeout, cc.healthCheck);
        defer(t.Stop());
    }
    while (true) {
        var (f, err) = cc.fr.ReadFrame();
        if (t != null) {
            t.Reset(readIdleTimeout);
        }
        if (err != null) {
            cc.vlogf("http2: Transport readFrame error on conn %p: (%T) %v", cc, err, err);
        }
        {
            http2StreamError (se, ok) = err._<http2StreamError>();

            if (ok) {
                {
                    var cs = rl.streamByID(se.StreamID);

                    if (cs != null) {
                        if (se.Cause == null) {
                            se.Cause = cc.fr.errDetail;
                        }
                        rl.endStreamError(cs, se);
                    }

                }
                continue;
            }
            else if (err != null) {
                return error.As(err)!;
            }

        }
        if (http2VerboseLogs) {
            cc.vlogf("http2: Transport received %s", http2summarizeFrame(f));
        }
        if (!gotSettings) {
            {
                ptr<http2SettingsFrame> (_, ok) = f._<ptr<http2SettingsFrame>>();

                if (!ok) {
                    cc.logf("protocol error: received %T before a SETTINGS frame", f);
                    return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
                }

            }
            gotSettings = true;
        }
        switch (f.type()) {
            case ptr<http2MetaHeadersFrame> f:
                err = rl.processHeaders(f);
                break;
            case ptr<http2DataFrame> f:
                err = rl.processData(f);
                break;
            case ptr<http2GoAwayFrame> f:
                err = rl.processGoAway(f);
                break;
            case ptr<http2RSTStreamFrame> f:
                err = rl.processResetStream(f);
                break;
            case ptr<http2SettingsFrame> f:
                err = rl.processSettings(f);
                break;
            case ptr<http2PushPromiseFrame> f:
                err = rl.processPushPromise(f);
                break;
            case ptr<http2WindowUpdateFrame> f:
                err = rl.processWindowUpdate(f);
                break;
            case ptr<http2PingFrame> f:
                err = rl.processPing(f);
                break;
            default:
            {
                var f = f.type();
                cc.logf("Transport: unhandled response frame type %T", f);
                break;
            }
        }
        if (err != null) {
            if (http2VerboseLogs) {
                cc.vlogf("http2: Transport conn %p received error from processing frame %v: %v", cc, http2summarizeFrame(f), err);
            }
            return error.As(err)!;
        }
    }
});

private static error processHeaders(this ptr<http2clientConnReadLoop> _addr_rl, ptr<http2MetaHeadersFrame> _addr_f) {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;
    ref http2MetaHeadersFrame f = ref _addr_f.val;

    var cs = rl.streamByID(f.StreamID);
    if (cs == null) { 
        // We'd get here if we canceled a request while the
        // server had its response still in flight. So if this
        // was just something we canceled, ignore it.
        return error.As(null!)!;
    }
    if (cs.readClosed) {
        rl.endStreamError(cs, new http2StreamError(StreamID:f.StreamID,Code:http2ErrCodeProtocol,Cause:errors.New("protocol error: headers after END_STREAM"),));
        return error.As(null!)!;
    }
    if (!cs.firstByte) {
        if (cs.trace != null) { 
            // TODO(bradfitz): move first response byte earlier,
            // when we first read the 9 byte header, not waiting
            // until all the HEADERS+CONTINUATION frames have been
            // merged. This works for now.
            http2traceFirstResponseByte(_addr_cs.trace);
        }
        cs.firstByte = true;
    }
    if (!cs.pastHeaders) {
        cs.pastHeaders = true;
    }
    else
 {
        return error.As(rl.processTrailers(cs, f))!;
    }
    var (res, err) = rl.handleResponse(cs, f);
    if (err != null) {
        {
            http2ConnectionError (_, ok) = err._<http2ConnectionError>();

            if (ok) {
                return error.As(err)!;
            } 
            // Any other error type is a stream error.

        } 
        // Any other error type is a stream error.
        rl.endStreamError(cs, new http2StreamError(StreamID:f.StreamID,Code:http2ErrCodeProtocol,Cause:err,));
        return error.As(null!)!; // return nil from process* funcs to keep conn alive
    }
    if (res == null) { 
        // (nil, nil) special case. See handleResponse docs.
        return error.As(null!)!;
    }
    cs.resTrailer = _addr_res.Trailer;
    cs.res = res;
    close(cs.respHeaderRecv);
    if (f.StreamEnded()) {
        rl.endStream(cs);
    }
    return error.As(null!)!;
}

// may return error types nil, or ConnectionError. Any other error value
// is a StreamError of type ErrCodeProtocol. The returned error in that case
// is the detail.
//
// As a special case, handleResponse may return (nil, nil) to skip the
// frame (currently only used for 1xx responses).
private static (ptr<Response>, error) handleResponse(this ptr<http2clientConnReadLoop> _addr_rl, ptr<http2clientStream> _addr_cs, ptr<http2MetaHeadersFrame> _addr_f) {
    ptr<Response> _p0 = default!;
    error _p0 = default!;
    ref http2clientConnReadLoop rl = ref _addr_rl.val;
    ref http2clientStream cs = ref _addr_cs.val;
    ref http2MetaHeadersFrame f = ref _addr_f.val;

    if (f.Truncated) {
        return (_addr_null!, error.As(http2errResponseHeaderListSize)!);
    }
    var status = f.PseudoValue("status");
    if (status == "") {
        return (_addr_null!, error.As(errors.New("malformed response from server: missing status pseudo header"))!);
    }
    var (statusCode, err) = strconv.Atoi(status);
    if (err != null) {
        return (_addr_null!, error.As(errors.New("malformed response from server: malformed non-numeric status pseudo header"))!);
    }
    var regularFields = f.RegularFields();
    var strs = make_slice<@string>(len(regularFields));
    var header = make(Header, len(regularFields));
    ptr<Response> res = addr(new Response(Proto:"HTTP/2.0",ProtoMajor:2,Header:header,StatusCode:statusCode,Status:status+" "+StatusText(statusCode),));
    foreach (var (_, hf) in regularFields) {
        var key = CanonicalHeaderKey(hf.Name);
        if (key == "Trailer") {
            var t = res.Trailer;
            if (t == null) {
                t = make(Header);
                res.Trailer = t;
            }
            http2foreachHeaderElement(hf.Value, v => {
                t[CanonicalHeaderKey(v)] = null;
            }
        else
);
        } {
            var vv = header[key];
            if (vv == null && len(strs) > 0) { 
                // More than likely this will be a single-element key.
                // Most headers aren't multi-valued.
                // Set the capacity on strs[0] to 1, so any future append
                // won't extend the slice into the other strings.
                (vv, strs) = (strs.slice(-1, 1, 1), strs[(int)1..]);                vv[0] = hf.Value;
                header[key] = vv;
            }
            else
 {
                header[key] = append(vv, hf.Value);
            }
        }
    }    if (statusCode >= 100 && statusCode <= 199) {
        if (f.StreamEnded()) {
            return (_addr_null!, error.As(errors.New("1xx informational response with END_STREAM flag"))!);
        }
        cs.num1xx++;
        const nint max1xxResponses = 5; // arbitrary bound on number of informational responses, same as net/http
 // arbitrary bound on number of informational responses, same as net/http
        if (cs.num1xx > max1xxResponses) {
            return (_addr_null!, error.As(errors.New("http2: too many 1xx informational responses"))!);
        }
        {
            var fn = cs.get1xxTraceFunc();

            if (fn != null) {
                {
                    var err = fn(statusCode, textproto.MIMEHeader(header));

                    if (err != null) {
                        return (_addr_null!, error.As(err)!);
                    }

                }
            }

        }
        if (statusCode == 100) {
            http2traceGot100Continue(_addr_cs.trace);
        }
        cs.pastHeaders = false; // do it all again
        return (_addr_null!, error.As(null!)!);
    }
    res.ContentLength = -1;
    {
        var clens = res.Header["Content-Length"];

        if (len(clens) == 1) {
            {
                var (cl, err) = strconv.ParseUint(clens[0], 10, 63);

                if (err == null) {
                    res.ContentLength = int64(cl);
                }
                else
 { 
                    // TODO: care? unlike http/1, it won't mess up our framing, so it's
                    // more safe smuggling-wise to ignore.
                }

            }
        }
        else if (len(clens) > 1) { 
            // TODO: care? unlike http/1, it won't mess up our framing, so it's
            // more safe smuggling-wise to ignore.
        }
        else if (f.StreamEnded() && !cs.isHead) {
            res.ContentLength = 0;
        }

    }

    if (cs.isHead) {
        res.Body = http2noBody;
        return (_addr_res!, error.As(null!)!);
    }
    if (f.StreamEnded()) {
        if (res.ContentLength > 0) {
            res.Body = new http2missingBody();
        }
        else
 {
            res.Body = http2noBody;
        }
        return (_addr_res!, error.As(null!)!);
    }
    cs.bufPipe.setBuffer(addr(new http2dataBuffer(expected:res.ContentLength)));
    cs.bytesRemain = res.ContentLength;
    res.Body = new http2transportResponseBody(cs);

    if (cs.requestedGzip && res.Header.Get("Content-Encoding") == "gzip") {
        res.Header.Del("Content-Encoding");
        res.Header.Del("Content-Length");
        res.ContentLength = -1;
        res.Body = addr(new http2gzipReader(body:res.Body));
        res.Uncompressed = true;
    }
    return (_addr_res!, error.As(null!)!);
}

private static error processTrailers(this ptr<http2clientConnReadLoop> _addr_rl, ptr<http2clientStream> _addr_cs, ptr<http2MetaHeadersFrame> _addr_f) {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;
    ref http2clientStream cs = ref _addr_cs.val;
    ref http2MetaHeadersFrame f = ref _addr_f.val;

    if (cs.pastTrailers) { 
        // Too many HEADERS frames for this stream.
        return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
    }
    cs.pastTrailers = true;
    if (!f.StreamEnded()) { 
        // We expect that any headers for trailers also
        // has END_STREAM.
        return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
    }
    if (len(f.PseudoFields()) > 0) { 
        // No pseudo header fields are defined for trailers.
        // TODO: ConnectionError might be overly harsh? Check.
        return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
    }
    var trailer = make(Header);
    foreach (var (_, hf) in f.RegularFields()) {
        var key = CanonicalHeaderKey(hf.Name);
        trailer[key] = append(trailer[key], hf.Value);
    }    cs.trailer = trailer;

    rl.endStream(cs);
    return error.As(null!)!;
}

// transportResponseBody is the concrete type of Transport.RoundTrip's
// Response.Body. It is an io.ReadCloser.
private partial struct http2transportResponseBody {
    public ptr<http2clientStream> cs;
}

private static (nint, error) Read(this http2transportResponseBody b, slice<byte> p) => func((defer, _, _) => {
    nint n = default;
    error err = default!;

    var cs = b.cs;
    var cc = cs.cc;

    if (cs.readErr != null) {
        return (0, error.As(cs.readErr)!);
    }
    n, err = b.cs.bufPipe.Read(p);
    if (cs.bytesRemain != -1) {
        if (int64(n) > cs.bytesRemain) {
            n = int(cs.bytesRemain);
            if (err == null) {
                err = errors.New("net/http: server replied with more than declared Content-Length; truncated");
                cs.abortStream(err);
            }
            cs.readErr = err;
            return (int(cs.bytesRemain), error.As(err)!);
        }
        cs.bytesRemain -= int64(n);
        if (err == io.EOF && cs.bytesRemain > 0) {
            err = io.ErrUnexpectedEOF;
            cs.readErr = err;
            return (n, error.As(err)!);
        }
    }
    if (n == 0) { 
        // No flow control tokens to send back.
        return ;
    }
    cc.mu.Lock();
    int connAdd = default;    int streamAdd = default; 
    // Check the conn-level first, before the stream-level.
 
    // Check the conn-level first, before the stream-level.
    {
        var v__prev1 = v;

        var v = cc.inflow.available();

        if (v < http2transportDefaultConnFlow / 2) {
            connAdd = http2transportDefaultConnFlow - v;
            cc.inflow.add(connAdd);
        }
        v = v__prev1;

    }
    if (err == null) { // No need to refresh if the stream is over or failed.
        // Consider any buffered body data (read from the conn but not
        // consumed by the client) when computing flow control for this
        // stream.
        v = int(cs.inflow.available()) + cs.bufPipe.Len();
        if (v < http2transportDefaultStreamFlow - http2transportDefaultStreamMinRefresh) {
            streamAdd = int32(http2transportDefaultStreamFlow - v);
            cs.inflow.add(streamAdd);
        }
    }
    cc.mu.Unlock();

    if (connAdd != 0 || streamAdd != 0) {
        cc.wmu.Lock();
        defer(cc.wmu.Unlock());
        if (connAdd != 0) {
            cc.fr.WriteWindowUpdate(0, http2mustUint31(connAdd));
        }
        if (streamAdd != 0) {
            cc.fr.WriteWindowUpdate(cs.ID, http2mustUint31(streamAdd));
        }
        cc.bw.Flush();
    }
    return ;
});

private static var http2errClosedResponseBody = errors.New("http2: response body closed");

private static error Close(this http2transportResponseBody b) {
    var cs = b.cs;
    var cc = cs.cc;

    var unread = cs.bufPipe.Len();
    if (unread > 0) {
        cc.mu.Lock(); 
        // Return connection-level flow control.
        if (unread > 0) {
            cc.inflow.add(int32(unread));
        }
        cc.mu.Unlock(); 

        // TODO(dneil): Acquiring this mutex can block indefinitely.
        // Move flow control return to a goroutine?
        cc.wmu.Lock(); 
        // Return connection-level flow control.
        if (unread > 0) {
            cc.fr.WriteWindowUpdate(0, uint32(unread));
        }
        cc.bw.Flush();
        cc.wmu.Unlock();
    }
    cs.bufPipe.BreakWithError(http2errClosedResponseBody);
    cs.abortStream(http2errClosedResponseBody);

    return error.As(cs.ctx.Err())!;
    return error.As(http2errRequestCanceled)!;
    return error.As(null!)!;
}

private static error processData(this ptr<http2clientConnReadLoop> _addr_rl, ptr<http2DataFrame> _addr_f) {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;
    ref http2DataFrame f = ref _addr_f.val;

    var cc = rl.cc;
    var cs = rl.streamByID(f.StreamID);
    var data = f.Data();
    if (cs == null) {
        cc.mu.Lock();
        var neverSent = cc.nextStreamID;
        cc.mu.Unlock();
        if (f.StreamID >= neverSent) { 
            // We never asked for this.
            cc.logf("http2: Transport received unsolicited DATA frame; closing connection");
            return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
        }
        if (f.Length > 0) {
            cc.mu.Lock();
            cc.inflow.add(int32(f.Length));
            cc.mu.Unlock();

            cc.wmu.Lock();
            cc.fr.WriteWindowUpdate(0, uint32(f.Length));
            cc.bw.Flush();
            cc.wmu.Unlock();
        }
        return error.As(null!)!;
    }
    if (cs.readClosed) {
        cc.logf("protocol error: received DATA after END_STREAM");
        rl.endStreamError(cs, new http2StreamError(StreamID:f.StreamID,Code:http2ErrCodeProtocol,));
        return error.As(null!)!;
    }
    if (!cs.firstByte) {
        cc.logf("protocol error: received DATA before a HEADERS frame");
        rl.endStreamError(cs, new http2StreamError(StreamID:f.StreamID,Code:http2ErrCodeProtocol,));
        return error.As(null!)!;
    }
    if (f.Length > 0) {
        if (cs.isHead && len(data) > 0) {
            cc.logf("protocol error: received DATA on a HEAD request");
            rl.endStreamError(cs, new http2StreamError(StreamID:f.StreamID,Code:http2ErrCodeProtocol,));
            return error.As(null!)!;
        }
        cc.mu.Lock();
        if (cs.inflow.available() >= int32(f.Length)) {
            cs.inflow.take(int32(f.Length));
        }
        else
 {
            cc.mu.Unlock();
            return error.As(http2ConnectionError(http2ErrCodeFlowControl))!;
        }
        nint refund = default;
        {
            var pad = int(f.Length) - len(data);

            if (pad > 0) {
                refund += pad;
            }

        }

        var didReset = false;
        error err = default!;
        if (len(data) > 0) {
            _, err = cs.bufPipe.Write(data);

            if (err != null) { 
                // Return len(data) now if the stream is already closed,
                // since data will never be read.
                didReset = true;
                refund += len(data);
            }
        }
        if (refund > 0) {
            cc.inflow.add(int32(refund));
            if (!didReset) {
                cs.inflow.add(int32(refund));
            }
        }
        cc.mu.Unlock();

        if (refund > 0) {
            cc.wmu.Lock();
            cc.fr.WriteWindowUpdate(0, uint32(refund));
            if (!didReset) {
                cc.fr.WriteWindowUpdate(cs.ID, uint32(refund));
            }
            cc.bw.Flush();
            cc.wmu.Unlock();
        }
        if (err != null) {
            rl.endStreamError(cs, err);
            return error.As(null!)!;
        }
    }
    if (f.StreamEnded()) {
        rl.endStream(cs);
    }
    return error.As(null!)!;
}

private static void endStream(this ptr<http2clientConnReadLoop> _addr_rl, ptr<http2clientStream> _addr_cs) {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;
    ref http2clientStream cs = ref _addr_cs.val;
 
    // TODO: check that any declared content-length matches, like
    // server.go's (*stream).endStream method.
    if (!cs.readClosed) {
        cs.readClosed = true;
        cs.bufPipe.closeWithErrorAndCode(io.EOF, cs.copyTrailers);
        close(cs.peerClosed);
    }
}

private static void endStreamError(this ptr<http2clientConnReadLoop> _addr_rl, ptr<http2clientStream> _addr_cs, error err) {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;
    ref http2clientStream cs = ref _addr_cs.val;

    cs.readAborted = true;
    cs.abortStream(err);
}

private static ptr<http2clientStream> streamByID(this ptr<http2clientConnReadLoop> _addr_rl, uint id) => func((defer, _, _) => {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;

    rl.cc.mu.Lock();
    defer(rl.cc.mu.Unlock());
    var cs = rl.cc.streams[id];
    if (cs != null && !cs.readAborted) {
        return _addr_cs!;
    }
    return _addr_null!;
});

private static void copyTrailers(this ptr<http2clientStream> _addr_cs) {
    ref http2clientStream cs = ref _addr_cs.val;

    foreach (var (k, vv) in cs.trailer) {
        var t = cs.resTrailer;
        if (t == null.val) {
            t.val = make(Header);
        }
        (t.val)[k] = vv;
    }
}

private static error processGoAway(this ptr<http2clientConnReadLoop> _addr_rl, ptr<http2GoAwayFrame> _addr_f) {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;
    ref http2GoAwayFrame f = ref _addr_f.val;

    var cc = rl.cc;
    cc.t.connPool().MarkDead(cc);
    if (f.ErrCode != 0) { 
        // TODO: deal with GOAWAY more. particularly the error code
        cc.vlogf("transport got GOAWAY with error code = %v", f.ErrCode);
    }
    cc.setGoAway(f);
    return error.As(null!)!;
}

private static error processSettings(this ptr<http2clientConnReadLoop> _addr_rl, ptr<http2SettingsFrame> _addr_f) => func((defer, _, _) => {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;
    ref http2SettingsFrame f = ref _addr_f.val;

    var cc = rl.cc; 
    // Locking both mu and wmu here allows frame encoding to read settings with only wmu held.
    // Acquiring wmu when f.IsAck() is unnecessary, but convenient and mostly harmless.
    cc.wmu.Lock();
    defer(cc.wmu.Unlock());

    {
        var err = rl.processSettingsNoWrite(f);

        if (err != null) {
            return error.As(err)!;
        }
    }
    if (!f.IsAck()) {
        cc.fr.WriteSettingsAck();
        cc.bw.Flush();
    }
    return error.As(null!)!;
});

private static error processSettingsNoWrite(this ptr<http2clientConnReadLoop> _addr_rl, ptr<http2SettingsFrame> _addr_f) => func((defer, _, _) => {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;
    ref http2SettingsFrame f = ref _addr_f.val;

    var cc = rl.cc;
    cc.mu.Lock();
    defer(cc.mu.Unlock());

    if (f.IsAck()) {
        if (cc.wantSettingsAck) {
            cc.wantSettingsAck = false;
            return error.As(null!)!;
        }
        return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
    }
    bool seenMaxConcurrentStreams = default;
    var err = f.ForeachSetting(s => {

        if (s.ID == http2SettingMaxFrameSize) 
            cc.maxFrameSize = s.Val;
        else if (s.ID == http2SettingMaxConcurrentStreams) 
            cc.maxConcurrentStreams = s.Val;
            seenMaxConcurrentStreams = true;
        else if (s.ID == http2SettingMaxHeaderListSize) 
            cc.peerMaxHeaderListSize = uint64(s.Val);
        else if (s.ID == http2SettingInitialWindowSize) 
            // Values above the maximum flow-control
            // window size of 2^31-1 MUST be treated as a
            // connection error (Section 5.4.1) of type
            // FLOW_CONTROL_ERROR.
            if (s.Val > math.MaxInt32) {
                return error.As(http2ConnectionError(http2ErrCodeFlowControl))!;
            } 

            // Adjust flow control of currently-open
            // frames by the difference of the old initial
            // window size and this one.
            var delta = int32(s.Val) - int32(cc.initialWindowSize);
            foreach (var (_, cs) in cc.streams) {
                cs.flow.add(delta);
            }
            cc.cond.Broadcast();

            cc.initialWindowSize = s.Val;
        else 
            // TODO(bradfitz): handle more settings? SETTINGS_HEADER_TABLE_SIZE probably.
            cc.vlogf("Unhandled Setting: %v", s);
                return error.As(null!)!;
    });
    if (err != null) {
        return error.As(err)!;
    }
    if (!cc.seenSettings) {
        if (!seenMaxConcurrentStreams) { 
            // This was the servers initial SETTINGS frame and it
            // didn't contain a MAX_CONCURRENT_STREAMS field so
            // increase the number of concurrent streams this
            // connection can establish to our default.
            cc.maxConcurrentStreams = http2defaultMaxConcurrentStreams;
        }
        cc.seenSettings = true;
    }
    return error.As(null!)!;
});

private static error processWindowUpdate(this ptr<http2clientConnReadLoop> _addr_rl, ptr<http2WindowUpdateFrame> _addr_f) => func((defer, _, _) => {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;
    ref http2WindowUpdateFrame f = ref _addr_f.val;

    var cc = rl.cc;
    var cs = rl.streamByID(f.StreamID);
    if (f.StreamID != 0 && cs == null) {
        return error.As(null!)!;
    }
    cc.mu.Lock();
    defer(cc.mu.Unlock());

    var fl = _addr_cc.flow;
    if (cs != null) {
        fl = _addr_cs.flow;
    }
    if (!fl.add(int32(f.Increment))) {
        return error.As(http2ConnectionError(http2ErrCodeFlowControl))!;
    }
    cc.cond.Broadcast();
    return error.As(null!)!;
});

private static error processResetStream(this ptr<http2clientConnReadLoop> _addr_rl, ptr<http2RSTStreamFrame> _addr_f) {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;
    ref http2RSTStreamFrame f = ref _addr_f.val;

    var cs = rl.streamByID(f.StreamID);
    if (cs == null) { 
        // TODO: return error if server tries to RST_STEAM an idle stream
        return error.As(null!)!;
    }
    var serr = http2streamError(cs.ID, f.ErrCode);
    serr.Cause = http2errFromPeer;
    if (f.ErrCode == http2ErrCodeProtocol) {
        rl.cc.SetDoNotReuse();
    }
    cs.abortStream(serr);

    cs.bufPipe.CloseWithError(serr);
    return error.As(null!)!;
}

// Ping sends a PING frame to the server and waits for the ack.
private static error Ping(this ptr<http2ClientConn> _addr_cc, context.Context ctx) => func((defer, _, _) => {
    ref http2ClientConn cc = ref _addr_cc.val;

    var c = make_channel<object>(); 
    // Generate a random payload
    array<byte> p = new array<byte>(8);
    while (true) {
        {
            var err__prev1 = err;

            var (_, err) = rand.Read(p[..]);

            if (err != null) {
                return error.As(err)!;
            }

            err = err__prev1;

        }
        cc.mu.Lock(); 
        // check for dup before insert
        {
            var (_, found) = cc.pings[p];

            if (!found) {
                cc.pings[p] = c;
                cc.mu.Unlock();
                break;
            }

        }
        cc.mu.Unlock();
    }
    var errc = make_channel<error>(1);
    go_(() => () => {
        cc.wmu.Lock();
        defer(cc.wmu.Unlock());
        {
            var err__prev1 = err;

            var err = cc.fr.WritePing(false, p);

            if (err != null) {
                errc.Send(err);
                return ;
            }

            err = err__prev1;

        }
        {
            var err__prev1 = err;

            err = cc.bw.Flush();

            if (err != null) {
                errc.Send(err);
                return ;
            }

            err = err__prev1;

        }
    }());
    return error.As(null!)!;
    return error.As(err)!;
    return error.As(ctx.Err())!;
    return error.As(cc.readerErr)!;
});

private static error processPing(this ptr<http2clientConnReadLoop> _addr_rl, ptr<http2PingFrame> _addr_f) => func((defer, _, _) => {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;
    ref http2PingFrame f = ref _addr_f.val;

    if (f.IsAck()) {
        var cc = rl.cc;
        cc.mu.Lock();
        defer(cc.mu.Unlock()); 
        // If ack, notify listener if any
        {
            var (c, ok) = cc.pings[f.Data];

            if (ok) {
                close(c);
                delete(cc.pings, f.Data);
            }

        }
        return error.As(null!)!;
    }
    cc = rl.cc;
    cc.wmu.Lock();
    defer(cc.wmu.Unlock());
    {
        var err = cc.fr.WritePing(true, f.Data);

        if (err != null) {
            return error.As(err)!;
        }
    }
    return error.As(cc.bw.Flush())!;
});

private static error processPushPromise(this ptr<http2clientConnReadLoop> _addr_rl, ptr<http2PushPromiseFrame> _addr_f) {
    ref http2clientConnReadLoop rl = ref _addr_rl.val;
    ref http2PushPromiseFrame f = ref _addr_f.val;
 
    // We told the peer we don't want them.
    // Spec says:
    // "PUSH_PROMISE MUST NOT be sent if the SETTINGS_ENABLE_PUSH
    // setting of the peer endpoint is set to 0. An endpoint that
    // has set this setting and has received acknowledgement MUST
    // treat the receipt of a PUSH_PROMISE frame as a connection
    // error (Section 5.4.1) of type PROTOCOL_ERROR."
    return error.As(http2ConnectionError(http2ErrCodeProtocol))!;
}

private static void writeStreamReset(this ptr<http2ClientConn> _addr_cc, uint streamID, http2ErrCode code, error err) {
    ref http2ClientConn cc = ref _addr_cc.val;
 
    // TODO: map err to more interesting error codes, once the
    // HTTP community comes up with some. But currently for
    // RST_STREAM there's no equivalent to GOAWAY frame's debug
    // data, and the error codes are all pretty vague ("cancel").
    cc.wmu.Lock();
    cc.fr.WriteRSTStream(streamID, code);
    cc.bw.Flush();
    cc.wmu.Unlock();
}

private static var http2errResponseHeaderListSize = errors.New("http2: response header list larger than advertised limit");private static var http2errRequestHeaderListSize = errors.New("http2: request header list larger than peer's advertised limit");

private static void logf(this ptr<http2ClientConn> _addr_cc, @string format, params object[] args) {
    args = args.Clone();
    ref http2ClientConn cc = ref _addr_cc.val;

    cc.t.logf(format, args);
}

private static void vlogf(this ptr<http2ClientConn> _addr_cc, @string format, params object[] args) {
    args = args.Clone();
    ref http2ClientConn cc = ref _addr_cc.val;

    cc.t.vlogf(format, args);
}

private static void vlogf(this ptr<http2Transport> _addr_t, @string format, params object[] args) {
    args = args.Clone();
    ref http2Transport t = ref _addr_t.val;

    if (http2VerboseLogs) {
        t.logf(format, args);
    }
}

private static void logf(this ptr<http2Transport> _addr_t, @string format, params object[] args) {
    args = args.Clone();
    ref http2Transport t = ref _addr_t.val;

    log.Printf(format, args);
}

private static io.ReadCloser http2noBody = ioutil.NopCloser(bytes.NewReader(null));

private partial struct http2missingBody {
}

private static error Close(this http2missingBody _p0) {
    return error.As(null!)!;
}

private static (nint, error) Read(this http2missingBody _p0, slice<byte> _p0) {
    nint _p0 = default;
    error _p0 = default!;

    return (0, error.As(io.ErrUnexpectedEOF)!);
}

private static bool http2strSliceContains(slice<@string> ss, @string s) {
    foreach (var (_, v) in ss) {
        if (v == s) {
            return true;
        }
    }    return false;
}

private partial struct http2erringRoundTripper {
    public error err;
}

private static error RoundTripErr(this http2erringRoundTripper rt) {
    return error.As(rt.err)!;
}

private static (ptr<Response>, error) RoundTrip(this http2erringRoundTripper rt, ptr<Request> _addr__p0) {
    ptr<Response> _p0 = default!;
    error _p0 = default!;
    ref Request _p0 = ref _addr__p0.val;

    return (_addr_null!, error.As(rt.err)!);
}

// gzipReader wraps a response body so it can lazily
// call gzip.NewReader on the first call to Read
private partial struct http2gzipReader {
    public http2incomparable _;
    public io.ReadCloser body; // underlying Response.Body
    public ptr<gzip.Reader> zr; // lazily-initialized gzip reader
    public error zerr; // sticky error
}

private static (nint, error) Read(this ptr<http2gzipReader> _addr_gz, slice<byte> p) {
    nint n = default;
    error err = default!;
    ref http2gzipReader gz = ref _addr_gz.val;

    if (gz.zerr != null) {
        return (0, error.As(gz.zerr)!);
    }
    if (gz.zr == null) {
        gz.zr, err = gzip.NewReader(gz.body);
        if (err != null) {
            gz.zerr = err;
            return (0, error.As(err)!);
        }
    }
    return gz.zr.Read(p);
}

private static error Close(this ptr<http2gzipReader> _addr_gz) {
    ref http2gzipReader gz = ref _addr_gz.val;

    return error.As(gz.body.Close())!;
}

private partial struct http2errorReader {
    public error err;
}

private static (nint, error) Read(this http2errorReader r, slice<byte> p) {
    nint _p0 = default;
    error _p0 = default!;

    return (0, error.As(r.err)!);
}

// isConnectionCloseRequest reports whether req should use its own
// connection for a single request and then close the connection.
private static bool http2isConnectionCloseRequest(ptr<Request> _addr_req) {
    ref Request req = ref _addr_req.val;

    return req.Close || httpguts.HeaderValuesContainsToken(req.Header["Connection"], "close");
}

// registerHTTPSProtocol calls Transport.RegisterProtocol but
// converting panics into errors.
private static error http2registerHTTPSProtocol(ptr<Transport> _addr_t, http2noDialH2RoundTripper rt) => func((defer, _, _) => {
    error err = default!;
    ref Transport t = ref _addr_t.val;

    defer(() => {
        {
            var e = recover();

            if (e != null) {
                err = fmt.Errorf("%v", e);
            }

        }
    }());
    t.RegisterProtocol("https", rt);
    return error.As(null!)!;
});

// noDialH2RoundTripper is a RoundTripper which only tries to complete the request
// if there's already has a cached connection to the host.
// (The field is exported so it can be accessed via reflect from net/http; tested
// by TestNoDialH2RoundTripperType)
private partial struct http2noDialH2RoundTripper {
    public ref ptr<http2Transport> ptr<http2Transport> => ref ptr<http2Transport>_ptr;
}

private static (ptr<Response>, error) RoundTrip(this http2noDialH2RoundTripper rt, ptr<Request> _addr_req) {
    ptr<Response> _p0 = default!;
    error _p0 = default!;
    ref Request req = ref _addr_req.val;

    var (res, err) = rt.http2Transport.RoundTrip(req);
    if (http2isNoCachedConnError(err)) {
        return (_addr_null!, error.As(ErrSkipAltProtocol)!);
    }
    return (_addr_res!, error.As(err)!);
}

private static time.Duration idleConnTimeout(this ptr<http2Transport> _addr_t) {
    ref http2Transport t = ref _addr_t.val;

    if (t.t1 != null) {
        return t.t1.IdleConnTimeout;
    }
    return 0;
}

private static void http2traceGetConn(ptr<Request> _addr_req, @string hostPort) {
    ref Request req = ref _addr_req.val;

    var trace = httptrace.ContextClientTrace(req.Context());
    if (trace == null || trace.GetConn == null) {
        return ;
    }
    trace.GetConn(hostPort);
}

private static void http2traceGotConn(ptr<Request> _addr_req, ptr<http2ClientConn> _addr_cc, bool reused) {
    ref Request req = ref _addr_req.val;
    ref http2ClientConn cc = ref _addr_cc.val;

    var trace = httptrace.ContextClientTrace(req.Context());
    if (trace == null || trace.GotConn == null) {
        return ;
    }
    httptrace.GotConnInfo ci = new httptrace.GotConnInfo(Conn:cc.tconn);
    ci.Reused = reused;
    cc.mu.Lock();
    ci.WasIdle = len(cc.streams) == 0 && reused;
    if (ci.WasIdle && !cc.lastActive.IsZero()) {
        ci.IdleTime = time.Now().Sub(cc.lastActive);
    }
    cc.mu.Unlock();

    trace.GotConn(ci);
}

private static void http2traceWroteHeaders(ptr<httptrace.ClientTrace> _addr_trace) {
    ref httptrace.ClientTrace trace = ref _addr_trace.val;

    if (trace != null && trace.WroteHeaders != null) {
        trace.WroteHeaders();
    }
}

private static void http2traceGot100Continue(ptr<httptrace.ClientTrace> _addr_trace) {
    ref httptrace.ClientTrace trace = ref _addr_trace.val;

    if (trace != null && trace.Got100Continue != null) {
        trace.Got100Continue();
    }
}

private static void http2traceWait100Continue(ptr<httptrace.ClientTrace> _addr_trace) {
    ref httptrace.ClientTrace trace = ref _addr_trace.val;

    if (trace != null && trace.Wait100Continue != null) {
        trace.Wait100Continue();
    }
}

private static void http2traceWroteRequest(ptr<httptrace.ClientTrace> _addr_trace, error err) {
    ref httptrace.ClientTrace trace = ref _addr_trace.val;

    if (trace != null && trace.WroteRequest != null) {
        trace.WroteRequest(new httptrace.WroteRequestInfo(Err:err));
    }
}

private static void http2traceFirstResponseByte(ptr<httptrace.ClientTrace> _addr_trace) {
    ref httptrace.ClientTrace trace = ref _addr_trace.val;

    if (trace != null && trace.GotFirstResponseByte != null) {
        trace.GotFirstResponseByte();
    }
}

// writeFramer is implemented by any type that is used to write frames.
private partial interface http2writeFramer {
    bool writeFrame(http2writeContext _p0); // staysWithinBuffer reports whether this writer promises that
// it will only write less than or equal to size bytes, and it
// won't Flush the write context.
    bool staysWithinBuffer(nint size);
}

// writeContext is the interface needed by the various frame writer
// types below. All the writeFrame methods below are scheduled via the
// frame writing scheduler (see writeScheduler in writesched.go).
//
// This interface is implemented by *serverConn.
//
// TODO: decide whether to a) use this in the client code (which didn't
// end up using this yet, because it has a simpler design, not
// currently implementing priorities), or b) delete this and
// make the server code a bit more concrete.
private partial interface http2writeContext {
    (ptr<hpack.Encoder>, ptr<bytes.Buffer>) Framer();
    (ptr<hpack.Encoder>, ptr<bytes.Buffer>) Flush();
    (ptr<hpack.Encoder>, ptr<bytes.Buffer>) CloseConn(); // HeaderEncoder returns an HPACK encoder that writes to the
// returned buffer.
    (ptr<hpack.Encoder>, ptr<bytes.Buffer>) HeaderEncoder();
}

// writeEndsStream reports whether w writes a frame that will transition
// the stream to a half-closed local state. This returns false for RST_STREAM,
// which closes the entire stream (not just the local half).
private static bool http2writeEndsStream(http2writeFramer w) => func((_, panic, _) => {
    switch (w.type()) {
        case ptr<http2writeData> v:
            return v.endStream;
            break;
        case ptr<http2writeResHeaders> v:
            return v.endStream;
            break;
        case 
            panic("writeEndsStream called on nil writeFramer");
            break;
    }
    return false;
});

private partial struct http2flushFrameWriter {
}

private static error writeFrame(this http2flushFrameWriter _p0, http2writeContext ctx) {
    return error.As(ctx.Flush())!;
}

private static bool staysWithinBuffer(this http2flushFrameWriter _p0, nint max) {
    return false;
}

private partial struct http2writeSettings { // : slice<http2Setting>
}

private static bool staysWithinBuffer(this http2writeSettings s, nint max) {
    const nint settingSize = 6; // uint16 + uint32
 // uint16 + uint32
    return http2frameHeaderLen + settingSize * len(s) <= max;
}

private static error writeFrame(this http2writeSettings s, http2writeContext ctx) {
    return error.As(ctx.Framer().WriteSettings((slice<http2Setting>)s))!;
}

private partial struct http2writeGoAway {
    public uint maxStreamID;
    public http2ErrCode code;
}

private static error writeFrame(this ptr<http2writeGoAway> _addr_p, http2writeContext ctx) {
    ref http2writeGoAway p = ref _addr_p.val;

    var err = ctx.Framer().WriteGoAway(p.maxStreamID, p.code, null);
    ctx.Flush(); // ignore error: we're hanging up on them anyway
    return error.As(err)!;
}

private static bool staysWithinBuffer(this ptr<http2writeGoAway> _addr__p0, nint max) {
    ref http2writeGoAway _p0 = ref _addr__p0.val;

    return false;
} // flushes

private partial struct http2writeData {
    public uint streamID;
    public slice<byte> p;
    public bool endStream;
}

private static @string String(this ptr<http2writeData> _addr_w) {
    ref http2writeData w = ref _addr_w.val;

    return fmt.Sprintf("writeData(stream=%d, p=%d, endStream=%v)", w.streamID, len(w.p), w.endStream);
}

private static error writeFrame(this ptr<http2writeData> _addr_w, http2writeContext ctx) {
    ref http2writeData w = ref _addr_w.val;

    return error.As(ctx.Framer().WriteData(w.streamID, w.endStream, w.p))!;
}

private static bool staysWithinBuffer(this ptr<http2writeData> _addr_w, nint max) {
    ref http2writeData w = ref _addr_w.val;

    return http2frameHeaderLen + len(w.p) <= max;
}

// handlerPanicRST is the message sent from handler goroutines when
// the handler panics.
private partial struct http2handlerPanicRST {
    public uint StreamID;
}

private static error writeFrame(this http2handlerPanicRST hp, http2writeContext ctx) {
    return error.As(ctx.Framer().WriteRSTStream(hp.StreamID, http2ErrCodeInternal))!;
}

private static bool staysWithinBuffer(this http2handlerPanicRST hp, nint max) {
    return http2frameHeaderLen + 4 <= max;
}

private static error writeFrame(this http2StreamError se, http2writeContext ctx) {
    return error.As(ctx.Framer().WriteRSTStream(se.StreamID, se.Code))!;
}

private static bool staysWithinBuffer(this http2StreamError se, nint max) {
    return http2frameHeaderLen + 4 <= max;
}

private partial struct http2writePingAck {
    public ptr<http2PingFrame> pf;
}

private static error writeFrame(this http2writePingAck w, http2writeContext ctx) {
    return error.As(ctx.Framer().WritePing(true, w.pf.Data))!;
}

private static bool staysWithinBuffer(this http2writePingAck w, nint max) {
    return http2frameHeaderLen + len(w.pf.Data) <= max;
}

private partial struct http2writeSettingsAck {
}

private static error writeFrame(this http2writeSettingsAck _p0, http2writeContext ctx) {
    return error.As(ctx.Framer().WriteSettingsAck())!;
}

private static bool staysWithinBuffer(this http2writeSettingsAck _p0, nint max) {
    return http2frameHeaderLen <= max;
}

// splitHeaderBlock splits headerBlock into fragments so that each fragment fits
// in a single frame, then calls fn for each fragment. firstFrag/lastFrag are true
// for the first/last fragment, respectively.
private static error http2splitHeaderBlock(http2writeContext ctx, slice<byte> headerBlock, Func<http2writeContext, slice<byte>, bool, bool, error> fn) { 
    // For now we're lazy and just pick the minimum MAX_FRAME_SIZE
    // that all peers must support (16KB). Later we could care
    // more and send larger frames if the peer advertised it, but
    // there's little point. Most headers are small anyway (so we
    // generally won't have CONTINUATION frames), and extra frames
    // only waste 9 bytes anyway.
    const nint maxFrameSize = 16384;



    var first = true;
    while (len(headerBlock) > 0) {
        var frag = headerBlock;
        if (len(frag) > maxFrameSize) {
            frag = frag[..(int)maxFrameSize];
        }
        headerBlock = headerBlock[(int)len(frag)..];
        {
            var err = fn(ctx, frag, first, len(headerBlock) == 0);

            if (err != null) {
                return error.As(err)!;
            }

        }
        first = false;
    }
    return error.As(null!)!;
}

// writeResHeaders is a request to write a HEADERS and 0+ CONTINUATION frames
// for HTTP response headers or trailers from a server handler.
private partial struct http2writeResHeaders {
    public uint streamID;
    public nint httpResCode; // 0 means no ":status" line
    public Header h; // may be nil
    public slice<@string> trailers; // if non-nil, which keys of h to write. nil means all.
    public bool endStream;
    public @string date;
    public @string contentType;
    public @string contentLength;
}

private static void http2encKV(ptr<hpack.Encoder> _addr_enc, @string k, @string v) {
    ref hpack.Encoder enc = ref _addr_enc.val;

    if (http2VerboseLogs) {
        log.Printf("http2: server encoding header %q = %q", k, v);
    }
    enc.WriteField(new hpack.HeaderField(Name:k,Value:v));
}

private static bool staysWithinBuffer(this ptr<http2writeResHeaders> _addr_w, nint max) {
    ref http2writeResHeaders w = ref _addr_w.val;
 
    // TODO: this is a common one. It'd be nice to return true
    // here and get into the fast path if we could be clever and
    // calculate the size fast enough, or at least a conservative
    // upper bound that usually fires. (Maybe if w.h and
    // w.trailers are nil, so we don't need to enumerate it.)
    // Otherwise I'm afraid that just calculating the length to
    // answer this question would be slower than the ~2s benefit.
    return false;
}

private static error writeFrame(this ptr<http2writeResHeaders> _addr_w, http2writeContext ctx) => func((_, panic, _) => {
    ref http2writeResHeaders w = ref _addr_w.val;

    var (enc, buf) = ctx.HeaderEncoder();
    buf.Reset();

    if (w.httpResCode != 0) {
        http2encKV(_addr_enc, ":status", http2httpCodeString(w.httpResCode));
    }
    http2encodeHeaders(_addr_enc, w.h, w.trailers);

    if (w.contentType != "") {
        http2encKV(_addr_enc, "content-type", w.contentType);
    }
    if (w.contentLength != "") {
        http2encKV(_addr_enc, "content-length", w.contentLength);
    }
    if (w.date != "") {
        http2encKV(_addr_enc, "date", w.date);
    }
    var headerBlock = buf.Bytes();
    if (len(headerBlock) == 0 && w.trailers == null) {
        panic("unexpected empty hpack");
    }
    return error.As(http2splitHeaderBlock(ctx, headerBlock, w.writeHeaderBlock))!;
});

private static error writeHeaderBlock(this ptr<http2writeResHeaders> _addr_w, http2writeContext ctx, slice<byte> frag, bool firstFrag, bool lastFrag) {
    ref http2writeResHeaders w = ref _addr_w.val;

    if (firstFrag) {
        return error.As(ctx.Framer().WriteHeaders(new http2HeadersFrameParam(StreamID:w.streamID,BlockFragment:frag,EndStream:w.endStream,EndHeaders:lastFrag,)))!;
    }
    else
 {
        return error.As(ctx.Framer().WriteContinuation(w.streamID, lastFrag, frag))!;
    }
}

// writePushPromise is a request to write a PUSH_PROMISE and 0+ CONTINUATION frames.
private partial struct http2writePushPromise {
    public uint streamID; // pusher stream
    public @string method; // for :method
    public ptr<url.URL> url; // for :scheme, :authority, :path
    public Header h; // Creates an ID for a pushed stream. This runs on serveG just before
// the frame is written. The returned ID is copied to promisedID.
    public Func<(uint, error)> allocatePromisedID;
    public uint promisedID;
}

private static bool staysWithinBuffer(this ptr<http2writePushPromise> _addr_w, nint max) {
    ref http2writePushPromise w = ref _addr_w.val;
 
    // TODO: see writeResHeaders.staysWithinBuffer
    return false;
}

private static error writeFrame(this ptr<http2writePushPromise> _addr_w, http2writeContext ctx) => func((_, panic, _) => {
    ref http2writePushPromise w = ref _addr_w.val;

    var (enc, buf) = ctx.HeaderEncoder();
    buf.Reset();

    http2encKV(_addr_enc, ":method", w.method);
    http2encKV(_addr_enc, ":scheme", w.url.Scheme);
    http2encKV(_addr_enc, ":authority", w.url.Host);
    http2encKV(_addr_enc, ":path", w.url.RequestURI());
    http2encodeHeaders(_addr_enc, w.h, null);

    var headerBlock = buf.Bytes();
    if (len(headerBlock) == 0) {
        panic("unexpected empty hpack");
    }
    return error.As(http2splitHeaderBlock(ctx, headerBlock, w.writeHeaderBlock))!;
});

private static error writeHeaderBlock(this ptr<http2writePushPromise> _addr_w, http2writeContext ctx, slice<byte> frag, bool firstFrag, bool lastFrag) {
    ref http2writePushPromise w = ref _addr_w.val;

    if (firstFrag) {
        return error.As(ctx.Framer().WritePushPromise(new http2PushPromiseParam(StreamID:w.streamID,PromiseID:w.promisedID,BlockFragment:frag,EndHeaders:lastFrag,)))!;
    }
    else
 {
        return error.As(ctx.Framer().WriteContinuation(w.streamID, lastFrag, frag))!;
    }
}

private partial struct http2write100ContinueHeadersFrame {
    public uint streamID;
}

private static error writeFrame(this http2write100ContinueHeadersFrame w, http2writeContext ctx) {
    var (enc, buf) = ctx.HeaderEncoder();
    buf.Reset();
    http2encKV(_addr_enc, ":status", "100");
    return error.As(ctx.Framer().WriteHeaders(new http2HeadersFrameParam(StreamID:w.streamID,BlockFragment:buf.Bytes(),EndStream:false,EndHeaders:true,)))!;
}

private static bool staysWithinBuffer(this http2write100ContinueHeadersFrame w, nint max) { 
    // Sloppy but conservative:
    return 9 + 2 * (len(":status") + len("100")) <= max;
}

private partial struct http2writeWindowUpdate {
    public uint streamID; // or 0 for conn-level
    public uint n;
}

private static bool staysWithinBuffer(this http2writeWindowUpdate wu, nint max) {
    return http2frameHeaderLen + 4 <= max;
}

private static error writeFrame(this http2writeWindowUpdate wu, http2writeContext ctx) {
    return error.As(ctx.Framer().WriteWindowUpdate(wu.streamID, wu.n))!;
}

// encodeHeaders encodes an http.Header. If keys is not nil, then (k, h[k])
// is encoded only if k is in keys.
private static void http2encodeHeaders(ptr<hpack.Encoder> _addr_enc, Header h, slice<@string> keys) => func((defer, _, _) => {
    ref hpack.Encoder enc = ref _addr_enc.val;

    if (keys == null) {
        ptr<http2sorter> sorter = http2sorterPool.Get()._<ptr<http2sorter>>(); 
        // Using defer here, since the returned keys from the
        // sorter.Keys method is only valid until the sorter
        // is returned:
        defer(http2sorterPool.Put(sorter));
        keys = sorter.Keys(h);
    }
    {
        var k__prev1 = k;

        foreach (var (_, __k) in keys) {
            k = __k;
            var vv = h[k];
            var (k, ascii) = http2lowerHeader(k);
            if (!ascii) { 
                // Skip writing invalid headers. Per RFC 7540, Section 8.1.2, header
                // field names have to be ASCII characters (just as in HTTP/1.x).
                continue;
            }
            if (!http2validWireHeaderFieldName(k)) { 
                // Skip it as backup paranoia. Per
                // golang.org/issue/14048, these should
                // already be rejected at a higher level.
                continue;
            }
            var isTE = k == "transfer-encoding";
            foreach (var (_, v) in vv) {
                if (!httpguts.ValidHeaderFieldValue(v)) { 
                    // TODO: return an error? golang.org/issue/14048
                    // For now just omit it.
                    continue;
                } 
                // TODO: more of "8.1.2.2 Connection-Specific Header Fields"
                if (isTE && v != "trailers") {
                    continue;
                }
                http2encKV(_addr_enc, k, v);
            }
        }
        k = k__prev1;
    }
});

// WriteScheduler is the interface implemented by HTTP/2 write schedulers.
// Methods are never called concurrently.
private partial interface http2WriteScheduler {
    (http2FrameWriteRequest, bool) OpenStream(uint streamID, http2OpenStreamOptions options); // CloseStream closes a stream in the write scheduler. Any frames queued on
// this stream should be discarded. It is illegal to call this on a stream
// that is not open -- the call may panic.
    (http2FrameWriteRequest, bool) CloseStream(uint streamID); // AdjustStream adjusts the priority of the given stream. This may be called
// on a stream that has not yet been opened or has been closed. Note that
// RFC 7540 allows PRIORITY frames to be sent on streams in any state. See:
// https://tools.ietf.org/html/rfc7540#section-5.1
    (http2FrameWriteRequest, bool) AdjustStream(uint streamID, http2PriorityParam priority); // Push queues a frame in the scheduler. In most cases, this will not be
// called with wr.StreamID()!=0 unless that stream is currently open. The one
// exception is RST_STREAM frames, which may be sent on idle or closed streams.
    (http2FrameWriteRequest, bool) Push(http2FrameWriteRequest wr); // Pop dequeues the next frame to write. Returns false if no frames can
// be written. Frames with a given wr.StreamID() are Pop'd in the same
// order they are Push'd. No frames should be discarded except by CloseStream.
    (http2FrameWriteRequest, bool) Pop();
}

// OpenStreamOptions specifies extra options for WriteScheduler.OpenStream.
private partial struct http2OpenStreamOptions {
    public uint PusherID;
}

// FrameWriteRequest is a request to write a frame.
private partial struct http2FrameWriteRequest {
    public http2writeFramer write; // stream is the stream on which this frame will be written.
// nil for non-stream frames like PING and SETTINGS.
    public ptr<http2stream> stream; // done, if non-nil, must be a buffered channel with space for
// 1 message and is sent the return value from write (or an
// earlier error) when the frame has been written.
    public channel<error> done;
}

// StreamID returns the id of the stream this frame will be written to.
// 0 is used for non-stream frames such as PING and SETTINGS.
private static uint StreamID(this http2FrameWriteRequest wr) {
    if (wr.stream == null) {
        {
            http2StreamError (se, ok) = wr.write._<http2StreamError>();

            if (ok) { 
                // (*serverConn).resetStream doesn't set
                // stream because it doesn't necessarily have
                // one. So special case this type of write
                // message.
                return se.StreamID;
            }

        }
        return 0;
    }
    return wr.stream.id;
}

// isControl reports whether wr is a control frame for MaxQueuedControlFrames
// purposes. That includes non-stream frames and RST_STREAM frames.
private static bool isControl(this http2FrameWriteRequest wr) {
    return wr.stream == null;
}

// DataSize returns the number of flow control bytes that must be consumed
// to write this entire frame. This is 0 for non-DATA frames.
private static nint DataSize(this http2FrameWriteRequest wr) {
    {
        ptr<http2writeData> (wd, ok) = wr.write._<ptr<http2writeData>>();

        if (ok) {
            return len(wd.p);
        }
    }
    return 0;
}

// Consume consumes min(n, available) bytes from this frame, where available
// is the number of flow control bytes available on the stream. Consume returns
// 0, 1, or 2 frames, where the integer return value gives the number of frames
// returned.
//
// If flow control prevents consuming any bytes, this returns (_, _, 0). If
// the entire frame was consumed, this returns (wr, _, 1). Otherwise, this
// returns (consumed, rest, 2), where 'consumed' contains the consumed bytes and
// 'rest' contains the remaining bytes. The consumed bytes are deducted from the
// underlying stream's flow control budget.
private static (http2FrameWriteRequest, http2FrameWriteRequest, nint) Consume(this http2FrameWriteRequest wr, int n) {
    http2FrameWriteRequest _p0 = default;
    http2FrameWriteRequest _p0 = default;
    nint _p0 = default;

    http2FrameWriteRequest empty = default; 

    // Non-DATA frames are always consumed whole.
    ptr<http2writeData> (wd, ok) = wr.write._<ptr<http2writeData>>();
    if (!ok || len(wd.p) == 0) {
        return (wr, empty, 1);
    }
    var allowed = wr.stream.flow.available();
    if (n < allowed) {
        allowed = n;
    }
    if (wr.stream.sc.maxFrameSize < allowed) {
        allowed = wr.stream.sc.maxFrameSize;
    }
    if (allowed <= 0) {
        return (empty, empty, 0);
    }
    if (len(wd.p) > int(allowed)) {
        wr.stream.flow.take(allowed);
        http2FrameWriteRequest consumed = new http2FrameWriteRequest(stream:wr.stream,write:&http2writeData{streamID:wd.streamID,p:wd.p[:allowed],endStream:false,},done:nil,);
        http2FrameWriteRequest rest = new http2FrameWriteRequest(stream:wr.stream,write:&http2writeData{streamID:wd.streamID,p:wd.p[allowed:],endStream:wd.endStream,},done:wr.done,);
        return (consumed, rest, 2);
    }
    wr.stream.flow.take(int32(len(wd.p)));
    return (wr, empty, 1);
}

// String is for debugging only.
private static @string String(this http2FrameWriteRequest wr) {
    @string des = default;
    {
        fmt.Stringer (s, ok) = wr.write._<fmt.Stringer>();

        if (ok) {
            des = s.String();
        }
        else
 {
            des = fmt.Sprintf("%T", wr.write);
        }
    }
    return fmt.Sprintf("[FrameWriteRequest stream=%d, ch=%v, writer=%v]", wr.StreamID(), wr.done != null, des);
}

// replyToWriter sends err to wr.done and panics if the send must block
// This does nothing if wr.done is nil.
private static void replyToWriter(this ptr<http2FrameWriteRequest> _addr_wr, error err) => func((_, panic, _) => {
    ref http2FrameWriteRequest wr = ref _addr_wr.val;

    if (wr.done == null) {
        return ;
    }
    panic(fmt.Sprintf("unbuffered done channel passed in for type %T", wr.write));
    wr.write = null; // prevent use (assume it's tainted after wr.done send)
});

// writeQueue is used by implementations of WriteScheduler.
private partial struct http2writeQueue {
    public slice<http2FrameWriteRequest> s;
}

private static bool empty(this ptr<http2writeQueue> _addr_q) {
    ref http2writeQueue q = ref _addr_q.val;

    return len(q.s) == 0;
}

private static void push(this ptr<http2writeQueue> _addr_q, http2FrameWriteRequest wr) {
    ref http2writeQueue q = ref _addr_q.val;

    q.s = append(q.s, wr);
}

private static http2FrameWriteRequest shift(this ptr<http2writeQueue> _addr_q) => func((_, panic, _) => {
    ref http2writeQueue q = ref _addr_q.val;

    if (len(q.s) == 0) {
        panic("invalid use of queue");
    }
    var wr = q.s[0]; 
    // TODO: less copy-happy queue.
    copy(q.s, q.s[(int)1..]);
    q.s[len(q.s) - 1] = new http2FrameWriteRequest();
    q.s = q.s[..(int)len(q.s) - 1];
    return wr;
});

// consume consumes up to n bytes from q.s[0]. If the frame is
// entirely consumed, it is removed from the queue. If the frame
// is partially consumed, the frame is kept with the consumed
// bytes removed. Returns true iff any bytes were consumed.
private static (http2FrameWriteRequest, bool) consume(this ptr<http2writeQueue> _addr_q, int n) {
    http2FrameWriteRequest _p0 = default;
    bool _p0 = default;
    ref http2writeQueue q = ref _addr_q.val;

    if (len(q.s) == 0) {
        return (new http2FrameWriteRequest(), false);
    }
    var (consumed, rest, numresult) = q.s[0].Consume(n);
    switch (numresult) {
        case 0: 
            return (new http2FrameWriteRequest(), false);
            break;
        case 1: 
            q.shift();
            break;
        case 2: 
            q.s[0] = rest;
            break;
    }
    return (consumed, true);
}

private partial struct http2writeQueuePool { // : slice<ptr<http2writeQueue>>
}

// put inserts an unused writeQueue into the pool.

// put inserts an unused writeQueue into the pool.
private static void put(this ptr<http2writeQueuePool> _addr_p, ptr<http2writeQueue> _addr_q) {
    ref http2writeQueuePool p = ref _addr_p.val;
    ref http2writeQueue q = ref _addr_q.val;

    foreach (var (i) in q.s) {
        q.s[i] = new http2FrameWriteRequest();
    }    q.s = q.s[..(int)0];
    p.val = append(p.val, q);
}

// get returns an empty writeQueue.
private static ptr<http2writeQueue> get(this ptr<http2writeQueuePool> _addr_p) {
    ref http2writeQueuePool p = ref _addr_p.val;

    var ln = len(p.val);
    if (ln == 0) {
        return @new<http2writeQueue>();
    }
    var x = ln - 1;
    var q = (p.val)[x];
    (p.val)[x] = null;
    p.val = (p.val)[..(int)x];
    return _addr_q!;
}

// RFC 7540, Section 5.3.5: the default weight is 16.
private static readonly nint http2priorityDefaultWeight = 15; // 16 = 15 + 1

// PriorityWriteSchedulerConfig configures a priorityWriteScheduler.
 // 16 = 15 + 1

// PriorityWriteSchedulerConfig configures a priorityWriteScheduler.
private partial struct http2PriorityWriteSchedulerConfig {
    public nint MaxClosedNodesInTree; // MaxIdleNodesInTree controls the maximum number of idle streams to
// retain in the priority tree. Setting this to zero saves a small amount
// of memory at the cost of performance.
//
// See RFC 7540, Section 5.3.4:
//   Similarly, streams that are in the "idle" state can be assigned
//   priority or become a parent of other streams. This allows for the
//   creation of a grouping node in the dependency tree, which enables
//   more flexible expressions of priority. Idle streams begin with a
//   default priority (Section 5.3.5).
    public nint MaxIdleNodesInTree; // ThrottleOutOfOrderWrites enables write throttling to help ensure that
// data is delivered in priority order. This works around a race where
// stream B depends on stream A and both streams are about to call Write
// to queue DATA frames. If B wins the race, a naive scheduler would eagerly
// write as much data from B as possible, but this is suboptimal because A
// is a higher-priority stream. With throttling enabled, we write a small
// amount of data from B to minimize the amount of bandwidth that B can
// steal from A.
    public bool ThrottleOutOfOrderWrites;
}

// NewPriorityWriteScheduler constructs a WriteScheduler that schedules
// frames by following HTTP/2 priorities as described in RFC 7540 Section 5.3.
// If cfg is nil, default options are used.
private static http2WriteScheduler http2NewPriorityWriteScheduler(ptr<http2PriorityWriteSchedulerConfig> _addr_cfg) {
    ref http2PriorityWriteSchedulerConfig cfg = ref _addr_cfg.val;

    if (cfg == null) { 
        // For justification of these defaults, see:
        // https://docs.google.com/document/d/1oLhNg1skaWD4_DtaoCxdSRN5erEXrH-KnLrMwEpOtFY
        cfg = addr(new http2PriorityWriteSchedulerConfig(MaxClosedNodesInTree:10,MaxIdleNodesInTree:10,ThrottleOutOfOrderWrites:false,));
    }
    ptr<http2priorityWriteScheduler> ws = addr(new http2priorityWriteScheduler(nodes:make(map[uint32]*http2priorityNode),maxClosedNodesInTree:cfg.MaxClosedNodesInTree,maxIdleNodesInTree:cfg.MaxIdleNodesInTree,enableWriteThrottle:cfg.ThrottleOutOfOrderWrites,));
    ws.nodes[0] = _addr_ws.root;
    if (cfg.ThrottleOutOfOrderWrites) {
        ws.writeThrottleLimit = 1024;
    }
    else
 {
        ws.writeThrottleLimit = math.MaxInt32;
    }
    return ws;
}

private partial struct http2priorityNodeState { // : nint
}

private static readonly http2priorityNodeState http2priorityNodeOpen = iota;
private static readonly var http2priorityNodeClosed = 0;
private static readonly var http2priorityNodeIdle = 1;

// priorityNode is a node in an HTTP/2 priority tree.
// Each node is associated with a single stream ID.
// See RFC 7540, Section 5.3.
private partial struct http2priorityNode {
    public http2writeQueue q; // queue of pending frames to write
    public uint id; // id of the stream, or 0 for the root of the tree
    public byte weight; // the actual weight is weight+1, so the value is in [1,256]
    public http2priorityNodeState state; // open | closed | idle
    public long bytes; // number of bytes written by this node, or 0 if closed
    public long subtreeBytes; // sum(node.bytes) of all nodes in this subtree

// These links form the priority tree.
    public ptr<http2priorityNode> parent;
    public ptr<http2priorityNode> kids; // start of the kids list
    public ptr<http2priorityNode> prev; // doubly-linked list of siblings
    public ptr<http2priorityNode> next; // doubly-linked list of siblings
}

private static void setParent(this ptr<http2priorityNode> _addr_n, ptr<http2priorityNode> _addr_parent) => func((_, panic, _) => {
    ref http2priorityNode n = ref _addr_n.val;
    ref http2priorityNode parent = ref _addr_parent.val;

    if (n == parent) {
        panic("setParent to self");
    }
    if (n.parent == parent) {
        return ;
    }
    {
        var parent = n.parent;

        if (parent != null) {
            if (n.prev == null) {
                parent.kids = n.next;
            }
            else
 {
                n.prev.next = n.next;
            }
            if (n.next != null) {
                n.next.prev = n.prev;
            }
        }
    } 
    // Link to new parent.
    // If parent=nil, remove n from the tree.
    // Always insert at the head of parent.kids (this is assumed by walkReadyInOrder).
    n.parent = parent;
    if (parent == null) {
        n.next = null;
        n.prev = null;
    }
    else
 {
        n.next = parent.kids;
        n.prev = null;
        if (n.next != null) {
            n.next.prev = n;
        }
        parent.kids = n;
    }
});

private static void addBytes(this ptr<http2priorityNode> _addr_n, long b) {
    ref http2priorityNode n = ref _addr_n.val;

    n.bytes += b;
    while (n != null) {
        n.subtreeBytes += b;
        n = n.parent;
    }
}

// walkReadyInOrder iterates over the tree in priority order, calling f for each node
// with a non-empty write queue. When f returns true, this function returns true and the
// walk halts. tmp is used as scratch space for sorting.
//
// f(n, openParent) takes two arguments: the node to visit, n, and a bool that is true
// if any ancestor p of n is still open (ignoring the root node).
private static bool walkReadyInOrder(this ptr<http2priorityNode> _addr_n, bool openParent, ptr<slice<ptr<http2priorityNode>>> _addr_tmp, Func<ptr<http2priorityNode>, bool, bool> f) {
    ref http2priorityNode n = ref _addr_n.val;
    ref slice<ptr<http2priorityNode>> tmp = ref _addr_tmp.val;

    if (!n.q.empty() && f(n, openParent)) {
        return true;
    }
    if (n.kids == null) {
        return false;
    }
    if (n.id != 0) {
        openParent = openParent || (n.state == http2priorityNodeOpen);
    }
    var w = n.kids.weight;
    var needSort = false;
    {
        var k__prev1 = k;

        var k = n.kids.next;

        while (k != null) {
            if (k.weight != w) {
                needSort = true;
                break;
            k = k.next;
            }
        }

        k = k__prev1;
    }
    if (!needSort) {
        {
            var k__prev1 = k;

            k = n.kids;

            while (k != null) {
                if (k.walkReadyInOrder(openParent, tmp, f)) {
                    return true;
                k = k.next;
                }
            }


            k = k__prev1;
        }
        return false;
    }
    tmp.val = (tmp.val)[..(int)0];
    while (n.kids != null) {
        tmp.val = append(tmp.val, n.kids);
        n.kids.setParent(null);
    }
    sort.Sort(http2sortPriorityNodeSiblings(tmp.val));
    for (var i = len(tmp.val) - 1; i >= 0; i--) {
        (tmp.val)[i].setParent(n); // setParent inserts at the head of n.kids
    }
    {
        var k__prev1 = k;

        k = n.kids;

        while (k != null) {
            if (k.walkReadyInOrder(openParent, tmp, f)) {
                return true;
            k = k.next;
            }
        }

        k = k__prev1;
    }
    return false;
}

private partial struct http2sortPriorityNodeSiblings { // : slice<ptr<http2priorityNode>>
}

private static nint Len(this http2sortPriorityNodeSiblings z) {
    return len(z);
}

private static void Swap(this http2sortPriorityNodeSiblings z, nint i, nint k) {
    (z[i], z[k]) = (z[k], z[i]);
}

private static bool Less(this http2sortPriorityNodeSiblings z, nint i, nint k) { 
    // Prefer the subtree that has sent fewer bytes relative to its weight.
    // See sections 5.3.2 and 5.3.4.
    var wi = float64(z[i].weight + 1);
    var bi = float64(z[i].subtreeBytes);
    var wk = float64(z[k].weight + 1);
    var bk = float64(z[k].subtreeBytes);
    if (bi == 0 && bk == 0) {
        return wi >= wk;
    }
    if (bk == 0) {
        return false;
    }
    return bi / bk <= wi / wk;
}

private partial struct http2priorityWriteScheduler {
    public http2priorityNode root; // nodes maps stream ids to priority tree nodes.
    public map<uint, ptr<http2priorityNode>> nodes; // maxID is the maximum stream id in nodes.
    public uint maxID; // lists of nodes that have been closed or are idle, but are kept in
// the tree for improved prioritization. When the lengths exceed either
// maxClosedNodesInTree or maxIdleNodesInTree, old nodes are discarded.
    public slice<ptr<http2priorityNode>> closedNodes; // From the config.
    public slice<ptr<http2priorityNode>> idleNodes; // From the config.
    public nint maxClosedNodesInTree;
    public nint maxIdleNodesInTree;
    public int writeThrottleLimit;
    public bool enableWriteThrottle; // tmp is scratch space for priorityNode.walkReadyInOrder to reduce allocations.
    public slice<ptr<http2priorityNode>> tmp; // pool of empty queues for reuse.
    public http2writeQueuePool queuePool;
}

private static void OpenStream(this ptr<http2priorityWriteScheduler> _addr_ws, uint streamID, http2OpenStreamOptions options) => func((_, panic, _) => {
    ref http2priorityWriteScheduler ws = ref _addr_ws.val;
 
    // The stream may be currently idle but cannot be opened or closed.
    {
        var curr = ws.nodes[streamID];

        if (curr != null) {
            if (curr.state != http2priorityNodeIdle) {
                panic(fmt.Sprintf("stream %d already opened", streamID));
            }
            curr.state = http2priorityNodeOpen;
            return ;
        }
    } 

    // RFC 7540, Section 5.3.5:
    //  "All streams are initially assigned a non-exclusive dependency on stream 0x0.
    //  Pushed streams initially depend on their associated stream. In both cases,
    //  streams are assigned a default weight of 16."
    var parent = ws.nodes[options.PusherID];
    if (parent == null) {
        parent = _addr_ws.root;
    }
    ptr<http2priorityNode> n = addr(new http2priorityNode(q:*ws.queuePool.get(),id:streamID,weight:http2priorityDefaultWeight,state:http2priorityNodeOpen,));
    n.setParent(parent);
    ws.nodes[streamID] = n;
    if (streamID > ws.maxID) {
        ws.maxID = streamID;
    }
});

private static void CloseStream(this ptr<http2priorityWriteScheduler> _addr_ws, uint streamID) => func((_, panic, _) => {
    ref http2priorityWriteScheduler ws = ref _addr_ws.val;

    if (streamID == 0) {
        panic("violation of WriteScheduler interface: cannot close stream 0");
    }
    if (ws.nodes[streamID] == null) {
        panic(fmt.Sprintf("violation of WriteScheduler interface: unknown stream %d", streamID));
    }
    if (ws.nodes[streamID].state != http2priorityNodeOpen) {
        panic(fmt.Sprintf("violation of WriteScheduler interface: stream %d already closed", streamID));
    }
    var n = ws.nodes[streamID];
    n.state = http2priorityNodeClosed;
    n.addBytes(-n.bytes);

    ref var q = ref heap(n.q, out ptr<var> _addr_q);
    ws.queuePool.put(_addr_q);
    n.q.s = null;
    if (ws.maxClosedNodesInTree > 0) {
        ws.addClosedOrIdleNode(_addr_ws.closedNodes, ws.maxClosedNodesInTree, n);
    }
    else
 {
        ws.removeNode(n);
    }
});

private static void AdjustStream(this ptr<http2priorityWriteScheduler> _addr_ws, uint streamID, http2PriorityParam priority) => func((_, panic, _) => {
    ref http2priorityWriteScheduler ws = ref _addr_ws.val;

    if (streamID == 0) {
        panic("adjustPriority on root");
    }
    var n = ws.nodes[streamID];
    if (n == null) {
        if (streamID <= ws.maxID || ws.maxIdleNodesInTree == 0) {
            return ;
        }
        ws.maxID = streamID;
        n = addr(new http2priorityNode(q:*ws.queuePool.get(),id:streamID,weight:http2priorityDefaultWeight,state:http2priorityNodeIdle,));
        n.setParent(_addr_ws.root);
        ws.nodes[streamID] = n;
        ws.addClosedOrIdleNode(_addr_ws.idleNodes, ws.maxIdleNodesInTree, n);
    }
    var parent = ws.nodes[priority.StreamDep];
    if (parent == null) {
        n.setParent(_addr_ws.root);
        n.weight = http2priorityDefaultWeight;
        return ;
    }
    if (n == parent) {
        return ;
    }
    {
        var x = parent.parent;

        while (x != null) {
            if (x == n) {
                parent.setParent(n.parent);
                break;
            x = x.parent;
            }
        }
    } 

    // Section 5.3.3: The exclusive flag causes the stream to become the sole
    // dependency of its parent stream, causing other dependencies to become
    // dependent on the exclusive stream.
    if (priority.Exclusive) {
        var k = parent.kids;
        while (k != null) {
            var next = k.next;
            if (k != n) {
                k.setParent(n);
            }
            k = next;
        }
    }
    n.setParent(parent);
    n.weight = priority.Weight;
});

private static void Push(this ptr<http2priorityWriteScheduler> _addr_ws, http2FrameWriteRequest wr) => func((_, panic, _) => {
    ref http2priorityWriteScheduler ws = ref _addr_ws.val;

    ptr<http2priorityNode> n;
    {
        var id = wr.StreamID();

        if (id == 0) {
            n = _addr_ws.root;
        }
        else
 {
            n = ws.nodes[id];
            if (n == null) { 
                // id is an idle or closed stream. wr should not be a HEADERS or
                // DATA frame. However, wr can be a RST_STREAM. In this case, we
                // push wr onto the root, rather than creating a new priorityNode,
                // since RST_STREAM is tiny and the stream's priority is unknown
                // anyway. See issue #17919.
                if (wr.DataSize() > 0) {
                    panic("add DATA on non-open stream");
                }
                n = _addr_ws.root;
            }
        }
    }
    n.q.push(wr);
});

private static (http2FrameWriteRequest, bool) Pop(this ptr<http2priorityWriteScheduler> _addr_ws) {
    http2FrameWriteRequest wr = default;
    bool ok = default;
    ref http2priorityWriteScheduler ws = ref _addr_ws.val;

    ws.root.walkReadyInOrder(false, _addr_ws.tmp, (n, openParent) => {
        var limit = int32(math.MaxInt32);
        if (openParent) {
            limit = ws.writeThrottleLimit;
        }
        wr, ok = n.q.consume(limit);
        if (!ok) {
            return false;
        }
        n.addBytes(int64(wr.DataSize())); 
        // If B depends on A and B continuously has data available but A
        // does not, gradually increase the throttling limit to allow B to
        // steal more and more bandwidth from A.
        if (openParent) {
            ws.writeThrottleLimit += 1024;
            if (ws.writeThrottleLimit < 0) {
                ws.writeThrottleLimit = math.MaxInt32;
            }
        }
        else if (ws.enableWriteThrottle) {
            ws.writeThrottleLimit = 1024;
        }
        return true;
    });
    return (wr, ok);
}

private static void addClosedOrIdleNode(this ptr<http2priorityWriteScheduler> _addr_ws, ptr<slice<ptr<http2priorityNode>>> _addr_list, nint maxSize, ptr<http2priorityNode> _addr_n) {
    ref http2priorityWriteScheduler ws = ref _addr_ws.val;
    ref slice<ptr<http2priorityNode>> list = ref _addr_list.val;
    ref http2priorityNode n = ref _addr_n.val;

    if (maxSize == 0) {
        return ;
    }
    if (len(list.val) == maxSize) { 
        // Remove the oldest node, then shift left.
        ws.removeNode((list.val)[0]);
        slice<ptr<http2priorityNode>> x = (list.val)[(int)1..];
        copy(list.val, x);
        list.val = (list.val)[..(int)len(x)];
    }
    list.val = append(list.val, n);
}

private static void removeNode(this ptr<http2priorityWriteScheduler> _addr_ws, ptr<http2priorityNode> _addr_n) {
    ref http2priorityWriteScheduler ws = ref _addr_ws.val;
    ref http2priorityNode n = ref _addr_n.val;

    {
        var k = n.kids;

        while (k != null) {
            k.setParent(n.parent);
            k = k.next;
        }
    }
    n.setParent(null);
    delete(ws.nodes, n.id);
}

// NewRandomWriteScheduler constructs a WriteScheduler that ignores HTTP/2
// priorities. Control frames like SETTINGS and PING are written before DATA
// frames, but if no control frames are queued and multiple streams have queued
// HEADERS or DATA frames, Pop selects a ready stream arbitrarily.
private static http2WriteScheduler http2NewRandomWriteScheduler() {
    return addr(new http2randomWriteScheduler(sq:make(map[uint32]*http2writeQueue)));
}

private partial struct http2randomWriteScheduler {
    public http2writeQueue zero; // sq contains the stream-specific queues, keyed by stream ID.
// When a stream is idle, closed, or emptied, it's deleted
// from the map.
    public map<uint, ptr<http2writeQueue>> sq; // pool of empty queues for reuse.
    public http2writeQueuePool queuePool;
}

private static void OpenStream(this ptr<http2randomWriteScheduler> _addr_ws, uint streamID, http2OpenStreamOptions options) {
    ref http2randomWriteScheduler ws = ref _addr_ws.val;
 
    // no-op: idle streams are not tracked
}

private static void CloseStream(this ptr<http2randomWriteScheduler> _addr_ws, uint streamID) {
    ref http2randomWriteScheduler ws = ref _addr_ws.val;

    var (q, ok) = ws.sq[streamID];
    if (!ok) {
        return ;
    }
    delete(ws.sq, streamID);
    ws.queuePool.put(q);
}

private static void AdjustStream(this ptr<http2randomWriteScheduler> _addr_ws, uint streamID, http2PriorityParam priority) {
    ref http2randomWriteScheduler ws = ref _addr_ws.val;
 
    // no-op: priorities are ignored
}

private static void Push(this ptr<http2randomWriteScheduler> _addr_ws, http2FrameWriteRequest wr) {
    ref http2randomWriteScheduler ws = ref _addr_ws.val;

    var id = wr.StreamID();
    if (id == 0) {
        ws.zero.push(wr);
        return ;
    }
    var (q, ok) = ws.sq[id];
    if (!ok) {
        q = ws.queuePool.get();
        ws.sq[id] = q;
    }
    q.push(wr);
}

private static (http2FrameWriteRequest, bool) Pop(this ptr<http2randomWriteScheduler> _addr_ws) {
    http2FrameWriteRequest _p0 = default;
    bool _p0 = default;
    ref http2randomWriteScheduler ws = ref _addr_ws.val;
 
    // Control frames first.
    if (!ws.zero.empty()) {
        return (ws.zero.shift(), true);
    }
    foreach (var (streamID, q) in ws.sq) {
        {
            var (wr, ok) = q.consume(math.MaxInt32);

            if (ok) {
                if (q.empty()) {
                    delete(ws.sq, streamID);
                    ws.queuePool.put(q);
                }
                return (wr, true);
            }

        }
    }    return (new http2FrameWriteRequest(), false);
}

} // end http_package
