// Code generated by 'go generate'; DO NOT EDIT.

// package syscall -- go2cs converted at 2020 October 08 03:30:29 UTC
// import "syscall" ==> using syscall = go.syscall_package
// Original source: C:\Go\src\syscall\zsyscall_windows.go
using sysdll = go.@internal.syscall.windows.sysdll_package;
using @unsafe = go.@unsafe_package;
using static go.builtin;

namespace go
{
    public static partial class syscall_package
    {
        private static unsafe.Pointer _ = default;

        // Do the interface allocations only once for common
        // Errno values.
        private static readonly long errnoERROR_IO_PENDING = (long)997L;


        private static error errERROR_IO_PENDING = error.As(Errno(errnoERROR_IO_PENDING))!;

        // errnoErr returns common boxed Errno values, to prevent
        // allocations at runtime.
        private static error errnoErr(Errno e)
        {

            if (e == 0L) 
                return error.As(null!)!;
            else if (e == errnoERROR_IO_PENDING) 
                return error.As(errERROR_IO_PENDING)!;
            // TODO: add more here, after collecting data on the common
            // error values see on Windows. (perhaps when running
            // all.bat?)
            return error.As(e)!;

        }

        private static var modkernel32 = NewLazyDLL(sysdll.Add("kernel32.dll"));        private static var modadvapi32 = NewLazyDLL(sysdll.Add("advapi32.dll"));        private static var modshell32 = NewLazyDLL(sysdll.Add("shell32.dll"));        private static var modmswsock = NewLazyDLL(sysdll.Add("mswsock.dll"));        private static var modcrypt32 = NewLazyDLL(sysdll.Add("crypt32.dll"));        private static var modws2_32 = NewLazyDLL(sysdll.Add("ws2_32.dll"));        private static var moddnsapi = NewLazyDLL(sysdll.Add("dnsapi.dll"));        private static var modiphlpapi = NewLazyDLL(sysdll.Add("iphlpapi.dll"));        private static var modsecur32 = NewLazyDLL(sysdll.Add("secur32.dll"));        private static var modnetapi32 = NewLazyDLL(sysdll.Add("netapi32.dll"));        private static var moduserenv = NewLazyDLL(sysdll.Add("userenv.dll"));        private static var procGetLastError = modkernel32.NewProc("GetLastError");        private static var procLoadLibraryW = modkernel32.NewProc("LoadLibraryW");        private static var procFreeLibrary = modkernel32.NewProc("FreeLibrary");        private static var procGetProcAddress = modkernel32.NewProc("GetProcAddress");        private static var procGetVersion = modkernel32.NewProc("GetVersion");        private static var procFormatMessageW = modkernel32.NewProc("FormatMessageW");        private static var procExitProcess = modkernel32.NewProc("ExitProcess");        private static var procCreateFileW = modkernel32.NewProc("CreateFileW");        private static var procReadFile = modkernel32.NewProc("ReadFile");        private static var procWriteFile = modkernel32.NewProc("WriteFile");        private static var procSetFilePointer = modkernel32.NewProc("SetFilePointer");        private static var procCloseHandle = modkernel32.NewProc("CloseHandle");        private static var procGetStdHandle = modkernel32.NewProc("GetStdHandle");        private static var procFindFirstFileW = modkernel32.NewProc("FindFirstFileW");        private static var procFindNextFileW = modkernel32.NewProc("FindNextFileW");        private static var procFindClose = modkernel32.NewProc("FindClose");        private static var procGetFileInformationByHandle = modkernel32.NewProc("GetFileInformationByHandle");        private static var procGetCurrentDirectoryW = modkernel32.NewProc("GetCurrentDirectoryW");        private static var procSetCurrentDirectoryW = modkernel32.NewProc("SetCurrentDirectoryW");        private static var procCreateDirectoryW = modkernel32.NewProc("CreateDirectoryW");        private static var procRemoveDirectoryW = modkernel32.NewProc("RemoveDirectoryW");        private static var procDeleteFileW = modkernel32.NewProc("DeleteFileW");        private static var procMoveFileW = modkernel32.NewProc("MoveFileW");        private static var procGetComputerNameW = modkernel32.NewProc("GetComputerNameW");        private static var procSetEndOfFile = modkernel32.NewProc("SetEndOfFile");        private static var procGetSystemTimeAsFileTime = modkernel32.NewProc("GetSystemTimeAsFileTime");        private static var procGetTimeZoneInformation = modkernel32.NewProc("GetTimeZoneInformation");        private static var procCreateIoCompletionPort = modkernel32.NewProc("CreateIoCompletionPort");        private static var procGetQueuedCompletionStatus = modkernel32.NewProc("GetQueuedCompletionStatus");        private static var procPostQueuedCompletionStatus = modkernel32.NewProc("PostQueuedCompletionStatus");        private static var procCancelIo = modkernel32.NewProc("CancelIo");        private static var procCancelIoEx = modkernel32.NewProc("CancelIoEx");        private static var procCreateProcessW = modkernel32.NewProc("CreateProcessW");        private static var procCreateProcessAsUserW = modadvapi32.NewProc("CreateProcessAsUserW");        private static var procOpenProcess = modkernel32.NewProc("OpenProcess");        private static var procTerminateProcess = modkernel32.NewProc("TerminateProcess");        private static var procGetExitCodeProcess = modkernel32.NewProc("GetExitCodeProcess");        private static var procGetStartupInfoW = modkernel32.NewProc("GetStartupInfoW");        private static var procGetCurrentProcess = modkernel32.NewProc("GetCurrentProcess");        private static var procGetProcessTimes = modkernel32.NewProc("GetProcessTimes");        private static var procDuplicateHandle = modkernel32.NewProc("DuplicateHandle");        private static var procWaitForSingleObject = modkernel32.NewProc("WaitForSingleObject");        private static var procGetTempPathW = modkernel32.NewProc("GetTempPathW");        private static var procCreatePipe = modkernel32.NewProc("CreatePipe");        private static var procGetFileType = modkernel32.NewProc("GetFileType");        private static var procCryptAcquireContextW = modadvapi32.NewProc("CryptAcquireContextW");        private static var procCryptReleaseContext = modadvapi32.NewProc("CryptReleaseContext");        private static var procCryptGenRandom = modadvapi32.NewProc("CryptGenRandom");        private static var procGetEnvironmentStringsW = modkernel32.NewProc("GetEnvironmentStringsW");        private static var procFreeEnvironmentStringsW = modkernel32.NewProc("FreeEnvironmentStringsW");        private static var procGetEnvironmentVariableW = modkernel32.NewProc("GetEnvironmentVariableW");        private static var procSetEnvironmentVariableW = modkernel32.NewProc("SetEnvironmentVariableW");        private static var procSetFileTime = modkernel32.NewProc("SetFileTime");        private static var procGetFileAttributesW = modkernel32.NewProc("GetFileAttributesW");        private static var procSetFileAttributesW = modkernel32.NewProc("SetFileAttributesW");        private static var procGetFileAttributesExW = modkernel32.NewProc("GetFileAttributesExW");        private static var procGetCommandLineW = modkernel32.NewProc("GetCommandLineW");        private static var procCommandLineToArgvW = modshell32.NewProc("CommandLineToArgvW");        private static var procLocalFree = modkernel32.NewProc("LocalFree");        private static var procSetHandleInformation = modkernel32.NewProc("SetHandleInformation");        private static var procFlushFileBuffers = modkernel32.NewProc("FlushFileBuffers");        private static var procGetFullPathNameW = modkernel32.NewProc("GetFullPathNameW");        private static var procGetLongPathNameW = modkernel32.NewProc("GetLongPathNameW");        private static var procGetShortPathNameW = modkernel32.NewProc("GetShortPathNameW");        private static var procCreateFileMappingW = modkernel32.NewProc("CreateFileMappingW");        private static var procMapViewOfFile = modkernel32.NewProc("MapViewOfFile");        private static var procUnmapViewOfFile = modkernel32.NewProc("UnmapViewOfFile");        private static var procFlushViewOfFile = modkernel32.NewProc("FlushViewOfFile");        private static var procVirtualLock = modkernel32.NewProc("VirtualLock");        private static var procVirtualUnlock = modkernel32.NewProc("VirtualUnlock");        private static var procTransmitFile = modmswsock.NewProc("TransmitFile");        private static var procReadDirectoryChangesW = modkernel32.NewProc("ReadDirectoryChangesW");        private static var procCertOpenSystemStoreW = modcrypt32.NewProc("CertOpenSystemStoreW");        private static var procCertOpenStore = modcrypt32.NewProc("CertOpenStore");        private static var procCertEnumCertificatesInStore = modcrypt32.NewProc("CertEnumCertificatesInStore");        private static var procCertAddCertificateContextToStore = modcrypt32.NewProc("CertAddCertificateContextToStore");        private static var procCertCloseStore = modcrypt32.NewProc("CertCloseStore");        private static var procCertGetCertificateChain = modcrypt32.NewProc("CertGetCertificateChain");        private static var procCertFreeCertificateChain = modcrypt32.NewProc("CertFreeCertificateChain");        private static var procCertCreateCertificateContext = modcrypt32.NewProc("CertCreateCertificateContext");        private static var procCertFreeCertificateContext = modcrypt32.NewProc("CertFreeCertificateContext");        private static var procCertVerifyCertificateChainPolicy = modcrypt32.NewProc("CertVerifyCertificateChainPolicy");        private static var procRegOpenKeyExW = modadvapi32.NewProc("RegOpenKeyExW");        private static var procRegCloseKey = modadvapi32.NewProc("RegCloseKey");        private static var procRegQueryInfoKeyW = modadvapi32.NewProc("RegQueryInfoKeyW");        private static var procRegEnumKeyExW = modadvapi32.NewProc("RegEnumKeyExW");        private static var procRegQueryValueExW = modadvapi32.NewProc("RegQueryValueExW");        private static var procGetCurrentProcessId = modkernel32.NewProc("GetCurrentProcessId");        private static var procGetConsoleMode = modkernel32.NewProc("GetConsoleMode");        private static var procWriteConsoleW = modkernel32.NewProc("WriteConsoleW");        private static var procReadConsoleW = modkernel32.NewProc("ReadConsoleW");        private static var procCreateToolhelp32Snapshot = modkernel32.NewProc("CreateToolhelp32Snapshot");        private static var procProcess32FirstW = modkernel32.NewProc("Process32FirstW");        private static var procProcess32NextW = modkernel32.NewProc("Process32NextW");        private static var procDeviceIoControl = modkernel32.NewProc("DeviceIoControl");        private static var procCreateSymbolicLinkW = modkernel32.NewProc("CreateSymbolicLinkW");        private static var procCreateHardLinkW = modkernel32.NewProc("CreateHardLinkW");        private static var procWSAStartup = modws2_32.NewProc("WSAStartup");        private static var procWSACleanup = modws2_32.NewProc("WSACleanup");        private static var procWSAIoctl = modws2_32.NewProc("WSAIoctl");        private static var procsocket = modws2_32.NewProc("socket");        private static var procsetsockopt = modws2_32.NewProc("setsockopt");        private static var procgetsockopt = modws2_32.NewProc("getsockopt");        private static var procbind = modws2_32.NewProc("bind");        private static var procconnect = modws2_32.NewProc("connect");        private static var procgetsockname = modws2_32.NewProc("getsockname");        private static var procgetpeername = modws2_32.NewProc("getpeername");        private static var proclisten = modws2_32.NewProc("listen");        private static var procshutdown = modws2_32.NewProc("shutdown");        private static var procclosesocket = modws2_32.NewProc("closesocket");        private static var procAcceptEx = modmswsock.NewProc("AcceptEx");        private static var procGetAcceptExSockaddrs = modmswsock.NewProc("GetAcceptExSockaddrs");        private static var procWSARecv = modws2_32.NewProc("WSARecv");        private static var procWSASend = modws2_32.NewProc("WSASend");        private static var procWSARecvFrom = modws2_32.NewProc("WSARecvFrom");        private static var procWSASendTo = modws2_32.NewProc("WSASendTo");        private static var procgethostbyname = modws2_32.NewProc("gethostbyname");        private static var procgetservbyname = modws2_32.NewProc("getservbyname");        private static var procntohs = modws2_32.NewProc("ntohs");        private static var procgetprotobyname = modws2_32.NewProc("getprotobyname");        private static var procDnsQuery_W = moddnsapi.NewProc("DnsQuery_W");        private static var procDnsRecordListFree = moddnsapi.NewProc("DnsRecordListFree");        private static var procDnsNameCompare_W = moddnsapi.NewProc("DnsNameCompare_W");        private static var procGetAddrInfoW = modws2_32.NewProc("GetAddrInfoW");        private static var procFreeAddrInfoW = modws2_32.NewProc("FreeAddrInfoW");        private static var procGetIfEntry = modiphlpapi.NewProc("GetIfEntry");        private static var procGetAdaptersInfo = modiphlpapi.NewProc("GetAdaptersInfo");        private static var procSetFileCompletionNotificationModes = modkernel32.NewProc("SetFileCompletionNotificationModes");        private static var procWSAEnumProtocolsW = modws2_32.NewProc("WSAEnumProtocolsW");        private static var procTranslateNameW = modsecur32.NewProc("TranslateNameW");        private static var procGetUserNameExW = modsecur32.NewProc("GetUserNameExW");        private static var procNetUserGetInfo = modnetapi32.NewProc("NetUserGetInfo");        private static var procNetGetJoinInformation = modnetapi32.NewProc("NetGetJoinInformation");        private static var procNetApiBufferFree = modnetapi32.NewProc("NetApiBufferFree");        private static var procLookupAccountSidW = modadvapi32.NewProc("LookupAccountSidW");        private static var procLookupAccountNameW = modadvapi32.NewProc("LookupAccountNameW");        private static var procConvertSidToStringSidW = modadvapi32.NewProc("ConvertSidToStringSidW");        private static var procConvertStringSidToSidW = modadvapi32.NewProc("ConvertStringSidToSidW");        private static var procGetLengthSid = modadvapi32.NewProc("GetLengthSid");        private static var procCopySid = modadvapi32.NewProc("CopySid");        private static var procOpenProcessToken = modadvapi32.NewProc("OpenProcessToken");        private static var procGetTokenInformation = modadvapi32.NewProc("GetTokenInformation");        private static var procGetUserProfileDirectoryW = moduserenv.NewProc("GetUserProfileDirectoryW");        private static var procGetSystemDirectoryW = modkernel32.NewProc("GetSystemDirectoryW");

        public static error GetLastError()
        {
            error lasterr = default!;

            var (r0, _, _) = Syscall(procGetLastError.Addr(), 0L, 0L, 0L, 0L);
            if (r0 != 0L)
            {
                lasterr = Errno(r0);
            }

            return ;

        }

        public static (Handle, error) LoadLibrary(@string libname)
        {
            Handle handle = default;
            error err = default!;

            ptr<ushort> _p0;
            _p0, err = UTF16PtrFromString(libname);
            if (err != null)
            {
                return ;
            }

            return _LoadLibrary(_p0);

        }

        private static (Handle, error) _LoadLibrary(ptr<ushort> _addr_libname)
        {
            Handle handle = default;
            error err = default!;
            ref ushort libname = ref _addr_libname.val;

            var (r0, _, e1) = Syscall(procLoadLibraryW.Addr(), 1L, uintptr(@unsafe.Pointer(libname)), 0L, 0L);
            handle = Handle(r0);
            if (handle == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error FreeLibrary(Handle handle)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procFreeLibrary.Addr(), 1L, uintptr(handle), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (System.UIntPtr, error) GetProcAddress(Handle module, @string procname)
        {
            System.UIntPtr proc = default;
            error err = default!;

            ptr<byte> _p0;
            _p0, err = BytePtrFromString(procname);
            if (err != null)
            {
                return ;
            }

            return _GetProcAddress(module, _p0);

        }

        private static (System.UIntPtr, error) _GetProcAddress(Handle module, ptr<byte> _addr_procname)
        {
            System.UIntPtr proc = default;
            error err = default!;
            ref byte procname = ref _addr_procname.val;

            var (r0, _, e1) = Syscall(procGetProcAddress.Addr(), 2L, uintptr(module), uintptr(@unsafe.Pointer(procname)), 0L);
            proc = uintptr(r0);
            if (proc == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (uint, error) GetVersion()
        {
            uint ver = default;
            error err = default!;

            var (r0, _, e1) = Syscall(procGetVersion.Addr(), 0L, 0L, 0L, 0L);
            ver = uint32(r0);
            if (ver == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        private static (uint, error) formatMessage(uint flags, System.UIntPtr msgsrc, uint msgid, uint langid, slice<ushort> buf, ptr<byte> _addr_args)
        {
            uint n = default;
            error err = default!;
            ref byte args = ref _addr_args.val;

            ptr<ushort> _p0;
            if (len(buf) > 0L)
            {
                _p0 = _addr_buf[0L];
            }

            var (r0, _, e1) = Syscall9(procFormatMessageW.Addr(), 7L, uintptr(flags), uintptr(msgsrc), uintptr(msgid), uintptr(langid), uintptr(@unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(@unsafe.Pointer(args)), 0L, 0L);
            n = uint32(r0);
            if (n == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static void ExitProcess(uint exitcode)
        {
            Syscall(procExitProcess.Addr(), 1L, uintptr(exitcode), 0L, 0L);
            return ;
        }

        public static (Handle, error) CreateFile(ptr<ushort> _addr_name, uint access, uint mode, ptr<SecurityAttributes> _addr_sa, uint createmode, uint attrs, int templatefile)
        {
            Handle handle = default;
            error err = default!;
            ref ushort name = ref _addr_name.val;
            ref SecurityAttributes sa = ref _addr_sa.val;

            var (r0, _, e1) = Syscall9(procCreateFileW.Addr(), 7L, uintptr(@unsafe.Pointer(name)), uintptr(access), uintptr(mode), uintptr(@unsafe.Pointer(sa)), uintptr(createmode), uintptr(attrs), uintptr(templatefile), 0L, 0L);
            handle = Handle(r0);
            if (handle == InvalidHandle)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error ReadFile(Handle handle, slice<byte> buf, ptr<uint> _addr_done, ptr<Overlapped> _addr_overlapped)
        {
            error err = default!;
            ref uint done = ref _addr_done.val;
            ref Overlapped overlapped = ref _addr_overlapped.val;

            ptr<byte> _p0;
            if (len(buf) > 0L)
            {
                _p0 = _addr_buf[0L];
            }

            var (r1, _, e1) = Syscall6(procReadFile.Addr(), 5L, uintptr(handle), uintptr(@unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(@unsafe.Pointer(done)), uintptr(@unsafe.Pointer(overlapped)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error WriteFile(Handle handle, slice<byte> buf, ptr<uint> _addr_done, ptr<Overlapped> _addr_overlapped)
        {
            error err = default!;
            ref uint done = ref _addr_done.val;
            ref Overlapped overlapped = ref _addr_overlapped.val;

            ptr<byte> _p0;
            if (len(buf) > 0L)
            {
                _p0 = _addr_buf[0L];
            }

            var (r1, _, e1) = Syscall6(procWriteFile.Addr(), 5L, uintptr(handle), uintptr(@unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(@unsafe.Pointer(done)), uintptr(@unsafe.Pointer(overlapped)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (uint, error) SetFilePointer(Handle handle, int lowoffset, ptr<int> _addr_highoffsetptr, uint whence)
        {
            uint newlowoffset = default;
            error err = default!;
            ref int highoffsetptr = ref _addr_highoffsetptr.val;

            var (r0, _, e1) = Syscall6(procSetFilePointer.Addr(), 4L, uintptr(handle), uintptr(lowoffset), uintptr(@unsafe.Pointer(highoffsetptr)), uintptr(whence), 0L, 0L);
            newlowoffset = uint32(r0);
            if (newlowoffset == 0xffffffffUL)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CloseHandle(Handle handle)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procCloseHandle.Addr(), 1L, uintptr(handle), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (Handle, error) GetStdHandle(long stdhandle)
        {
            Handle handle = default;
            error err = default!;

            var (r0, _, e1) = Syscall(procGetStdHandle.Addr(), 1L, uintptr(stdhandle), 0L, 0L);
            handle = Handle(r0);
            if (handle == InvalidHandle)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        private static (Handle, error) findFirstFile1(ptr<ushort> _addr_name, ptr<win32finddata1> _addr_data)
        {
            Handle handle = default;
            error err = default!;
            ref ushort name = ref _addr_name.val;
            ref win32finddata1 data = ref _addr_data.val;

            var (r0, _, e1) = Syscall(procFindFirstFileW.Addr(), 2L, uintptr(@unsafe.Pointer(name)), uintptr(@unsafe.Pointer(data)), 0L);
            handle = Handle(r0);
            if (handle == InvalidHandle)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        private static error findNextFile1(Handle handle, ptr<win32finddata1> _addr_data)
        {
            error err = default!;
            ref win32finddata1 data = ref _addr_data.val;

            var (r1, _, e1) = Syscall(procFindNextFileW.Addr(), 2L, uintptr(handle), uintptr(@unsafe.Pointer(data)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error FindClose(Handle handle)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procFindClose.Addr(), 1L, uintptr(handle), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error GetFileInformationByHandle(Handle handle, ptr<ByHandleFileInformation> _addr_data)
        {
            error err = default!;
            ref ByHandleFileInformation data = ref _addr_data.val;

            var (r1, _, e1) = Syscall(procGetFileInformationByHandle.Addr(), 2L, uintptr(handle), uintptr(@unsafe.Pointer(data)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (uint, error) GetCurrentDirectory(uint buflen, ptr<ushort> _addr_buf)
        {
            uint n = default;
            error err = default!;
            ref ushort buf = ref _addr_buf.val;

            var (r0, _, e1) = Syscall(procGetCurrentDirectoryW.Addr(), 2L, uintptr(buflen), uintptr(@unsafe.Pointer(buf)), 0L);
            n = uint32(r0);
            if (n == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error SetCurrentDirectory(ptr<ushort> _addr_path)
        {
            error err = default!;
            ref ushort path = ref _addr_path.val;

            var (r1, _, e1) = Syscall(procSetCurrentDirectoryW.Addr(), 1L, uintptr(@unsafe.Pointer(path)), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CreateDirectory(ptr<ushort> _addr_path, ptr<SecurityAttributes> _addr_sa)
        {
            error err = default!;
            ref ushort path = ref _addr_path.val;
            ref SecurityAttributes sa = ref _addr_sa.val;

            var (r1, _, e1) = Syscall(procCreateDirectoryW.Addr(), 2L, uintptr(@unsafe.Pointer(path)), uintptr(@unsafe.Pointer(sa)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error RemoveDirectory(ptr<ushort> _addr_path)
        {
            error err = default!;
            ref ushort path = ref _addr_path.val;

            var (r1, _, e1) = Syscall(procRemoveDirectoryW.Addr(), 1L, uintptr(@unsafe.Pointer(path)), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error DeleteFile(ptr<ushort> _addr_path)
        {
            error err = default!;
            ref ushort path = ref _addr_path.val;

            var (r1, _, e1) = Syscall(procDeleteFileW.Addr(), 1L, uintptr(@unsafe.Pointer(path)), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error MoveFile(ptr<ushort> _addr_from, ptr<ushort> _addr_to)
        {
            error err = default!;
            ref ushort from = ref _addr_from.val;
            ref ushort to = ref _addr_to.val;

            var (r1, _, e1) = Syscall(procMoveFileW.Addr(), 2L, uintptr(@unsafe.Pointer(from)), uintptr(@unsafe.Pointer(to)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error GetComputerName(ptr<ushort> _addr_buf, ptr<uint> _addr_n)
        {
            error err = default!;
            ref ushort buf = ref _addr_buf.val;
            ref uint n = ref _addr_n.val;

            var (r1, _, e1) = Syscall(procGetComputerNameW.Addr(), 2L, uintptr(@unsafe.Pointer(buf)), uintptr(@unsafe.Pointer(n)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error SetEndOfFile(Handle handle)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procSetEndOfFile.Addr(), 1L, uintptr(handle), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static void GetSystemTimeAsFileTime(ptr<Filetime> _addr_time)
        {
            ref Filetime time = ref _addr_time.val;

            Syscall(procGetSystemTimeAsFileTime.Addr(), 1L, uintptr(@unsafe.Pointer(time)), 0L, 0L);
            return ;
        }

        public static (uint, error) GetTimeZoneInformation(ptr<Timezoneinformation> _addr_tzi)
        {
            uint rc = default;
            error err = default!;
            ref Timezoneinformation tzi = ref _addr_tzi.val;

            var (r0, _, e1) = Syscall(procGetTimeZoneInformation.Addr(), 1L, uintptr(@unsafe.Pointer(tzi)), 0L, 0L);
            rc = uint32(r0);
            if (rc == 0xffffffffUL)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (Handle, error) CreateIoCompletionPort(Handle filehandle, Handle cphandle, uint key, uint threadcnt)
        {
            Handle handle = default;
            error err = default!;

            var (r0, _, e1) = Syscall6(procCreateIoCompletionPort.Addr(), 4L, uintptr(filehandle), uintptr(cphandle), uintptr(key), uintptr(threadcnt), 0L, 0L);
            handle = Handle(r0);
            if (handle == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error GetQueuedCompletionStatus(Handle cphandle, ptr<uint> _addr_qty, ptr<uint> _addr_key, ptr<ptr<Overlapped>> _addr_overlapped, uint timeout)
        {
            error err = default!;
            ref uint qty = ref _addr_qty.val;
            ref uint key = ref _addr_key.val;
            ref ptr<Overlapped> overlapped = ref _addr_overlapped.val;

            var (r1, _, e1) = Syscall6(procGetQueuedCompletionStatus.Addr(), 5L, uintptr(cphandle), uintptr(@unsafe.Pointer(qty)), uintptr(@unsafe.Pointer(key)), uintptr(@unsafe.Pointer(overlapped)), uintptr(timeout), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error PostQueuedCompletionStatus(Handle cphandle, uint qty, uint key, ptr<Overlapped> _addr_overlapped)
        {
            error err = default!;
            ref Overlapped overlapped = ref _addr_overlapped.val;

            var (r1, _, e1) = Syscall6(procPostQueuedCompletionStatus.Addr(), 4L, uintptr(cphandle), uintptr(qty), uintptr(key), uintptr(@unsafe.Pointer(overlapped)), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CancelIo(Handle s)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procCancelIo.Addr(), 1L, uintptr(s), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CancelIoEx(Handle s, ptr<Overlapped> _addr_o)
        {
            error err = default!;
            ref Overlapped o = ref _addr_o.val;

            var (r1, _, e1) = Syscall(procCancelIoEx.Addr(), 2L, uintptr(s), uintptr(@unsafe.Pointer(o)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CreateProcess(ptr<ushort> _addr_appName, ptr<ushort> _addr_commandLine, ptr<SecurityAttributes> _addr_procSecurity, ptr<SecurityAttributes> _addr_threadSecurity, bool inheritHandles, uint creationFlags, ptr<ushort> _addr_env, ptr<ushort> _addr_currentDir, ptr<StartupInfo> _addr_startupInfo, ptr<ProcessInformation> _addr_outProcInfo)
        {
            error err = default!;
            ref ushort appName = ref _addr_appName.val;
            ref ushort commandLine = ref _addr_commandLine.val;
            ref SecurityAttributes procSecurity = ref _addr_procSecurity.val;
            ref SecurityAttributes threadSecurity = ref _addr_threadSecurity.val;
            ref ushort env = ref _addr_env.val;
            ref ushort currentDir = ref _addr_currentDir.val;
            ref StartupInfo startupInfo = ref _addr_startupInfo.val;
            ref ProcessInformation outProcInfo = ref _addr_outProcInfo.val;

            uint _p0 = default;
            if (inheritHandles)
            {
                _p0 = 1L;
            }
            else
            {
                _p0 = 0L;
            }

            var (r1, _, e1) = Syscall12(procCreateProcessW.Addr(), 10L, uintptr(@unsafe.Pointer(appName)), uintptr(@unsafe.Pointer(commandLine)), uintptr(@unsafe.Pointer(procSecurity)), uintptr(@unsafe.Pointer(threadSecurity)), uintptr(_p0), uintptr(creationFlags), uintptr(@unsafe.Pointer(env)), uintptr(@unsafe.Pointer(currentDir)), uintptr(@unsafe.Pointer(startupInfo)), uintptr(@unsafe.Pointer(outProcInfo)), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CreateProcessAsUser(Token token, ptr<ushort> _addr_appName, ptr<ushort> _addr_commandLine, ptr<SecurityAttributes> _addr_procSecurity, ptr<SecurityAttributes> _addr_threadSecurity, bool inheritHandles, uint creationFlags, ptr<ushort> _addr_env, ptr<ushort> _addr_currentDir, ptr<StartupInfo> _addr_startupInfo, ptr<ProcessInformation> _addr_outProcInfo)
        {
            error err = default!;
            ref ushort appName = ref _addr_appName.val;
            ref ushort commandLine = ref _addr_commandLine.val;
            ref SecurityAttributes procSecurity = ref _addr_procSecurity.val;
            ref SecurityAttributes threadSecurity = ref _addr_threadSecurity.val;
            ref ushort env = ref _addr_env.val;
            ref ushort currentDir = ref _addr_currentDir.val;
            ref StartupInfo startupInfo = ref _addr_startupInfo.val;
            ref ProcessInformation outProcInfo = ref _addr_outProcInfo.val;

            uint _p0 = default;
            if (inheritHandles)
            {
                _p0 = 1L;
            }
            else
            {
                _p0 = 0L;
            }

            var (r1, _, e1) = Syscall12(procCreateProcessAsUserW.Addr(), 11L, uintptr(token), uintptr(@unsafe.Pointer(appName)), uintptr(@unsafe.Pointer(commandLine)), uintptr(@unsafe.Pointer(procSecurity)), uintptr(@unsafe.Pointer(threadSecurity)), uintptr(_p0), uintptr(creationFlags), uintptr(@unsafe.Pointer(env)), uintptr(@unsafe.Pointer(currentDir)), uintptr(@unsafe.Pointer(startupInfo)), uintptr(@unsafe.Pointer(outProcInfo)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (Handle, error) OpenProcess(uint da, bool inheritHandle, uint pid)
        {
            Handle handle = default;
            error err = default!;

            uint _p0 = default;
            if (inheritHandle)
            {
                _p0 = 1L;
            }
            else
            {
                _p0 = 0L;
            }

            var (r0, _, e1) = Syscall(procOpenProcess.Addr(), 3L, uintptr(da), uintptr(_p0), uintptr(pid));
            handle = Handle(r0);
            if (handle == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error TerminateProcess(Handle handle, uint exitcode)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procTerminateProcess.Addr(), 2L, uintptr(handle), uintptr(exitcode), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error GetExitCodeProcess(Handle handle, ptr<uint> _addr_exitcode)
        {
            error err = default!;
            ref uint exitcode = ref _addr_exitcode.val;

            var (r1, _, e1) = Syscall(procGetExitCodeProcess.Addr(), 2L, uintptr(handle), uintptr(@unsafe.Pointer(exitcode)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error GetStartupInfo(ptr<StartupInfo> _addr_startupInfo)
        {
            error err = default!;
            ref StartupInfo startupInfo = ref _addr_startupInfo.val;

            var (r1, _, e1) = Syscall(procGetStartupInfoW.Addr(), 1L, uintptr(@unsafe.Pointer(startupInfo)), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (Handle, error) GetCurrentProcess()
        {
            Handle pseudoHandle = default;
            error err = default!;

            var (r0, _, e1) = Syscall(procGetCurrentProcess.Addr(), 0L, 0L, 0L, 0L);
            pseudoHandle = Handle(r0);
            if (pseudoHandle == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error GetProcessTimes(Handle handle, ptr<Filetime> _addr_creationTime, ptr<Filetime> _addr_exitTime, ptr<Filetime> _addr_kernelTime, ptr<Filetime> _addr_userTime)
        {
            error err = default!;
            ref Filetime creationTime = ref _addr_creationTime.val;
            ref Filetime exitTime = ref _addr_exitTime.val;
            ref Filetime kernelTime = ref _addr_kernelTime.val;
            ref Filetime userTime = ref _addr_userTime.val;

            var (r1, _, e1) = Syscall6(procGetProcessTimes.Addr(), 5L, uintptr(handle), uintptr(@unsafe.Pointer(creationTime)), uintptr(@unsafe.Pointer(exitTime)), uintptr(@unsafe.Pointer(kernelTime)), uintptr(@unsafe.Pointer(userTime)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error DuplicateHandle(Handle hSourceProcessHandle, Handle hSourceHandle, Handle hTargetProcessHandle, ptr<Handle> _addr_lpTargetHandle, uint dwDesiredAccess, bool bInheritHandle, uint dwOptions)
        {
            error err = default!;
            ref Handle lpTargetHandle = ref _addr_lpTargetHandle.val;

            uint _p0 = default;
            if (bInheritHandle)
            {
                _p0 = 1L;
            }
            else
            {
                _p0 = 0L;
            }

            var (r1, _, e1) = Syscall9(procDuplicateHandle.Addr(), 7L, uintptr(hSourceProcessHandle), uintptr(hSourceHandle), uintptr(hTargetProcessHandle), uintptr(@unsafe.Pointer(lpTargetHandle)), uintptr(dwDesiredAccess), uintptr(_p0), uintptr(dwOptions), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (uint, error) WaitForSingleObject(Handle handle, uint waitMilliseconds)
        {
            uint @event = default;
            error err = default!;

            var (r0, _, e1) = Syscall(procWaitForSingleObject.Addr(), 2L, uintptr(handle), uintptr(waitMilliseconds), 0L);
            event = uint32(r0);
            if (event == 0xffffffffUL)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (uint, error) GetTempPath(uint buflen, ptr<ushort> _addr_buf)
        {
            uint n = default;
            error err = default!;
            ref ushort buf = ref _addr_buf.val;

            var (r0, _, e1) = Syscall(procGetTempPathW.Addr(), 2L, uintptr(buflen), uintptr(@unsafe.Pointer(buf)), 0L);
            n = uint32(r0);
            if (n == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CreatePipe(ptr<Handle> _addr_readhandle, ptr<Handle> _addr_writehandle, ptr<SecurityAttributes> _addr_sa, uint size)
        {
            error err = default!;
            ref Handle readhandle = ref _addr_readhandle.val;
            ref Handle writehandle = ref _addr_writehandle.val;
            ref SecurityAttributes sa = ref _addr_sa.val;

            var (r1, _, e1) = Syscall6(procCreatePipe.Addr(), 4L, uintptr(@unsafe.Pointer(readhandle)), uintptr(@unsafe.Pointer(writehandle)), uintptr(@unsafe.Pointer(sa)), uintptr(size), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (uint, error) GetFileType(Handle filehandle)
        {
            uint n = default;
            error err = default!;

            var (r0, _, e1) = Syscall(procGetFileType.Addr(), 1L, uintptr(filehandle), 0L, 0L);
            n = uint32(r0);
            if (n == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CryptAcquireContext(ptr<Handle> _addr_provhandle, ptr<ushort> _addr_container, ptr<ushort> _addr_provider, uint provtype, uint flags)
        {
            error err = default!;
            ref Handle provhandle = ref _addr_provhandle.val;
            ref ushort container = ref _addr_container.val;
            ref ushort provider = ref _addr_provider.val;

            var (r1, _, e1) = Syscall6(procCryptAcquireContextW.Addr(), 5L, uintptr(@unsafe.Pointer(provhandle)), uintptr(@unsafe.Pointer(container)), uintptr(@unsafe.Pointer(provider)), uintptr(provtype), uintptr(flags), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CryptReleaseContext(Handle provhandle, uint flags)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procCryptReleaseContext.Addr(), 2L, uintptr(provhandle), uintptr(flags), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CryptGenRandom(Handle provhandle, uint buflen, ptr<byte> _addr_buf)
        {
            error err = default!;
            ref byte buf = ref _addr_buf.val;

            var (r1, _, e1) = Syscall(procCryptGenRandom.Addr(), 3L, uintptr(provhandle), uintptr(buflen), uintptr(@unsafe.Pointer(buf)));
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (ptr<ushort>, error) GetEnvironmentStrings()
        {
            ptr<ushort> envs = default!;
            error err = default!;

            var (r0, _, e1) = Syscall(procGetEnvironmentStringsW.Addr(), 0L, 0L, 0L, 0L);
            envs = (uint16.val)(@unsafe.Pointer(r0));
            if (envs == null)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error FreeEnvironmentStrings(ptr<ushort> _addr_envs)
        {
            error err = default!;
            ref ushort envs = ref _addr_envs.val;

            var (r1, _, e1) = Syscall(procFreeEnvironmentStringsW.Addr(), 1L, uintptr(@unsafe.Pointer(envs)), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (uint, error) GetEnvironmentVariable(ptr<ushort> _addr_name, ptr<ushort> _addr_buffer, uint size)
        {
            uint n = default;
            error err = default!;
            ref ushort name = ref _addr_name.val;
            ref ushort buffer = ref _addr_buffer.val;

            var (r0, _, e1) = Syscall(procGetEnvironmentVariableW.Addr(), 3L, uintptr(@unsafe.Pointer(name)), uintptr(@unsafe.Pointer(buffer)), uintptr(size));
            n = uint32(r0);
            if (n == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error SetEnvironmentVariable(ptr<ushort> _addr_name, ptr<ushort> _addr_value)
        {
            error err = default!;
            ref ushort name = ref _addr_name.val;
            ref ushort value = ref _addr_value.val;

            var (r1, _, e1) = Syscall(procSetEnvironmentVariableW.Addr(), 2L, uintptr(@unsafe.Pointer(name)), uintptr(@unsafe.Pointer(value)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error SetFileTime(Handle handle, ptr<Filetime> _addr_ctime, ptr<Filetime> _addr_atime, ptr<Filetime> _addr_wtime)
        {
            error err = default!;
            ref Filetime ctime = ref _addr_ctime.val;
            ref Filetime atime = ref _addr_atime.val;
            ref Filetime wtime = ref _addr_wtime.val;

            var (r1, _, e1) = Syscall6(procSetFileTime.Addr(), 4L, uintptr(handle), uintptr(@unsafe.Pointer(ctime)), uintptr(@unsafe.Pointer(atime)), uintptr(@unsafe.Pointer(wtime)), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (uint, error) GetFileAttributes(ptr<ushort> _addr_name)
        {
            uint attrs = default;
            error err = default!;
            ref ushort name = ref _addr_name.val;

            var (r0, _, e1) = Syscall(procGetFileAttributesW.Addr(), 1L, uintptr(@unsafe.Pointer(name)), 0L, 0L);
            attrs = uint32(r0);
            if (attrs == INVALID_FILE_ATTRIBUTES)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error SetFileAttributes(ptr<ushort> _addr_name, uint attrs)
        {
            error err = default!;
            ref ushort name = ref _addr_name.val;

            var (r1, _, e1) = Syscall(procSetFileAttributesW.Addr(), 2L, uintptr(@unsafe.Pointer(name)), uintptr(attrs), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error GetFileAttributesEx(ptr<ushort> _addr_name, uint level, ptr<byte> _addr_info)
        {
            error err = default!;
            ref ushort name = ref _addr_name.val;
            ref byte info = ref _addr_info.val;

            var (r1, _, e1) = Syscall(procGetFileAttributesExW.Addr(), 3L, uintptr(@unsafe.Pointer(name)), uintptr(level), uintptr(@unsafe.Pointer(info)));
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static ptr<ushort> GetCommandLine()
        {
            ptr<ushort> cmd = default!;

            var (r0, _, _) = Syscall(procGetCommandLineW.Addr(), 0L, 0L, 0L, 0L);
            cmd = (uint16.val)(@unsafe.Pointer(r0));
            return ;
        }

        public static (ptr<array<ptr<array<ushort>>>>, error) CommandLineToArgv(ptr<ushort> _addr_cmd, ptr<int> _addr_argc)
        {
            ptr<array<ptr<array<ushort>>>> argv = default!;
            error err = default!;
            ref ushort cmd = ref _addr_cmd.val;
            ref int argc = ref _addr_argc.val;

            var (r0, _, e1) = Syscall(procCommandLineToArgvW.Addr(), 2L, uintptr(@unsafe.Pointer(cmd)), uintptr(@unsafe.Pointer(argc)), 0L);
            argv = new ptr<ptr<array<ptr<array<ushort>>>>>(@unsafe.Pointer(r0));
            if (argv == null)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (Handle, error) LocalFree(Handle hmem)
        {
            Handle handle = default;
            error err = default!;

            var (r0, _, e1) = Syscall(procLocalFree.Addr(), 1L, uintptr(hmem), 0L, 0L);
            handle = Handle(r0);
            if (handle != 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error SetHandleInformation(Handle handle, uint mask, uint flags)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procSetHandleInformation.Addr(), 3L, uintptr(handle), uintptr(mask), uintptr(flags));
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error FlushFileBuffers(Handle handle)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procFlushFileBuffers.Addr(), 1L, uintptr(handle), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (uint, error) GetFullPathName(ptr<ushort> _addr_path, uint buflen, ptr<ushort> _addr_buf, ptr<ptr<ushort>> _addr_fname)
        {
            uint n = default;
            error err = default!;
            ref ushort path = ref _addr_path.val;
            ref ushort buf = ref _addr_buf.val;
            ref ptr<ushort> fname = ref _addr_fname.val;

            var (r0, _, e1) = Syscall6(procGetFullPathNameW.Addr(), 4L, uintptr(@unsafe.Pointer(path)), uintptr(buflen), uintptr(@unsafe.Pointer(buf)), uintptr(@unsafe.Pointer(fname)), 0L, 0L);
            n = uint32(r0);
            if (n == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (uint, error) GetLongPathName(ptr<ushort> _addr_path, ptr<ushort> _addr_buf, uint buflen)
        {
            uint n = default;
            error err = default!;
            ref ushort path = ref _addr_path.val;
            ref ushort buf = ref _addr_buf.val;

            var (r0, _, e1) = Syscall(procGetLongPathNameW.Addr(), 3L, uintptr(@unsafe.Pointer(path)), uintptr(@unsafe.Pointer(buf)), uintptr(buflen));
            n = uint32(r0);
            if (n == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (uint, error) GetShortPathName(ptr<ushort> _addr_longpath, ptr<ushort> _addr_shortpath, uint buflen)
        {
            uint n = default;
            error err = default!;
            ref ushort longpath = ref _addr_longpath.val;
            ref ushort shortpath = ref _addr_shortpath.val;

            var (r0, _, e1) = Syscall(procGetShortPathNameW.Addr(), 3L, uintptr(@unsafe.Pointer(longpath)), uintptr(@unsafe.Pointer(shortpath)), uintptr(buflen));
            n = uint32(r0);
            if (n == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (Handle, error) CreateFileMapping(Handle fhandle, ptr<SecurityAttributes> _addr_sa, uint prot, uint maxSizeHigh, uint maxSizeLow, ptr<ushort> _addr_name)
        {
            Handle handle = default;
            error err = default!;
            ref SecurityAttributes sa = ref _addr_sa.val;
            ref ushort name = ref _addr_name.val;

            var (r0, _, e1) = Syscall6(procCreateFileMappingW.Addr(), 6L, uintptr(fhandle), uintptr(@unsafe.Pointer(sa)), uintptr(prot), uintptr(maxSizeHigh), uintptr(maxSizeLow), uintptr(@unsafe.Pointer(name)));
            handle = Handle(r0);
            if (handle == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (System.UIntPtr, error) MapViewOfFile(Handle handle, uint access, uint offsetHigh, uint offsetLow, System.UIntPtr length)
        {
            System.UIntPtr addr = default;
            error err = default!;

            var (r0, _, e1) = Syscall6(procMapViewOfFile.Addr(), 5L, uintptr(handle), uintptr(access), uintptr(offsetHigh), uintptr(offsetLow), uintptr(length), 0L);
            addr = uintptr(r0);
            if (addr == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error UnmapViewOfFile(System.UIntPtr addr)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procUnmapViewOfFile.Addr(), 1L, uintptr(addr), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error FlushViewOfFile(System.UIntPtr addr, System.UIntPtr length)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procFlushViewOfFile.Addr(), 2L, uintptr(addr), uintptr(length), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error VirtualLock(System.UIntPtr addr, System.UIntPtr length)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procVirtualLock.Addr(), 2L, uintptr(addr), uintptr(length), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error VirtualUnlock(System.UIntPtr addr, System.UIntPtr length)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procVirtualUnlock.Addr(), 2L, uintptr(addr), uintptr(length), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error TransmitFile(Handle s, Handle handle, uint bytesToWrite, uint bytsPerSend, ptr<Overlapped> _addr_overlapped, ptr<TransmitFileBuffers> _addr_transmitFileBuf, uint flags)
        {
            error err = default!;
            ref Overlapped overlapped = ref _addr_overlapped.val;
            ref TransmitFileBuffers transmitFileBuf = ref _addr_transmitFileBuf.val;

            var (r1, _, e1) = Syscall9(procTransmitFile.Addr(), 7L, uintptr(s), uintptr(handle), uintptr(bytesToWrite), uintptr(bytsPerSend), uintptr(@unsafe.Pointer(overlapped)), uintptr(@unsafe.Pointer(transmitFileBuf)), uintptr(flags), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error ReadDirectoryChanges(Handle handle, ptr<byte> _addr_buf, uint buflen, bool watchSubTree, uint mask, ptr<uint> _addr_retlen, ptr<Overlapped> _addr_overlapped, System.UIntPtr completionRoutine)
        {
            error err = default!;
            ref byte buf = ref _addr_buf.val;
            ref uint retlen = ref _addr_retlen.val;
            ref Overlapped overlapped = ref _addr_overlapped.val;

            uint _p0 = default;
            if (watchSubTree)
            {
                _p0 = 1L;
            }
            else
            {
                _p0 = 0L;
            }

            var (r1, _, e1) = Syscall9(procReadDirectoryChangesW.Addr(), 8L, uintptr(handle), uintptr(@unsafe.Pointer(buf)), uintptr(buflen), uintptr(_p0), uintptr(mask), uintptr(@unsafe.Pointer(retlen)), uintptr(@unsafe.Pointer(overlapped)), uintptr(completionRoutine), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (Handle, error) CertOpenSystemStore(Handle hprov, ptr<ushort> _addr_name)
        {
            Handle store = default;
            error err = default!;
            ref ushort name = ref _addr_name.val;

            var (r0, _, e1) = Syscall(procCertOpenSystemStoreW.Addr(), 2L, uintptr(hprov), uintptr(@unsafe.Pointer(name)), 0L);
            store = Handle(r0);
            if (store == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (Handle, error) CertOpenStore(System.UIntPtr storeProvider, uint msgAndCertEncodingType, System.UIntPtr cryptProv, uint flags, System.UIntPtr para)
        {
            Handle handle = default;
            error err = default!;

            var (r0, _, e1) = Syscall6(procCertOpenStore.Addr(), 5L, uintptr(storeProvider), uintptr(msgAndCertEncodingType), uintptr(cryptProv), uintptr(flags), uintptr(para), 0L);
            handle = Handle(r0);
            if (handle == InvalidHandle)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (ptr<CertContext>, error) CertEnumCertificatesInStore(Handle store, ptr<CertContext> _addr_prevContext)
        {
            ptr<CertContext> context = default!;
            error err = default!;
            ref CertContext prevContext = ref _addr_prevContext.val;

            var (r0, _, e1) = Syscall(procCertEnumCertificatesInStore.Addr(), 2L, uintptr(store), uintptr(@unsafe.Pointer(prevContext)), 0L);
            context = (CertContext.val)(@unsafe.Pointer(r0));
            if (context == null)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CertAddCertificateContextToStore(Handle store, ptr<CertContext> _addr_certContext, uint addDisposition, ptr<ptr<CertContext>> _addr_storeContext)
        {
            error err = default!;
            ref CertContext certContext = ref _addr_certContext.val;
            ref ptr<CertContext> storeContext = ref _addr_storeContext.val;

            var (r1, _, e1) = Syscall6(procCertAddCertificateContextToStore.Addr(), 4L, uintptr(store), uintptr(@unsafe.Pointer(certContext)), uintptr(addDisposition), uintptr(@unsafe.Pointer(storeContext)), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CertCloseStore(Handle store, uint flags)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procCertCloseStore.Addr(), 2L, uintptr(store), uintptr(flags), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CertGetCertificateChain(Handle engine, ptr<CertContext> _addr_leaf, ptr<Filetime> _addr_time, Handle additionalStore, ptr<CertChainPara> _addr_para, uint flags, System.UIntPtr reserved, ptr<ptr<CertChainContext>> _addr_chainCtx)
        {
            error err = default!;
            ref CertContext leaf = ref _addr_leaf.val;
            ref Filetime time = ref _addr_time.val;
            ref CertChainPara para = ref _addr_para.val;
            ref ptr<CertChainContext> chainCtx = ref _addr_chainCtx.val;

            var (r1, _, e1) = Syscall9(procCertGetCertificateChain.Addr(), 8L, uintptr(engine), uintptr(@unsafe.Pointer(leaf)), uintptr(@unsafe.Pointer(time)), uintptr(additionalStore), uintptr(@unsafe.Pointer(para)), uintptr(flags), uintptr(reserved), uintptr(@unsafe.Pointer(chainCtx)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static void CertFreeCertificateChain(ptr<CertChainContext> _addr_ctx)
        {
            ref CertChainContext ctx = ref _addr_ctx.val;

            Syscall(procCertFreeCertificateChain.Addr(), 1L, uintptr(@unsafe.Pointer(ctx)), 0L, 0L);
            return ;
        }

        public static (ptr<CertContext>, error) CertCreateCertificateContext(uint certEncodingType, ptr<byte> _addr_certEncoded, uint encodedLen)
        {
            ptr<CertContext> context = default!;
            error err = default!;
            ref byte certEncoded = ref _addr_certEncoded.val;

            var (r0, _, e1) = Syscall(procCertCreateCertificateContext.Addr(), 3L, uintptr(certEncodingType), uintptr(@unsafe.Pointer(certEncoded)), uintptr(encodedLen));
            context = (CertContext.val)(@unsafe.Pointer(r0));
            if (context == null)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CertFreeCertificateContext(ptr<CertContext> _addr_ctx)
        {
            error err = default!;
            ref CertContext ctx = ref _addr_ctx.val;

            var (r1, _, e1) = Syscall(procCertFreeCertificateContext.Addr(), 1L, uintptr(@unsafe.Pointer(ctx)), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CertVerifyCertificateChainPolicy(System.UIntPtr policyOID, ptr<CertChainContext> _addr_chain, ptr<CertChainPolicyPara> _addr_para, ptr<CertChainPolicyStatus> _addr_status)
        {
            error err = default!;
            ref CertChainContext chain = ref _addr_chain.val;
            ref CertChainPolicyPara para = ref _addr_para.val;
            ref CertChainPolicyStatus status = ref _addr_status.val;

            var (r1, _, e1) = Syscall6(procCertVerifyCertificateChainPolicy.Addr(), 4L, uintptr(policyOID), uintptr(@unsafe.Pointer(chain)), uintptr(@unsafe.Pointer(para)), uintptr(@unsafe.Pointer(status)), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error RegOpenKeyEx(Handle key, ptr<ushort> _addr_subkey, uint options, uint desiredAccess, ptr<Handle> _addr_result)
        {
            error regerrno = default!;
            ref ushort subkey = ref _addr_subkey.val;
            ref Handle result = ref _addr_result.val;

            var (r0, _, _) = Syscall6(procRegOpenKeyExW.Addr(), 5L, uintptr(key), uintptr(@unsafe.Pointer(subkey)), uintptr(options), uintptr(desiredAccess), uintptr(@unsafe.Pointer(result)), 0L);
            if (r0 != 0L)
            {
                regerrno = Errno(r0);
            }

            return ;

        }

        public static error RegCloseKey(Handle key)
        {
            error regerrno = default!;

            var (r0, _, _) = Syscall(procRegCloseKey.Addr(), 1L, uintptr(key), 0L, 0L);
            if (r0 != 0L)
            {
                regerrno = Errno(r0);
            }

            return ;

        }

        public static error RegQueryInfoKey(Handle key, ptr<ushort> _addr_@class, ptr<uint> _addr_classLen, ptr<uint> _addr_reserved, ptr<uint> _addr_subkeysLen, ptr<uint> _addr_maxSubkeyLen, ptr<uint> _addr_maxClassLen, ptr<uint> _addr_valuesLen, ptr<uint> _addr_maxValueNameLen, ptr<uint> _addr_maxValueLen, ptr<uint> _addr_saLen, ptr<Filetime> _addr_lastWriteTime)
        {
            error regerrno = default!;
            ref ushort @class = ref _addr_@class.val;
            ref uint classLen = ref _addr_classLen.val;
            ref uint reserved = ref _addr_reserved.val;
            ref uint subkeysLen = ref _addr_subkeysLen.val;
            ref uint maxSubkeyLen = ref _addr_maxSubkeyLen.val;
            ref uint maxClassLen = ref _addr_maxClassLen.val;
            ref uint valuesLen = ref _addr_valuesLen.val;
            ref uint maxValueNameLen = ref _addr_maxValueNameLen.val;
            ref uint maxValueLen = ref _addr_maxValueLen.val;
            ref uint saLen = ref _addr_saLen.val;
            ref Filetime lastWriteTime = ref _addr_lastWriteTime.val;

            var (r0, _, _) = Syscall12(procRegQueryInfoKeyW.Addr(), 12L, uintptr(key), uintptr(@unsafe.Pointer(class)), uintptr(@unsafe.Pointer(classLen)), uintptr(@unsafe.Pointer(reserved)), uintptr(@unsafe.Pointer(subkeysLen)), uintptr(@unsafe.Pointer(maxSubkeyLen)), uintptr(@unsafe.Pointer(maxClassLen)), uintptr(@unsafe.Pointer(valuesLen)), uintptr(@unsafe.Pointer(maxValueNameLen)), uintptr(@unsafe.Pointer(maxValueLen)), uintptr(@unsafe.Pointer(saLen)), uintptr(@unsafe.Pointer(lastWriteTime)));
            if (r0 != 0L)
            {
                regerrno = Errno(r0);
            }

            return ;

        }

        public static error RegEnumKeyEx(Handle key, uint index, ptr<ushort> _addr_name, ptr<uint> _addr_nameLen, ptr<uint> _addr_reserved, ptr<ushort> _addr_@class, ptr<uint> _addr_classLen, ptr<Filetime> _addr_lastWriteTime)
        {
            error regerrno = default!;
            ref ushort name = ref _addr_name.val;
            ref uint nameLen = ref _addr_nameLen.val;
            ref uint reserved = ref _addr_reserved.val;
            ref ushort @class = ref _addr_@class.val;
            ref uint classLen = ref _addr_classLen.val;
            ref Filetime lastWriteTime = ref _addr_lastWriteTime.val;

            var (r0, _, _) = Syscall9(procRegEnumKeyExW.Addr(), 8L, uintptr(key), uintptr(index), uintptr(@unsafe.Pointer(name)), uintptr(@unsafe.Pointer(nameLen)), uintptr(@unsafe.Pointer(reserved)), uintptr(@unsafe.Pointer(class)), uintptr(@unsafe.Pointer(classLen)), uintptr(@unsafe.Pointer(lastWriteTime)), 0L);
            if (r0 != 0L)
            {
                regerrno = Errno(r0);
            }

            return ;

        }

        public static error RegQueryValueEx(Handle key, ptr<ushort> _addr_name, ptr<uint> _addr_reserved, ptr<uint> _addr_valtype, ptr<byte> _addr_buf, ptr<uint> _addr_buflen)
        {
            error regerrno = default!;
            ref ushort name = ref _addr_name.val;
            ref uint reserved = ref _addr_reserved.val;
            ref uint valtype = ref _addr_valtype.val;
            ref byte buf = ref _addr_buf.val;
            ref uint buflen = ref _addr_buflen.val;

            var (r0, _, _) = Syscall6(procRegQueryValueExW.Addr(), 6L, uintptr(key), uintptr(@unsafe.Pointer(name)), uintptr(@unsafe.Pointer(reserved)), uintptr(@unsafe.Pointer(valtype)), uintptr(@unsafe.Pointer(buf)), uintptr(@unsafe.Pointer(buflen)));
            if (r0 != 0L)
            {
                regerrno = Errno(r0);
            }

            return ;

        }

        private static uint getCurrentProcessId()
        {
            uint pid = default;

            var (r0, _, _) = Syscall(procGetCurrentProcessId.Addr(), 0L, 0L, 0L, 0L);
            pid = uint32(r0);
            return ;
        }

        public static error GetConsoleMode(Handle console, ptr<uint> _addr_mode)
        {
            error err = default!;
            ref uint mode = ref _addr_mode.val;

            var (r1, _, e1) = Syscall(procGetConsoleMode.Addr(), 2L, uintptr(console), uintptr(@unsafe.Pointer(mode)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error WriteConsole(Handle console, ptr<ushort> _addr_buf, uint towrite, ptr<uint> _addr_written, ptr<byte> _addr_reserved)
        {
            error err = default!;
            ref ushort buf = ref _addr_buf.val;
            ref uint written = ref _addr_written.val;
            ref byte reserved = ref _addr_reserved.val;

            var (r1, _, e1) = Syscall6(procWriteConsoleW.Addr(), 5L, uintptr(console), uintptr(@unsafe.Pointer(buf)), uintptr(towrite), uintptr(@unsafe.Pointer(written)), uintptr(@unsafe.Pointer(reserved)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error ReadConsole(Handle console, ptr<ushort> _addr_buf, uint toread, ptr<uint> _addr_read, ptr<byte> _addr_inputControl)
        {
            error err = default!;
            ref ushort buf = ref _addr_buf.val;
            ref uint read = ref _addr_read.val;
            ref byte inputControl = ref _addr_inputControl.val;

            var (r1, _, e1) = Syscall6(procReadConsoleW.Addr(), 5L, uintptr(console), uintptr(@unsafe.Pointer(buf)), uintptr(toread), uintptr(@unsafe.Pointer(read)), uintptr(@unsafe.Pointer(inputControl)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (Handle, error) CreateToolhelp32Snapshot(uint flags, uint processId)
        {
            Handle handle = default;
            error err = default!;

            var (r0, _, e1) = Syscall(procCreateToolhelp32Snapshot.Addr(), 2L, uintptr(flags), uintptr(processId), 0L);
            handle = Handle(r0);
            if (handle == InvalidHandle)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error Process32First(Handle snapshot, ptr<ProcessEntry32> _addr_procEntry)
        {
            error err = default!;
            ref ProcessEntry32 procEntry = ref _addr_procEntry.val;

            var (r1, _, e1) = Syscall(procProcess32FirstW.Addr(), 2L, uintptr(snapshot), uintptr(@unsafe.Pointer(procEntry)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error Process32Next(Handle snapshot, ptr<ProcessEntry32> _addr_procEntry)
        {
            error err = default!;
            ref ProcessEntry32 procEntry = ref _addr_procEntry.val;

            var (r1, _, e1) = Syscall(procProcess32NextW.Addr(), 2L, uintptr(snapshot), uintptr(@unsafe.Pointer(procEntry)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error DeviceIoControl(Handle handle, uint ioControlCode, ptr<byte> _addr_inBuffer, uint inBufferSize, ptr<byte> _addr_outBuffer, uint outBufferSize, ptr<uint> _addr_bytesReturned, ptr<Overlapped> _addr_overlapped)
        {
            error err = default!;
            ref byte inBuffer = ref _addr_inBuffer.val;
            ref byte outBuffer = ref _addr_outBuffer.val;
            ref uint bytesReturned = ref _addr_bytesReturned.val;
            ref Overlapped overlapped = ref _addr_overlapped.val;

            var (r1, _, e1) = Syscall9(procDeviceIoControl.Addr(), 8L, uintptr(handle), uintptr(ioControlCode), uintptr(@unsafe.Pointer(inBuffer)), uintptr(inBufferSize), uintptr(@unsafe.Pointer(outBuffer)), uintptr(outBufferSize), uintptr(@unsafe.Pointer(bytesReturned)), uintptr(@unsafe.Pointer(overlapped)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CreateSymbolicLink(ptr<ushort> _addr_symlinkfilename, ptr<ushort> _addr_targetfilename, uint flags)
        {
            error err = default!;
            ref ushort symlinkfilename = ref _addr_symlinkfilename.val;
            ref ushort targetfilename = ref _addr_targetfilename.val;

            var (r1, _, e1) = Syscall(procCreateSymbolicLinkW.Addr(), 3L, uintptr(@unsafe.Pointer(symlinkfilename)), uintptr(@unsafe.Pointer(targetfilename)), uintptr(flags));
            if (r1 & 0xffUL == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error CreateHardLink(ptr<ushort> _addr_filename, ptr<ushort> _addr_existingfilename, System.UIntPtr reserved)
        {
            error err = default!;
            ref ushort filename = ref _addr_filename.val;
            ref ushort existingfilename = ref _addr_existingfilename.val;

            var (r1, _, e1) = Syscall(procCreateHardLinkW.Addr(), 3L, uintptr(@unsafe.Pointer(filename)), uintptr(@unsafe.Pointer(existingfilename)), uintptr(reserved));
            if (r1 & 0xffUL == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error WSAStartup(uint verreq, ptr<WSAData> _addr_data)
        {
            error sockerr = default!;
            ref WSAData data = ref _addr_data.val;

            var (r0, _, _) = Syscall(procWSAStartup.Addr(), 2L, uintptr(verreq), uintptr(@unsafe.Pointer(data)), 0L);
            if (r0 != 0L)
            {
                sockerr = Errno(r0);
            }

            return ;

        }

        public static error WSACleanup()
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procWSACleanup.Addr(), 0L, 0L, 0L, 0L);
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error WSAIoctl(Handle s, uint iocc, ptr<byte> _addr_inbuf, uint cbif, ptr<byte> _addr_outbuf, uint cbob, ptr<uint> _addr_cbbr, ptr<Overlapped> _addr_overlapped, System.UIntPtr completionRoutine)
        {
            error err = default!;
            ref byte inbuf = ref _addr_inbuf.val;
            ref byte outbuf = ref _addr_outbuf.val;
            ref uint cbbr = ref _addr_cbbr.val;
            ref Overlapped overlapped = ref _addr_overlapped.val;

            var (r1, _, e1) = Syscall9(procWSAIoctl.Addr(), 9L, uintptr(s), uintptr(iocc), uintptr(@unsafe.Pointer(inbuf)), uintptr(cbif), uintptr(@unsafe.Pointer(outbuf)), uintptr(cbob), uintptr(@unsafe.Pointer(cbbr)), uintptr(@unsafe.Pointer(overlapped)), uintptr(completionRoutine));
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        private static (Handle, error) socket(int af, int typ, int protocol)
        {
            Handle handle = default;
            error err = default!;

            var (r0, _, e1) = Syscall(procsocket.Addr(), 3L, uintptr(af), uintptr(typ), uintptr(protocol));
            handle = Handle(r0);
            if (handle == InvalidHandle)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error Setsockopt(Handle s, int level, int optname, ptr<byte> _addr_optval, int optlen)
        {
            error err = default!;
            ref byte optval = ref _addr_optval.val;

            var (r1, _, e1) = Syscall6(procsetsockopt.Addr(), 5L, uintptr(s), uintptr(level), uintptr(optname), uintptr(@unsafe.Pointer(optval)), uintptr(optlen), 0L);
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error Getsockopt(Handle s, int level, int optname, ptr<byte> _addr_optval, ptr<int> _addr_optlen)
        {
            error err = default!;
            ref byte optval = ref _addr_optval.val;
            ref int optlen = ref _addr_optlen.val;

            var (r1, _, e1) = Syscall6(procgetsockopt.Addr(), 5L, uintptr(s), uintptr(level), uintptr(optname), uintptr(@unsafe.Pointer(optval)), uintptr(@unsafe.Pointer(optlen)), 0L);
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        private static error bind(Handle s, unsafe.Pointer name, int namelen)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procbind.Addr(), 3L, uintptr(s), uintptr(name), uintptr(namelen));
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        private static error connect(Handle s, unsafe.Pointer name, int namelen)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procconnect.Addr(), 3L, uintptr(s), uintptr(name), uintptr(namelen));
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        private static error getsockname(Handle s, ptr<RawSockaddrAny> _addr_rsa, ptr<int> _addr_addrlen)
        {
            error err = default!;
            ref RawSockaddrAny rsa = ref _addr_rsa.val;
            ref int addrlen = ref _addr_addrlen.val;

            var (r1, _, e1) = Syscall(procgetsockname.Addr(), 3L, uintptr(s), uintptr(@unsafe.Pointer(rsa)), uintptr(@unsafe.Pointer(addrlen)));
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        private static error getpeername(Handle s, ptr<RawSockaddrAny> _addr_rsa, ptr<int> _addr_addrlen)
        {
            error err = default!;
            ref RawSockaddrAny rsa = ref _addr_rsa.val;
            ref int addrlen = ref _addr_addrlen.val;

            var (r1, _, e1) = Syscall(procgetpeername.Addr(), 3L, uintptr(s), uintptr(@unsafe.Pointer(rsa)), uintptr(@unsafe.Pointer(addrlen)));
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        private static error listen(Handle s, int backlog)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(proclisten.Addr(), 2L, uintptr(s), uintptr(backlog), 0L);
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        private static error shutdown(Handle s, int how)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procshutdown.Addr(), 2L, uintptr(s), uintptr(how), 0L);
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error Closesocket(Handle s)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procclosesocket.Addr(), 1L, uintptr(s), 0L, 0L);
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error AcceptEx(Handle ls, Handle @as, ptr<byte> _addr_buf, uint rxdatalen, uint laddrlen, uint raddrlen, ptr<uint> _addr_recvd, ptr<Overlapped> _addr_overlapped)
        {
            error err = default!;
            ref byte buf = ref _addr_buf.val;
            ref uint recvd = ref _addr_recvd.val;
            ref Overlapped overlapped = ref _addr_overlapped.val;

            var (r1, _, e1) = Syscall9(procAcceptEx.Addr(), 8L, uintptr(ls), uintptr(as), uintptr(@unsafe.Pointer(buf)), uintptr(rxdatalen), uintptr(laddrlen), uintptr(raddrlen), uintptr(@unsafe.Pointer(recvd)), uintptr(@unsafe.Pointer(overlapped)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static void GetAcceptExSockaddrs(ptr<byte> _addr_buf, uint rxdatalen, uint laddrlen, uint raddrlen, ptr<ptr<RawSockaddrAny>> _addr_lrsa, ptr<int> _addr_lrsalen, ptr<ptr<RawSockaddrAny>> _addr_rrsa, ptr<int> _addr_rrsalen)
        {
            ref byte buf = ref _addr_buf.val;
            ref ptr<RawSockaddrAny> lrsa = ref _addr_lrsa.val;
            ref int lrsalen = ref _addr_lrsalen.val;
            ref ptr<RawSockaddrAny> rrsa = ref _addr_rrsa.val;
            ref int rrsalen = ref _addr_rrsalen.val;

            Syscall9(procGetAcceptExSockaddrs.Addr(), 8L, uintptr(@unsafe.Pointer(buf)), uintptr(rxdatalen), uintptr(laddrlen), uintptr(raddrlen), uintptr(@unsafe.Pointer(lrsa)), uintptr(@unsafe.Pointer(lrsalen)), uintptr(@unsafe.Pointer(rrsa)), uintptr(@unsafe.Pointer(rrsalen)), 0L);
            return ;
        }

        public static error WSARecv(Handle s, ptr<WSABuf> _addr_bufs, uint bufcnt, ptr<uint> _addr_recvd, ptr<uint> _addr_flags, ptr<Overlapped> _addr_overlapped, ptr<byte> _addr_croutine)
        {
            error err = default!;
            ref WSABuf bufs = ref _addr_bufs.val;
            ref uint recvd = ref _addr_recvd.val;
            ref uint flags = ref _addr_flags.val;
            ref Overlapped overlapped = ref _addr_overlapped.val;
            ref byte croutine = ref _addr_croutine.val;

            var (r1, _, e1) = Syscall9(procWSARecv.Addr(), 7L, uintptr(s), uintptr(@unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(@unsafe.Pointer(recvd)), uintptr(@unsafe.Pointer(flags)), uintptr(@unsafe.Pointer(overlapped)), uintptr(@unsafe.Pointer(croutine)), 0L, 0L);
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error WSASend(Handle s, ptr<WSABuf> _addr_bufs, uint bufcnt, ptr<uint> _addr_sent, uint flags, ptr<Overlapped> _addr_overlapped, ptr<byte> _addr_croutine)
        {
            error err = default!;
            ref WSABuf bufs = ref _addr_bufs.val;
            ref uint sent = ref _addr_sent.val;
            ref Overlapped overlapped = ref _addr_overlapped.val;
            ref byte croutine = ref _addr_croutine.val;

            var (r1, _, e1) = Syscall9(procWSASend.Addr(), 7L, uintptr(s), uintptr(@unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(@unsafe.Pointer(sent)), uintptr(flags), uintptr(@unsafe.Pointer(overlapped)), uintptr(@unsafe.Pointer(croutine)), 0L, 0L);
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error WSARecvFrom(Handle s, ptr<WSABuf> _addr_bufs, uint bufcnt, ptr<uint> _addr_recvd, ptr<uint> _addr_flags, ptr<RawSockaddrAny> _addr_from, ptr<int> _addr_fromlen, ptr<Overlapped> _addr_overlapped, ptr<byte> _addr_croutine)
        {
            error err = default!;
            ref WSABuf bufs = ref _addr_bufs.val;
            ref uint recvd = ref _addr_recvd.val;
            ref uint flags = ref _addr_flags.val;
            ref RawSockaddrAny from = ref _addr_from.val;
            ref int fromlen = ref _addr_fromlen.val;
            ref Overlapped overlapped = ref _addr_overlapped.val;
            ref byte croutine = ref _addr_croutine.val;

            var (r1, _, e1) = Syscall9(procWSARecvFrom.Addr(), 9L, uintptr(s), uintptr(@unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(@unsafe.Pointer(recvd)), uintptr(@unsafe.Pointer(flags)), uintptr(@unsafe.Pointer(from)), uintptr(@unsafe.Pointer(fromlen)), uintptr(@unsafe.Pointer(overlapped)), uintptr(@unsafe.Pointer(croutine)));
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error WSASendTo(Handle s, ptr<WSABuf> _addr_bufs, uint bufcnt, ptr<uint> _addr_sent, uint flags, ptr<RawSockaddrAny> _addr_to, int tolen, ptr<Overlapped> _addr_overlapped, ptr<byte> _addr_croutine)
        {
            error err = default!;
            ref WSABuf bufs = ref _addr_bufs.val;
            ref uint sent = ref _addr_sent.val;
            ref RawSockaddrAny to = ref _addr_to.val;
            ref Overlapped overlapped = ref _addr_overlapped.val;
            ref byte croutine = ref _addr_croutine.val;

            var (r1, _, e1) = Syscall9(procWSASendTo.Addr(), 9L, uintptr(s), uintptr(@unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(@unsafe.Pointer(sent)), uintptr(flags), uintptr(@unsafe.Pointer(to)), uintptr(tolen), uintptr(@unsafe.Pointer(overlapped)), uintptr(@unsafe.Pointer(croutine)));
            if (r1 == socket_error)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (ptr<Hostent>, error) GetHostByName(@string name)
        {
            ptr<Hostent> h = default!;
            error err = default!;

            ptr<byte> _p0;
            _p0, err = BytePtrFromString(name);
            if (err != null)
            {
                return ;
            }

            return _addr__GetHostByName(_p0)!;

        }

        private static (ptr<Hostent>, error) _GetHostByName(ptr<byte> _addr_name)
        {
            ptr<Hostent> h = default!;
            error err = default!;
            ref byte name = ref _addr_name.val;

            var (r0, _, e1) = Syscall(procgethostbyname.Addr(), 1L, uintptr(@unsafe.Pointer(name)), 0L, 0L);
            h = (Hostent.val)(@unsafe.Pointer(r0));
            if (h == null)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (ptr<Servent>, error) GetServByName(@string name, @string proto)
        {
            ptr<Servent> s = default!;
            error err = default!;

            ptr<byte> _p0;
            _p0, err = BytePtrFromString(name);
            if (err != null)
            {
                return ;
            }

            ptr<byte> _p1;
            _p1, err = BytePtrFromString(proto);
            if (err != null)
            {
                return ;
            }

            return _addr__GetServByName(_p0, _p1)!;

        }

        private static (ptr<Servent>, error) _GetServByName(ptr<byte> _addr_name, ptr<byte> _addr_proto)
        {
            ptr<Servent> s = default!;
            error err = default!;
            ref byte name = ref _addr_name.val;
            ref byte proto = ref _addr_proto.val;

            var (r0, _, e1) = Syscall(procgetservbyname.Addr(), 2L, uintptr(@unsafe.Pointer(name)), uintptr(@unsafe.Pointer(proto)), 0L);
            s = (Servent.val)(@unsafe.Pointer(r0));
            if (s == null)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static ushort Ntohs(ushort netshort)
        {
            ushort u = default;

            var (r0, _, _) = Syscall(procntohs.Addr(), 1L, uintptr(netshort), 0L, 0L);
            u = uint16(r0);
            return ;
        }

        public static (ptr<Protoent>, error) GetProtoByName(@string name)
        {
            ptr<Protoent> p = default!;
            error err = default!;

            ptr<byte> _p0;
            _p0, err = BytePtrFromString(name);
            if (err != null)
            {
                return ;
            }

            return _addr__GetProtoByName(_p0)!;

        }

        private static (ptr<Protoent>, error) _GetProtoByName(ptr<byte> _addr_name)
        {
            ptr<Protoent> p = default!;
            error err = default!;
            ref byte name = ref _addr_name.val;

            var (r0, _, e1) = Syscall(procgetprotobyname.Addr(), 1L, uintptr(@unsafe.Pointer(name)), 0L, 0L);
            p = (Protoent.val)(@unsafe.Pointer(r0));
            if (p == null)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error DnsQuery(@string name, ushort qtype, uint options, ptr<byte> _addr_extra, ptr<ptr<DNSRecord>> _addr_qrs, ptr<byte> _addr_pr)
        {
            error status = default!;
            ref byte extra = ref _addr_extra.val;
            ref ptr<DNSRecord> qrs = ref _addr_qrs.val;
            ref byte pr = ref _addr_pr.val;

            ptr<ushort> _p0;
            _p0, status = UTF16PtrFromString(name);
            if (status != null)
            {
                return ;
            }

            return error.As(_DnsQuery(_p0, qtype, options, _addr_extra, _addr_qrs, _addr_pr))!;

        }

        private static error _DnsQuery(ptr<ushort> _addr_name, ushort qtype, uint options, ptr<byte> _addr_extra, ptr<ptr<DNSRecord>> _addr_qrs, ptr<byte> _addr_pr)
        {
            error status = default!;
            ref ushort name = ref _addr_name.val;
            ref byte extra = ref _addr_extra.val;
            ref ptr<DNSRecord> qrs = ref _addr_qrs.val;
            ref byte pr = ref _addr_pr.val;

            var (r0, _, _) = Syscall6(procDnsQuery_W.Addr(), 6L, uintptr(@unsafe.Pointer(name)), uintptr(qtype), uintptr(options), uintptr(@unsafe.Pointer(extra)), uintptr(@unsafe.Pointer(qrs)), uintptr(@unsafe.Pointer(pr)));
            if (r0 != 0L)
            {
                status = Errno(r0);
            }

            return ;

        }

        public static void DnsRecordListFree(ptr<DNSRecord> _addr_rl, uint freetype)
        {
            ref DNSRecord rl = ref _addr_rl.val;

            Syscall(procDnsRecordListFree.Addr(), 2L, uintptr(@unsafe.Pointer(rl)), uintptr(freetype), 0L);
            return ;
        }

        public static bool DnsNameCompare(ptr<ushort> _addr_name1, ptr<ushort> _addr_name2)
        {
            bool same = default;
            ref ushort name1 = ref _addr_name1.val;
            ref ushort name2 = ref _addr_name2.val;

            var (r0, _, _) = Syscall(procDnsNameCompare_W.Addr(), 2L, uintptr(@unsafe.Pointer(name1)), uintptr(@unsafe.Pointer(name2)), 0L);
            same = r0 != 0L;
            return ;
        }

        public static error GetAddrInfoW(ptr<ushort> _addr_nodename, ptr<ushort> _addr_servicename, ptr<AddrinfoW> _addr_hints, ptr<ptr<AddrinfoW>> _addr_result)
        {
            error sockerr = default!;
            ref ushort nodename = ref _addr_nodename.val;
            ref ushort servicename = ref _addr_servicename.val;
            ref AddrinfoW hints = ref _addr_hints.val;
            ref ptr<AddrinfoW> result = ref _addr_result.val;

            var (r0, _, _) = Syscall6(procGetAddrInfoW.Addr(), 4L, uintptr(@unsafe.Pointer(nodename)), uintptr(@unsafe.Pointer(servicename)), uintptr(@unsafe.Pointer(hints)), uintptr(@unsafe.Pointer(result)), 0L, 0L);
            if (r0 != 0L)
            {
                sockerr = Errno(r0);
            }

            return ;

        }

        public static void FreeAddrInfoW(ptr<AddrinfoW> _addr_addrinfo)
        {
            ref AddrinfoW addrinfo = ref _addr_addrinfo.val;

            Syscall(procFreeAddrInfoW.Addr(), 1L, uintptr(@unsafe.Pointer(addrinfo)), 0L, 0L);
            return ;
        }

        public static error GetIfEntry(ptr<MibIfRow> _addr_pIfRow)
        {
            error errcode = default!;
            ref MibIfRow pIfRow = ref _addr_pIfRow.val;

            var (r0, _, _) = Syscall(procGetIfEntry.Addr(), 1L, uintptr(@unsafe.Pointer(pIfRow)), 0L, 0L);
            if (r0 != 0L)
            {
                errcode = Errno(r0);
            }

            return ;

        }

        public static error GetAdaptersInfo(ptr<IpAdapterInfo> _addr_ai, ptr<uint> _addr_ol)
        {
            error errcode = default!;
            ref IpAdapterInfo ai = ref _addr_ai.val;
            ref uint ol = ref _addr_ol.val;

            var (r0, _, _) = Syscall(procGetAdaptersInfo.Addr(), 2L, uintptr(@unsafe.Pointer(ai)), uintptr(@unsafe.Pointer(ol)), 0L);
            if (r0 != 0L)
            {
                errcode = Errno(r0);
            }

            return ;

        }

        public static error SetFileCompletionNotificationModes(Handle handle, byte flags)
        {
            error err = default!;

            var (r1, _, e1) = Syscall(procSetFileCompletionNotificationModes.Addr(), 2L, uintptr(handle), uintptr(flags), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static (int, error) WSAEnumProtocols(ptr<int> _addr_protocols, ptr<WSAProtocolInfo> _addr_protocolBuffer, ptr<uint> _addr_bufferLength)
        {
            int n = default;
            error err = default!;
            ref int protocols = ref _addr_protocols.val;
            ref WSAProtocolInfo protocolBuffer = ref _addr_protocolBuffer.val;
            ref uint bufferLength = ref _addr_bufferLength.val;

            var (r0, _, e1) = Syscall(procWSAEnumProtocolsW.Addr(), 3L, uintptr(@unsafe.Pointer(protocols)), uintptr(@unsafe.Pointer(protocolBuffer)), uintptr(@unsafe.Pointer(bufferLength)));
            n = int32(r0);
            if (n == -1L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error TranslateName(ptr<ushort> _addr_accName, uint accNameFormat, uint desiredNameFormat, ptr<ushort> _addr_translatedName, ptr<uint> _addr_nSize)
        {
            error err = default!;
            ref ushort accName = ref _addr_accName.val;
            ref ushort translatedName = ref _addr_translatedName.val;
            ref uint nSize = ref _addr_nSize.val;

            var (r1, _, e1) = Syscall6(procTranslateNameW.Addr(), 5L, uintptr(@unsafe.Pointer(accName)), uintptr(accNameFormat), uintptr(desiredNameFormat), uintptr(@unsafe.Pointer(translatedName)), uintptr(@unsafe.Pointer(nSize)), 0L);
            if (r1 & 0xffUL == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error GetUserNameEx(uint nameFormat, ptr<ushort> _addr_nameBuffre, ptr<uint> _addr_nSize)
        {
            error err = default!;
            ref ushort nameBuffre = ref _addr_nameBuffre.val;
            ref uint nSize = ref _addr_nSize.val;

            var (r1, _, e1) = Syscall(procGetUserNameExW.Addr(), 3L, uintptr(nameFormat), uintptr(@unsafe.Pointer(nameBuffre)), uintptr(@unsafe.Pointer(nSize)));
            if (r1 & 0xffUL == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error NetUserGetInfo(ptr<ushort> _addr_serverName, ptr<ushort> _addr_userName, uint level, ptr<ptr<byte>> _addr_buf)
        {
            error neterr = default!;
            ref ushort serverName = ref _addr_serverName.val;
            ref ushort userName = ref _addr_userName.val;
            ref ptr<byte> buf = ref _addr_buf.val;

            var (r0, _, _) = Syscall6(procNetUserGetInfo.Addr(), 4L, uintptr(@unsafe.Pointer(serverName)), uintptr(@unsafe.Pointer(userName)), uintptr(level), uintptr(@unsafe.Pointer(buf)), 0L, 0L);
            if (r0 != 0L)
            {
                neterr = Errno(r0);
            }

            return ;

        }

        public static error NetGetJoinInformation(ptr<ushort> _addr_server, ptr<ptr<ushort>> _addr_name, ptr<uint> _addr_bufType)
        {
            error neterr = default!;
            ref ushort server = ref _addr_server.val;
            ref ptr<ushort> name = ref _addr_name.val;
            ref uint bufType = ref _addr_bufType.val;

            var (r0, _, _) = Syscall(procNetGetJoinInformation.Addr(), 3L, uintptr(@unsafe.Pointer(server)), uintptr(@unsafe.Pointer(name)), uintptr(@unsafe.Pointer(bufType)));
            if (r0 != 0L)
            {
                neterr = Errno(r0);
            }

            return ;

        }

        public static error NetApiBufferFree(ptr<byte> _addr_buf)
        {
            error neterr = default!;
            ref byte buf = ref _addr_buf.val;

            var (r0, _, _) = Syscall(procNetApiBufferFree.Addr(), 1L, uintptr(@unsafe.Pointer(buf)), 0L, 0L);
            if (r0 != 0L)
            {
                neterr = Errno(r0);
            }

            return ;

        }

        public static error LookupAccountSid(ptr<ushort> _addr_systemName, ptr<SID> _addr_sid, ptr<ushort> _addr_name, ptr<uint> _addr_nameLen, ptr<ushort> _addr_refdDomainName, ptr<uint> _addr_refdDomainNameLen, ptr<uint> _addr_use)
        {
            error err = default!;
            ref ushort systemName = ref _addr_systemName.val;
            ref SID sid = ref _addr_sid.val;
            ref ushort name = ref _addr_name.val;
            ref uint nameLen = ref _addr_nameLen.val;
            ref ushort refdDomainName = ref _addr_refdDomainName.val;
            ref uint refdDomainNameLen = ref _addr_refdDomainNameLen.val;
            ref uint use = ref _addr_use.val;

            var (r1, _, e1) = Syscall9(procLookupAccountSidW.Addr(), 7L, uintptr(@unsafe.Pointer(systemName)), uintptr(@unsafe.Pointer(sid)), uintptr(@unsafe.Pointer(name)), uintptr(@unsafe.Pointer(nameLen)), uintptr(@unsafe.Pointer(refdDomainName)), uintptr(@unsafe.Pointer(refdDomainNameLen)), uintptr(@unsafe.Pointer(use)), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error LookupAccountName(ptr<ushort> _addr_systemName, ptr<ushort> _addr_accountName, ptr<SID> _addr_sid, ptr<uint> _addr_sidLen, ptr<ushort> _addr_refdDomainName, ptr<uint> _addr_refdDomainNameLen, ptr<uint> _addr_use)
        {
            error err = default!;
            ref ushort systemName = ref _addr_systemName.val;
            ref ushort accountName = ref _addr_accountName.val;
            ref SID sid = ref _addr_sid.val;
            ref uint sidLen = ref _addr_sidLen.val;
            ref ushort refdDomainName = ref _addr_refdDomainName.val;
            ref uint refdDomainNameLen = ref _addr_refdDomainNameLen.val;
            ref uint use = ref _addr_use.val;

            var (r1, _, e1) = Syscall9(procLookupAccountNameW.Addr(), 7L, uintptr(@unsafe.Pointer(systemName)), uintptr(@unsafe.Pointer(accountName)), uintptr(@unsafe.Pointer(sid)), uintptr(@unsafe.Pointer(sidLen)), uintptr(@unsafe.Pointer(refdDomainName)), uintptr(@unsafe.Pointer(refdDomainNameLen)), uintptr(@unsafe.Pointer(use)), 0L, 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error ConvertSidToStringSid(ptr<SID> _addr_sid, ptr<ptr<ushort>> _addr_stringSid)
        {
            error err = default!;
            ref SID sid = ref _addr_sid.val;
            ref ptr<ushort> stringSid = ref _addr_stringSid.val;

            var (r1, _, e1) = Syscall(procConvertSidToStringSidW.Addr(), 2L, uintptr(@unsafe.Pointer(sid)), uintptr(@unsafe.Pointer(stringSid)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error ConvertStringSidToSid(ptr<ushort> _addr_stringSid, ptr<ptr<SID>> _addr_sid)
        {
            error err = default!;
            ref ushort stringSid = ref _addr_stringSid.val;
            ref ptr<SID> sid = ref _addr_sid.val;

            var (r1, _, e1) = Syscall(procConvertStringSidToSidW.Addr(), 2L, uintptr(@unsafe.Pointer(stringSid)), uintptr(@unsafe.Pointer(sid)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static uint GetLengthSid(ptr<SID> _addr_sid)
        {
            uint len = default;
            ref SID sid = ref _addr_sid.val;

            var (r0, _, _) = Syscall(procGetLengthSid.Addr(), 1L, uintptr(@unsafe.Pointer(sid)), 0L, 0L);
            len = uint32(r0);
            return ;
        }

        public static error CopySid(uint destSidLen, ptr<SID> _addr_destSid, ptr<SID> _addr_srcSid)
        {
            error err = default!;
            ref SID destSid = ref _addr_destSid.val;
            ref SID srcSid = ref _addr_srcSid.val;

            var (r1, _, e1) = Syscall(procCopySid.Addr(), 3L, uintptr(destSidLen), uintptr(@unsafe.Pointer(destSid)), uintptr(@unsafe.Pointer(srcSid)));
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error OpenProcessToken(Handle h, uint access, ptr<Token> _addr_token)
        {
            error err = default!;
            ref Token token = ref _addr_token.val;

            var (r1, _, e1) = Syscall(procOpenProcessToken.Addr(), 3L, uintptr(h), uintptr(access), uintptr(@unsafe.Pointer(token)));
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error GetTokenInformation(Token t, uint infoClass, ptr<byte> _addr_info, uint infoLen, ptr<uint> _addr_returnedLen)
        {
            error err = default!;
            ref byte info = ref _addr_info.val;
            ref uint returnedLen = ref _addr_returnedLen.val;

            var (r1, _, e1) = Syscall6(procGetTokenInformation.Addr(), 5L, uintptr(t), uintptr(infoClass), uintptr(@unsafe.Pointer(info)), uintptr(infoLen), uintptr(@unsafe.Pointer(returnedLen)), 0L);
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        public static error GetUserProfileDirectory(Token t, ptr<ushort> _addr_dir, ptr<uint> _addr_dirLen)
        {
            error err = default!;
            ref ushort dir = ref _addr_dir.val;
            ref uint dirLen = ref _addr_dirLen.val;

            var (r1, _, e1) = Syscall(procGetUserProfileDirectoryW.Addr(), 3L, uintptr(t), uintptr(@unsafe.Pointer(dir)), uintptr(@unsafe.Pointer(dirLen)));
            if (r1 == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }

        private static (uint, error) getSystemDirectory(ptr<ushort> _addr_dir, uint dirLen)
        {
            uint len = default;
            error err = default!;
            ref ushort dir = ref _addr_dir.val;

            var (r0, _, e1) = Syscall(procGetSystemDirectoryW.Addr(), 2L, uintptr(@unsafe.Pointer(dir)), uintptr(dirLen), 0L);
            len = uint32(r0);
            if (len == 0L)
            {
                if (e1 != 0L)
                {
                    err = errnoErr(e1);
                }
                else
                {
                    err = EINVAL;
                }

            }

            return ;

        }
    }
}
