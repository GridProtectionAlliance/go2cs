//---------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes to this
//     file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generated on 2020 October 09 05:19:33 UTC
// </auto-generated>
//---------------------------------------------------------
using System;
using System.CodeDom.Compiler;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using static go.builtin;
using bytes = go.bytes_package;
using fmt = go.fmt_package;
using constant = go.go.constant_package;
using token = go.go.token_package;
using go;

#nullable enable
#pragma warning disable CS0660, CS0661

namespace go {
namespace go
{
    public static partial class types_package
    {
        [GeneratedCode("go2cs", "0.1.0.0")]
        public partial interface Object
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static Object As<T>(in T target) => (Object<T>)target!;

            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static Object As<T>(ptr<T> target_ptr) => (Object<T>)target_ptr;

            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static Object? As(object target) =>
                typeof(Object<>).CreateInterfaceHandler<Object>(target);
        }

        [GeneratedCode("go2cs", "0.1.0.0")]
        public class Object<T> : Object
        {
            private T m_target = default!;
            private readonly ptr<T>? m_target_ptr;
            private readonly bool m_target_is_ptr;

            public ref T Target
            {
                get
                {
                    if (m_target_is_ptr && !(m_target_ptr is null))
                        return ref m_target_ptr.val;

                    return ref m_target;
                }
            }

            public Object(in T target) => m_target = target;

            public Object(ptr<T> target_ptr)
            {
                m_target_ptr = target_ptr;
                m_target_is_ptr = true;
            }

            private delegate token.Pos ParentByPtr(ptr<T> value);
            private delegate token.Pos ParentByVal(T value);

            private static readonly ParentByPtr? s_ParentByPtr;
            private static readonly ParentByVal? s_ParentByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos Parent()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_ParentByPtr is null || !m_target_is_ptr)
                    return s_ParentByVal!(target);

                return s_ParentByPtr(m_target_ptr);
            }

            private delegate token.Pos PosByPtr(ptr<T> value);
            private delegate token.Pos PosByVal(T value);

            private static readonly PosByPtr? s_PosByPtr;
            private static readonly PosByVal? s_PosByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos Pos()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_PosByPtr is null || !m_target_is_ptr)
                    return s_PosByVal!(target);

                return s_PosByPtr(m_target_ptr);
            }

            private delegate token.Pos PkgByPtr(ptr<T> value);
            private delegate token.Pos PkgByVal(T value);

            private static readonly PkgByPtr? s_PkgByPtr;
            private static readonly PkgByVal? s_PkgByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos Pkg()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_PkgByPtr is null || !m_target_is_ptr)
                    return s_PkgByVal!(target);

                return s_PkgByPtr(m_target_ptr);
            }

            private delegate token.Pos NameByPtr(ptr<T> value);
            private delegate token.Pos NameByVal(T value);

            private static readonly NameByPtr? s_NameByPtr;
            private static readonly NameByVal? s_NameByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos Name()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_NameByPtr is null || !m_target_is_ptr)
                    return s_NameByVal!(target);

                return s_NameByPtr(m_target_ptr);
            }

            private delegate token.Pos TypeByPtr(ptr<T> value);
            private delegate token.Pos TypeByVal(T value);

            private static readonly TypeByPtr? s_TypeByPtr;
            private static readonly TypeByVal? s_TypeByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos Type()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_TypeByPtr is null || !m_target_is_ptr)
                    return s_TypeByVal!(target);

                return s_TypeByPtr(m_target_ptr);
            }

            private delegate token.Pos ExportedByPtr(ptr<T> value);
            private delegate token.Pos ExportedByVal(T value);

            private static readonly ExportedByPtr? s_ExportedByPtr;
            private static readonly ExportedByVal? s_ExportedByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos Exported()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_ExportedByPtr is null || !m_target_is_ptr)
                    return s_ExportedByVal!(target);

                return s_ExportedByPtr(m_target_ptr);
            }

            private delegate token.Pos IdByPtr(ptr<T> value);
            private delegate token.Pos IdByVal(T value);

            private static readonly IdByPtr? s_IdByPtr;
            private static readonly IdByVal? s_IdByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos Id()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_IdByPtr is null || !m_target_is_ptr)
                    return s_IdByVal!(target);

                return s_IdByPtr(m_target_ptr);
            }

            private delegate token.Pos StringByPtr(ptr<T> value);
            private delegate token.Pos StringByVal(T value);

            private static readonly StringByPtr? s_StringByPtr;
            private static readonly StringByVal? s_StringByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos String()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_StringByPtr is null || !m_target_is_ptr)
                    return s_StringByVal!(target);

                return s_StringByPtr(m_target_ptr);
            }

            private delegate token.Pos orderByPtr(ptr<T> value);
            private delegate token.Pos orderByVal(T value);

            private static readonly orderByPtr? s_orderByPtr;
            private static readonly orderByVal? s_orderByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos order()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_orderByPtr is null || !m_target_is_ptr)
                    return s_orderByVal!(target);

                return s_orderByPtr(m_target_ptr);
            }

            private delegate token.Pos colorByPtr(ptr<T> value);
            private delegate token.Pos colorByVal(T value);

            private static readonly colorByPtr? s_colorByPtr;
            private static readonly colorByVal? s_colorByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos color()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_colorByPtr is null || !m_target_is_ptr)
                    return s_colorByVal!(target);

                return s_colorByPtr(m_target_ptr);
            }

            private delegate token.Pos setOrderByPtr(ptr<T> value, uint _p0);
            private delegate token.Pos setOrderByVal(T value, uint _p0);

            private static readonly setOrderByPtr? s_setOrderByPtr;
            private static readonly setOrderByVal? s_setOrderByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos setOrder(uint _p0)
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_setOrderByPtr is null || !m_target_is_ptr)
                    return s_setOrderByVal!(target, _p0);

                return s_setOrderByPtr(m_target_ptr, _p0);
            }

            private delegate token.Pos setColorByPtr(ptr<T> value, color color);
            private delegate token.Pos setColorByVal(T value, color color);

            private static readonly setColorByPtr? s_setColorByPtr;
            private static readonly setColorByVal? s_setColorByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos setColor(color color)
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_setColorByPtr is null || !m_target_is_ptr)
                    return s_setColorByVal!(target, color);

                return s_setColorByPtr(m_target_ptr, color);
            }

            private delegate token.Pos setParentByPtr(ptr<T> value, ptr<Scope> _p0);
            private delegate token.Pos setParentByVal(T value, ptr<Scope> _p0);

            private static readonly setParentByPtr? s_setParentByPtr;
            private static readonly setParentByVal? s_setParentByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos setParent(ptr<Scope> _p0)
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_setParentByPtr is null || !m_target_is_ptr)
                    return s_setParentByVal!(target, _p0);

                return s_setParentByPtr(m_target_ptr, _p0);
            }

            private delegate token.Pos sameIdByPtr(ptr<T> value, ptr<Package> pkg, @string name);
            private delegate token.Pos sameIdByVal(T value, ptr<Package> pkg, @string name);

            private static readonly sameIdByPtr? s_sameIdByPtr;
            private static readonly sameIdByVal? s_sameIdByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos sameId(ptr<Package> pkg, @string name)
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_sameIdByPtr is null || !m_target_is_ptr)
                    return s_sameIdByVal!(target, pkg, name);

                return s_sameIdByPtr(m_target_ptr, pkg, name);
            }

            private delegate token.Pos scopePosByPtr(ptr<T> value);
            private delegate token.Pos scopePosByVal(T value);

            private static readonly scopePosByPtr? s_scopePosByPtr;
            private static readonly scopePosByVal? s_scopePosByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos scopePos()
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_scopePosByPtr is null || !m_target_is_ptr)
                    return s_scopePosByVal!(target);

                return s_scopePosByPtr(m_target_ptr);
            }

            private delegate token.Pos setScopePosByPtr(ptr<T> value, token.Pos pos);
            private delegate token.Pos setScopePosByVal(T value, token.Pos pos);

            private static readonly setScopePosByPtr? s_setScopePosByPtr;
            private static readonly setScopePosByVal? s_setScopePosByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public token.Pos setScopePos(token.Pos pos)
            {
                T target = m_target;

                if (m_target_is_ptr && !(m_target_ptr is null))
                    target = m_target_ptr.val;

                if (s_setScopePosByPtr is null || !m_target_is_ptr)
                    return s_setScopePosByVal!(target, pos);

                return s_setScopePosByPtr(m_target_ptr, pos);
            }
            
            public string ToString(string? format, IFormatProvider? formatProvider) => format;

            [DebuggerStepperBoundary]
            static Object()
            {
                Type targetType = typeof(T);
                Type targetTypeByPtr = typeof(ptr<T>);
                MethodInfo extensionMethod;

               extensionMethod = targetTypeByPtr.GetExtensionMethod("Parent");

                if (!(extensionMethod is null))
                    s_ParentByPtr = extensionMethod.CreateStaticDelegate(typeof(ParentByPtr)) as ParentByPtr;

                extensionMethod = targetType.GetExtensionMethod("Parent");

                if (!(extensionMethod is null))
                    s_ParentByVal = extensionMethod.CreateStaticDelegate(typeof(ParentByVal)) as ParentByVal;

                if (s_ParentByPtr is null && s_ParentByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.Parent method", new Exception("Parent"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("Pos");

                if (!(extensionMethod is null))
                    s_PosByPtr = extensionMethod.CreateStaticDelegate(typeof(PosByPtr)) as PosByPtr;

                extensionMethod = targetType.GetExtensionMethod("Pos");

                if (!(extensionMethod is null))
                    s_PosByVal = extensionMethod.CreateStaticDelegate(typeof(PosByVal)) as PosByVal;

                if (s_PosByPtr is null && s_PosByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.Pos method", new Exception("Pos"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("Pkg");

                if (!(extensionMethod is null))
                    s_PkgByPtr = extensionMethod.CreateStaticDelegate(typeof(PkgByPtr)) as PkgByPtr;

                extensionMethod = targetType.GetExtensionMethod("Pkg");

                if (!(extensionMethod is null))
                    s_PkgByVal = extensionMethod.CreateStaticDelegate(typeof(PkgByVal)) as PkgByVal;

                if (s_PkgByPtr is null && s_PkgByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.Pkg method", new Exception("Pkg"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("Name");

                if (!(extensionMethod is null))
                    s_NameByPtr = extensionMethod.CreateStaticDelegate(typeof(NameByPtr)) as NameByPtr;

                extensionMethod = targetType.GetExtensionMethod("Name");

                if (!(extensionMethod is null))
                    s_NameByVal = extensionMethod.CreateStaticDelegate(typeof(NameByVal)) as NameByVal;

                if (s_NameByPtr is null && s_NameByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.Name method", new Exception("Name"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("Type");

                if (!(extensionMethod is null))
                    s_TypeByPtr = extensionMethod.CreateStaticDelegate(typeof(TypeByPtr)) as TypeByPtr;

                extensionMethod = targetType.GetExtensionMethod("Type");

                if (!(extensionMethod is null))
                    s_TypeByVal = extensionMethod.CreateStaticDelegate(typeof(TypeByVal)) as TypeByVal;

                if (s_TypeByPtr is null && s_TypeByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.Type method", new Exception("Type"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("Exported");

                if (!(extensionMethod is null))
                    s_ExportedByPtr = extensionMethod.CreateStaticDelegate(typeof(ExportedByPtr)) as ExportedByPtr;

                extensionMethod = targetType.GetExtensionMethod("Exported");

                if (!(extensionMethod is null))
                    s_ExportedByVal = extensionMethod.CreateStaticDelegate(typeof(ExportedByVal)) as ExportedByVal;

                if (s_ExportedByPtr is null && s_ExportedByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.Exported method", new Exception("Exported"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("Id");

                if (!(extensionMethod is null))
                    s_IdByPtr = extensionMethod.CreateStaticDelegate(typeof(IdByPtr)) as IdByPtr;

                extensionMethod = targetType.GetExtensionMethod("Id");

                if (!(extensionMethod is null))
                    s_IdByVal = extensionMethod.CreateStaticDelegate(typeof(IdByVal)) as IdByVal;

                if (s_IdByPtr is null && s_IdByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.Id method", new Exception("Id"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("String");

                if (!(extensionMethod is null))
                    s_StringByPtr = extensionMethod.CreateStaticDelegate(typeof(StringByPtr)) as StringByPtr;

                extensionMethod = targetType.GetExtensionMethod("String");

                if (!(extensionMethod is null))
                    s_StringByVal = extensionMethod.CreateStaticDelegate(typeof(StringByVal)) as StringByVal;

                if (s_StringByPtr is null && s_StringByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.String method", new Exception("String"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("order");

                if (!(extensionMethod is null))
                    s_orderByPtr = extensionMethod.CreateStaticDelegate(typeof(orderByPtr)) as orderByPtr;

                extensionMethod = targetType.GetExtensionMethod("order");

                if (!(extensionMethod is null))
                    s_orderByVal = extensionMethod.CreateStaticDelegate(typeof(orderByVal)) as orderByVal;

                if (s_orderByPtr is null && s_orderByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.order method", new Exception("order"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("color");

                if (!(extensionMethod is null))
                    s_colorByPtr = extensionMethod.CreateStaticDelegate(typeof(colorByPtr)) as colorByPtr;

                extensionMethod = targetType.GetExtensionMethod("color");

                if (!(extensionMethod is null))
                    s_colorByVal = extensionMethod.CreateStaticDelegate(typeof(colorByVal)) as colorByVal;

                if (s_colorByPtr is null && s_colorByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.color method", new Exception("color"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("setOrder");

                if (!(extensionMethod is null))
                    s_setOrderByPtr = extensionMethod.CreateStaticDelegate(typeof(setOrderByPtr)) as setOrderByPtr;

                extensionMethod = targetType.GetExtensionMethod("setOrder");

                if (!(extensionMethod is null))
                    s_setOrderByVal = extensionMethod.CreateStaticDelegate(typeof(setOrderByVal)) as setOrderByVal;

                if (s_setOrderByPtr is null && s_setOrderByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.setOrder method", new Exception("setOrder"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("setColor");

                if (!(extensionMethod is null))
                    s_setColorByPtr = extensionMethod.CreateStaticDelegate(typeof(setColorByPtr)) as setColorByPtr;

                extensionMethod = targetType.GetExtensionMethod("setColor");

                if (!(extensionMethod is null))
                    s_setColorByVal = extensionMethod.CreateStaticDelegate(typeof(setColorByVal)) as setColorByVal;

                if (s_setColorByPtr is null && s_setColorByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.setColor method", new Exception("setColor"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("setParent");

                if (!(extensionMethod is null))
                    s_setParentByPtr = extensionMethod.CreateStaticDelegate(typeof(setParentByPtr)) as setParentByPtr;

                extensionMethod = targetType.GetExtensionMethod("setParent");

                if (!(extensionMethod is null))
                    s_setParentByVal = extensionMethod.CreateStaticDelegate(typeof(setParentByVal)) as setParentByVal;

                if (s_setParentByPtr is null && s_setParentByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.setParent method", new Exception("setParent"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("sameId");

                if (!(extensionMethod is null))
                    s_sameIdByPtr = extensionMethod.CreateStaticDelegate(typeof(sameIdByPtr)) as sameIdByPtr;

                extensionMethod = targetType.GetExtensionMethod("sameId");

                if (!(extensionMethod is null))
                    s_sameIdByVal = extensionMethod.CreateStaticDelegate(typeof(sameIdByVal)) as sameIdByVal;

                if (s_sameIdByPtr is null && s_sameIdByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.sameId method", new Exception("sameId"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("scopePos");

                if (!(extensionMethod is null))
                    s_scopePosByPtr = extensionMethod.CreateStaticDelegate(typeof(scopePosByPtr)) as scopePosByPtr;

                extensionMethod = targetType.GetExtensionMethod("scopePos");

                if (!(extensionMethod is null))
                    s_scopePosByVal = extensionMethod.CreateStaticDelegate(typeof(scopePosByVal)) as scopePosByVal;

                if (s_scopePosByPtr is null && s_scopePosByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.scopePos method", new Exception("scopePos"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("setScopePos");

                if (!(extensionMethod is null))
                    s_setScopePosByPtr = extensionMethod.CreateStaticDelegate(typeof(setScopePosByPtr)) as setScopePosByPtr;

                extensionMethod = targetType.GetExtensionMethod("setScopePos");

                if (!(extensionMethod is null))
                    s_setScopePosByVal = extensionMethod.CreateStaticDelegate(typeof(setScopePosByVal)) as setScopePosByVal;

                if (s_setScopePosByPtr is null && s_setScopePosByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Object.setScopePos method", new Exception("setScopePos"));
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static explicit operator Object<T>(in ptr<T> target_ptr) => new Object<T>(target_ptr);

            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static explicit operator Object<T>(in T target) => new Object<T>(target);

            // Enable comparisons between nil and Object<T> interface instance
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator ==(Object<T> value, NilType nil) => Activator.CreateInstance<Object<T>>().Equals(value);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator !=(Object<T> value, NilType nil) => !(value == nil);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator ==(NilType nil, Object<T> value) => value == nil;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator !=(NilType nil, Object<T> value) => value != nil;
        }
    }
}}

namespace go
{
    public static class types_ObjectExtensions
    {
        private static readonly ConcurrentDictionary<Type, MethodInfo> s_conversionOperators = new ConcurrentDictionary<Type, MethodInfo>();

        [GeneratedCode("go2cs", "0.1.0.0"), MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
        public static T _<T>(this go.go.types_package.Object target)
        {
            try
            {
                return ((go.go.types_package.Object<T>)target).Target;
            }
            catch (NotImplementedException ex)
            {
                throw new PanicException($"interface conversion: {GetGoTypeName(target.GetType())} is not {GetGoTypeName(typeof(T))}: missing method {ex.InnerException?.Message}");
            }
        }

        [GeneratedCode("go2cs", "0.1.0.0"), MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
        public static bool _<T>(this go.go.types_package.Object target, out T result)
        {
            try
            {
                result = target._<T>();
                return true;
            }
            catch (PanicException)
            {
                result = default!;
                return false;
            }
        }

        [GeneratedCode("go2cs", "0.1.0.0"), MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
        public static object? _(this go.go.types_package.Object target, Type type)
        {
            try
            {
                MethodInfo? conversionOperator = s_conversionOperators.GetOrAdd(type, _ => typeof(go.go.types_package.Object<>).GetExplicitGenericConversionOperator(type));

                if (conversionOperator is null)
                    throw new PanicException($"interface conversion: failed to create converter for {GetGoTypeName(target.GetType())} to {GetGoTypeName(type)}");

                dynamic? result = conversionOperator.Invoke(null, new object[] { target });
                return result?.Target;
            }
            catch (NotImplementedException ex)
            {
                throw new PanicException($"interface conversion: {GetGoTypeName(target.GetType())} is not {GetGoTypeName(type)}: missing method {ex.InnerException?.Message}");
            }
        }

        [GeneratedCode("go2cs", "0.1.0.0"), MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
        public static bool _(this go.go.types_package.Object target, Type type, out object? result)
        {
            try
            {
                result = target._(type);
                return true;
            }
            catch (PanicException)
            {
                result = type.IsValueType ? Activator.CreateInstance(type) : null;
                return false;
            }
        }
    }
}