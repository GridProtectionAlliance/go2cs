// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file implements printing of expressions.

// package types -- go2cs converted at 2020 October 08 04:03:25 UTC
// import "go/types" ==> using types = go.go.types_package
// Original source: C:\Go\src\go\types\exprstring.go
using bytes = go.bytes_package;
using ast = go.go.ast_package;
using static go.builtin;

namespace go {
namespace go
{
    public static partial class types_package
    {
        // ExprString returns the (possibly shortened) string representation for x.
        // Shortened representations are suitable for user interfaces but may not
        // necessarily follow Go syntax.
        public static @string ExprString(ast.Expr x)
        {
            ref bytes.Buffer buf = ref heap(out ptr<bytes.Buffer> _addr_buf);
            WriteExpr(_addr_buf, x);
            return buf.String();
        }

        // WriteExpr writes the (possibly shortened) string representation for x to buf.
        // Shortened representations are suitable for user interfaces but may not
        // necessarily follow Go syntax.
        public static void WriteExpr(ptr<bytes.Buffer> _addr_buf, ast.Expr x)
        {
            ref bytes.Buffer buf = ref _addr_buf.val;
 
            // The AST preserves source-level parentheses so there is
            // no need to introduce them here to correct for different
            // operator precedences. (This assumes that the AST was
            // generated by a Go parser.)

            switch (x.type())
            {
                case ptr<ast.Ident> x:
                    buf.WriteString(x.Name);
                    break;
                case ptr<ast.Ellipsis> x:
                    buf.WriteString("...");
                    if (x.Elt != null)
                    {
                        WriteExpr(_addr_buf, x.Elt);
                    }

                    break;
                case ptr<ast.BasicLit> x:
                    buf.WriteString(x.Value);
                    break;
                case ptr<ast.FuncLit> x:
                    buf.WriteByte('(');
                    WriteExpr(_addr_buf, x.Type);
                    buf.WriteString(" literal)"); // shortened
                    break;
                case ptr<ast.CompositeLit> x:
                    buf.WriteByte('(');
                    WriteExpr(_addr_buf, x.Type);
                    buf.WriteString(" literal)"); // shortened
                    break;
                case ptr<ast.ParenExpr> x:
                    buf.WriteByte('(');
                    WriteExpr(_addr_buf, x.X);
                    buf.WriteByte(')');
                    break;
                case ptr<ast.SelectorExpr> x:
                    WriteExpr(_addr_buf, x.X);
                    buf.WriteByte('.');
                    buf.WriteString(x.Sel.Name);
                    break;
                case ptr<ast.IndexExpr> x:
                    WriteExpr(_addr_buf, x.X);
                    buf.WriteByte('[');
                    WriteExpr(_addr_buf, x.Index);
                    buf.WriteByte(']');
                    break;
                case ptr<ast.SliceExpr> x:
                    WriteExpr(_addr_buf, x.X);
                    buf.WriteByte('[');
                    if (x.Low != null)
                    {
                        WriteExpr(_addr_buf, x.Low);
                    }

                    buf.WriteByte(':');
                    if (x.High != null)
                    {
                        WriteExpr(_addr_buf, x.High);
                    }

                    if (x.Slice3)
                    {
                        buf.WriteByte(':');
                        if (x.Max != null)
                        {
                            WriteExpr(_addr_buf, x.Max);
                        }

                    }

                    buf.WriteByte(']');
                    break;
                case ptr<ast.TypeAssertExpr> x:
                    WriteExpr(_addr_buf, x.X);
                    buf.WriteString(".(");
                    WriteExpr(_addr_buf, x.Type);
                    buf.WriteByte(')');
                    break;
                case ptr<ast.CallExpr> x:
                    WriteExpr(_addr_buf, x.Fun);
                    buf.WriteByte('(');
                    foreach (var (i, arg) in x.Args)
                    {
                        if (i > 0L)
                        {
                            buf.WriteString(", ");
                        }

                        WriteExpr(_addr_buf, arg);

                    }
                    if (x.Ellipsis.IsValid())
                    {
                        buf.WriteString("...");
                    }

                    buf.WriteByte(')');
                    break;
                case ptr<ast.StarExpr> x:
                    buf.WriteByte('*');
                    WriteExpr(_addr_buf, x.X);
                    break;
                case ptr<ast.UnaryExpr> x:
                    buf.WriteString(x.Op.String());
                    WriteExpr(_addr_buf, x.X);
                    break;
                case ptr<ast.BinaryExpr> x:
                    WriteExpr(_addr_buf, x.X);
                    buf.WriteByte(' ');
                    buf.WriteString(x.Op.String());
                    buf.WriteByte(' ');
                    WriteExpr(_addr_buf, x.Y);
                    break;
                case ptr<ast.ArrayType> x:
                    buf.WriteByte('[');
                    if (x.Len != null)
                    {
                        WriteExpr(_addr_buf, x.Len);
                    }

                    buf.WriteByte(']');
                    WriteExpr(_addr_buf, x.Elt);
                    break;
                case ptr<ast.StructType> x:
                    buf.WriteString("struct{");
                    writeFieldList(_addr_buf, _addr_x.Fields, "; ", false);
                    buf.WriteByte('}');
                    break;
                case ptr<ast.FuncType> x:
                    buf.WriteString("func");
                    writeSigExpr(_addr_buf, _addr_x);
                    break;
                case ptr<ast.InterfaceType> x:
                    buf.WriteString("interface{");
                    writeFieldList(_addr_buf, _addr_x.Methods, "; ", true);
                    buf.WriteByte('}');
                    break;
                case ptr<ast.MapType> x:
                    buf.WriteString("map[");
                    WriteExpr(_addr_buf, x.Key);
                    buf.WriteByte(']');
                    WriteExpr(_addr_buf, x.Value);
                    break;
                case ptr<ast.ChanType> x:
                    @string s = default;

                    if (x.Dir == ast.SEND) 
                        s = "chan<- ";
                    else if (x.Dir == ast.RECV) 
                        s = "<-chan ";
                    else 
                        s = "chan ";
                                        buf.WriteString(s);
                    WriteExpr(_addr_buf, x.Value);
                    break;
                default:
                {
                    var x = x.type();
                    buf.WriteString("(bad expr)"); // nil, ast.BadExpr, ast.KeyValueExpr
                    break;
                }
            }

        }

        private static void writeSigExpr(ptr<bytes.Buffer> _addr_buf, ptr<ast.FuncType> _addr_sig)
        {
            ref bytes.Buffer buf = ref _addr_buf.val;
            ref ast.FuncType sig = ref _addr_sig.val;

            buf.WriteByte('(');
            writeFieldList(_addr_buf, _addr_sig.Params, ", ", false);
            buf.WriteByte(')');

            var res = sig.Results;
            var n = res.NumFields();
            if (n == 0L)
            { 
                // no result
                return ;

            }

            buf.WriteByte(' ');
            if (n == 1L && len(res.List[0L].Names) == 0L)
            { 
                // single unnamed result
                WriteExpr(_addr_buf, res.List[0L].Type);
                return ;

            } 

            // multiple or named result(s)
            buf.WriteByte('(');
            writeFieldList(_addr_buf, _addr_res, ", ", false);
            buf.WriteByte(')');

        }

        private static void writeFieldList(ptr<bytes.Buffer> _addr_buf, ptr<ast.FieldList> _addr_fields, @string sep, bool iface)
        {
            ref bytes.Buffer buf = ref _addr_buf.val;
            ref ast.FieldList fields = ref _addr_fields.val;

            {
                var i__prev1 = i;

                foreach (var (__i, __f) in fields.List)
                {
                    i = __i;
                    f = __f;
                    if (i > 0L)
                    {
                        buf.WriteString(sep);
                    } 

                    // field list names
                    {
                        var i__prev2 = i;

                        foreach (var (__i, __name) in f.Names)
                        {
                            i = __i;
                            name = __name;
                            if (i > 0L)
                            {
                                buf.WriteString(", ");
                            }

                            buf.WriteString(name.Name);

                        } 

                        // types of interface methods consist of signatures only

                        i = i__prev2;
                    }

                    {
                        ptr<ast.FuncType> (sig, _) = f.Type._<ptr<ast.FuncType>>();

                        if (sig != null && iface)
                        {
                            writeSigExpr(_addr_buf, sig);
                            continue;
                        } 

                        // named fields are separated with a blank from the field type

                    } 

                    // named fields are separated with a blank from the field type
                    if (len(f.Names) > 0L)
                    {
                        buf.WriteByte(' ');
                    }

                    WriteExpr(_addr_buf, f.Type); 

                    // ignore tag
                }

                i = i__prev1;
            }
        }
    }
}}
