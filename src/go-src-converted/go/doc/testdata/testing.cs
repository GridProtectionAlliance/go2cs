// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package testing provides support for automated testing of Go packages.
// It is intended to be used in concert with the ``go test'' utility, which automates
// execution of any function of the form
//     func TestXxx(*testing.T)
// where Xxx can be any alphanumeric string (but the first letter must not be in
// [a-z]) and serves to identify the test routine.
// These TestXxx routines should be declared within the package they are testing.
//
// Functions of the form
//     func BenchmarkXxx(*testing.B)
// are considered benchmarks, and are executed by go test when the -test.bench
// flag is provided.
//
// A sample benchmark function looks like this:
//     func BenchmarkHello(b *testing.B) {
//         for i := 0; i < b.N; i++ {
//             fmt.Sprintf("hello")
//         }
//     }
// The benchmark package will vary b.N until the benchmark function lasts
// long enough to be timed reliably. The output
//     testing.BenchmarkHello    10000000    282 ns/op
// means that the loop ran 10000000 times at a speed of 282 ns per loop.
//
// If a benchmark needs some expensive setup before running, the timer
// may be stopped:
//     func BenchmarkBigLen(b *testing.B) {
//         b.StopTimer()
//         big := NewBig()
//         b.StartTimer()
//         for i := 0; i < b.N; i++ {
//             big.Len()
//         }
//     }
// package testing -- go2cs converted at 2020 October 09 05:19:12 UTC
// import "go/doc.testing" ==> using testing = go.go.doc.testing_package
// Original source: C:\Go\src\go\doc\testdata\testing.go
using flag = go.flag_package;
using fmt = go.fmt_package;
using os = go.os_package;
using runtime = go.runtime_package;
using pprof = go.runtime.pprof_package;
using strconv = go.strconv_package;
using strings = go.strings_package;
using time = go.time_package;
using static go.builtin;
using System;
using System.Threading;

namespace go {
namespace go
{
    public static partial class testing_package
    {
 
        // The short flag requests that tests run more quickly, but its functionality
        // is provided by test writers themselves. The testing package is just its
        // home. The all.bash installation script sets it to make installation more
        // efficient, but by default the flag is off so a plain "go test" will do a
        // full test of the package.
        private static var @short = flag.Bool("test.short", false, "run smaller test suite to save time");        private static var chatty = flag.Bool("test.v", false, "verbose: print additional output");        private static var match = flag.String("test.run", "", "regular expression to select tests to run");        private static var memProfile = flag.String("test.memprofile", "", "write a memory profile to the named file after execution");        private static var memProfileRate = flag.Int("test.memprofilerate", 0L, "if >=0, sets runtime.MemProfileRate");        private static var cpuProfile = flag.String("test.cpuprofile", "", "write a cpu profile to the named file during execution");        private static var timeout = flag.Duration("test.timeout", 0L, "if positive, sets an aggregate time limit for all tests");        private static var cpuListStr = flag.String("test.cpu", "", "comma-separated list of number of CPUs to use for each test");        private static var parallel = flag.Int("test.parallel", runtime.GOMAXPROCS(0L), "maximum test parallelism");        private static slice<long> cpuList = default;

        // common holds the elements common between T and B and
        // captures common methods such as Errorf.
        private partial struct common
        {
            public slice<byte> output; // Output generated by test or benchmark.
            public bool failed; // Test or benchmark has failed.
            public time.Time start; // Time test or benchmark started
            public time.Duration duration;
            public channel<object> signal; // Output for serial tests.
        }

        // Short reports whether the -test.short flag is set.
        public static bool Short()
        {
            return short.val;
        }

        // decorate inserts the final newline if needed and indentation tabs for formatting.
        // If addFileLine is true, it also prefixes the string with the file and line of the call site.
        private static @string decorate(@string s, bool addFileLine)
        {
            if (addFileLine)
            {
                var (_, file, line, ok) = runtime.Caller(3L); // decorate + log + public function.
                if (ok)
                { 
                    // Truncate file name at last file name separator.
                    {
                        var index = strings.LastIndex(file, "/");

                        if (index >= 0L)
                        {
                            file = file[index + 1L..];
                        }                        index = strings.LastIndex(file, "\\");


                        else if (index >= 0L)
                        {
                            file = file[index + 1L..];
                        }


                    }

                }
                else
                {
                    file = "???";
                    line = 1L;
                }

                s = fmt.Sprintf("%s:%d: %s", file, line, s);

            }

            s = "\t" + s; // Every line is indented at least one tab.
            var n = len(s);
            if (n > 0L && s[n - 1L] != '\n')
            {
                s += "\n";
                n++;
            }

            for (long i = 0L; i < n - 1L; i++)
            { // -1 to avoid final newline
                if (s[i] == '\n')
                { 
                    // Second and subsequent lines are indented an extra tab.
                    return s[0L..i + 1L] + "\t" + decorate(s[i + 1L..n], false);

                }

            }

            return s;

        }

        // T is a type passed to Test functions to manage test state and support formatted test logs.
        // Logs are accumulated during execution and dumped to standard error when done.
        public partial struct T
        {
            public ref common common => ref common_val;
            public @string name; // Name of test.
            public channel<bool> startParallel; // Parallel tests will wait on this.
        }

        // Fail marks the function as having failed but continues execution.
        private static void Fail(this ptr<common> _addr_c)
        {
            ref common c = ref _addr_c.val;

            c.failed = true;
        }

        // Failed reports whether the function has failed.
        private static bool Failed(this ptr<common> _addr_c)
        {
            ref common c = ref _addr_c.val;

            return c.failed;
        }

        // FailNow marks the function as having failed and stops its execution.
        // Execution will continue at the next Test.
        private static void FailNow(this ptr<common> _addr_c)
        {
            ref common c = ref _addr_c.val;

            c.Fail(); 

            // Calling runtime.Goexit will exit the goroutine, which
            // will run the deferred functions in this goroutine,
            // which will eventually run the deferred lines in tRunner,
            // which will signal to the test loop that this test is done.
            //
            // A previous version of this code said:
            //
            //    c.duration = ...
            //    c.signal <- c.self
            //    runtime.Goexit()
            //
            // This previous version duplicated code (those lines are in
            // tRunner no matter what), but worse the goroutine teardown
            // implicit in runtime.Goexit was not guaranteed to complete
            // before the test exited. If a test deferred an important cleanup
            // function (like removing temporary files), there was no guarantee
            // it would run on a test failure. Because we send on c.signal during
            // a top-of-stack deferred function now, we know that the send
            // only happens after any other stacked defers have completed.
            runtime.Goexit();

        }

        // log generates the output. It's always at the same stack depth.
        private static void log(this ptr<common> _addr_c, @string s)
        {
            ref common c = ref _addr_c.val;

            c.output = append(c.output, decorate(s, true));
        }

        // Log formats its arguments using default formatting, analogous to Println(),
        // and records the text in the error log.
        private static void Log(this ptr<common> _addr_c, params object[] args)
        {
            args = args.Clone();
            ref common c = ref _addr_c.val;

            c.log(fmt.Sprintln(args));
        }

        // Logf formats its arguments according to the format, analogous to Printf(),
        // and records the text in the error log.
        private static void Logf(this ptr<common> _addr_c, @string format, params object[] args)
        {
            args = args.Clone();
            ref common c = ref _addr_c.val;

            c.log(fmt.Sprintf(format, args));
        }

        // Error is equivalent to Log() followed by Fail().
        private static void Error(this ptr<common> _addr_c, params object[] args)
        {
            args = args.Clone();
            ref common c = ref _addr_c.val;

            c.log(fmt.Sprintln(args));
            c.Fail();
        }

        // Errorf is equivalent to Logf() followed by Fail().
        private static void Errorf(this ptr<common> _addr_c, @string format, params object[] args)
        {
            args = args.Clone();
            ref common c = ref _addr_c.val;

            c.log(fmt.Sprintf(format, args));
            c.Fail();
        }

        // Fatal is equivalent to Log() followed by FailNow().
        private static void Fatal(this ptr<common> _addr_c, params object[] args)
        {
            args = args.Clone();
            ref common c = ref _addr_c.val;

            c.log(fmt.Sprintln(args));
            c.FailNow();
        }

        // Fatalf is equivalent to Logf() followed by FailNow().
        private static void Fatalf(this ptr<common> _addr_c, @string format, params object[] args)
        {
            args = args.Clone();
            ref common c = ref _addr_c.val;

            c.log(fmt.Sprintf(format, args));
            c.FailNow();
        }

        // Parallel signals that this test is to be run in parallel with (and only with)
        // other parallel tests in this CPU group.
        private static void Parallel(this ptr<T> _addr_t)
        {
            ref T t = ref _addr_t.val;

            t.signal.Send((T.val)(null)); // Release main testing loop
            t.startParallel.Receive(); // Wait for serial tests to finish
        }

        // An internal type but exported because it is cross-package; part of the implementation
        // of go test.
        public partial struct InternalTest
        {
            public @string Name;
            public Action<ptr<T>> F;
        }

        private static void tRunner(ptr<T> _addr_t, ptr<InternalTest> _addr_test) => func((defer, _, __) =>
        {
            ref T t = ref _addr_t.val;
            ref InternalTest test = ref _addr_test.val;

            t.start = time.Now(); 

            // When this goroutine is done, either because test.F(t)
            // returned normally or because a test failure triggered
            // a call to runtime.Goexit, record the duration and send
            // a signal saying that the test is done.
            defer(() =>
            {
                t.duration = time.Now().Sub(t.start);
                t.signal.Send(t);
            }());

            test.F(t);

        });

        // An internal function but exported because it is cross-package; part of the implementation
        // of go test.
        public static (bool, error) Main(Func<@string, @string, (bool, error)> matchString, slice<InternalTest> tests, slice<InternalBenchmark> benchmarks, slice<InternalExample> examples)
        {
            bool _p0 = default;
            error _p0 = default!;

            flag.Parse();
            parseCpuList();

            before();
            startAlarm();
            var testOk = RunTests(matchString, tests);
            var exampleOk = RunExamples(examples);
            if (!testOk || !exampleOk)
            {
                fmt.Println("FAIL");
                os.Exit(1L);
            }

            fmt.Println("PASS");
            stopAlarm();
            RunBenchmarks(matchString, benchmarks);
            after();

        }

        private static void report(this ptr<T> _addr_t)
        {
            ref T t = ref _addr_t.val;

            var tstr = fmt.Sprintf("(%.2f seconds)", t.duration.Seconds());
            @string format = "--- %s: %s %s\n%s";
            if (t.failed)
            {
                fmt.Printf(format, "FAIL", t.name, tstr, t.output);
            }
            else if (chatty.val)
            {
                fmt.Printf(format, "PASS", t.name, tstr, t.output);
            }

        }

        public static bool RunTests(Func<@string, @string, (bool, error)> matchString, slice<InternalTest> tests)
        {
            bool ok = default;

            ok = true;
            if (len(tests) == 0L)
            {
                fmt.Fprintln(os.Stderr, "testing: warning: no tests to run");
                return ;
            }

            foreach (var (_, procs) in cpuList)
            {
                runtime.GOMAXPROCS(procs); 
                // We build a new channel tree for each run of the loop.
                // collector merges in one channel all the upstream signals from parallel tests.
                // If all tests pump to the same channel, a bug can occur where a test
                // kicks off a goroutine that Fails, yet the test still delivers a completion signal,
                // which skews the counting.
                var collector = make_channel<object>();

                long numParallel = 0L;
                var startParallel = make_channel<bool>();

                for (long i = 0L; i < len(tests); i++)
                {
                    var (matched, err) = matchString(match.val, tests[i].Name);
                    if (err != null)
                    {
                        fmt.Fprintf(os.Stderr, "testing: invalid regexp for -test.run: %s\n", err);
                        os.Exit(1L);
                    }

                    if (!matched)
                    {
                        continue;
                    }

                    var testName = tests[i].Name;
                    if (procs != 1L)
                    {
                        testName = fmt.Sprintf("%s-%d", tests[i].Name, procs);
                    }

                    ptr<T> t = addr(new T(common:common{signal:make(chaninterface{}),},name:testName,startParallel:startParallel,));
                    t.self = t;
                    if (chatty.val)
                    {
                        fmt.Printf("=== RUN %s\n", t.name);
                    }

                    go_(() => tRunner(t, _addr_tests[i]));
                    ptr<T> @out = (t.signal.Receive())._<ptr<T>>();
                    if (out == null)
                    { // Parallel run.
                        go_(() => () =>
                        {
                            collector.Send(t.signal.Receive());
                        }());
                        numParallel++;
                        continue;

                    }

                    t.report();
                    ok = ok && !@out.failed;

                }


                long running = 0L;
                while (numParallel + running > 0L)
                {
                    if (running < parallel && numParallel > 0L.val)
                    {
                        startParallel.Send(true);
                        running++;
                        numParallel--;
                        continue;
                    }

                    t = (collector.Receive())._<ptr<T>>();
                    t.report();
                    ok = ok && !t.failed;
                    running--;

                }


            }
            return ;

        }

        // before runs before all testing.
        private static void before()
        {
            if (memProfileRate > 0L.val)
            {
                runtime.MemProfileRate = memProfileRate.val;
            }

            if (cpuProfile != "".val)
            {
                var (f, err) = os.Create(cpuProfile.val);
                if (err != null)
                {
                    fmt.Fprintf(os.Stderr, "testing: %s", err);
                    return ;
                }

                {
                    var err = pprof.StartCPUProfile(f);

                    if (err != null)
                    {
                        fmt.Fprintf(os.Stderr, "testing: can't start cpu profile: %s", err);
                        f.Close();
                        return ;
                    } 
                    // Could save f so after can call f.Close; not worth the effort.

                } 
                // Could save f so after can call f.Close; not worth the effort.
            }

        }

        // after runs after all testing.
        private static void after()
        {
            if (cpuProfile != "".val)
            {
                pprof.StopCPUProfile(); // flushes profile to disk
            }

            if (memProfile != "".val)
            {
                var (f, err) = os.Create(memProfile.val);
                if (err != null)
                {
                    fmt.Fprintf(os.Stderr, "testing: %s", err);
                    return ;
                }

                err = pprof.WriteHeapProfile(f);

                if (err != null)
                {
                    fmt.Fprintf(os.Stderr, "testing: can't write %s: %s", memProfile.val, err);
                }

                f.Close();

            }

        }

        private static ptr<time.Timer> timer;

        // startAlarm starts an alarm if requested.
        private static void startAlarm()
        {
            if (timeout > 0L.val)
            {
                timer = time.AfterFunc(timeout.val, alarm);
            }

        }

        // stopAlarm turns off the alarm.
        private static void stopAlarm()
        {
            if (timeout > 0L.val)
            {
                timer.Stop();
            }

        }

        // alarm is called if the timeout expires.
        private static void alarm() => func((_, panic, __) =>
        {
            panic("test timed out");
        });

        private static void parseCpuList()
        {
            if (len(cpuListStr.val) == 0L)
            {
                cpuList = append(cpuList, runtime.GOMAXPROCS(-1L));
            }
            else
            {
                foreach (var (_, val) in strings.Split(cpuListStr.val, ","))
                {
                    var (cpu, err) = strconv.Atoi(val);
                    if (err != null || cpu <= 0L)
                    {
                        fmt.Fprintf(os.Stderr, "testing: invalid value %q for -test.cpu", val);
                        os.Exit(1L);
                    }

                    cpuList = append(cpuList, cpu);

                }

            }

        }
    }
}}
