{"Files":{"C:\\Program Files\\Go\\src\\unsafe\\unsafe.go":{"Package":"@unsafe","PackageImport":"unsafe","SourceFileName":"C:\\Program Files\\Go\\src\\unsafe\\unsafe.go","TargetFileName":"D:\\Projects\\go2cs\\src\\go-src-converted\\unsafe\\unsafe.cs","ImportAliases":{},"Interfaces":{},"Structs":{},"Functions":{"Sizeof()":{"Signature":{"Name":"Sizeof","Signature":{"Parameters":[{"Name":"x","Type":{"Name":"ArbitraryType","TypeName":"ArbitraryType","FullTypeName":"ArbitraryType","TypeClass":0,"IsDerefPointer":false,"IsByRefPointer":false,"IsConst":false},"IsVariadic":false}],"Result":[{"Name":"","Type":{"Name":"uintptr","TypeName":"System.UIntPtr","FullTypeName":"System.UIntPtr","TypeClass":0,"IsDerefPointer":false,"IsByRefPointer":false,"IsConst":false},"IsVariadic":false}]},"Comments":"\r\n\r\n// Offsetof returns the offset within the struct of the field represented by x,\r\n// which must be of the form structValue.field. In other words, it returns the\r\n// number of bytes between the start of the struct and the start of the field.\r\n// The return value of Offsetof is a Go constant.\r\n","IsPromoted":false},"Variables":{},"HasDefer":false,"HasPanic":false,"HasRecover":false},"Offsetof()":{"Signature":{"Name":"Offsetof","Signature":{"Parameters":[{"Name":"x","Type":{"Name":"ArbitraryType","TypeName":"ArbitraryType","FullTypeName":"ArbitraryType","TypeClass":0,"IsDerefPointer":false,"IsByRefPointer":false,"IsConst":false},"IsVariadic":false}],"Result":[{"Name":"","Type":{"Name":"uintptr","TypeName":"System.UIntPtr","FullTypeName":"System.UIntPtr","TypeClass":0,"IsDerefPointer":false,"IsByRefPointer":false,"IsConst":false},"IsVariadic":false}]},"Comments":"\r\n\r\n// Alignof takes an expression x of any type and returns the required alignment\r\n// of a hypothetical variable v as if v was declared via var v = x.\r\n// It is the largest value m such that the address of v is always zero mod m.\r\n// It is the same as the value returned by reflect.TypeOf(x).Align().\r\n// As a special case, if a variable s is of struct type and f is a field\r\n// within that struct, then Alignof(s.f) will return the required alignment\r\n// of a field of that type within a struct. This case is the same as the\r\n// value returned by reflect.TypeOf(s.f).FieldAlign().\r\n// The return value of Alignof is a Go constant.\r\n","IsPromoted":false},"Variables":{},"HasDefer":false,"HasPanic":false,"HasRecover":false},"Alignof()":{"Signature":{"Name":"Alignof","Signature":{"Parameters":[{"Name":"x","Type":{"Name":"ArbitraryType","TypeName":"ArbitraryType","FullTypeName":"ArbitraryType","TypeClass":0,"IsDerefPointer":false,"IsByRefPointer":false,"IsConst":false},"IsVariadic":false}],"Result":[{"Name":"","Type":{"Name":"uintptr","TypeName":"System.UIntPtr","FullTypeName":"System.UIntPtr","TypeClass":0,"IsDerefPointer":false,"IsByRefPointer":false,"IsConst":false},"IsVariadic":false}]},"Comments":"\r\n\r\n// The function Add adds len to ptr and returns the updated pointer\r\n// Pointer(uintptr(ptr) \u002B uintptr(len)).\r\n// The len argument must be of integer type or an untyped constant.\r\n// A constant len argument must be representable by a value of type int;\r\n// if it is an untyped constant it is given type int.\r\n// The rules for valid uses of Pointer still apply.\r\n","IsPromoted":false},"Variables":{},"HasDefer":false,"HasPanic":false,"HasRecover":false},"Add()":{"Signature":{"Name":"Add","Signature":{"Parameters":[{"Name":"ptr","Type":{"Name":"Pointer","TypeName":"Pointer","FullTypeName":"Pointer","TypeClass":0,"IsDerefPointer":false,"IsByRefPointer":false,"IsConst":false},"IsVariadic":false},{"Name":"len","Type":{"Name":"IntegerType","TypeName":"IntegerType","FullTypeName":"IntegerType","TypeClass":0,"IsDerefPointer":false,"IsByRefPointer":false,"IsConst":false},"IsVariadic":false}],"Result":[{"Name":"","Type":{"Name":"Pointer","TypeName":"Pointer","FullTypeName":"Pointer","TypeClass":0,"IsDerefPointer":false,"IsByRefPointer":false,"IsConst":false},"IsVariadic":false}]},"Comments":"\r\n\r\n// The function Slice returns a slice whose underlying array starts at ptr\r\n// and whose length and capacity are len.\r\n// Slice(ptr, len) is equivalent to\r\n//\r\n//    (*[len]ArbitraryType)(unsafe.Pointer(ptr))[:]\r\n//\r\n// except that, as a special case, if ptr is nil and len is zero,\r\n// Slice returns nil.\r\n//\r\n// The len argument must be of integer type or an untyped constant.\r\n// A constant len argument must be non-negative and representable by a value of type int;\r\n// if it is an untyped constant it is given type int.\r\n// At run time, if len is negative, or if ptr is nil and len is not zero,\r\n// a run-time panic occurs.\r\n","IsPromoted":false},"Variables":{},"HasDefer":false,"HasPanic":false,"HasRecover":false},"Slice()":{"Signature":{"Name":"Slice","Signature":{"Parameters":[{"Name":"ptr","Type":{"DerivedTypeInfo":0,"TargetTypeInfo":{"Name":"ArbitraryType","TypeName":"ArbitraryType","FullTypeName":"ArbitraryType","TypeClass":0,"IsDerefPointer":false,"IsByRefPointer":false,"IsConst":false},"Name":"*ArbitraryType","TypeName":"ptr\u003CArbitraryType\u003E","FullTypeName":"ptr\u003CArbitraryType\u003E","TypeClass":0,"IsDerefPointer":false,"IsByRefPointer":false,"IsConst":false},"IsVariadic":false},{"Name":"len","Type":{"Name":"IntegerType","TypeName":"IntegerType","FullTypeName":"IntegerType","TypeClass":0,"IsDerefPointer":false,"IsByRefPointer":false,"IsConst":false},"IsVariadic":false}],"Result":[{"Name":"","Type":{"Name":"ArbitraryType","TypeName":"slice\u003CArbitraryType\u003E","FullTypeName":"go.slice\u003CArbitraryType\u003E","TypeClass":2,"IsDerefPointer":false,"IsByRefPointer":false,"IsConst":false},"IsVariadic":false}]},"Comments":"\n","IsPromoted":false},"Variables":{},"HasDefer":false,"HasPanic":false,"HasRecover":false}},"LastUpdate":"2022-03-06T20:32:16.7114304Z"}}}