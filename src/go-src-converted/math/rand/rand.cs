// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package rand implements pseudo-random number generators.
//
// Random numbers are generated by a Source. Top-level functions, such as
// Float64 and Int, use a default shared Source that produces a deterministic
// sequence of values each time a program is run. Use the Seed function to
// initialize the default Source if different behavior is required for each run.
// The default Source is safe for concurrent use by multiple goroutines, but
// Sources created by NewSource are not.
//
// For random numbers suitable for security-sensitive work, see the crypto/rand
// package.
// package rand -- go2cs converted at 2020 August 29 08:25:54 UTC
// import "math/rand" ==> using rand = go.math.rand_package
// Original source: C:\Go\src\math\rand\rand.go
using sync = go.sync_package;
using static go.builtin;
using System;

namespace go {
namespace math
{
    public static partial class rand_package
    {
        // A Source represents a source of uniformly-distributed
        // pseudo-random int64 values in the range [0, 1<<63).
        public partial interface Source
        {
            long Int63();
            long Seed(long seed);
        }

        // A Source64 is a Source that can also generate
        // uniformly-distributed pseudo-random uint64 values in
        // the range [0, 1<<64) directly.
        // If a Rand r's underlying Source s implements Source64,
        // then r.Uint64 returns the result of one call to s.Uint64
        // instead of making two calls to s.Int63.
        public partial interface Source64 : Source
        {
            ulong Uint64();
        }

        // NewSource returns a new pseudo-random Source seeded with the given value.
        // Unlike the default Source used by top-level functions, this source is not
        // safe for concurrent use by multiple goroutines.
        public static Source NewSource(long seed)
        {
            rngSource rng = default;
            rng.Seed(seed);
            return ref rng;
        }

        // A Rand is a source of random numbers.
        public partial struct Rand
        {
            public Source src;
            public Source64 s64; // non-nil if src is source64

// readVal contains remainder of 63-bit integer used for bytes
// generation during most recent Read call.
// It is saved so next Read call can start where the previous
// one finished.
            public long readVal; // readPos indicates the number of low-order bytes of readVal
// that are still valid.
            public sbyte readPos;
        }

        // New returns a new Rand that uses random values from src
        // to generate other random values.
        public static ref Rand New(Source src)
        {
            Source64 (s64, _) = src._<Source64>();
            return ref new Rand(src:src,s64:s64);
        }

        // Seed uses the provided seed value to initialize the generator to a deterministic state.
        // Seed should not be called concurrently with any other Rand method.
        private static void Seed(this ref Rand r, long seed)
        {
            {
                ref lockedSource (lk, ok) = r.src._<ref lockedSource>();

                if (ok)
                {
                    lk.seedPos(seed, ref r.readPos);
                    return;
                }

            }

            r.src.Seed(seed);
            r.readPos = 0L;
        }

        // Int63 returns a non-negative pseudo-random 63-bit integer as an int64.
        private static long Int63(this ref Rand r)
        {
            return r.src.Int63();
        }

        // Uint32 returns a pseudo-random 32-bit value as a uint32.
        private static uint Uint32(this ref Rand r)
        {
            return uint32(r.Int63() >> (int)(31L));
        }

        // Uint64 returns a pseudo-random 64-bit value as a uint64.
        private static ulong Uint64(this ref Rand r)
        {
            if (r.s64 != null)
            {
                return r.s64.Uint64();
            }
            return uint64(r.Int63()) >> (int)(31L) | uint64(r.Int63()) << (int)(32L);
        }

        // Int31 returns a non-negative pseudo-random 31-bit integer as an int32.
        private static int Int31(this ref Rand r)
        {
            return int32(r.Int63() >> (int)(32L));
        }

        // Int returns a non-negative pseudo-random int.
        private static long Int(this ref Rand r)
        {
            var u = uint(r.Int63());
            return int(u << (int)(1L) >> (int)(1L)); // clear sign bit if int == int32
        }

        // Int63n returns, as an int64, a non-negative pseudo-random number in [0,n).
        // It panics if n <= 0.
        private static long Int63n(this ref Rand _r, long n) => func(_r, (ref Rand r, Defer _, Panic panic, Recover __) =>
        {
            if (n <= 0L)
            {
                panic("invalid argument to Int63n");
            }
            if (n & (n - 1L) == 0L)
            { // n is power of two, can mask
                return r.Int63() & (n - 1L);
            }
            var max = int64((1L << (int)(63L)) - 1L - (1L << (int)(63L)) % uint64(n));
            var v = r.Int63();
            while (v > max)
            {
                v = r.Int63();
            }

            return v % n;
        });

        // Int31n returns, as an int32, a non-negative pseudo-random number in [0,n).
        // It panics if n <= 0.
        private static int Int31n(this ref Rand _r, int n) => func(_r, (ref Rand r, Defer _, Panic panic, Recover __) =>
        {
            if (n <= 0L)
            {
                panic("invalid argument to Int31n");
            }
            if (n & (n - 1L) == 0L)
            { // n is power of two, can mask
                return r.Int31() & (n - 1L);
            }
            var max = int32((1L << (int)(31L)) - 1L - (1L << (int)(31L)) % uint32(n));
            var v = r.Int31();
            while (v > max)
            {
                v = r.Int31();
            }

            return v % n;
        });

        // int31n returns, as an int32, a non-negative pseudo-random number in [0,n).
        // n must be > 0, but int31n does not check this; the caller must ensure it.
        // int31n exists because Int31n is inefficient, but Go 1 compatibility
        // requires that the stream of values produced by math/rand remain unchanged.
        // int31n can thus only be used internally, by newly introduced APIs.
        //
        // For implementation details, see:
        // https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction
        // https://lemire.me/blog/2016/06/30/fast-random-shuffling
        private static int int31n(this ref Rand r, int n)
        {
            var v = r.Uint32();
            var prod = uint64(v) * uint64(n);
            var low = uint32(prod);
            if (low < uint32(n))
            {
                var thresh = uint32(-n) % uint32(n);
                while (low < thresh)
                {
                    v = r.Uint32();
                    prod = uint64(v) * uint64(n);
                    low = uint32(prod);
                }

            }
            return int32(prod >> (int)(32L));
        }

        // Intn returns, as an int, a non-negative pseudo-random number in [0,n).
        // It panics if n <= 0.
        private static long Intn(this ref Rand _r, long n) => func(_r, (ref Rand r, Defer _, Panic panic, Recover __) =>
        {
            if (n <= 0L)
            {
                panic("invalid argument to Intn");
            }
            if (n <= 1L << (int)(31L) - 1L)
            {
                return int(r.Int31n(int32(n)));
            }
            return int(r.Int63n(int64(n)));
        });

        // Float64 returns, as a float64, a pseudo-random number in [0.0,1.0).
        private static double Float64(this ref Rand r)
        { 
            // A clearer, simpler implementation would be:
            //    return float64(r.Int63n(1<<53)) / (1<<53)
            // However, Go 1 shipped with
            //    return float64(r.Int63()) / (1 << 63)
            // and we want to preserve that value stream.
            //
            // There is one bug in the value stream: r.Int63() may be so close
            // to 1<<63 that the division rounds up to 1.0, and we've guaranteed
            // that the result is always less than 1.0.
            //
            // We tried to fix this by mapping 1.0 back to 0.0, but since float64
            // values near 0 are much denser than near 1, mapping 1 to 0 caused
            // a theoretically significant overshoot in the probability of returning 0.
            // Instead of that, if we round up to 1, just try again.
            // Getting 1 only happens 1/2⁵³ of the time, so most clients
            // will not observe it anyway.
again:
            var f = float64(r.Int63()) / (1L << (int)(63L));
            if (f == 1L)
            {
                goto again; // resample; this branch is taken O(never)
            }
            return f;
        }

        // Float32 returns, as a float32, a pseudo-random number in [0.0,1.0).
        private static float Float32(this ref Rand r)
        { 
            // Same rationale as in Float64: we want to preserve the Go 1 value
            // stream except we want to fix it not to return 1.0
            // This only happens 1/2²⁴ of the time (plus the 1/2⁵³ of the time in Float64).
again:
            var f = float32(r.Float64());
            if (f == 1L)
            {
                goto again; // resample; this branch is taken O(very rarely)
            }
            return f;
        }

        // Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n).
        private static slice<long> Perm(this ref Rand r, long n)
        {
            var m = make_slice<long>(n); 
            // In the following loop, the iteration when i=0 always swaps m[0] with m[0].
            // A change to remove this useless iteration is to assign 1 to i in the init
            // statement. But Perm also effects r. Making this change will affect
            // the final state of r. So this change can't be made for compatibility
            // reasons for Go 1.
            for (long i = 0L; i < n; i++)
            {
                var j = r.Intn(i + 1L);
                m[i] = m[j];
                m[j] = i;
            }

            return m;
        }

        // Shuffle pseudo-randomizes the order of elements.
        // n is the number of elements. Shuffle panics if n < 0.
        // swap swaps the elements with indexes i and j.
        private static void Shuffle(this ref Rand _r, long n, Action<long, long> swap) => func(_r, (ref Rand r, Defer _, Panic panic, Recover __) =>
        {
            if (n < 0L)
            {
                panic("invalid argument to Shuffle");
            } 

            // Fisher-Yates shuffle: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
            // Shuffle really ought not be called with n that doesn't fit in 32 bits.
            // Not only will it take a very long time, but with 2³¹! possible permutations,
            // there's no way that any PRNG can have a big enough internal state to
            // generate even a minuscule percentage of the possible permutations.
            // Nevertheless, the right API signature accepts an int n, so handle it as best we can.
            var i = n - 1L;
            while (i > 1L << (int)(31L) - 1L - 1L)
            {
                var j = int(r.Int63n(int64(i + 1L)));
                swap(i, j);
                i--;
            }

            while (i > 0L)
            {
                j = int(r.int31n(int32(i + 1L)));
                swap(i, j);
                i--;
            }

        });

        // Read generates len(p) random bytes and writes them into p. It
        // always returns len(p) and a nil error.
        // Read should not be called concurrently with any other Rand method.
        private static (long, error) Read(this ref Rand r, slice<byte> p)
        {
            {
                ref lockedSource (lk, ok) = r.src._<ref lockedSource>();

                if (ok)
                {
                    return lk.read(p, ref r.readVal, ref r.readPos);
                }

            }
            return read(p, r.Int63, ref r.readVal, ref r.readPos);
        }

        private static (long, error) read(slice<byte> p, Func<long> int63, ref long readVal, ref sbyte readPos)
        {
            var pos = readPos.Value;
            var val = readVal.Value;
            for (n = 0L; n < len(p); n++)
            {
                if (pos == 0L)
                {
                    val = int63();
                    pos = 7L;
                }
                p[n] = byte(val);
                val >>= 8L;
                pos--;
            }

            readPos.Value = pos;
            readVal.Value = val;
            return;
        }

        /*
         * Top-level convenience functions
         */

        private static var globalRand = New(ref new lockedSource(src:NewSource(1).(Source64)));

        // Seed uses the provided seed value to initialize the default Source to a
        // deterministic state. If Seed is not called, the generator behaves as
        // if seeded by Seed(1). Seed values that have the same remainder when
        // divided by 2^31-1 generate the same pseudo-random sequence.
        // Seed, unlike the Rand.Seed method, is safe for concurrent use.
        public static void Seed(long seed)
        {
            globalRand.Seed(seed);

        }

        // Int63 returns a non-negative pseudo-random 63-bit integer as an int64
        // from the default Source.
        public static long Int63()
        {
            return globalRand.Int63();
        }

        // Uint32 returns a pseudo-random 32-bit value as a uint32
        // from the default Source.
        public static uint Uint32()
        {
            return globalRand.Uint32();
        }

        // Uint64 returns a pseudo-random 64-bit value as a uint64
        // from the default Source.
        public static ulong Uint64()
        {
            return globalRand.Uint64();
        }

        // Int31 returns a non-negative pseudo-random 31-bit integer as an int32
        // from the default Source.
        public static int Int31()
        {
            return globalRand.Int31();
        }

        // Int returns a non-negative pseudo-random int from the default Source.
        public static long Int()
        {
            return globalRand.Int();
        }

        // Int63n returns, as an int64, a non-negative pseudo-random number in [0,n)
        // from the default Source.
        // It panics if n <= 0.
        public static long Int63n(long n)
        {
            return globalRand.Int63n(n);
        }

        // Int31n returns, as an int32, a non-negative pseudo-random number in [0,n)
        // from the default Source.
        // It panics if n <= 0.
        public static int Int31n(int n)
        {
            return globalRand.Int31n(n);
        }

        // Intn returns, as an int, a non-negative pseudo-random number in [0,n)
        // from the default Source.
        // It panics if n <= 0.
        public static long Intn(long n)
        {
            return globalRand.Intn(n);
        }

        // Float64 returns, as a float64, a pseudo-random number in [0.0,1.0)
        // from the default Source.
        public static double Float64()
        {
            return globalRand.Float64();
        }

        // Float32 returns, as a float32, a pseudo-random number in [0.0,1.0)
        // from the default Source.
        public static float Float32()
        {
            return globalRand.Float32();
        }

        // Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n)
        // from the default Source.
        public static slice<long> Perm(long n)
        {
            return globalRand.Perm(n);
        }

        // Shuffle pseudo-randomizes the order of elements using the default Source.
        // n is the number of elements. Shuffle panics if n < 0.
        // swap swaps the elements with indexes i and j.
        public static void Shuffle(long n, Action<long, long> swap)
        {
            globalRand.Shuffle(n, swap);

        }

        // Read generates len(p) random bytes from the default Source and
        // writes them into p. It always returns len(p) and a nil error.
        // Read, unlike the Rand.Read method, is safe for concurrent use.
        public static (long, error) Read(slice<byte> p)
        {
            return globalRand.Read(p);
        }

        // NormFloat64 returns a normally distributed float64 in the range
        // [-math.MaxFloat64, +math.MaxFloat64] with
        // standard normal distribution (mean = 0, stddev = 1)
        // from the default Source.
        // To produce a different normal distribution, callers can
        // adjust the output using:
        //
        //  sample = NormFloat64() * desiredStdDev + desiredMean
        //
        public static double NormFloat64()
        {
            return globalRand.NormFloat64();
        }

        // ExpFloat64 returns an exponentially distributed float64 in the range
        // (0, +math.MaxFloat64] with an exponential distribution whose rate parameter
        // (lambda) is 1 and whose mean is 1/lambda (1) from the default Source.
        // To produce a distribution with a different rate parameter,
        // callers can adjust the output using:
        //
        //  sample = ExpFloat64() / desiredRateParameter
        //
        public static double ExpFloat64()
        {
            return globalRand.ExpFloat64();
        }

        private partial struct lockedSource
        {
            public sync.Mutex lk;
            public Source64 src;
        }

        private static long Int63(this ref lockedSource r)
        {
            r.lk.Lock();
            n = r.src.Int63();
            r.lk.Unlock();
            return;
        }

        private static ulong Uint64(this ref lockedSource r)
        {
            r.lk.Lock();
            n = r.src.Uint64();
            r.lk.Unlock();
            return;
        }

        private static void Seed(this ref lockedSource r, long seed)
        {
            r.lk.Lock();
            r.src.Seed(seed);
            r.lk.Unlock();
        }

        // seedPos implements Seed for a lockedSource without a race condition.
        private static void seedPos(this ref lockedSource r, long seed, ref sbyte readPos)
        {
            r.lk.Lock();
            r.src.Seed(seed);
            readPos.Value = 0L;
            r.lk.Unlock();
        }

        // read implements Read for a lockedSource without a race condition.
        private static (long, error) read(this ref lockedSource r, slice<byte> p, ref long readVal, ref sbyte readPos)
        {
            r.lk.Lock();
            n, err = read(p, r.src.Int63, readVal, readPos);
            r.lk.Unlock();
            return;
        }
    }
}}
