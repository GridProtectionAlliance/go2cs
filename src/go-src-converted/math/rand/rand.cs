// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package rand implements pseudo-random number generators unsuitable for
// security-sensitive work.
//
// Random numbers are generated by a Source. Top-level functions, such as
// Float64 and Int, use a default shared Source that produces a deterministic
// sequence of values each time a program is run. Use the Seed function to
// initialize the default Source if different behavior is required for each run.
// The default Source is safe for concurrent use by multiple goroutines, but
// Sources created by NewSource are not.
//
// This package's outputs might be easily predictable regardless of how it's
// seeded. For random numbers suitable for security-sensitive work, see the
// crypto/rand package.
// package rand -- go2cs converted at 2022 March 06 22:17:53 UTC
// import "math/rand" ==> using rand = go.math.rand_package
// Original source: C:\Program Files\Go\src\math\rand\rand.go
using sync = go.sync_package;
using System;


namespace go.math;

public static partial class rand_package {

    // A Source represents a source of uniformly-distributed
    // pseudo-random int64 values in the range [0, 1<<63).
public partial interface Source {
    long Int63();
    long Seed(long seed);
}

// A Source64 is a Source that can also generate
// uniformly-distributed pseudo-random uint64 values in
// the range [0, 1<<64) directly.
// If a Rand r's underlying Source s implements Source64,
// then r.Uint64 returns the result of one call to s.Uint64
// instead of making two calls to s.Int63.
public partial interface Source64 {
    ulong Uint64();
}

// NewSource returns a new pseudo-random Source seeded with the given value.
// Unlike the default Source used by top-level functions, this source is not
// safe for concurrent use by multiple goroutines.
public static Source NewSource(long seed) {
    ref rngSource rng = ref heap(out ptr<rngSource> _addr_rng);
    rng.Seed(seed);
    return _addr_rng;
}

// A Rand is a source of random numbers.
public partial struct Rand {
    public Source src;
    public Source64 s64; // non-nil if src is source64

// readVal contains remainder of 63-bit integer used for bytes
// generation during most recent Read call.
// It is saved so next Read call can start where the previous
// one finished.
    public long readVal; // readPos indicates the number of low-order bytes of readVal
// that are still valid.
    public sbyte readPos;
}

// New returns a new Rand that uses random values from src
// to generate other random values.
public static ptr<Rand> New(Source src) {
    Source64 (s64, _) = Source64.As(src._<Source64>())!;
    return addr(new Rand(src:src,s64:s64));
}

// Seed uses the provided seed value to initialize the generator to a deterministic state.
// Seed should not be called concurrently with any other Rand method.
private static void Seed(this ptr<Rand> _addr_r, long seed) {
    ref Rand r = ref _addr_r.val;

    {
        ptr<lockedSource> (lk, ok) = r.src._<ptr<lockedSource>>();

        if (ok) {
            lk.seedPos(seed, _addr_r.readPos);
            return ;
        }
    }


    r.src.Seed(seed);
    r.readPos = 0;

}

// Int63 returns a non-negative pseudo-random 63-bit integer as an int64.
private static long Int63(this ptr<Rand> _addr_r) {
    ref Rand r = ref _addr_r.val;

    return r.src.Int63();
}

// Uint32 returns a pseudo-random 32-bit value as a uint32.
private static uint Uint32(this ptr<Rand> _addr_r) {
    ref Rand r = ref _addr_r.val;

    return uint32(r.Int63() >> 31);
}

// Uint64 returns a pseudo-random 64-bit value as a uint64.
private static ulong Uint64(this ptr<Rand> _addr_r) {
    ref Rand r = ref _addr_r.val;

    if (r.s64 != null) {
        return r.s64.Uint64();
    }
    return uint64(r.Int63()) >> 31 | uint64(r.Int63()) << 32;

}

// Int31 returns a non-negative pseudo-random 31-bit integer as an int32.
private static int Int31(this ptr<Rand> _addr_r) {
    ref Rand r = ref _addr_r.val;

    return int32(r.Int63() >> 32);
}

// Int returns a non-negative pseudo-random int.
private static nint Int(this ptr<Rand> _addr_r) {
    ref Rand r = ref _addr_r.val;

    var u = uint(r.Int63());
    return int(u << 1 >> 1); // clear sign bit if int == int32
}

// Int63n returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n).
// It panics if n <= 0.
private static long Int63n(this ptr<Rand> _addr_r, long n) => func((_, panic, _) => {
    ref Rand r = ref _addr_r.val;

    if (n <= 0) {
        panic("invalid argument to Int63n");
    }
    if (n & (n - 1) == 0) { // n is power of two, can mask
        return r.Int63() & (n - 1);

    }
    var max = int64((1 << 63) - 1 - (1 << 63) % uint64(n));
    var v = r.Int63();
    while (v > max) {
        v = r.Int63();
    }
    return v % n;

});

// Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n).
// It panics if n <= 0.
private static int Int31n(this ptr<Rand> _addr_r, int n) => func((_, panic, _) => {
    ref Rand r = ref _addr_r.val;

    if (n <= 0) {
        panic("invalid argument to Int31n");
    }
    if (n & (n - 1) == 0) { // n is power of two, can mask
        return r.Int31() & (n - 1);

    }
    var max = int32((1 << 31) - 1 - (1 << 31) % uint32(n));
    var v = r.Int31();
    while (v > max) {
        v = r.Int31();
    }
    return v % n;

});

// int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n).
// n must be > 0, but int31n does not check this; the caller must ensure it.
// int31n exists because Int31n is inefficient, but Go 1 compatibility
// requires that the stream of values produced by math/rand remain unchanged.
// int31n can thus only be used internally, by newly introduced APIs.
//
// For implementation details, see:
// https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction
// https://lemire.me/blog/2016/06/30/fast-random-shuffling
private static int int31n(this ptr<Rand> _addr_r, int n) {
    ref Rand r = ref _addr_r.val;

    var v = r.Uint32();
    var prod = uint64(v) * uint64(n);
    var low = uint32(prod);
    if (low < uint32(n)) {
        var thresh = uint32(-n) % uint32(n);
        while (low < thresh) {
            v = r.Uint32();
            prod = uint64(v) * uint64(n);
            low = uint32(prod);
        }
    }
    return int32(prod >> 32);

}

// Intn returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n).
// It panics if n <= 0.
private static nint Intn(this ptr<Rand> _addr_r, nint n) => func((_, panic, _) => {
    ref Rand r = ref _addr_r.val;

    if (n <= 0) {
        panic("invalid argument to Intn");
    }
    if (n <= 1 << 31 - 1) {
        return int(r.Int31n(int32(n)));
    }
    return int(r.Int63n(int64(n)));

});

// Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0).
private static double Float64(this ptr<Rand> _addr_r) {
    ref Rand r = ref _addr_r.val;
 
    // A clearer, simpler implementation would be:
    //    return float64(r.Int63n(1<<53)) / (1<<53)
    // However, Go 1 shipped with
    //    return float64(r.Int63()) / (1 << 63)
    // and we want to preserve that value stream.
    //
    // There is one bug in the value stream: r.Int63() may be so close
    // to 1<<63 that the division rounds up to 1.0, and we've guaranteed
    // that the result is always less than 1.0.
    //
    // We tried to fix this by mapping 1.0 back to 0.0, but since float64
    // values near 0 are much denser than near 1, mapping 1 to 0 caused
    // a theoretically significant overshoot in the probability of returning 0.
    // Instead of that, if we round up to 1, just try again.
    // Getting 1 only happens 1/2⁵³ of the time, so most clients
    // will not observe it anyway.
again:
    var f = float64(r.Int63()) / (1 << 63);
    if (f == 1) {
        goto again; // resample; this branch is taken O(never)
    }
    return f;

}

// Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0).
private static float Float32(this ptr<Rand> _addr_r) {
    ref Rand r = ref _addr_r.val;
 
    // Same rationale as in Float64: we want to preserve the Go 1 value
    // stream except we want to fix it not to return 1.0
    // This only happens 1/2²⁴ of the time (plus the 1/2⁵³ of the time in Float64).
again:
    var f = float32(r.Float64());
    if (f == 1) {
        goto again; // resample; this branch is taken O(very rarely)
    }
    return f;

}

// Perm returns, as a slice of n ints, a pseudo-random permutation of the integers
// in the half-open interval [0,n).
private static slice<nint> Perm(this ptr<Rand> _addr_r, nint n) {
    ref Rand r = ref _addr_r.val;

    var m = make_slice<nint>(n); 
    // In the following loop, the iteration when i=0 always swaps m[0] with m[0].
    // A change to remove this useless iteration is to assign 1 to i in the init
    // statement. But Perm also effects r. Making this change will affect
    // the final state of r. So this change can't be made for compatibility
    // reasons for Go 1.
    for (nint i = 0; i < n; i++) {
        var j = r.Intn(i + 1);
        m[i] = m[j];
        m[j] = i;
    }
    return m;

}

// Shuffle pseudo-randomizes the order of elements.
// n is the number of elements. Shuffle panics if n < 0.
// swap swaps the elements with indexes i and j.
private static void Shuffle(this ptr<Rand> _addr_r, nint n, Action<nint, nint> swap) => func((_, panic, _) => {
    ref Rand r = ref _addr_r.val;

    if (n < 0) {
        panic("invalid argument to Shuffle");
    }
    var i = n - 1;
    while (i > 1 << 31 - 1 - 1) {
        var j = int(r.Int63n(int64(i + 1)));
        swap(i, j);
        i--;
    }
    while (i > 0) {
        j = int(r.int31n(int32(i + 1)));
        swap(i, j);
        i--;
    }

});

// Read generates len(p) random bytes and writes them into p. It
// always returns len(p) and a nil error.
// Read should not be called concurrently with any other Rand method.
private static (nint, error) Read(this ptr<Rand> _addr_r, slice<byte> p) {
    nint n = default;
    error err = default!;
    ref Rand r = ref _addr_r.val;

    {
        ptr<lockedSource> (lk, ok) = r.src._<ptr<lockedSource>>();

        if (ok) {
            return lk.read(p, _addr_r.readVal, _addr_r.readPos);
        }
    }

    return read(p, r.src, _addr_r.readVal, _addr_r.readPos);

}

private static (nint, error) read(slice<byte> p, Source src, ptr<long> _addr_readVal, ptr<sbyte> _addr_readPos) {
    nint n = default;
    error err = default!;
    ref long readVal = ref _addr_readVal.val;
    ref sbyte readPos = ref _addr_readPos.val;

    sbyte pos = readPos;
    long val = readVal;
    ptr<rngSource> (rng, _) = src._<ptr<rngSource>>();
    for (n = 0; n < len(p); n++) {
        if (pos == 0) {
            if (rng != null) {
                val = rng.Int63();
            }
            else
 {
                val = src.Int63();
            }

            pos = 7;

        }
        p[n] = byte(val);
        val>>=8;
        pos--;

    }
    readPos = pos;
    readVal = val;
    return ;

}

/*
 * Top-level convenience functions
 */

private static var globalRand = New(addr(new lockedSource(src:NewSource(1).(*rngSource))));

// Type assert that globalRand's source is a lockedSource whose src is a *rngSource.
private static ptr<rngSource> _globalRand.src._<ptr<lockedSource>>().src;

// Seed uses the provided seed value to initialize the default Source to a
// deterministic state. If Seed is not called, the generator behaves as
// if seeded by Seed(1). Seed values that have the same remainder when
// divided by 2³¹-1 generate the same pseudo-random sequence.
// Seed, unlike the Rand.Seed method, is safe for concurrent use.
public static void Seed(long seed) {
    globalRand.Seed(seed);
}

// Int63 returns a non-negative pseudo-random 63-bit integer as an int64
// from the default Source.
public static long Int63() {
    return globalRand.Int63();
}

// Uint32 returns a pseudo-random 32-bit value as a uint32
// from the default Source.
public static uint Uint32() {
    return globalRand.Uint32();
}

// Uint64 returns a pseudo-random 64-bit value as a uint64
// from the default Source.
public static ulong Uint64() {
    return globalRand.Uint64();
}

// Int31 returns a non-negative pseudo-random 31-bit integer as an int32
// from the default Source.
public static int Int31() {
    return globalRand.Int31();
}

// Int returns a non-negative pseudo-random int from the default Source.
public static nint Int() {
    return globalRand.Int();
}

// Int63n returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n)
// from the default Source.
// It panics if n <= 0.
public static long Int63n(long n) {
    return globalRand.Int63n(n);
}

// Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n)
// from the default Source.
// It panics if n <= 0.
public static int Int31n(int n) {
    return globalRand.Int31n(n);
}

// Intn returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n)
// from the default Source.
// It panics if n <= 0.
public static nint Intn(nint n) {
    return globalRand.Intn(n);
}

// Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0)
// from the default Source.
public static double Float64() {
    return globalRand.Float64();
}

// Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0)
// from the default Source.
public static float Float32() {
    return globalRand.Float32();
}

// Perm returns, as a slice of n ints, a pseudo-random permutation of the integers
// in the half-open interval [0,n) from the default Source.
public static slice<nint> Perm(nint n) {
    return globalRand.Perm(n);
}

// Shuffle pseudo-randomizes the order of elements using the default Source.
// n is the number of elements. Shuffle panics if n < 0.
// swap swaps the elements with indexes i and j.
public static void Shuffle(nint n, Action<nint, nint> swap) {
    globalRand.Shuffle(n, swap);
}

// Read generates len(p) random bytes from the default Source and
// writes them into p. It always returns len(p) and a nil error.
// Read, unlike the Rand.Read method, is safe for concurrent use.
public static (nint, error) Read(slice<byte> p) {
    nint n = default;
    error err = default!;

    return globalRand.Read(p);
}

// NormFloat64 returns a normally distributed float64 in the range
// [-math.MaxFloat64, +math.MaxFloat64] with
// standard normal distribution (mean = 0, stddev = 1)
// from the default Source.
// To produce a different normal distribution, callers can
// adjust the output using:
//
//  sample = NormFloat64() * desiredStdDev + desiredMean
//
public static double NormFloat64() {
    return globalRand.NormFloat64();
}

// ExpFloat64 returns an exponentially distributed float64 in the range
// (0, +math.MaxFloat64] with an exponential distribution whose rate parameter
// (lambda) is 1 and whose mean is 1/lambda (1) from the default Source.
// To produce a distribution with a different rate parameter,
// callers can adjust the output using:
//
//  sample = ExpFloat64() / desiredRateParameter
//
public static double ExpFloat64() {
    return globalRand.ExpFloat64();
}

private partial struct lockedSource {
    public sync.Mutex lk;
    public ptr<rngSource> src;
}

private static long Int63(this ptr<lockedSource> _addr_r) {
    long n = default;
    ref lockedSource r = ref _addr_r.val;

    r.lk.Lock();
    n = r.src.Int63();
    r.lk.Unlock();
    return ;
}

private static ulong Uint64(this ptr<lockedSource> _addr_r) {
    ulong n = default;
    ref lockedSource r = ref _addr_r.val;

    r.lk.Lock();
    n = r.src.Uint64();
    r.lk.Unlock();
    return ;
}

private static void Seed(this ptr<lockedSource> _addr_r, long seed) {
    ref lockedSource r = ref _addr_r.val;

    r.lk.Lock();
    r.src.Seed(seed);
    r.lk.Unlock();
}

// seedPos implements Seed for a lockedSource without a race condition.
private static void seedPos(this ptr<lockedSource> _addr_r, long seed, ptr<sbyte> _addr_readPos) {
    ref lockedSource r = ref _addr_r.val;
    ref sbyte readPos = ref _addr_readPos.val;

    r.lk.Lock();
    r.src.Seed(seed);
    readPos = 0;
    r.lk.Unlock();
}

// read implements Read for a lockedSource without a race condition.
private static (nint, error) read(this ptr<lockedSource> _addr_r, slice<byte> p, ptr<long> _addr_readVal, ptr<sbyte> _addr_readPos) {
    nint n = default;
    error err = default!;
    ref lockedSource r = ref _addr_r.val;
    ref long readVal = ref _addr_readVal.val;
    ref sbyte readPos = ref _addr_readPos.val;

    r.lk.Lock();
    n, err = read(p, r.src, _addr_readVal, _addr_readPos);
    r.lk.Unlock();
    return ;
}

} // end rand_package
