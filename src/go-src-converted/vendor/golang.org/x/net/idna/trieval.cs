// Code generated by running "go generate" in golang.org/x/text. DO NOT EDIT.

// package idna -- go2cs converted at 2020 October 08 05:01:22 UTC
// import "vendor/golang.org/x/net/idna" ==> using idna = go.vendor.golang.org.x.net.idna_package
// Original source: C:\Go\src\vendor\golang.org\x\net\idna\trieval.go

using static go.builtin;

namespace go {
namespace vendor {
namespace golang.org {
namespace x {
namespace net
{
    public static partial class idna_package
    {
        // This file contains definitions for interpreting the trie value of the idna
        // trie generated by "go run gen*.go". It is shared by both the generator
        // program and the resultant package. Sharing is achieved by the generator
        // copying gen_trieval.go to trieval.go and changing what's above this comment.

        // info holds information from the IDNA mapping table for a single rune. It is
        // the value returned by a trie lookup. In most cases, all information fits in
        // a 16-bit value. For mappings, this value may contain an index into a slice
        // with the mapped string. Such mappings can consist of the actual mapped value
        // or an XOR pattern to be applied to the bytes of the UTF8 encoding of the
        // input rune. This technique is used by the cases packages and reduces the
        // table size significantly.
        //
        // The per-rune values have the following format:
        //
        //   if mapped {
        //     if inlinedXOR {
        //       15..13 inline XOR marker
        //       12..11 unused
        //       10..3  inline XOR mask
        //     } else {
        //       15..3  index into xor or mapping table
        //     }
        //   } else {
        //       15..14 unused
        //       13     mayNeedNorm
        //       12..11 attributes
        //       10..8  joining type
        //        7..3  category type
        //   }
        //      2  use xor pattern
        //   1..0  mapped category
        //
        // See the definitions below for a more detailed description of the various
        // bits.
        private partial struct info // : ushort
        {
        }

        private static readonly ulong catSmallMask = (ulong)0x3UL;
        private static readonly ulong catBigMask = (ulong)0xF8UL;
        private static readonly long indexShift = (long)3L;
        private static readonly ulong xorBit = (ulong)0x4UL; // interpret the index as an xor pattern
        private static readonly ulong inlineXOR = (ulong)0xE000UL; // These bits are set if the XOR pattern is inlined.

        private static readonly long joinShift = (long)8L;
        private static readonly ulong joinMask = (ulong)0x07UL; 

        // Attributes
        private static readonly ulong attributesMask = (ulong)0x1800UL;
        private static readonly ulong viramaModifier = (ulong)0x1800UL;
        private static readonly ulong modifier = (ulong)0x1000UL;
        private static readonly ulong rtl = (ulong)0x0800UL;

        private static readonly ulong mayNeedNorm = (ulong)0x2000UL;


        // A category corresponds to a category defined in the IDNA mapping table.
        private partial struct category // : ushort
        {
        }

        private static readonly category unknown = (category)0L; // not currently defined in unicode.
        private static readonly category mapped = (category)1L;
        private static readonly category disallowedSTD3Mapped = (category)2L;
        private static readonly category deviation = (category)3L;


        private static readonly category valid = (category)0x08UL;
        private static readonly category validNV8 = (category)0x18UL;
        private static readonly category validXV8 = (category)0x28UL;
        private static readonly category disallowed = (category)0x40UL;
        private static readonly category disallowedSTD3Valid = (category)0x80UL;
        private static readonly category ignored = (category)0xC0UL;


        // join types and additional rune information
        private static readonly var joiningL = (var)(iota + 1L);
        private static readonly var joiningD = (var)0;
        private static readonly var joiningT = (var)1;
        private static readonly var joiningR = (var)2; 

        //the following types are derived during processing
        private static readonly var joinZWJ = (var)3;
        private static readonly var joinZWNJ = (var)4;
        private static readonly var joinVirama = (var)5;
        private static readonly var numJoinTypes = (var)6;


        private static bool isMapped(this info c)
        {
            return c & 0x3UL != 0L;
        }

        private static category category(this info c)
        {
            var small = c & catSmallMask;
            if (small != 0L)
            {
                return category(small);
            }

            return category(c & catBigMask);

        }

        private static info joinType(this info c)
        {
            if (c.isMapped())
            {
                return 0L;
            }

            return (c >> (int)(joinShift)) & joinMask;

        }

        private static bool isModifier(this info c)
        {
            return c & (modifier | catSmallMask) == modifier;
        }

        private static bool isViramaModifier(this info c)
        {
            return c & (attributesMask | catSmallMask) == viramaModifier;
        }
    }
}}}}}
