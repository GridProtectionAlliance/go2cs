// Code generated by running "go generate" in golang.org/x/text. DO NOT EDIT.

// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// package norm -- go2cs converted at 2020 August 29 10:13:39 UTC
// import "vendor/golang_org/x/text/unicode/norm" ==> using norm = go.vendor.golang_org.x.text.unicode.norm_package
// Original source: C:\Go\src\vendor\golang_org\x\text\unicode\norm\transform.go
using utf8 = go.unicode.utf8_package;

using transform = go.golang_org.x.text.transform_package;
using static go.builtin;

namespace go {
namespace vendor {
namespace golang_org {
namespace x {
namespace text {
namespace unicode
{
    public static partial class norm_package
    {
        // Reset implements the Reset method of the transform.Transformer interface.
        public static void Reset(this Form _p0)
        {
        }

        // Transform implements the Transform method of the transform.Transformer
        // interface. It may need to write segments of up to MaxSegmentSize at once.
        // Users should either catch ErrShortDst and allow dst to grow or have dst be at
        // least of size MaxTransformChunkSize to be guaranteed of progress.
        public static (long, long, error) Transform(this Form f, slice<byte> dst, slice<byte> src, bool atEOF)
        {
            long n = 0L; 
            // Cap the maximum number of src bytes to check.
            var b = src;
            var eof = atEOF;
            {
                var ns = len(dst);

                if (ns < len(b))
                {
                    err = transform.ErrShortDst;
                    eof = false;
                    b = b[..ns];
                }

            }
            var (i, ok) = formTable[f].quickSpan(inputBytes(b), n, len(b), eof);
            n += copy(dst[n..], b[n..i]);
            if (!ok)
            {
                nDst, nSrc, err = f.transform(dst[n..], src[n..], atEOF);
                return (nDst + n, nSrc + n, err);
            }
            if (n < len(src) && !atEOF)
            {
                err = transform.ErrShortSrc;
            }
            return (n, n, err);
        }

        private static bool flushTransform(ref reorderBuffer rb)
        { 
            // Write out (must fully fit in dst, or else it is an ErrShortDst).
            if (len(rb.@out) < rb.nrune * utf8.UTFMax)
            {
                return false;
            }
            rb.@out = rb.@out[rb.flushCopy(rb.@out)..];
            return true;
        }

        private static error errs = new slice<error>(new error[] { error.As(nil), error.As(transform.ErrShortDst), error.As(transform.ErrShortSrc) });

        // transform implements the transform.Transformer interface. It is only called
        // when quickSpan does not pass for a given string.
        public static (long, long, error) transform(this Form f, slice<byte> dst, slice<byte> src, bool atEOF)
        { 
            // TODO: get rid of reorderBuffer. See CL 23460044.
            reorderBuffer rb = new reorderBuffer();
            rb.init(f, src);
            while (true)
            { 
                // Load segment into reorder buffer.
                rb.setFlusher(dst[nDst..], flushTransform);
                var end = decomposeSegment(ref rb, nSrc, atEOF);
                if (end < 0L)
                {
                    return (nDst, nSrc, errs[-end]);
                }
                nDst = len(dst) - len(rb.@out);
                nSrc = end; 

                // Next quickSpan.
                end = rb.nsrc;
                var eof = atEOF;
                {
                    var n__prev1 = n;

                    var n = nSrc + len(dst) - nDst;

                    if (n < end)
                    {
                        err = transform.ErrShortDst;
                        end = n;
                        eof = false;
                    }

                    n = n__prev1;

                }
                var (end, ok) = rb.f.quickSpan(rb.src, nSrc, end, eof);
                n = copy(dst[nDst..], rb.src.bytes[nSrc..end]);
                nSrc += n;
                nDst += n;
                if (ok)
                {
                    if (n < rb.nsrc && !atEOF)
                    {
                        err = transform.ErrShortSrc;
                    }
                    return (nDst, nSrc, err);
                }
            }

        }
    }
}}}}}}
