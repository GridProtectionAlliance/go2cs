//---------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes to this
//     file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generated on 2020 October 09 06:03:51 UTC
// </auto-generated>
//---------------------------------------------------------
using System;
using System.CodeDom.Compiler;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using static go.builtin;
using errors = go.errors_package;
using fmt = go.fmt_package;
using ast = go.go.ast_package;
using build = go.go.build_package;
using parser = go.go.parser_package;
using token = go.go.token_package;
using types = go.go.types_package;
using os = go.os_package;
using filepath = go.path.filepath_package;
using sort = go.sort_package;
using strings = go.strings_package;
using sync = go.sync_package;
using time = go.time_package;
using astutil = go.golang.org.x.tools.go.ast.astutil_package;
using cgo = go.golang.org.x.tools.go.@internal.cgo_package;
using go;

#nullable enable

namespace go {
namespace golang.org {
namespace x {
namespace tools {
namespace go
{
    public static partial class loader_package
    {
        [GeneratedCode("go2cs", "0.1.0.0")]
        [PromotedStruct(typeof(types.Info))]
        public partial struct PackageInfo
        {
            // Info structure promotion - sourced from value copy
            private readonly ptr<Info> m_InfoRef;

            private ref Info Info_val => ref m_InfoRef.Value;

            public ref map<ast.Expr, TypeAndValue> Types => ref m_InfoRef.Value.Types;

            public ref map<ptr<ast.Ident>, Object> Defs => ref m_InfoRef.Value.Defs;

            public ref map<ptr<ast.Ident>, Object> Uses => ref m_InfoRef.Value.Uses;

            public ref map<ast.Node, Object> Implicits => ref m_InfoRef.Value.Implicits;

            public ref map<ptr<ast.SelectorExpr>, ptr<Selection>> Selections => ref m_InfoRef.Value.Selections;

            public ref map<ast.Node, ptr<Scope>> Scopes => ref m_InfoRef.Value.Scopes;

            public ref slice<ptr<Initializer>> InitOrder => ref m_InfoRef.Value.InitOrder;

            // Constructors
            public PackageInfo(NilType _)
            {
                this.Pkg = default;
                this.Importable = default;
                this.TransitivelyErrorFree = default;
                this.Files = default;
                this.Errors = default;
                this.m_InfoRef = new ptr<types.Info>(new types.Info(nil));
                this.dir = default;
                this.checker = default;
                this.errorFunc = default;
            }

            public PackageInfo(ref ptr<types.Package> Pkg = default, bool Importable = default, bool TransitivelyErrorFree = default, slice<ptr<ast.File>> Files = default, slice<error> Errors = default, types.Info Info = default, @string dir = default, ref ptr<types.Checker> checker = default, Action<error> errorFunc = default)
            {
                this.Pkg = Pkg;
                this.Importable = Importable;
                this.TransitivelyErrorFree = TransitivelyErrorFree;
                this.Files = Files;
                this.Errors = Errors;
                this.m_InfoRef = new ptr<types.Info>(Info);
                this.dir = dir;
                this.checker = checker;
                this.errorFunc = errorFunc;
            }

            // Enable comparisons between nil and PackageInfo struct
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator ==(PackageInfo value, NilType nil) => value.Equals(default(PackageInfo));

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator !=(PackageInfo value, NilType nil) => !(value == nil);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator ==(NilType nil, PackageInfo value) => value == nil;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator !=(NilType nil, PackageInfo value) => value != nil;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static implicit operator PackageInfo(NilType nil) => default(PackageInfo);
        }

        [GeneratedCode("go2cs", "0.1.0.0")]
        public static PackageInfo PackageInfo_cast(dynamic value)
        {
            return new PackageInfo(ref value.Pkg, value.Importable, value.TransitivelyErrorFree, value.Files, value.Errors, value.Info, value.dir, ref value.checker, value.errorFunc);
        }
    }
}}}}}