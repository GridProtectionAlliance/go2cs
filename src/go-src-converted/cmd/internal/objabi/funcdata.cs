// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// package objabi -- go2cs converted at 2020 October 08 03:50:14 UTC
// import "cmd/internal/objabi" ==> using objabi = go.cmd.@internal.objabi_package
// Original source: C:\Go\src\cmd\internal\objabi\funcdata.go

using static go.builtin;

namespace go {
namespace cmd {
namespace @internal
{
    public static partial class objabi_package
    {
        // This file defines the IDs for PCDATA and FUNCDATA instructions
        // in Go binaries.
        //
        // These must agree with ../../../runtime/funcdata.h and
        // ../../../runtime/symtab.go.
        public static readonly long PCDATA_RegMapIndex = (long)0L; // if !go115ReduceLiveness
        public static readonly long PCDATA_UnsafePoint = (long)0L; // if go115ReduceLiveness
        public static readonly long PCDATA_StackMapIndex = (long)1L;
        public static readonly long PCDATA_InlTreeIndex = (long)2L;

        public static readonly long FUNCDATA_ArgsPointerMaps = (long)0L;
        public static readonly long FUNCDATA_LocalsPointerMaps = (long)1L;
        public static readonly long FUNCDATA_RegPointerMaps = (long)2L; // if !go115ReduceLiveness
        public static readonly long FUNCDATA_StackObjects = (long)3L;
        public static readonly long FUNCDATA_InlTree = (long)4L;
        public static readonly long FUNCDATA_OpenCodedDeferInfo = (long)5L; 

        // ArgsSizeUnknown is set in Func.argsize to mark all functions
        // whose argument size is unknown (C vararg functions, and
        // assembly code without an explicit specification).
        // This value is generated by the compiler, assembler, or linker.
        public static readonly ulong ArgsSizeUnknown = (ulong)-0x80000000UL;


        // Special PCDATA values.
 
        // PCDATA_RegMapIndex values.
        //
        // Only if !go115ReduceLiveness.
        public static readonly long PCDATA_RegMapUnsafe = (long)-2L; // Unsafe for async preemption

        // PCDATA_UnsafePoint values.
        public static readonly long PCDATA_UnsafePointSafe = (long)-1L; // Safe for async preemption
        public static readonly long PCDATA_UnsafePointUnsafe = (long)-2L; // Unsafe for async preemption

        // PCDATA_Restart1(2) apply on a sequence of instructions, within
        // which if an async preemption happens, we should back off the PC
        // to the start of the sequence when resuming.
        // We need two so we can distinguish the start/end of the sequence
        // in case that two sequences are next to each other.
        public static readonly long PCDATA_Restart1 = (long)-3L;
        public static readonly long PCDATA_Restart2 = (long)-4L; 

        // Like PCDATA_Restart1, but back to function entry if async preempted.
        public static readonly long PCDATA_RestartAtEntry = (long)-5L;

    }
}}}
