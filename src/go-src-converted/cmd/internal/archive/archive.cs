// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package archive implements reading of archive files generated by the Go
// toolchain.

// package archive -- go2cs converted at 2022 March 13 05:43:18 UTC
// import "cmd/internal/archive" ==> using archive = go.cmd.@internal.archive_package
// Original source: C:\Program Files\Go\src\cmd\internal\archive\archive.go
namespace go.cmd.@internal;

using bufio = bufio_package;
using bytes = bytes_package;
using bio = cmd.@internal.bio_package;
using goobj = cmd.@internal.goobj_package;
using errors = errors_package;
using fmt = fmt_package;
using io = io_package;
using log = log_package;
using os = os_package;
using strconv = strconv_package;
using strings = strings_package;
using time = time_package;
using utf8 = unicode.utf8_package;


/*
The archive format is:

First, on a line by itself
    !<arch>

Then zero or more file records. Each file record has a fixed-size one-line header
followed by data bytes followed by an optional padding byte. The header is:

    %-16s%-12d%-6d%-6d%-8o%-10d`
    name mtime uid gid mode size

(note the trailing backquote). The %-16s here means at most 16 *bytes* of
the name, and if shorter, space padded on the right.
*/

// A Data is a reference to data stored in an object file.
// It records the offset and size of the data, so that a client can
// read the data only if necessary.

using System;
public static partial class archive_package {

public partial struct Data {
    public long Offset;
    public long Size;
}

public partial struct Archive {
    public ptr<os.File> f;
    public slice<Entry> Entries;
}

private static ptr<os.File> File(this ptr<Archive> _addr_a) {
    ref Archive a = ref _addr_a.val;

    return _addr_a.f!;
}

public partial struct Entry {
    public @string Name;
    public EntryType Type;
    public long Mtime;
    public nint Uid;
    public nint Gid;
    public os.FileMode Mode;
    public ref Data Data => ref Data_val;
    public ptr<GoObj> Obj; // nil if this entry is not a Go object file
}

public partial struct EntryType { // : nint
}

public static readonly EntryType EntryPkgDef = iota;
public static readonly var EntryGoObj = 0;
public static readonly var EntryNativeObj = 1;

private static @string String(this ptr<Entry> _addr_e) {
    ref Entry e = ref _addr_e.val;

    return fmt.Sprintf("%s %6d/%-6d %12d %s %s", (e.Mode & 0777).String(), e.Uid, e.Gid, e.Size, time.Unix(e.Mtime, 0).Format(timeFormat), e.Name);
}

public partial struct GoObj {
    public slice<byte> TextHeader;
    public @string Arch;
    public ref Data Data => ref Data_val;
}

private static readonly @string entryHeader = "%s%-12d%-6d%-6d%-8o%-10d`\n"; 
// In entryHeader the first entry, the name, is always printed as 16 bytes right-padded.
private static readonly nint entryLen = 16 + 12 + 6 + 6 + 8 + 10 + 1 + 1;
private static readonly @string timeFormat = "Jan _2 15:04 2006";

private static slice<byte> archiveHeader = (slice<byte>)"!<arch>\n";private static slice<byte> archiveMagic = (slice<byte>)"`\n";private static slice<byte> goobjHeader = (slice<byte>)"go objec";private static var errCorruptArchive = errors.New("corrupt archive");private static var errTruncatedArchive = errors.New("truncated archive");private static var errCorruptObject = errors.New("corrupt object file");private static var errNotObject = errors.New("unrecognized object file format");

public partial struct ErrGoObjOtherVersion {
    public slice<byte> magic;
}

public static @string Error(this ErrGoObjOtherVersion e) {
    return fmt.Sprintf("go object of a different version: %q", e.magic);
}

// An objReader is an object file reader.
private partial struct objReader {
    public ptr<Archive> a;
    public ptr<bio.Reader> b;
    public error err;
    public long offset;
    public long limit;
    public array<byte> tmp;
}

private static void init(this ptr<objReader> _addr_r, ptr<os.File> _addr_f) {
    ref objReader r = ref _addr_r.val;
    ref os.File f = ref _addr_f.val;

    r.a = addr(new Archive(f,nil));
    r.offset, _ = f.Seek(0, os.SEEK_CUR);
    r.limit, _ = f.Seek(0, os.SEEK_END);
    f.Seek(r.offset, os.SEEK_SET);
    r.b = bio.NewReader(f);
}

// error records that an error occurred.
// It returns only the first error, so that an error
// caused by an earlier error does not discard information
// about the earlier error.
private static error error(this ptr<objReader> _addr_r, error err) {
    ref objReader r = ref _addr_r.val;

    if (r.err == null) {
        if (err == io.EOF) {
            err = io.ErrUnexpectedEOF;
        }
        r.err = err;
    }
    return error.As(r.err)!;
}

// peek returns the next n bytes without advancing the reader.
private static (slice<byte>, error) peek(this ptr<objReader> _addr_r, nint n) {
    slice<byte> _p0 = default;
    error _p0 = default!;
    ref objReader r = ref _addr_r.val;

    if (r.err != null) {
        return (null, error.As(r.err)!);
    }
    if (r.offset >= r.limit) {
        r.error(io.ErrUnexpectedEOF);
        return (null, error.As(r.err)!);
    }
    var (b, err) = r.b.Peek(n);
    if (err != null) {
        if (err != bufio.ErrBufferFull) {
            r.error(err);
        }
    }
    return (b, error.As(err)!);
}

// readByte reads and returns a byte from the input file.
// On I/O error or EOF, it records the error but returns byte 0.
// A sequence of 0 bytes will eventually terminate any
// parsing state in the object file. In particular, it ends the
// reading of a varint.
private static byte readByte(this ptr<objReader> _addr_r) {
    ref objReader r = ref _addr_r.val;

    if (r.err != null) {
        return 0;
    }
    if (r.offset >= r.limit) {
        r.error(io.ErrUnexpectedEOF);
        return 0;
    }
    var (b, err) = r.b.ReadByte();
    if (err != null) {
        if (err == io.EOF) {
            err = io.ErrUnexpectedEOF;
        }
        r.error(err);
        b = 0;
    }
    else
 {
        r.offset++;
    }
    return b;
}

// read reads exactly len(b) bytes from the input file.
// If an error occurs, read returns the error but also
// records it, so it is safe for callers to ignore the result
// as long as delaying the report is not a problem.
private static error readFull(this ptr<objReader> _addr_r, slice<byte> b) {
    ref objReader r = ref _addr_r.val;

    if (r.err != null) {
        return error.As(r.err)!;
    }
    if (r.offset + int64(len(b)) > r.limit) {
        return error.As(r.error(io.ErrUnexpectedEOF))!;
    }
    var (n, err) = io.ReadFull(r.b, b);
    r.offset += int64(n);
    if (err != null) {
        return error.As(r.error(err))!;
    }
    return error.As(null!)!;
}

// skip skips n bytes in the input.
private static void skip(this ptr<objReader> _addr_r, long n) {
    ref objReader r = ref _addr_r.val;

    if (n < 0) {
        r.error(fmt.Errorf("debug/goobj: internal error: misuse of skip"));
    }
    if (n < int64(len(r.tmp))) { 
        // Since the data is so small, a just reading from the buffered
        // reader is better than flushing the buffer and seeking.
        r.readFull(r.tmp[..(int)n]);
    }
    else if (n <= int64(r.b.Buffered())) { 
        // Even though the data is not small, it has already been read.
        // Advance the buffer instead of seeking.
        while (n > int64(len(r.tmp))) {
            r.readFull(r.tmp[..]);
            n -= int64(len(r.tmp));
        }
    else

        r.readFull(r.tmp[..(int)n]);
    } { 
        // Seek, giving up buffered data.
        r.b.MustSeek(r.offset + n, os.SEEK_SET);
        r.offset += n;
    }
}

// New writes to f to make a new archive.
public static (ptr<Archive>, error) New(ptr<os.File> _addr_f) {
    ptr<Archive> _p0 = default!;
    error _p0 = default!;
    ref os.File f = ref _addr_f.val;

    var (_, err) = f.Write(archiveHeader);
    if (err != null) {
        return (_addr_null!, error.As(err)!);
    }
    return (addr(new Archive(f:f)), error.As(null!)!);
}

// Parse parses an object file or archive from f.
public static (ptr<Archive>, error) Parse(ptr<os.File> _addr_f, bool verbose) {
    ptr<Archive> _p0 = default!;
    error _p0 = default!;
    ref os.File f = ref _addr_f.val;

    objReader r = default;
    r.init(f);
    var (t, err) = r.peek(8);
    if (err != null) {
        if (err == io.EOF) {
            err = io.ErrUnexpectedEOF;
        }
        return (_addr_null!, error.As(err)!);
    }

    if (bytes.Equal(t, archiveHeader)) 
        {
            var err__prev1 = err;

            var err = r.parseArchive(verbose);

            if (err != null) {
                return (_addr_null!, error.As(err)!);
            }

            err = err__prev1;

        }
    else if (bytes.Equal(t, goobjHeader)) 
        var off = r.offset;
        ptr<GoObj> o = addr(new GoObj());
        {
            var err__prev1 = err;

            err = r.parseObject(o, r.limit - off);

            if (err != null) {
                return (_addr_null!, error.As(err)!);
            }

            err = err__prev1;

        }
        r.a.Entries = new slice<Entry>(new Entry[] { {Name:f.Name(),Type:EntryGoObj,Data:Data{off,r.limit-off},Obj:o,} });
    else 
        return (_addr_null!, error.As(errNotObject)!);
        return (_addr_r.a!, error.As(null!)!);
}

// trimSpace removes trailing spaces from b and returns the corresponding string.
// This effectively parses the form used in archive headers.
private static @string trimSpace(slice<byte> b) {
    return string(bytes.TrimRight(b, " "));
}

// parseArchive parses a Unix archive of Go object files.
private static error parseArchive(this ptr<objReader> _addr_r, bool verbose) {
    ref objReader r = ref _addr_r.val;

    r.readFull(r.tmp[..(int)8]); // consume header (already checked)
    while (r.offset < r.limit) {
        {
            var err__prev1 = err;

            var err = r.readFull(r.tmp[..(int)60]);

            if (err != null) {
                return error.As(err)!;
            }

            err = err__prev1;

        }
        var data = r.tmp[..(int)60]; 

        // Each file is preceded by this text header (slice indices in first column):
        //     0:16    name
        //    16:28 date
        //    28:34 uid
        //    34:40 gid
        //    40:48 mode
        //    48:58 size
        //    58:60 magic - `\n
        // We only care about name, size, and magic, unless in verbose mode.
        // The fields are space-padded on the right.
        // The size is in decimal.
        // The file data - size bytes - follows the header.
        // Headers are 2-byte aligned, so if size is odd, an extra padding
        // byte sits between the file data and the next header.
        // The file data that follows is padded to an even number of bytes:
        // if size is odd, an extra padding byte is inserted betw the next header.
        if (len(data) < 60) {
            return error.As(errTruncatedArchive)!;
        }
        if (!bytes.Equal(data[(int)58..(int)60], archiveMagic)) {
            return error.As(errCorruptArchive)!;
        }
        var name = trimSpace(data[(int)0..(int)16]);
        err = default!;
        Func<nint, nint, nint, nint, long> get = (start, end, @base, bitsize) => {
            if (err != null) {
                return error.As(0)!;
            }
            long v = default;
            v, err = strconv.ParseInt(trimSpace(data[(int)start..(int)end]), base, bitsize);
            return error.As(v)!;
        };
        var size = get(48, 58, 10, 64);
        long mtime = default;        nint uid = default;        nint gid = default;
        os.FileMode mode = default;
        if (verbose) {
            mtime = get(16, 28, 10, 64);
            uid = int(get(28, 34, 10, 32));
            gid = int(get(34, 40, 10, 32));
            mode = os.FileMode(get(40, 48, 8, 32));
        }
        if (err != null) {
            return error.As(errCorruptArchive)!;
        }
        data = data[(int)60..];
        var fsize = size + size & 1;
        if (fsize < 0 || fsize < size) {
            return error.As(errCorruptArchive)!;
        }
        switch (name) {
            case "__.PKGDEF": 
                r.a.Entries = append(r.a.Entries, new Entry(Name:name,Type:EntryPkgDef,Mtime:mtime,Uid:uid,Gid:gid,Mode:mode,Data:Data{r.offset,size},));
                r.skip(size);
                break;
            default: 
                           EntryType typ = default;
                           ptr<GoObj> o;
                           var offset = r.offset;
                           var (p, err) = r.peek(8);
                           if (err != null) {
                               return error.As(err)!;
                           }
                           if (bytes.Equal(p, goobjHeader)) {
                               typ = EntryGoObj;
                               o = addr(new GoObj());
                               r.parseObject(o, size);
                           }
                           else
                {
                               typ = EntryNativeObj;
                               r.skip(size);
                           }
                           r.a.Entries = append(r.a.Entries, new Entry(Name:name,Type:typ,Mtime:mtime,Uid:uid,Gid:gid,Mode:mode,Data:Data{offset,size},Obj:o,));
                break;
        }
        if (size & 1 != 0) {
            r.skip(1);
        }
    }
    return error.As(null!)!;
}

// parseObject parses a single Go object file.
// The object file consists of a textual header ending in "\n!\n"
// and then the part we want to parse begins.
// The format of that part is defined in a comment at the top
// of cmd/internal/goobj/objfile.go.
private static error parseObject(this ptr<objReader> _addr_r, ptr<GoObj> _addr_o, long size) {
    ref objReader r = ref _addr_r.val;
    ref GoObj o = ref _addr_o.val;

    var h = make_slice<byte>(0, 256);
    byte c1 = default;    byte c2 = default;    byte c3 = default;

    while (true) {
        (c1, c2, c3) = (c2, c3, r.readByte());        h = append(h, c3); 
        // The new export format can contain 0 bytes.
        // Don't consider them errors, only look for r.err != nil.
        if (r.err != null) {
            return error.As(errCorruptObject)!;
        }
        if (c1 == '\n' && c2 == '!' && c3 == '\n') {
            break;
        }
    }
    o.TextHeader = h;
    var hs = strings.Fields(string(h));
    if (len(hs) >= 4) {
        o.Arch = hs[3];
    }
    o.Offset = r.offset;
    o.Size = size - int64(len(h));

    var (p, err) = r.peek(8);
    if (err != null) {
        return error.As(err)!;
    }
    if (!bytes.Equal(p, (slice<byte>)goobj.Magic)) {
        if (bytes.HasPrefix(p, (slice<byte>)"\x00go1") && bytes.HasSuffix(p, (slice<byte>)"ld")) {
            return error.As(r.error(new ErrGoObjOtherVersion(p[1:])))!; // strip the \x00 byte
        }
        return error.As(r.error(errCorruptObject))!;
    }
    r.skip(o.Size);
    return error.As(null!)!;
}

// AddEntry adds an entry to the end of a, with the content from r.
private static void AddEntry(this ptr<Archive> _addr_a, EntryType typ, @string name, long mtime, nint uid, nint gid, os.FileMode mode, long size, io.Reader r) {
    ref Archive a = ref _addr_a.val;

    var (off, err) = a.f.Seek(0, os.SEEK_END);
    if (err != null) {
        log.Fatal(err);
    }
    var (n, err) = fmt.Fprintf(a.f, entryHeader, exactly16Bytes(name), mtime, uid, gid, mode, size);
    if (err != null || n != entryLen) {
        log.Fatal("writing entry header: ", err);
    }
    var (n1, _) = io.CopyN(a.f, r, size);
    if (n1 != size) {
        log.Fatal(err);
    }
    if ((off + size) & 1 != 0) {
        a.f.Write(new slice<byte>(new byte[] { 0 })); // pad to even byte
    }
    a.Entries = append(a.Entries, new Entry(Name:name,Type:typ,Mtime:mtime,Uid:uid,Gid:gid,Mode:mode,Data:Data{off+entryLen,size},));
}

// exactly16Bytes truncates the string if necessary so it is at most 16 bytes long,
// then pads the result with spaces to be exactly 16 bytes.
// Fmt uses runes for its width calculation, but we need bytes in the entry header.
private static @string exactly16Bytes(@string s) {
    while (len(s) > 16) {
        var (_, wid) = utf8.DecodeLastRuneInString(s);
        s = s[..(int)len(s) - wid];
    }
    const @string sixteenSpaces = "                ";

    s += sixteenSpaces[..(int)16 - len(s)];
    return s;
}

// architecture-independent object file output
public static readonly nint HeaderSize = 60;



public static nint ReadHeader(ptr<bufio.Reader> _addr_b, @string name) {
    ref bufio.Reader b = ref _addr_b.val;

    array<byte> buf = new array<byte>(HeaderSize);
    {
        var (_, err) = io.ReadFull(b, buf[..]);

        if (err != null) {
            return -1;
        }
    }
    var aname = strings.Trim(string(buf[(int)0..(int)16]), " ");
    if (!strings.HasPrefix(aname, name)) {
        return -1;
    }
    var asize = strings.Trim(string(buf[(int)48..(int)58]), " ");
    var (i, _) = strconv.Atoi(asize);
    return i;
}

public static void FormatHeader(slice<byte> arhdr, @string name, long size) {
    copy(arhdr[..], fmt.Sprintf("%-16s%-12d%-6d%-6d%-8o%-10d`\n", name, 0, 0, 0, 0644, size));
}

} // end archive_package
