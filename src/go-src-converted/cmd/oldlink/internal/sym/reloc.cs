// Copyright 2017 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// package sym -- go2cs converted at 2020 October 08 04:40:29 UTC
// import "cmd/oldlink/internal/sym" ==> using sym = go.cmd.oldlink.@internal.sym_package
// Original source: C:\Go\src\cmd\oldlink\internal\sym\reloc.go
using objabi = go.cmd.@internal.objabi_package;
using sys = go.cmd.@internal.sys_package;
using elf = go.debug.elf_package;
using static go.builtin;

namespace go {
namespace cmd {
namespace oldlink {
namespace @internal
{
    public static partial class sym_package
    {
        // Reloc is a relocation.
        //
        // The typical Reloc rewrites part of a symbol at offset Off to address Sym.
        // A Reloc is stored in a slice on the Symbol it rewrites.
        //
        // Relocations are generated by the compiler as the type
        // cmd/internal/obj.Reloc, which is encoded into the object file wire
        // format and decoded by the linker into this type. A separate type is
        // used to hold linker-specific state about the relocation.
        //
        // Some relocations are created by cmd/link.
        public partial struct Reloc
        {
            public int Off; // offset to rewrite
            public byte Siz; // number of bytes to rewrite, 1, 2, or 4
            public bool Done; // set to true when relocation is complete
            public objabi.RelocType Type; // the relocation type
            public long Add; // addend
            public ptr<Symbol> Sym; // symbol the relocation addresses
            public ref ptr<relocExt> ptr<relocExt> => ref ptr<relocExt>_ptr; // extra fields (see below), may be nil, call InitExt before use
        }

        // relocExt contains extra fields in Reloc that are used only in
        // certain cases.
        private partial struct relocExt
        {
            public long Xadd; // addend passed to external linker
            public ptr<Symbol> Xsym; // symbol passed to external linker
            public RelocVariant Variant; // variation on Type, currently used only on PPC64 and S390X
        }

        private static void InitExt(this ptr<Reloc> _addr_r)
        {
            ref Reloc r = ref _addr_r.val;

            if (r.relocExt == null)
            {
                r.relocExt = @new<relocExt>();
            }

        }

        // RelocVariant is a linker-internal variation on a relocation.
        public partial struct RelocVariant // : byte
        {
        }

        public static readonly RelocVariant RV_NONE = (RelocVariant)iota;
        public static readonly var RV_POWER_LO = (var)0;
        public static readonly var RV_POWER_HI = (var)1;
        public static readonly var RV_POWER_HA = (var)2;
        public static readonly var RV_POWER_DS = (var)3; 

        // RV_390_DBL is a s390x-specific relocation variant that indicates that
        // the value to be placed into the relocatable field should first be
        // divided by 2.
        public static readonly var RV_390_DBL = (var)4;

        public static readonly RelocVariant RV_CHECK_OVERFLOW = (RelocVariant)1L << (int)(7L);
        public static readonly RelocVariant RV_TYPE_MASK = (RelocVariant)RV_CHECK_OVERFLOW - 1L;


        public static @string RelocName(ptr<sys.Arch> _addr_arch, objabi.RelocType r) => func((_, panic, __) =>
        {
            ref sys.Arch arch = ref _addr_arch.val;
 
            // We didn't have some relocation types at Go1.4.
            // Uncomment code when we include those in bootstrap code.


            if (r >= objabi.MachoRelocOffset)             else if (r >= objabi.ElfRelocOffset) // ELF
                var nr = r - objabi.ElfRelocOffset;

                if (arch.Family == sys.AMD64) 
                    return elf.R_X86_64(nr).String();
                else if (arch.Family == sys.ARM) 
                    return elf.R_ARM(nr).String();
                else if (arch.Family == sys.ARM64) 
                    return elf.R_AARCH64(nr).String();
                else if (arch.Family == sys.I386) 
                    return elf.R_386(nr).String();
                else if (arch.Family == sys.MIPS || arch.Family == sys.MIPS64) 
                    return elf.R_MIPS(nr).String();
                else if (arch.Family == sys.PPC64) 
                    return elf.R_PPC64(nr).String();
                else if (arch.Family == sys.S390X) 
                    return elf.R_390(nr).String();
                else 
                    panic("unreachable");
                                        return r.String();

        });

        // RelocByOff implements sort.Interface for sorting relocations by offset.
        public partial struct RelocByOff // : slice<Reloc>
        {
        }

        public static long Len(this RelocByOff x)
        {
            return len(x);
        }

        public static void Swap(this RelocByOff x, long i, long j)
        {
            x[i] = x[j];
            x[j] = x[i];
        }

        public static bool Less(this RelocByOff x, long i, long j)
        {
            var a = _addr_x[i];
            var b = _addr_x[j];
            if (a.Off < b.Off)
            {
                return true;
            }

            if (a.Off > b.Off)
            {
                return false;
            }

            return false;

        }
    }
}}}}
