// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file provides support for parsing coverage profiles
// generated by "go test -coverprofile=cover.out".
// It is a copy of golang.org/x/tools/cover/profile.go.

// package main -- go2cs converted at 2020 October 08 04:32:36 UTC
// Original source: C:\Go\src\cmd\cover\profile.go
using bufio = go.bufio_package;
using fmt = go.fmt_package;
using math = go.math_package;
using os = go.os_package;
using regexp = go.regexp_package;
using sort = go.sort_package;
using strconv = go.strconv_package;
using strings = go.strings_package;
using static go.builtin;
using System;

namespace go
{
    public static partial class main_package
    {
        // Profile represents the profiling data for a specific file.
        public partial struct Profile
        {
            public @string FileName;
            public @string Mode;
            public slice<ProfileBlock> Blocks;
        }

        // ProfileBlock represents a single block of profiling data.
        public partial struct ProfileBlock
        {
            public long StartLine;
            public long StartCol;
            public long EndLine;
            public long EndCol;
            public long NumStmt;
            public long Count;
        }

        private partial struct byFileName // : slice<ptr<Profile>>
        {
        }

        private static long Len(this byFileName p)
        {
            return len(p);
        }
        private static bool Less(this byFileName p, long i, long j)
        {
            return p[i].FileName < p[j].FileName;
        }
        private static void Swap(this byFileName p, long i, long j)
        {
            p[i] = p[j];
            p[j] = p[i];
        }

        // ParseProfiles parses profile data in the specified file and returns a
        // Profile for each source file described therein.
        public static (slice<ptr<Profile>>, error) ParseProfiles(@string fileName) => func((defer, _, __) =>
        {
            slice<ptr<Profile>> _p0 = default;
            error _p0 = default!;

            var (pf, err) = os.Open(fileName);
            if (err != null)
            {
                return (null, error.As(err)!);
            }

            defer(pf.Close());

            var files = make_map<@string, ptr<Profile>>();
            var buf = bufio.NewReader(pf); 
            // First line is "mode: foo", where foo is "set", "count", or "atomic".
            // Rest of file is in the format
            //    encoding/base64/base64.go:34.44,37.40 3 1
            // where the fields are: name.go:line.column,line.column numberOfStatements count
            var s = bufio.NewScanner(buf);
            @string mode = "";
            while (s.Scan())
            {
                var line = s.Text();
                if (mode == "")
                {
                    const @string p = (@string)"mode: ";

                    if (!strings.HasPrefix(line, p) || line == p)
                    {
                        return (null, error.As(fmt.Errorf("bad mode line: %v", line))!);
                    }

                    mode = line[len(p)..];
                    continue;

                }

                var m = lineRe.FindStringSubmatch(line);
                if (m == null)
                {
                    return (null, error.As(fmt.Errorf("line %q doesn't match expected format: %v", m, lineRe))!);
                }

                var fn = m[1L];
                var p = files[fn];
                if (p == null)
                {
                    p = addr(new Profile(FileName:fn,Mode:mode,));
                    files[fn] = p;
                }

                p.Blocks = append(p.Blocks, new ProfileBlock(StartLine:toInt(m[2]),StartCol:toInt(m[3]),EndLine:toInt(m[4]),EndCol:toInt(m[5]),NumStmt:toInt(m[6]),Count:toInt(m[7]),));

            }

            {
                var err = s.Err();

                if (err != null)
                {
                    return (null, error.As(err)!);
                }

            }

            {
                var p__prev1 = p;

                foreach (var (_, __p) in files)
                {
                    p = __p;
                    sort.Sort(blocksByStart(p.Blocks)); 
                    // Merge samples from the same location.
                    long j = 1L;
                    for (long i = 1L; i < len(p.Blocks); i++)
                    {
                        var b = p.Blocks[i];
                        var last = p.Blocks[j - 1L];
                        if (b.StartLine == last.StartLine && b.StartCol == last.StartCol && b.EndLine == last.EndLine && b.EndCol == last.EndCol)
                        {
                            if (b.NumStmt != last.NumStmt)
                            {
                                return (null, error.As(fmt.Errorf("inconsistent NumStmt: changed from %d to %d", last.NumStmt, b.NumStmt))!);
                            }

                            if (mode == "set")
                            {
                                p.Blocks[j - 1L].Count |= b.Count;
                            }
                            else
                            {
                                p.Blocks[j - 1L].Count += b.Count;
                            }

                            continue;

                        }

                        p.Blocks[j] = b;
                        j++;

                    }

                    p.Blocks = p.Blocks[..j];

                } 
                // Generate a sorted slice.

                p = p__prev1;
            }

            var profiles = make_slice<ptr<Profile>>(0L, len(files));
            foreach (var (_, profile) in files)
            {
                profiles = append(profiles, profile);
            }
            sort.Sort(byFileName(profiles));
            return (profiles, error.As(null!)!);

        });

        private partial struct blocksByStart // : slice<ProfileBlock>
        {
        }

        private static long Len(this blocksByStart b)
        {
            return len(b);
        }
        private static void Swap(this blocksByStart b, long i, long j)
        {
            b[i] = b[j];
            b[j] = b[i];
        }
        private static bool Less(this blocksByStart b, long i, long j)
        {
            var bi = b[i];
            var bj = b[j];
            return bi.StartLine < bj.StartLine || bi.StartLine == bj.StartLine && bi.StartCol < bj.StartCol;

        }

        private static var lineRe = regexp.MustCompile("^(.+):([0-9]+).([0-9]+),([0-9]+).([0-9]+) ([0-9]+) ([0-9]+)$");

        private static long toInt(@string s) => func((_, panic, __) =>
        {
            var (i, err) = strconv.Atoi(s);
            if (err != null)
            {
                panic(err);
            }

            return i;

        });

        // Boundary represents the position in a source file of the beginning or end of a
        // block as reported by the coverage profile. In HTML mode, it will correspond to
        // the opening or closing of a <span> tag and will be used to colorize the source
        public partial struct Boundary
        {
            public long Offset; // Location as a byte offset in the source file.
            public bool Start; // Is this the start of a block?
            public long Count; // Event count from the cover profile.
            public double Norm; // Count normalized to [0..1].
            public long Index; // Order in input file.
        }

        // Boundaries returns a Profile as a set of Boundary objects within the provided src.
        private static slice<Boundary> Boundaries(this ptr<Profile> _addr_p, slice<byte> src)
        {
            slice<Boundary> boundaries = default;
            ref Profile p = ref _addr_p.val;
 
            // Find maximum count.
            long max = 0L;
            {
                var b__prev1 = b;

                foreach (var (_, __b) in p.Blocks)
                {
                    b = __b;
                    if (b.Count > max)
                    {
                        max = b.Count;
                    }

                } 
                // Divisor for normalization.

                b = b__prev1;
            }

            var divisor = math.Log(float64(max)); 

            // boundary returns a Boundary, populating the Norm field with a normalized Count.
            long index = 0L;
            Func<long, bool, long, Boundary> boundary = (offset, start, count) =>
            {
                Boundary b = new Boundary(Offset:offset,Start:start,Count:count,Index:index);
                index++;
                if (!start || count == 0L)
                {
                    return b;
                }

                if (max <= 1L)
                {
                    b.Norm = 0.8F; // Profile is in "set" mode; we want a heat map. Use cov8 in the CSS.
                }
                else if (count > 0L)
                {
                    b.Norm = math.Log(float64(count)) / divisor;
                }

                return b;

            }
;

            long line = 1L;
            long col = 2L; // TODO: Why is this 2?
            {
                long si = 0L;
                long bi = 0L;

                while (si < len(src) && bi < len(p.Blocks))
                {
                    b = p.Blocks[bi];
                    if (b.StartLine == line && b.StartCol == col)
                    {
                        boundaries = append(boundaries, boundary(si, true, b.Count));
                    }

                    if (b.EndLine == line && b.EndCol == col || line > b.EndLine)
                    {
                        boundaries = append(boundaries, boundary(si, false, 0L));
                        bi++;
                        continue; // Don't advance through src; maybe the next block starts here.
                    }

                    if (src[si] == '\n')
                    {
                        line++;
                        col = 0L;
                    }

                    col++;
                    si++;

                }

            }
            sort.Sort(boundariesByPos(boundaries));
            return ;

        }

        private partial struct boundariesByPos // : slice<Boundary>
        {
        }

        private static long Len(this boundariesByPos b)
        {
            return len(b);
        }
        private static void Swap(this boundariesByPos b, long i, long j)
        {
            b[i] = b[j];
            b[j] = b[i];
        }
        private static bool Less(this boundariesByPos b, long i, long j)
        {
            if (b[i].Offset == b[j].Offset)
            { 
                // Boundaries at the same offset should be ordered according to
                // their original position.
                return b[i].Index < b[j].Index;

            }

            return b[i].Offset < b[j].Offset;

        }
    }
}
