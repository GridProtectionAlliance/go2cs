// Code generated by mknode.go. DO NOT EDIT.

// package ir -- go2cs converted at 2022 March 06 22:49:14 UTC
// import "cmd/compile/internal/ir" ==> using ir = go.cmd.compile.@internal.ir_package
// Original source: C:\Program Files\Go\src\cmd\compile\internal\ir\node_gen.go
using fmt = go.fmt_package;
using System;


namespace go.cmd.compile.@internal;

public static partial class ir_package {

private static void Format(this ptr<AddStringExpr> _addr_n, fmt.State s, int verb) {
    ref AddStringExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<AddStringExpr> _addr_n) {
    ref AddStringExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.List = copyNodes(c.List);
    return _addr_c;
}
private static bool doChildren(this ptr<AddStringExpr> _addr_n, Func<Node, bool> @do) {
    ref AddStringExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (doNodes(n.List, do)) {
        return true;
    }
    if (n.Prealloc != null && do(n.Prealloc)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<AddStringExpr> _addr_n, Func<Node, Node> edit) {
    ref AddStringExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    editNodes(n.List, edit);
    if (n.Prealloc != null) {
        n.Prealloc = edit(n.Prealloc)._<ptr<Name>>();
    }
}

private static void Format(this ptr<AddrExpr> _addr_n, fmt.State s, int verb) {
    ref AddrExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<AddrExpr> _addr_n) {
    ref AddrExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<AddrExpr> _addr_n, Func<Node, bool> @do) {
    ref AddrExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    if (n.Prealloc != null && do(n.Prealloc)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<AddrExpr> _addr_n, Func<Node, Node> edit) {
    ref AddrExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
    if (n.Prealloc != null) {
        n.Prealloc = edit(n.Prealloc)._<ptr<Name>>();
    }
}

private static void Format(this ptr<ArrayType> _addr_n, fmt.State s, int verb) {
    ref ArrayType n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<ArrayType> _addr_n) {
    ref ArrayType n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    return _addr_c;
}
private static bool doChildren(this ptr<ArrayType> _addr_n, Func<Node, bool> @do) {
    ref ArrayType n = ref _addr_n.val;

    if (n.Len != null && do(n.Len)) {
        return true;
    }
    if (n.Elem != null && do(n.Elem)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<ArrayType> _addr_n, Func<Node, Node> edit) {
    ref ArrayType n = ref _addr_n.val;

    if (n.Len != null) {
        n.Len = edit(n.Len)._<Node>();
    }
    if (n.Elem != null) {
        n.Elem = edit(n.Elem)._<Ntype>();
    }
}

private static void Format(this ptr<AssignListStmt> _addr_n, fmt.State s, int verb) {
    ref AssignListStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<AssignListStmt> _addr_n) {
    ref AssignListStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.Lhs = copyNodes(c.Lhs);
    c.Rhs = copyNodes(c.Rhs);
    return _addr_c;
}
private static bool doChildren(this ptr<AssignListStmt> _addr_n, Func<Node, bool> @do) {
    ref AssignListStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (doNodes(n.Lhs, do)) {
        return true;
    }
    if (doNodes(n.Rhs, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<AssignListStmt> _addr_n, Func<Node, Node> edit) {
    ref AssignListStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
    editNodes(n.Lhs, edit);
    editNodes(n.Rhs, edit);
}

private static void Format(this ptr<AssignOpStmt> _addr_n, fmt.State s, int verb) {
    ref AssignOpStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<AssignOpStmt> _addr_n) {
    ref AssignOpStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<AssignOpStmt> _addr_n, Func<Node, bool> @do) {
    ref AssignOpStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    if (n.Y != null && do(n.Y)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<AssignOpStmt> _addr_n, Func<Node, Node> edit) {
    ref AssignOpStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
    if (n.Y != null) {
        n.Y = edit(n.Y)._<Node>();
    }
}

private static void Format(this ptr<AssignStmt> _addr_n, fmt.State s, int verb) {
    ref AssignStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<AssignStmt> _addr_n) {
    ref AssignStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<AssignStmt> _addr_n, Func<Node, bool> @do) {
    ref AssignStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    if (n.Y != null && do(n.Y)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<AssignStmt> _addr_n, Func<Node, Node> edit) {
    ref AssignStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
    if (n.Y != null) {
        n.Y = edit(n.Y)._<Node>();
    }
}

private static void Format(this ptr<BasicLit> _addr_n, fmt.State s, int verb) {
    ref BasicLit n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<BasicLit> _addr_n) {
    ref BasicLit n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<BasicLit> _addr_n, Func<Node, bool> @do) {
    ref BasicLit n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<BasicLit> _addr_n, Func<Node, Node> edit) {
    ref BasicLit n = ref _addr_n.val;

    editNodes(n.init, edit);
}

private static void Format(this ptr<BinaryExpr> _addr_n, fmt.State s, int verb) {
    ref BinaryExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<BinaryExpr> _addr_n) {
    ref BinaryExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<BinaryExpr> _addr_n, Func<Node, bool> @do) {
    ref BinaryExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    if (n.Y != null && do(n.Y)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<BinaryExpr> _addr_n, Func<Node, Node> edit) {
    ref BinaryExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
    if (n.Y != null) {
        n.Y = edit(n.Y)._<Node>();
    }
}

private static void Format(this ptr<BlockStmt> _addr_n, fmt.State s, int verb) {
    ref BlockStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<BlockStmt> _addr_n) {
    ref BlockStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.List = copyNodes(c.List);
    return _addr_c;
}
private static bool doChildren(this ptr<BlockStmt> _addr_n, Func<Node, bool> @do) {
    ref BlockStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (doNodes(n.List, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<BlockStmt> _addr_n, Func<Node, Node> edit) {
    ref BlockStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
    editNodes(n.List, edit);
}

private static void Format(this ptr<BranchStmt> _addr_n, fmt.State s, int verb) {
    ref BranchStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<BranchStmt> _addr_n) {
    ref BranchStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<BranchStmt> _addr_n, Func<Node, bool> @do) {
    ref BranchStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<BranchStmt> _addr_n, Func<Node, Node> edit) {
    ref BranchStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
}

private static void Format(this ptr<CallExpr> _addr_n, fmt.State s, int verb) {
    ref CallExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<CallExpr> _addr_n) {
    ref CallExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.Args = copyNodes(c.Args);
    c.KeepAlive = copyNames(c.KeepAlive);
    return _addr_c;
}
private static bool doChildren(this ptr<CallExpr> _addr_n, Func<Node, bool> @do) {
    ref CallExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    if (doNodes(n.Args, do)) {
        return true;
    }
    if (doNames(n.KeepAlive, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<CallExpr> _addr_n, Func<Node, Node> edit) {
    ref CallExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
    editNodes(n.Args, edit);
    editNames(n.KeepAlive, edit);

}

private static void Format(this ptr<CaseClause> _addr_n, fmt.State s, int verb) {
    ref CaseClause n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<CaseClause> _addr_n) {
    ref CaseClause n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.List = copyNodes(c.List);
    c.Body = copyNodes(c.Body);
    return _addr_c;
}
private static bool doChildren(this ptr<CaseClause> _addr_n, Func<Node, bool> @do) {
    ref CaseClause n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.Var != null && do(n.Var)) {
        return true;
    }
    if (doNodes(n.List, do)) {
        return true;
    }
    if (doNodes(n.Body, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<CaseClause> _addr_n, Func<Node, Node> edit) {
    ref CaseClause n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.Var != null) {
        n.Var = edit(n.Var)._<ptr<Name>>();
    }
    editNodes(n.List, edit);
    editNodes(n.Body, edit);

}

private static void Format(this ptr<ChanType> _addr_n, fmt.State s, int verb) {
    ref ChanType n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<ChanType> _addr_n) {
    ref ChanType n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    return _addr_c;
}
private static bool doChildren(this ptr<ChanType> _addr_n, Func<Node, bool> @do) {
    ref ChanType n = ref _addr_n.val;

    if (n.Elem != null && do(n.Elem)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<ChanType> _addr_n, Func<Node, Node> edit) {
    ref ChanType n = ref _addr_n.val;

    if (n.Elem != null) {
        n.Elem = edit(n.Elem)._<Ntype>();
    }
}

private static void Format(this ptr<ClosureExpr> _addr_n, fmt.State s, int verb) {
    ref ClosureExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<ClosureExpr> _addr_n) {
    ref ClosureExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<ClosureExpr> _addr_n, Func<Node, bool> @do) {
    ref ClosureExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.Prealloc != null && do(n.Prealloc)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<ClosureExpr> _addr_n, Func<Node, Node> edit) {
    ref ClosureExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.Prealloc != null) {
        n.Prealloc = edit(n.Prealloc)._<ptr<Name>>();
    }
}

private static void Format(this ptr<CommClause> _addr_n, fmt.State s, int verb) {
    ref CommClause n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<CommClause> _addr_n) {
    ref CommClause n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.Body = copyNodes(c.Body);
    return _addr_c;
}
private static bool doChildren(this ptr<CommClause> _addr_n, Func<Node, bool> @do) {
    ref CommClause n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.Comm != null && do(n.Comm)) {
        return true;
    }
    if (doNodes(n.Body, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<CommClause> _addr_n, Func<Node, Node> edit) {
    ref CommClause n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.Comm != null) {
        n.Comm = edit(n.Comm)._<Node>();
    }
    editNodes(n.Body, edit);

}

private static void Format(this ptr<CompLitExpr> _addr_n, fmt.State s, int verb) {
    ref CompLitExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<CompLitExpr> _addr_n) {
    ref CompLitExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.List = copyNodes(c.List);
    return _addr_c;
}
private static bool doChildren(this ptr<CompLitExpr> _addr_n, Func<Node, bool> @do) {
    ref CompLitExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.Ntype != null && do(n.Ntype)) {
        return true;
    }
    if (doNodes(n.List, do)) {
        return true;
    }
    if (n.Prealloc != null && do(n.Prealloc)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<CompLitExpr> _addr_n, Func<Node, Node> edit) {
    ref CompLitExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.Ntype != null) {
        n.Ntype = edit(n.Ntype)._<Ntype>();
    }
    editNodes(n.List, edit);
    if (n.Prealloc != null) {
        n.Prealloc = edit(n.Prealloc)._<ptr<Name>>();
    }
}

private static void Format(this ptr<ConstExpr> _addr_n, fmt.State s, int verb) {
    ref ConstExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<ConstExpr> _addr_n) {
    ref ConstExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<ConstExpr> _addr_n, Func<Node, bool> @do) {
    ref ConstExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<ConstExpr> _addr_n, Func<Node, Node> edit) {
    ref ConstExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
}

private static void Format(this ptr<ConvExpr> _addr_n, fmt.State s, int verb) {
    ref ConvExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<ConvExpr> _addr_n) {
    ref ConvExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<ConvExpr> _addr_n, Func<Node, bool> @do) {
    ref ConvExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<ConvExpr> _addr_n, Func<Node, Node> edit) {
    ref ConvExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
}

private static void Format(this ptr<Decl> _addr_n, fmt.State s, int verb) {
    ref Decl n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<Decl> _addr_n) {
    ref Decl n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    return _addr_c;
}
private static bool doChildren(this ptr<Decl> _addr_n, Func<Node, bool> @do) {
    ref Decl n = ref _addr_n.val;

    if (n.X != null && do(n.X)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<Decl> _addr_n, Func<Node, Node> edit) {
    ref Decl n = ref _addr_n.val;

    if (n.X != null) {
        n.X = edit(n.X)._<ptr<Name>>();
    }
}

private static void Format(this ptr<ForStmt> _addr_n, fmt.State s, int verb) {
    ref ForStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<ForStmt> _addr_n) {
    ref ForStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.Late = copyNodes(c.Late);
    c.Body = copyNodes(c.Body);
    return _addr_c;
}
private static bool doChildren(this ptr<ForStmt> _addr_n, Func<Node, bool> @do) {
    ref ForStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.Cond != null && do(n.Cond)) {
        return true;
    }
    if (doNodes(n.Late, do)) {
        return true;
    }
    if (n.Post != null && do(n.Post)) {
        return true;
    }
    if (doNodes(n.Body, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<ForStmt> _addr_n, Func<Node, Node> edit) {
    ref ForStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.Cond != null) {
        n.Cond = edit(n.Cond)._<Node>();
    }
    editNodes(n.Late, edit);
    if (n.Post != null) {
        n.Post = edit(n.Post)._<Node>();
    }
    editNodes(n.Body, edit);

}

private static void Format(this ptr<Func> _addr_n, fmt.State s, int verb) {
    ref Func n = ref _addr_n.val;

    fmtNode(n, s, verb);
}

private static void Format(this ptr<FuncType> _addr_n, fmt.State s, int verb) {
    ref FuncType n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<FuncType> _addr_n) {
    ref FuncType n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.Recv = copyField(c.Recv);
    c.Params = copyFields(c.Params);
    c.Results = copyFields(c.Results);
    return _addr_c;
}
private static bool doChildren(this ptr<FuncType> _addr_n, Func<Node, bool> @do) {
    ref FuncType n = ref _addr_n.val;

    if (doField(n.Recv, do)) {
        return true;
    }
    if (doFields(n.Params, do)) {
        return true;
    }
    if (doFields(n.Results, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<FuncType> _addr_n, Func<Node, Node> edit) {
    ref FuncType n = ref _addr_n.val;

    editField(n.Recv, edit);
    editFields(n.Params, edit);
    editFields(n.Results, edit);
}

private static void Format(this ptr<GoDeferStmt> _addr_n, fmt.State s, int verb) {
    ref GoDeferStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<GoDeferStmt> _addr_n) {
    ref GoDeferStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<GoDeferStmt> _addr_n, Func<Node, bool> @do) {
    ref GoDeferStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.Call != null && do(n.Call)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<GoDeferStmt> _addr_n, Func<Node, Node> edit) {
    ref GoDeferStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.Call != null) {
        n.Call = edit(n.Call)._<Node>();
    }
}

private static void Format(this ptr<Ident> _addr_n, fmt.State s, int verb) {
    ref Ident n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<Ident> _addr_n) {
    ref Ident n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<Ident> _addr_n, Func<Node, bool> @do) {
    ref Ident n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<Ident> _addr_n, Func<Node, Node> edit) {
    ref Ident n = ref _addr_n.val;

    editNodes(n.init, edit);
}

private static void Format(this ptr<IfStmt> _addr_n, fmt.State s, int verb) {
    ref IfStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<IfStmt> _addr_n) {
    ref IfStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.Body = copyNodes(c.Body);
    c.Else = copyNodes(c.Else);
    return _addr_c;
}
private static bool doChildren(this ptr<IfStmt> _addr_n, Func<Node, bool> @do) {
    ref IfStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.Cond != null && do(n.Cond)) {
        return true;
    }
    if (doNodes(n.Body, do)) {
        return true;
    }
    if (doNodes(n.Else, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<IfStmt> _addr_n, Func<Node, Node> edit) {
    ref IfStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.Cond != null) {
        n.Cond = edit(n.Cond)._<Node>();
    }
    editNodes(n.Body, edit);
    editNodes(n.Else, edit);

}

private static void Format(this ptr<IndexExpr> _addr_n, fmt.State s, int verb) {
    ref IndexExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<IndexExpr> _addr_n) {
    ref IndexExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<IndexExpr> _addr_n, Func<Node, bool> @do) {
    ref IndexExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    if (n.Index != null && do(n.Index)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<IndexExpr> _addr_n, Func<Node, Node> edit) {
    ref IndexExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
    if (n.Index != null) {
        n.Index = edit(n.Index)._<Node>();
    }
}

private static void Format(this ptr<InlineMarkStmt> _addr_n, fmt.State s, int verb) {
    ref InlineMarkStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<InlineMarkStmt> _addr_n) {
    ref InlineMarkStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<InlineMarkStmt> _addr_n, Func<Node, bool> @do) {
    ref InlineMarkStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<InlineMarkStmt> _addr_n, Func<Node, Node> edit) {
    ref InlineMarkStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
}

private static void Format(this ptr<InlinedCallExpr> _addr_n, fmt.State s, int verb) {
    ref InlinedCallExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<InlinedCallExpr> _addr_n) {
    ref InlinedCallExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.Body = copyNodes(c.Body);
    c.ReturnVars = copyNodes(c.ReturnVars);
    return _addr_c;
}
private static bool doChildren(this ptr<InlinedCallExpr> _addr_n, Func<Node, bool> @do) {
    ref InlinedCallExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (doNodes(n.Body, do)) {
        return true;
    }
    if (doNodes(n.ReturnVars, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<InlinedCallExpr> _addr_n, Func<Node, Node> edit) {
    ref InlinedCallExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    editNodes(n.Body, edit);
    editNodes(n.ReturnVars, edit);
}

private static void Format(this ptr<InstExpr> _addr_n, fmt.State s, int verb) {
    ref InstExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<InstExpr> _addr_n) {
    ref InstExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.Targs = copyNodes(c.Targs);
    return _addr_c;
}
private static bool doChildren(this ptr<InstExpr> _addr_n, Func<Node, bool> @do) {
    ref InstExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    if (doNodes(n.Targs, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<InstExpr> _addr_n, Func<Node, Node> edit) {
    ref InstExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
    editNodes(n.Targs, edit);

}

private static void Format(this ptr<InterfaceType> _addr_n, fmt.State s, int verb) {
    ref InterfaceType n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<InterfaceType> _addr_n) {
    ref InterfaceType n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.Methods = copyFields(c.Methods);
    return _addr_c;
}
private static bool doChildren(this ptr<InterfaceType> _addr_n, Func<Node, bool> @do) {
    ref InterfaceType n = ref _addr_n.val;

    if (doFields(n.Methods, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<InterfaceType> _addr_n, Func<Node, Node> edit) {
    ref InterfaceType n = ref _addr_n.val;

    editFields(n.Methods, edit);
}

private static void Format(this ptr<KeyExpr> _addr_n, fmt.State s, int verb) {
    ref KeyExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<KeyExpr> _addr_n) {
    ref KeyExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<KeyExpr> _addr_n, Func<Node, bool> @do) {
    ref KeyExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.Key != null && do(n.Key)) {
        return true;
    }
    if (n.Value != null && do(n.Value)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<KeyExpr> _addr_n, Func<Node, Node> edit) {
    ref KeyExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.Key != null) {
        n.Key = edit(n.Key)._<Node>();
    }
    if (n.Value != null) {
        n.Value = edit(n.Value)._<Node>();
    }
}

private static void Format(this ptr<LabelStmt> _addr_n, fmt.State s, int verb) {
    ref LabelStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<LabelStmt> _addr_n) {
    ref LabelStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<LabelStmt> _addr_n, Func<Node, bool> @do) {
    ref LabelStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<LabelStmt> _addr_n, Func<Node, Node> edit) {
    ref LabelStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
}

private static void Format(this ptr<LinksymOffsetExpr> _addr_n, fmt.State s, int verb) {
    ref LinksymOffsetExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<LinksymOffsetExpr> _addr_n) {
    ref LinksymOffsetExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<LinksymOffsetExpr> _addr_n, Func<Node, bool> @do) {
    ref LinksymOffsetExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<LinksymOffsetExpr> _addr_n, Func<Node, Node> edit) {
    ref LinksymOffsetExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
}

private static void Format(this ptr<LogicalExpr> _addr_n, fmt.State s, int verb) {
    ref LogicalExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<LogicalExpr> _addr_n) {
    ref LogicalExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<LogicalExpr> _addr_n, Func<Node, bool> @do) {
    ref LogicalExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    if (n.Y != null && do(n.Y)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<LogicalExpr> _addr_n, Func<Node, Node> edit) {
    ref LogicalExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
    if (n.Y != null) {
        n.Y = edit(n.Y)._<Node>();
    }
}

private static void Format(this ptr<MakeExpr> _addr_n, fmt.State s, int verb) {
    ref MakeExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<MakeExpr> _addr_n) {
    ref MakeExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<MakeExpr> _addr_n, Func<Node, bool> @do) {
    ref MakeExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.Len != null && do(n.Len)) {
        return true;
    }
    if (n.Cap != null && do(n.Cap)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<MakeExpr> _addr_n, Func<Node, Node> edit) {
    ref MakeExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.Len != null) {
        n.Len = edit(n.Len)._<Node>();
    }
    if (n.Cap != null) {
        n.Cap = edit(n.Cap)._<Node>();
    }
}

private static void Format(this ptr<MapType> _addr_n, fmt.State s, int verb) {
    ref MapType n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<MapType> _addr_n) {
    ref MapType n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    return _addr_c;
}
private static bool doChildren(this ptr<MapType> _addr_n, Func<Node, bool> @do) {
    ref MapType n = ref _addr_n.val;

    if (n.Key != null && do(n.Key)) {
        return true;
    }
    if (n.Elem != null && do(n.Elem)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<MapType> _addr_n, Func<Node, Node> edit) {
    ref MapType n = ref _addr_n.val;

    if (n.Key != null) {
        n.Key = edit(n.Key)._<Ntype>();
    }
    if (n.Elem != null) {
        n.Elem = edit(n.Elem)._<Ntype>();
    }
}

private static void Format(this ptr<Name> _addr_n, fmt.State s, int verb) {
    ref Name n = ref _addr_n.val;

    fmtNode(n, s, verb);
}

private static void Format(this ptr<NilExpr> _addr_n, fmt.State s, int verb) {
    ref NilExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<NilExpr> _addr_n) {
    ref NilExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<NilExpr> _addr_n, Func<Node, bool> @do) {
    ref NilExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<NilExpr> _addr_n, Func<Node, Node> edit) {
    ref NilExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
}

private static void Format(this ptr<ParenExpr> _addr_n, fmt.State s, int verb) {
    ref ParenExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<ParenExpr> _addr_n) {
    ref ParenExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<ParenExpr> _addr_n, Func<Node, bool> @do) {
    ref ParenExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<ParenExpr> _addr_n, Func<Node, Node> edit) {
    ref ParenExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
}

private static void Format(this ptr<PkgName> _addr_n, fmt.State s, int verb) {
    ref PkgName n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<PkgName> _addr_n) {
    ref PkgName n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    return _addr_c;
}
private static bool doChildren(this ptr<PkgName> _addr_n, Func<Node, bool> @do) {
    ref PkgName n = ref _addr_n.val;

    return false;
}
private static Node editChildren(this ptr<PkgName> _addr_n, Func<Node, Node> edit) {
    ref PkgName n = ref _addr_n.val;

}

private static void Format(this ptr<RangeStmt> _addr_n, fmt.State s, int verb) {
    ref RangeStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<RangeStmt> _addr_n) {
    ref RangeStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.Body = copyNodes(c.Body);
    return _addr_c;
}
private static bool doChildren(this ptr<RangeStmt> _addr_n, Func<Node, bool> @do) {
    ref RangeStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    if (n.Key != null && do(n.Key)) {
        return true;
    }
    if (n.Value != null && do(n.Value)) {
        return true;
    }
    if (doNodes(n.Body, do)) {
        return true;
    }
    if (n.Prealloc != null && do(n.Prealloc)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<RangeStmt> _addr_n, Func<Node, Node> edit) {
    ref RangeStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
    if (n.Key != null) {
        n.Key = edit(n.Key)._<Node>();
    }
    if (n.Value != null) {
        n.Value = edit(n.Value)._<Node>();
    }
    editNodes(n.Body, edit);
    if (n.Prealloc != null) {
        n.Prealloc = edit(n.Prealloc)._<ptr<Name>>();
    }
}

private static void Format(this ptr<ResultExpr> _addr_n, fmt.State s, int verb) {
    ref ResultExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<ResultExpr> _addr_n) {
    ref ResultExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<ResultExpr> _addr_n, Func<Node, bool> @do) {
    ref ResultExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<ResultExpr> _addr_n, Func<Node, Node> edit) {
    ref ResultExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
}

private static void Format(this ptr<ReturnStmt> _addr_n, fmt.State s, int verb) {
    ref ReturnStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<ReturnStmt> _addr_n) {
    ref ReturnStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.Results = copyNodes(c.Results);
    return _addr_c;
}
private static bool doChildren(this ptr<ReturnStmt> _addr_n, Func<Node, bool> @do) {
    ref ReturnStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (doNodes(n.Results, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<ReturnStmt> _addr_n, Func<Node, Node> edit) {
    ref ReturnStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
    editNodes(n.Results, edit);
}

private static void Format(this ptr<SelectStmt> _addr_n, fmt.State s, int verb) {
    ref SelectStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<SelectStmt> _addr_n) {
    ref SelectStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.Cases = copyCommClauses(c.Cases);
    c.Compiled = copyNodes(c.Compiled);
    return _addr_c;
}
private static bool doChildren(this ptr<SelectStmt> _addr_n, Func<Node, bool> @do) {
    ref SelectStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (doCommClauses(n.Cases, do)) {
        return true;
    }
    if (doNodes(n.Compiled, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<SelectStmt> _addr_n, Func<Node, Node> edit) {
    ref SelectStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
    editCommClauses(n.Cases, edit);
    editNodes(n.Compiled, edit);
}

private static void Format(this ptr<SelectorExpr> _addr_n, fmt.State s, int verb) {
    ref SelectorExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<SelectorExpr> _addr_n) {
    ref SelectorExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<SelectorExpr> _addr_n, Func<Node, bool> @do) {
    ref SelectorExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    if (n.Prealloc != null && do(n.Prealloc)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<SelectorExpr> _addr_n, Func<Node, Node> edit) {
    ref SelectorExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
    if (n.Prealloc != null) {
        n.Prealloc = edit(n.Prealloc)._<ptr<Name>>();
    }
}

private static void Format(this ptr<SendStmt> _addr_n, fmt.State s, int verb) {
    ref SendStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<SendStmt> _addr_n) {
    ref SendStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<SendStmt> _addr_n, Func<Node, bool> @do) {
    ref SendStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.Chan != null && do(n.Chan)) {
        return true;
    }
    if (n.Value != null && do(n.Value)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<SendStmt> _addr_n, Func<Node, Node> edit) {
    ref SendStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.Chan != null) {
        n.Chan = edit(n.Chan)._<Node>();
    }
    if (n.Value != null) {
        n.Value = edit(n.Value)._<Node>();
    }
}

private static void Format(this ptr<SliceExpr> _addr_n, fmt.State s, int verb) {
    ref SliceExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<SliceExpr> _addr_n) {
    ref SliceExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<SliceExpr> _addr_n, Func<Node, bool> @do) {
    ref SliceExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    if (n.Low != null && do(n.Low)) {
        return true;
    }
    if (n.High != null && do(n.High)) {
        return true;
    }
    if (n.Max != null && do(n.Max)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<SliceExpr> _addr_n, Func<Node, Node> edit) {
    ref SliceExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
    if (n.Low != null) {
        n.Low = edit(n.Low)._<Node>();
    }
    if (n.High != null) {
        n.High = edit(n.High)._<Node>();
    }
    if (n.Max != null) {
        n.Max = edit(n.Max)._<Node>();
    }
}

private static void Format(this ptr<SliceHeaderExpr> _addr_n, fmt.State s, int verb) {
    ref SliceHeaderExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<SliceHeaderExpr> _addr_n) {
    ref SliceHeaderExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<SliceHeaderExpr> _addr_n, Func<Node, bool> @do) {
    ref SliceHeaderExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.Ptr != null && do(n.Ptr)) {
        return true;
    }
    if (n.Len != null && do(n.Len)) {
        return true;
    }
    if (n.Cap != null && do(n.Cap)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<SliceHeaderExpr> _addr_n, Func<Node, Node> edit) {
    ref SliceHeaderExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.Ptr != null) {
        n.Ptr = edit(n.Ptr)._<Node>();
    }
    if (n.Len != null) {
        n.Len = edit(n.Len)._<Node>();
    }
    if (n.Cap != null) {
        n.Cap = edit(n.Cap)._<Node>();
    }
}

private static void Format(this ptr<SliceType> _addr_n, fmt.State s, int verb) {
    ref SliceType n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<SliceType> _addr_n) {
    ref SliceType n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    return _addr_c;
}
private static bool doChildren(this ptr<SliceType> _addr_n, Func<Node, bool> @do) {
    ref SliceType n = ref _addr_n.val;

    if (n.Elem != null && do(n.Elem)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<SliceType> _addr_n, Func<Node, Node> edit) {
    ref SliceType n = ref _addr_n.val;

    if (n.Elem != null) {
        n.Elem = edit(n.Elem)._<Ntype>();
    }
}

private static void Format(this ptr<StarExpr> _addr_n, fmt.State s, int verb) {
    ref StarExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<StarExpr> _addr_n) {
    ref StarExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<StarExpr> _addr_n, Func<Node, bool> @do) {
    ref StarExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<StarExpr> _addr_n, Func<Node, Node> edit) {
    ref StarExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
}

private static void Format(this ptr<StructKeyExpr> _addr_n, fmt.State s, int verb) {
    ref StructKeyExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<StructKeyExpr> _addr_n) {
    ref StructKeyExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<StructKeyExpr> _addr_n, Func<Node, bool> @do) {
    ref StructKeyExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.Value != null && do(n.Value)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<StructKeyExpr> _addr_n, Func<Node, Node> edit) {
    ref StructKeyExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.Value != null) {
        n.Value = edit(n.Value)._<Node>();
    }
}

private static void Format(this ptr<StructType> _addr_n, fmt.State s, int verb) {
    ref StructType n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<StructType> _addr_n) {
    ref StructType n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.Fields = copyFields(c.Fields);
    return _addr_c;
}
private static bool doChildren(this ptr<StructType> _addr_n, Func<Node, bool> @do) {
    ref StructType n = ref _addr_n.val;

    if (doFields(n.Fields, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<StructType> _addr_n, Func<Node, Node> edit) {
    ref StructType n = ref _addr_n.val;

    editFields(n.Fields, edit);
}

private static void Format(this ptr<SwitchStmt> _addr_n, fmt.State s, int verb) {
    ref SwitchStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<SwitchStmt> _addr_n) {
    ref SwitchStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    c.Cases = copyCaseClauses(c.Cases);
    c.Compiled = copyNodes(c.Compiled);
    return _addr_c;
}
private static bool doChildren(this ptr<SwitchStmt> _addr_n, Func<Node, bool> @do) {
    ref SwitchStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.Tag != null && do(n.Tag)) {
        return true;
    }
    if (doCaseClauses(n.Cases, do)) {
        return true;
    }
    if (doNodes(n.Compiled, do)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<SwitchStmt> _addr_n, Func<Node, Node> edit) {
    ref SwitchStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.Tag != null) {
        n.Tag = edit(n.Tag)._<Node>();
    }
    editCaseClauses(n.Cases, edit);
    editNodes(n.Compiled, edit);

}

private static void Format(this ptr<TailCallStmt> _addr_n, fmt.State s, int verb) {
    ref TailCallStmt n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<TailCallStmt> _addr_n) {
    ref TailCallStmt n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<TailCallStmt> _addr_n, Func<Node, bool> @do) {
    ref TailCallStmt n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.Target != null && do(n.Target)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<TailCallStmt> _addr_n, Func<Node, Node> edit) {
    ref TailCallStmt n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.Target != null) {
        n.Target = edit(n.Target)._<ptr<Name>>();
    }
}

private static void Format(this ptr<TypeAssertExpr> _addr_n, fmt.State s, int verb) {
    ref TypeAssertExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<TypeAssertExpr> _addr_n) {
    ref TypeAssertExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<TypeAssertExpr> _addr_n, Func<Node, bool> @do) {
    ref TypeAssertExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    if (n.Ntype != null && do(n.Ntype)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<TypeAssertExpr> _addr_n, Func<Node, Node> edit) {
    ref TypeAssertExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
    if (n.Ntype != null) {
        n.Ntype = edit(n.Ntype)._<Ntype>();
    }
}

private static void Format(this ptr<TypeSwitchGuard> _addr_n, fmt.State s, int verb) {
    ref TypeSwitchGuard n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<TypeSwitchGuard> _addr_n) {
    ref TypeSwitchGuard n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    return _addr_c;
}
private static bool doChildren(this ptr<TypeSwitchGuard> _addr_n, Func<Node, bool> @do) {
    ref TypeSwitchGuard n = ref _addr_n.val;

    if (n.Tag != null && do(n.Tag)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<TypeSwitchGuard> _addr_n, Func<Node, Node> edit) {
    ref TypeSwitchGuard n = ref _addr_n.val;

    if (n.Tag != null) {
        n.Tag = edit(n.Tag)._<ptr<Ident>>();
    }
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
}

private static void Format(this ptr<UnaryExpr> _addr_n, fmt.State s, int verb) {
    ref UnaryExpr n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<UnaryExpr> _addr_n) {
    ref UnaryExpr n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    c.init = copyNodes(c.init);
    return _addr_c;
}
private static bool doChildren(this ptr<UnaryExpr> _addr_n, Func<Node, bool> @do) {
    ref UnaryExpr n = ref _addr_n.val;

    if (doNodes(n.init, do)) {
        return true;
    }
    if (n.X != null && do(n.X)) {
        return true;
    }
    return false;

}
private static Node editChildren(this ptr<UnaryExpr> _addr_n, Func<Node, Node> edit) {
    ref UnaryExpr n = ref _addr_n.val;

    editNodes(n.init, edit);
    if (n.X != null) {
        n.X = edit(n.X)._<Node>();
    }
}

private static void Format(this ptr<typeNode> _addr_n, fmt.State s, int verb) {
    ref typeNode n = ref _addr_n.val;

    fmtNode(n, s, verb);
}
private static Node copy(this ptr<typeNode> _addr_n) {
    ref typeNode n = ref _addr_n.val;

    ref var c = ref heap(n.val, out ptr<var> _addr_c);
    return _addr_c;
}
private static bool doChildren(this ptr<typeNode> _addr_n, Func<Node, bool> @do) {
    ref typeNode n = ref _addr_n.val;

    return false;
}
private static Node editChildren(this ptr<typeNode> _addr_n, Func<Node, Node> edit) {
    ref typeNode n = ref _addr_n.val;

}

private static slice<ptr<CaseClause>> copyCaseClauses(slice<ptr<CaseClause>> list) {
    if (list == null) {
        return null;
    }
    var c = make_slice<ptr<CaseClause>>(len(list));
    copy(c, list);
    return c;

}
private static bool doCaseClauses(slice<ptr<CaseClause>> list, Func<Node, bool> @do) {
    foreach (var (_, x) in list) {
        if (x != null && do(x)) {
            return true;
        }
    }    return false;

}
private static Node editCaseClauses(slice<ptr<CaseClause>> list, Func<Node, Node> edit) {
    foreach (var (i, x) in list) {
        if (x != null) {
            list[i] = edit(x)._<ptr<CaseClause>>();
        }
    }
}

private static slice<ptr<CommClause>> copyCommClauses(slice<ptr<CommClause>> list) {
    if (list == null) {
        return null;
    }
    var c = make_slice<ptr<CommClause>>(len(list));
    copy(c, list);
    return c;

}
private static bool doCommClauses(slice<ptr<CommClause>> list, Func<Node, bool> @do) {
    foreach (var (_, x) in list) {
        if (x != null && do(x)) {
            return true;
        }
    }    return false;

}
private static Node editCommClauses(slice<ptr<CommClause>> list, Func<Node, Node> edit) {
    foreach (var (i, x) in list) {
        if (x != null) {
            list[i] = edit(x)._<ptr<CommClause>>();
        }
    }
}

private static slice<ptr<Name>> copyNames(slice<ptr<Name>> list) {
    if (list == null) {
        return null;
    }
    var c = make_slice<ptr<Name>>(len(list));
    copy(c, list);
    return c;

}
private static bool doNames(slice<ptr<Name>> list, Func<Node, bool> @do) {
    foreach (var (_, x) in list) {
        if (x != null && do(x)) {
            return true;
        }
    }    return false;

}
private static Node editNames(slice<ptr<Name>> list, Func<Node, Node> edit) {
    foreach (var (i, x) in list) {
        if (x != null) {
            list[i] = edit(x)._<ptr<Name>>();
        }
    }
}

private static slice<Node> copyNodes(slice<Node> list) {
    if (list == null) {
        return null;
    }
    var c = make_slice<Node>(len(list));
    copy(c, list);
    return c;

}
private static bool doNodes(slice<Node> list, Func<Node, bool> @do) {
    foreach (var (_, x) in list) {
        if (x != null && do(x)) {
            return true;
        }
    }    return false;

}
private static Node editNodes(slice<Node> list, Func<Node, Node> edit) {
    foreach (var (i, x) in list) {
        if (x != null) {
            list[i] = edit(x)._<Node>();
        }
    }
}

} // end ir_package
