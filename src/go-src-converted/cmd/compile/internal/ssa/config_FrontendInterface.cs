//---------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes to this
//     file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generated on 2022 March 13 06:00:50 UTC
// </auto-generated>
//---------------------------------------------------------
using System;
using System.CodeDom.Compiler;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using abi = go.cmd.compile.@internal.abi_package;
using ir = go.cmd.compile.@internal.ir_package;
using types = go.cmd.compile.@internal.types_package;
using obj = go.cmd.@internal.obj_package;
using src = go.cmd.@internal.src_package;
using buildcfg = go.@internal.buildcfg_package;
using go;

#nullable enable
#pragma warning disable CS0660, CS0661

namespace go {
namespace cmd {
namespace compile {
namespace @internal
{
    public static partial class ssa_package
    {
        [GeneratedCode("go2cs", "0.1.2.0")]
        public partial interface Frontend
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static Frontend As<T>(in T target) => (Frontend<T>)target!;

            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static Frontend As<T>(ptr<T> target_ptr) => (Frontend<T>)target_ptr;

            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static Frontend? As(object target) =>
                typeof(Frontend<>).CreateInterfaceHandler<Frontend>(target);
        }

        [GeneratedCode("go2cs", "0.1.2.0")]
        public class Frontend<T> : Frontend
        {
            private T m_target = default!;
            private readonly ptr<T>? m_target_ptr;
            private readonly bool m_target_is_ptr;

            public ref T Target
            {
                get
                {
                    if (m_target_is_ptr && m_target_ptr is not null)
                        return ref m_target_ptr.val;

                    return ref m_target;
                }
            }

            public Frontend(in T target) => m_target = target;

            public Frontend(ptr<T> target_ptr)
            {
                m_target_ptr = target_ptr;
                m_target_is_ptr = true;
            }

            private delegate @string CanSSAByPtr(ptr<T> value, ptr<types.Type> t);
            private delegate @string CanSSAByVal(T value, ptr<types.Type> t);

            private static readonly CanSSAByPtr? s_CanSSAByPtr;
            private static readonly CanSSAByVal? s_CanSSAByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public @string CanSSA(ptr<types.Type> t)
            {
                T target = m_target;

                if (m_target_is_ptr && m_target_ptr is not null)
                    target = m_target_ptr.val;

                if (s_CanSSAByPtr is null || !m_target_is_ptr)
                    return s_CanSSAByVal!(target, t);

                return s_CanSSAByPtr(m_target_ptr!, t);
            }

            private delegate @string StringDataByPtr(ptr<T> value, @string _p0);
            private delegate @string StringDataByVal(T value, @string _p0);

            private static readonly StringDataByPtr? s_StringDataByPtr;
            private static readonly StringDataByVal? s_StringDataByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public @string StringData(@string _p0)
            {
                T target = m_target;

                if (m_target_is_ptr && m_target_ptr is not null)
                    target = m_target_ptr.val;

                if (s_StringDataByPtr is null || !m_target_is_ptr)
                    return s_StringDataByVal!(target, _p0);

                return s_StringDataByPtr(m_target_ptr!, _p0);
            }

            private delegate @string AutoByPtr(ptr<T> value, src.XPos _p0, ptr<types.Type> _p0);
            private delegate @string AutoByVal(T value, src.XPos _p0, ptr<types.Type> _p0);

            private static readonly AutoByPtr? s_AutoByPtr;
            private static readonly AutoByVal? s_AutoByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public @string Auto(src.XPos _p0, ptr<types.Type> _p0)
            {
                T target = m_target;

                if (m_target_is_ptr && m_target_ptr is not null)
                    target = m_target_ptr.val;

                if (s_AutoByPtr is null || !m_target_is_ptr)
                    return s_AutoByVal!(target, _p0, _p0);

                return s_AutoByPtr(m_target_ptr!, _p0, _p0);
            }

            private delegate @string SplitSlotByPtr(ptr<T> value, ptr<LocalSlot> parent, @string suffix, long offset, ptr<types.Type> t);
            private delegate @string SplitSlotByVal(T value, ptr<LocalSlot> parent, @string suffix, long offset, ptr<types.Type> t);

            private static readonly SplitSlotByPtr? s_SplitSlotByPtr;
            private static readonly SplitSlotByVal? s_SplitSlotByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public @string SplitSlot(ptr<LocalSlot> parent, @string suffix, long offset, ptr<types.Type> t)
            {
                T target = m_target;

                if (m_target_is_ptr && m_target_ptr is not null)
                    target = m_target_ptr.val;

                if (s_SplitSlotByPtr is null || !m_target_is_ptr)
                    return s_SplitSlotByVal!(target, parent, suffix, offset, t);

                return s_SplitSlotByPtr(m_target_ptr!, parent, suffix, offset, t);
            }

            private delegate @string DerefItabByPtr(ptr<T> value, ptr<obj.LSym> sym, long offset);
            private delegate @string DerefItabByVal(T value, ptr<obj.LSym> sym, long offset);

            private static readonly DerefItabByPtr? s_DerefItabByPtr;
            private static readonly DerefItabByVal? s_DerefItabByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public @string DerefItab(ptr<obj.LSym> sym, long offset)
            {
                T target = m_target;

                if (m_target_is_ptr && m_target_ptr is not null)
                    target = m_target_ptr.val;

                if (s_DerefItabByPtr is null || !m_target_is_ptr)
                    return s_DerefItabByVal!(target, sym, offset);

                return s_DerefItabByPtr(m_target_ptr!, sym, offset);
            }

            private delegate @string LineByPtr(ptr<T> value, src.XPos _p0);
            private delegate @string LineByVal(T value, src.XPos _p0);

            private static readonly LineByPtr? s_LineByPtr;
            private static readonly LineByVal? s_LineByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public @string Line(src.XPos _p0)
            {
                T target = m_target;

                if (m_target_is_ptr && m_target_ptr is not null)
                    target = m_target_ptr.val;

                if (s_LineByPtr is null || !m_target_is_ptr)
                    return s_LineByVal!(target, _p0);

                return s_LineByPtr(m_target_ptr!, _p0);
            }

            private delegate @string AllocFrameByPtr(ptr<T> value, ptr<Func> f);
            private delegate @string AllocFrameByVal(T value, ptr<Func> f);

            private static readonly AllocFrameByPtr? s_AllocFrameByPtr;
            private static readonly AllocFrameByVal? s_AllocFrameByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public @string AllocFrame(ptr<Func> f)
            {
                T target = m_target;

                if (m_target_is_ptr && m_target_ptr is not null)
                    target = m_target_ptr.val;

                if (s_AllocFrameByPtr is null || !m_target_is_ptr)
                    return s_AllocFrameByVal!(target, f);

                return s_AllocFrameByPtr(m_target_ptr!, f);
            }

            private delegate @string SyslookByPtr(ptr<T> value, @string _p0);
            private delegate @string SyslookByVal(T value, @string _p0);

            private static readonly SyslookByPtr? s_SyslookByPtr;
            private static readonly SyslookByVal? s_SyslookByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public @string Syslook(@string _p0)
            {
                T target = m_target;

                if (m_target_is_ptr && m_target_ptr is not null)
                    target = m_target_ptr.val;

                if (s_SyslookByPtr is null || !m_target_is_ptr)
                    return s_SyslookByVal!(target, _p0);

                return s_SyslookByPtr(m_target_ptr!, _p0);
            }

            private delegate @string UseWriteBarrierByPtr(ptr<T> value);
            private delegate @string UseWriteBarrierByVal(T value);

            private static readonly UseWriteBarrierByPtr? s_UseWriteBarrierByPtr;
            private static readonly UseWriteBarrierByVal? s_UseWriteBarrierByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public @string UseWriteBarrier()
            {
                T target = m_target;

                if (m_target_is_ptr && m_target_ptr is not null)
                    target = m_target_ptr.val;

                if (s_UseWriteBarrierByPtr is null || !m_target_is_ptr)
                    return s_UseWriteBarrierByVal!(target);

                return s_UseWriteBarrierByPtr(m_target_ptr!);
            }

            private delegate @string SetWBPosByPtr(ptr<T> value, src.XPos pos);
            private delegate @string SetWBPosByVal(T value, src.XPos pos);

            private static readonly SetWBPosByPtr? s_SetWBPosByPtr;
            private static readonly SetWBPosByVal? s_SetWBPosByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public @string SetWBPos(src.XPos pos)
            {
                T target = m_target;

                if (m_target_is_ptr && m_target_ptr is not null)
                    target = m_target_ptr.val;

                if (s_SetWBPosByPtr is null || !m_target_is_ptr)
                    return s_SetWBPosByVal!(target, pos);

                return s_SetWBPosByPtr(m_target_ptr!, pos);
            }

            private delegate @string MyImportPathByPtr(ptr<T> value);
            private delegate @string MyImportPathByVal(T value);

            private static readonly MyImportPathByPtr? s_MyImportPathByPtr;
            private static readonly MyImportPathByVal? s_MyImportPathByVal;

            [DebuggerNonUserCode, MethodImpl(MethodImplOptions.AggressiveInlining)]
            public @string MyImportPath()
            {
                T target = m_target;

                if (m_target_is_ptr && m_target_ptr is not null)
                    target = m_target_ptr.val;

                if (s_MyImportPathByPtr is null || !m_target_is_ptr)
                    return s_MyImportPathByVal!(target);

                return s_MyImportPathByPtr(m_target_ptr!);
            }
            
            public string ToString(string? format, IFormatProvider? formatProvider) => format ?? GetGoTypeName(typeof(T));

            [DebuggerStepperBoundary]
            static Frontend()
            {
                Type targetType = typeof(T);
                Type targetTypeByPtr = typeof(ptr<T>);
                MethodInfo extensionMethod;

               extensionMethod = targetTypeByPtr.GetExtensionMethod("CanSSA");

                if (extensionMethod is not null)
                    s_CanSSAByPtr = extensionMethod.CreateStaticDelegate(typeof(CanSSAByPtr)) as CanSSAByPtr;

                extensionMethod = targetType.GetExtensionMethod("CanSSA");

                if (extensionMethod is not null)
                    s_CanSSAByVal = extensionMethod.CreateStaticDelegate(typeof(CanSSAByVal)) as CanSSAByVal;

                if (s_CanSSAByPtr is null && s_CanSSAByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Frontend.CanSSA method", new Exception("CanSSA"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("StringData");

                if (extensionMethod is not null)
                    s_StringDataByPtr = extensionMethod.CreateStaticDelegate(typeof(StringDataByPtr)) as StringDataByPtr;

                extensionMethod = targetType.GetExtensionMethod("StringData");

                if (extensionMethod is not null)
                    s_StringDataByVal = extensionMethod.CreateStaticDelegate(typeof(StringDataByVal)) as StringDataByVal;

                if (s_StringDataByPtr is null && s_StringDataByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Frontend.StringData method", new Exception("StringData"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("Auto");

                if (extensionMethod is not null)
                    s_AutoByPtr = extensionMethod.CreateStaticDelegate(typeof(AutoByPtr)) as AutoByPtr;

                extensionMethod = targetType.GetExtensionMethod("Auto");

                if (extensionMethod is not null)
                    s_AutoByVal = extensionMethod.CreateStaticDelegate(typeof(AutoByVal)) as AutoByVal;

                if (s_AutoByPtr is null && s_AutoByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Frontend.Auto method", new Exception("Auto"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("SplitSlot");

                if (extensionMethod is not null)
                    s_SplitSlotByPtr = extensionMethod.CreateStaticDelegate(typeof(SplitSlotByPtr)) as SplitSlotByPtr;

                extensionMethod = targetType.GetExtensionMethod("SplitSlot");

                if (extensionMethod is not null)
                    s_SplitSlotByVal = extensionMethod.CreateStaticDelegate(typeof(SplitSlotByVal)) as SplitSlotByVal;

                if (s_SplitSlotByPtr is null && s_SplitSlotByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Frontend.SplitSlot method", new Exception("SplitSlot"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("DerefItab");

                if (extensionMethod is not null)
                    s_DerefItabByPtr = extensionMethod.CreateStaticDelegate(typeof(DerefItabByPtr)) as DerefItabByPtr;

                extensionMethod = targetType.GetExtensionMethod("DerefItab");

                if (extensionMethod is not null)
                    s_DerefItabByVal = extensionMethod.CreateStaticDelegate(typeof(DerefItabByVal)) as DerefItabByVal;

                if (s_DerefItabByPtr is null && s_DerefItabByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Frontend.DerefItab method", new Exception("DerefItab"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("Line");

                if (extensionMethod is not null)
                    s_LineByPtr = extensionMethod.CreateStaticDelegate(typeof(LineByPtr)) as LineByPtr;

                extensionMethod = targetType.GetExtensionMethod("Line");

                if (extensionMethod is not null)
                    s_LineByVal = extensionMethod.CreateStaticDelegate(typeof(LineByVal)) as LineByVal;

                if (s_LineByPtr is null && s_LineByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Frontend.Line method", new Exception("Line"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("AllocFrame");

                if (extensionMethod is not null)
                    s_AllocFrameByPtr = extensionMethod.CreateStaticDelegate(typeof(AllocFrameByPtr)) as AllocFrameByPtr;

                extensionMethod = targetType.GetExtensionMethod("AllocFrame");

                if (extensionMethod is not null)
                    s_AllocFrameByVal = extensionMethod.CreateStaticDelegate(typeof(AllocFrameByVal)) as AllocFrameByVal;

                if (s_AllocFrameByPtr is null && s_AllocFrameByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Frontend.AllocFrame method", new Exception("AllocFrame"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("Syslook");

                if (extensionMethod is not null)
                    s_SyslookByPtr = extensionMethod.CreateStaticDelegate(typeof(SyslookByPtr)) as SyslookByPtr;

                extensionMethod = targetType.GetExtensionMethod("Syslook");

                if (extensionMethod is not null)
                    s_SyslookByVal = extensionMethod.CreateStaticDelegate(typeof(SyslookByVal)) as SyslookByVal;

                if (s_SyslookByPtr is null && s_SyslookByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Frontend.Syslook method", new Exception("Syslook"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("UseWriteBarrier");

                if (extensionMethod is not null)
                    s_UseWriteBarrierByPtr = extensionMethod.CreateStaticDelegate(typeof(UseWriteBarrierByPtr)) as UseWriteBarrierByPtr;

                extensionMethod = targetType.GetExtensionMethod("UseWriteBarrier");

                if (extensionMethod is not null)
                    s_UseWriteBarrierByVal = extensionMethod.CreateStaticDelegate(typeof(UseWriteBarrierByVal)) as UseWriteBarrierByVal;

                if (s_UseWriteBarrierByPtr is null && s_UseWriteBarrierByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Frontend.UseWriteBarrier method", new Exception("UseWriteBarrier"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("SetWBPos");

                if (extensionMethod is not null)
                    s_SetWBPosByPtr = extensionMethod.CreateStaticDelegate(typeof(SetWBPosByPtr)) as SetWBPosByPtr;

                extensionMethod = targetType.GetExtensionMethod("SetWBPos");

                if (extensionMethod is not null)
                    s_SetWBPosByVal = extensionMethod.CreateStaticDelegate(typeof(SetWBPosByVal)) as SetWBPosByVal;

                if (s_SetWBPosByPtr is null && s_SetWBPosByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Frontend.SetWBPos method", new Exception("SetWBPos"));

               extensionMethod = targetTypeByPtr.GetExtensionMethod("MyImportPath");

                if (extensionMethod is not null)
                    s_MyImportPathByPtr = extensionMethod.CreateStaticDelegate(typeof(MyImportPathByPtr)) as MyImportPathByPtr;

                extensionMethod = targetType.GetExtensionMethod("MyImportPath");

                if (extensionMethod is not null)
                    s_MyImportPathByVal = extensionMethod.CreateStaticDelegate(typeof(MyImportPathByVal)) as MyImportPathByVal;

                if (s_MyImportPathByPtr is null && s_MyImportPathByVal is null)
                    throw new NotImplementedException($"{targetType.FullName} does not implement Frontend.MyImportPath method", new Exception("MyImportPath"));
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static explicit operator Frontend<T>(in ptr<T> target_ptr) => new Frontend<T>(target_ptr);

            [MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
            public static explicit operator Frontend<T>(in T target) => new Frontend<T>(target);

            // Enable comparisons between nil and Frontend<T> interface instance
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator ==(Frontend<T> value, NilType nil) => Activator.CreateInstance<Frontend<T>>().Equals(value);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator !=(Frontend<T> value, NilType nil) => !(value == nil);

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator ==(NilType nil, Frontend<T> value) => value == nil;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator !=(NilType nil, Frontend<T> value) => value != nil;
        }
    }
}}}}

namespace go
{
    public static class ssa_FrontendExtensions
    {
        private static readonly ConcurrentDictionary<Type, MethodInfo> s_conversionOperators = new ConcurrentDictionary<Type, MethodInfo>();

        [GeneratedCode("go2cs", "0.1.2.0"), MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
        public static T _<T>(this go.cmd.compile.@internal.ssa_package.Frontend target)
        {
            try
            {
                return ((go.cmd.compile.@internal.ssa_package.Frontend<T>)target).Target;
            }
            catch (NotImplementedException ex)
            {
                throw new PanicException($"interface conversion: {GetGoTypeName(target.GetType())} is not {GetGoTypeName(typeof(T))}: missing method {ex.InnerException?.Message}");
            }
        }

        [GeneratedCode("go2cs", "0.1.2.0"), MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
        public static bool _<T>(this go.cmd.compile.@internal.ssa_package.Frontend target, out T result)
        {
            try
            {
                result = target._<T>();
                return true;
            }
            catch (PanicException)
            {
                result = default!;
                return false;
            }
        }

        [GeneratedCode("go2cs", "0.1.2.0"), MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
        public static object? _(this go.cmd.compile.@internal.ssa_package.Frontend target, Type type)
        {
            try
            {
                MethodInfo? conversionOperator = s_conversionOperators.GetOrAdd(type, _ => typeof(go.cmd.compile.@internal.ssa_package.Frontend<>).GetExplicitGenericConversionOperator(type));

                if (conversionOperator is null)
                    throw new PanicException($"interface conversion: failed to create converter for {GetGoTypeName(target.GetType())} to {GetGoTypeName(type)}");

                dynamic? result = conversionOperator.Invoke(null, new object[] { target });
                return result?.Target;
            }
            catch (NotImplementedException ex)
            {
                throw new PanicException($"interface conversion: {GetGoTypeName(target.GetType())} is not {GetGoTypeName(type)}: missing method {ex.InnerException?.Message}");
            }
        }

        [GeneratedCode("go2cs", "0.1.2.0"), MethodImpl(MethodImplOptions.AggressiveInlining), DebuggerNonUserCode]
        public static bool _(this go.cmd.compile.@internal.ssa_package.Frontend target, Type type, out object? result)
        {
            try
            {
                result = target._(type);
                return true;
            }
            catch (PanicException)
            {
                result = type.IsValueType ? Activator.CreateInstance(type) : null;
                return false;
            }
        }
    }
}