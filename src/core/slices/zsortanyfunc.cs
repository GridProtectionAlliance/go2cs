// Code generated by gen_sort_variants.go; DO NOT EDIT.
// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go;

partial class slices_package {

// insertionSortCmpFunc sorts data[a:b] using insertion sort.
internal static void insertionSortCmpFunc<E>(slice<E> data, nint a, nint b, Func<E, E, nint> cmp)
    where E : new()
{
    for (nint i = a + 1; i < b; i++) {
        for (nint j = i; j > a && (cmp(data[j], data[j - 1]) < 0); j--) {
            (data[j], data[j - 1]) = (data[j - 1], data[j]);
        }
    }
}

// siftDownCmpFunc implements the heap property on data[lo:hi].
// first is an offset into the array where the root of the heap lies.
internal static void siftDownCmpFunc<E>(slice<E> data, nint lo, nint hi, nint first, Func<E, E, nint> cmp)
    where E : new()
{
    nint root = lo;
    while (ᐧ) {
        nint child = 2 * root + 1;
        if (child >= hi) {
            break;
        }
        if (child + 1 < hi && (cmp(data[first + child], data[first + child + 1]) < 0)) {
            child++;
        }
        if (!(cmp(data[first + root], data[first + child]) < 0)) {
            return;
        }
        (data[first + root], data[first + child]) = (data[first + child], data[first + root]);
        root = child;
    }
}

internal static void heapSortCmpFunc<E>(slice<E> data, nint a, nint b, Func<E, E, nint> cmp)
    where E : new()
{
    nint first = a;
    nint lo = 0;
    nint hi = b - a;
    // Build heap with greatest element at top.
    for (nint i = (hi - 1) / 2; i >= 0; i--) {
        siftDownCmpFunc(data, i, hi, first, cmp);
    }
    // Pop elements, largest first, into end of data.
    for (nint i = hi - 1; i >= 0; i--) {
        (data[first], data[first + i]) = (data[first + i], data[first]);
        siftDownCmpFunc(data, lo, i, first, cmp);
    }
}

// pdqsortCmpFunc sorts data[a:b].
// The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
// pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
// C++ implementation: https://github.com/orlp/pdqsort
// Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
// limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.
internal static void pdqsortCmpFunc<E>(slice<E> data, nint a, nint b, nint limit, Func<E, E, nint> cmp)
    where E : new()
{
    static readonly UntypedInt maxInsertion = 12;
    bool wasBalanced = true;   // whether the last partitioning was reasonably balanced
    bool wasPartitioned = true; // whether the slice was already partitioned
    while (ᐧ) {
        nint length = b - a;
        if (length <= maxInsertion) {
            insertionSortCmpFunc(data, a, b, cmp);
            return;
        }
        // Fall back to heapsort if too many bad choices were made.
        if (limit == 0) {
            heapSortCmpFunc(data, a, b, cmp);
            return;
        }
        // If the last partitioning was imbalanced, we need to breaking patterns.
        if (!wasBalanced) {
            breakPatternsCmpFunc(data, a, b, cmp);
            limit--;
        }
        var (pivot, hint) = choosePivotCmpFunc(data, a, b, cmp);
        if (hint == decreasingHint) {
            reverseRangeCmpFunc(data, a, b, cmp);
            // The chosen pivot was pivot-a elements after the start of the array.
            // After reversing it is pivot-a elements before the end of the array.
            // The idea came from Rust's implementation.
            pivot = (b - 1) - (pivot - a);
            hint = increasingHint;
        }
        // The slice is likely already sorted.
        if (wasBalanced && wasPartitioned && hint == increasingHint) {
            if (partialInsertionSortCmpFunc(data, a, b, cmp)) {
                return;
            }
        }
        // Probably the slice contains many duplicate elements, partition the slice into
        // elements equal to and elements greater than the pivot.
        if (a > 0 && !(cmp(data[a - 1], data[pivot]) < 0)) {
            nint mid = partitionEqualCmpFunc(data, a, b, pivot, cmp);
            a = mid;
            continue;
        }
        var (mid, alreadyPartitioned) = partitionCmpFunc(data, a, b, pivot, cmp);
        wasPartitioned = alreadyPartitioned;
        nint leftLen = mid - a;
        nint rightLen = b - mid;
        nint balanceThreshold = length / 8;
        if (leftLen < rightLen){
            wasBalanced = leftLen >= balanceThreshold;
            pdqsortCmpFunc(data, a, mid, limit, cmp);
            a = mid + 1;
        } else {
            wasBalanced = rightLen >= balanceThreshold;
            pdqsortCmpFunc(data, mid + 1, b, limit, cmp);
            b = mid;
        }
    }
}

// partitionCmpFunc does one quicksort partition.
// Let p = data[pivot]
// Moves elements in data[a:b] around, so that data[i]<p and data[j]>=p for i<newpivot and j>newpivot.
// On return, data[newpivot] = p
internal static (nint newpivot, bool alreadyPartitioned) partitionCmpFunc<E>(slice<E> data, nint a, nint b, nint pivot, Func<E, E, nint> cmp)
    where E : new()
{
    nint newpivot = default!;
    bool alreadyPartitioned = default!;

    (data[a], data[pivot]) = (data[pivot], data[a]);
    nint i = a + 1;
    nint j = b - 1;
    // i and j are inclusive of the elements remaining to be partitioned
    while (i <= j && (cmp(data[i], data[a]) < 0)) {
        i++;
    }
    while (i <= j && !(cmp(data[j], data[a]) < 0)) {
        j--;
    }
    if (i > j) {
        (data[j], data[a]) = (data[a], data[j]);
        return (j, true);
    }
    (data[i], data[j]) = (data[j], data[i]);
    i++;
    j--;
    while (ᐧ) {
        while (i <= j && (cmp(data[i], data[a]) < 0)) {
            i++;
        }
        while (i <= j && !(cmp(data[j], data[a]) < 0)) {
            j--;
        }
        if (i > j) {
            break;
        }
        (data[i], data[j]) = (data[j], data[i]);
        i++;
        j--;
    }
    (data[j], data[a]) = (data[a], data[j]);
    return (j, false);
}

// partitionEqualCmpFunc partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].
// It assumed that data[a:b] does not contain elements smaller than the data[pivot].
internal static nint /*newpivot*/ partitionEqualCmpFunc<E>(slice<E> data, nint a, nint b, nint pivot, Func<E, E, nint> cmp)
    where E : new()
{
    nint newpivot = default!;

    (data[a], data[pivot]) = (data[pivot], data[a]);
    nint i = a + 1;
    nint j = b - 1;
    // i and j are inclusive of the elements remaining to be partitioned
    while (ᐧ) {
        while (i <= j && !(cmp(data[a], data[i]) < 0)) {
            i++;
        }
        while (i <= j && (cmp(data[a], data[j]) < 0)) {
            j--;
        }
        if (i > j) {
            break;
        }
        (data[i], data[j]) = (data[j], data[i]);
        i++;
        j--;
    }
    return i;
}

// partialInsertionSortCmpFunc partially sorts a slice, returns true if the slice is sorted at the end.
internal static bool partialInsertionSortCmpFunc<E>(slice<E> data, nint a, nint b, Func<E, E, nint> cmp)
    where E : new()
{
    static readonly UntypedInt maxSteps = 5; // maximum number of adjacent out-of-order pairs that will get shifted
    static readonly UntypedInt shortestShifting = 50; // don't shift any elements on short arrays
    nint i = a + 1;
    for (nint j = 0; j < maxSteps; j++) {
        while (i < b && !(cmp(data[i], data[i - 1]) < 0)) {
            i++;
        }
        if (i == b) {
            return true;
        }
        if (b - a < shortestShifting) {
            return false;
        }
        (data[i], data[i - 1]) = (data[i - 1], data[i]);
        // Shift the smaller one to the left.
        if (i - a >= 2) {
            for (nint jΔ1 = i - 1; jΔ1 >= 1; jΔ1--) {
                if (!(cmp(data[jΔ1], data[jΔ1 - 1]) < 0)) {
                    break;
                }
                (data[j], data[j - 1]) = (data[jΔ1 - 1], data[jΔ1]);
            }
        }
        // Shift the greater one to the right.
        if (b - i >= 2) {
            for (nint jΔ2 = i + 1; jΔ2 < b; jΔ2++) {
                if (!(cmp(data[jΔ2], data[jΔ2 - 1]) < 0)) {
                    break;
                }
                (data[j], data[j - 1]) = (data[jΔ2 - 1], data[jΔ2]);
            }
        }
    }
    return false;
}

// breakPatternsCmpFunc scatters some elements around in an attempt to break some patterns
// that might cause imbalanced partitions in quicksort.
internal static void breakPatternsCmpFunc<E>(slice<E> data, nint a, nint b, Func<E, E, nint> cmp)
    where E : new()
{
    nint length = b - a;
    if (length >= 8) {
        var random = ((xorshift)length);
        nuint modulus = nextPowerOfTwo(length);
        for (nint idx = a + (length / 4) * 2 - 1; idx <= a + (length / 4) * 2 + 1; idx++) {
            nint other = ((nint)((nuint)(((nuint)random.Next()) & (modulus - 1))));
            if (other >= length) {
                other -= length;
            }
            (data[idx], data[a + other]) = (data[a + other], data[idx]);
        }
    }
}

// choosePivotCmpFunc chooses a pivot in data[a:b].
//
// [0,8): chooses a static pivot.
// [8,shortestNinther): uses the simple median-of-three method.
// [shortestNinther,∞): uses the Tukey ninther method.
internal static (nint pivot, sortedHint hint) choosePivotCmpFunc<E>(slice<E> data, nint a, nint b, Func<E, E, nint> cmp)
    where E : new()
{
    nint pivot = default!;
    sortedHint hint = default!;

    static readonly UntypedInt shortestNinther = 50;
    static readonly UntypedInt maxSwaps = /* 4 * 3 */ 12;
    nint l = b - a;
    ref var swaps = ref heap(new nint(), out var Ꮡswaps);
    nint i = a + l / 4 * 1;
    nint j = a + l / 4 * 2;
    nint k = a + l / 4 * 3;
    if (l >= 8) {
        if (l >= shortestNinther) {
            // Tukey ninther method, the idea came from Rust's implementation.
            i = medianAdjacentCmpFunc(data, i, Ꮡswaps, cmp);
            j = medianAdjacentCmpFunc(data, j, Ꮡswaps, cmp);
            k = medianAdjacentCmpFunc(data, k, Ꮡswaps, cmp);
        }
        // Find the median among i, j, k and stores it into j.
        j = medianCmpFunc(data, i, j, k, Ꮡswaps, cmp);
    }
    var exprᴛ1 = swaps;
    if (exprᴛ1 is 0) {
        return (j, increasingHint);
    }
    if (exprᴛ1 == maxSwaps) {
        return (j, decreasingHint);
    }
    { /* default: */
        return (j, unknownHint);
    }

}

// order2CmpFunc returns x,y where data[x] <= data[y], where x,y=a,b or x,y=b,a.
internal static (nint, nint) order2CmpFunc<E>(slice<E> data, nint a, nint b, ж<nint> Ꮡswaps, Func<E, E, nint> cmp)
    where E : new()
{
    ref var swaps = ref Ꮡswaps.val;

    if (cmp(data[b], data[a]) < 0) {
        swaps++;
        return (b, a);
    }
    return (a, b);
}

// medianCmpFunc returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.
internal static nint medianCmpFunc<E>(slice<E> data, nint a, nint b, nint c, ж<nint> Ꮡswaps, Func<E, E, nint> cmp)
    where E : new()
{
    ref var swaps = ref Ꮡswaps.val;

    (a, b) = order2CmpFunc(data, a, b, Ꮡswaps, cmp);
    (b, c) = order2CmpFunc(data, b, c, Ꮡswaps, cmp);
    (a, b) = order2CmpFunc(data, a, b, Ꮡswaps, cmp);
    return b;
}

// medianAdjacentCmpFunc finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.
internal static nint medianAdjacentCmpFunc<E>(slice<E> data, nint a, ж<nint> Ꮡswaps, Func<E, E, nint> cmp)
    where E : new()
{
    ref var swaps = ref Ꮡswaps.val;

    return medianCmpFunc(data, a - 1, a, a + 1, Ꮡswaps, cmp);
}

internal static void reverseRangeCmpFunc<E>(slice<E> data, nint a, nint b, Func<E, E, nint> cmp)
    where E : new()
{
    nint i = a;
    nint j = b - 1;
    while (i < j) {
        (data[i], data[j]) = (data[j], data[i]);
        i++;
        j--;
    }
}

internal static void swapRangeCmpFunc<E>(slice<E> data, nint a, nint b, nint n, Func<E, E, nint> cmp)
    where E : new()
{
    for (nint i = 0; i < n; i++) {
        (data[a + i], data[b + i]) = (data[b + i], data[a + i]);
    }
}

internal static void stableCmpFunc<E>(slice<E> data, nint n, Func<E, E, nint> cmp)
    where E : new()
{
    nint blockSize = 20;
    // must be > 0
    nint a = 0;
    nint b = blockSize;
    while (b <= n) {
        insertionSortCmpFunc(data, a, b, cmp);
        a = b;
        b += blockSize;
    }
    insertionSortCmpFunc(data, a, n, cmp);
    while (blockSize < n) {
        (a, b) = (0, 2 * blockSize);
        while (b <= n) {
            symMergeCmpFunc(data, a, a + blockSize, b, cmp);
            a = b;
            b += 2 * blockSize;
        }
        {
            nint m = a + blockSize; if (m < n) {
                symMergeCmpFunc(data, a, m, n, cmp);
            }
        }
        blockSize *= 2;
    }
}

// symMergeCmpFunc merges the two sorted subsequences data[a:m] and data[m:b] using
// the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
// Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
// Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
// Computer Science, pages 714-723. Springer, 2004.
//
// Let M = m-a and N = b-n. Wolog M < N.
// The recursion depth is bound by ceil(log(N+M)).
// The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
// The algorithm needs O((M+N)*log(M)) calls to data.Swap.
//
// The paper gives O((M+N)*log(M)) as the number of assignments assuming a
// rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
// in the paper carries through for Swap operations, especially as the block
// swapping rotate uses only O(M+N) Swaps.
//
// symMerge assumes non-degenerate arguments: a < m && m < b.
// Having the caller check this condition eliminates many leaf recursion calls,
// which improves performance.
internal static void symMergeCmpFunc<E>(slice<E> data, nint a, nint m, nint b, Func<E, E, nint> cmp)
    where E : new()
{
    // Avoid unnecessary recursions of symMerge
    // by direct insertion of data[a] into data[m:b]
    // if data[a:m] only contains one element.
    if (m - a == 1) {
        // Use binary search to find the lowest index i
        // such that data[i] >= data[a] for m <= i < b.
        // Exit the search loop with i == b in case no such index exists.
        nint i = m;
        nint j = b;
        while (i < j) {
            nint h = ((nint)(((nuint)(i + j)) >> (int)(1)));
            if (cmp(data[h], data[a]) < 0){
                i = h + 1;
            } else {
                j = h;
            }
        }
        // Swap values until data[a] reaches the position before i.
        for (nint k = a; k < i - 1; k++) {
            (data[k], data[k + 1]) = (data[k + 1], data[k]);
        }
        return;
    }
    // Avoid unnecessary recursions of symMerge
    // by direct insertion of data[m] into data[a:m]
    // if data[m:b] only contains one element.
    if (b - m == 1) {
        // Use binary search to find the lowest index i
        // such that data[i] > data[m] for a <= i < m.
        // Exit the search loop with i == m in case no such index exists.
        nint i = a;
        nint j = m;
        while (i < j) {
            nint h = ((nint)(((nuint)(i + j)) >> (int)(1)));
            if (!(cmp(data[m], data[h]) < 0)){
                i = h + 1;
            } else {
                j = h;
            }
        }
        // Swap values until data[m] reaches the position i.
        for (nint k = m; k > i; k--) {
            (data[k], data[k - 1]) = (data[k - 1], data[k]);
        }
        return;
    }
    nint mid = ((nint)(((nuint)(a + b)) >> (int)(1)));
    nint n = mid + m;
    nint start = default!;
    nint r = default!;
    if (m > mid){
        start = n - b;
        r = mid;
    } else {
        start = a;
        r = m;
    }
    nint p = n - 1;
    while (start < r) {
        nint c = ((nint)(((nuint)(start + r)) >> (int)(1)));
        if (!(cmp(data[p - c], data[c]) < 0)){
            start = c + 1;
        } else {
            r = c;
        }
    }
    nint end = n - start;
    if (start < m && m < end) {
        rotateCmpFunc(data, start, m, end, cmp);
    }
    if (a < start && start < mid) {
        symMergeCmpFunc(data, a, start, mid, cmp);
    }
    if (mid < end && end < b) {
        symMergeCmpFunc(data, mid, end, b, cmp);
    }
}

// rotateCmpFunc rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
// Data of the form 'x u v y' is changed to 'x v u y'.
// rotate performs at most b-a many calls to data.Swap,
// and it assumes non-degenerate arguments: a < m && m < b.
internal static void rotateCmpFunc<E>(slice<E> data, nint a, nint m, nint b, Func<E, E, nint> cmp)
    where E : new()
{
    nint i = m - a;
    nint j = b - m;
    while (i != j) {
        if (i > j){
            swapRangeCmpFunc(data, m - i, m, j, cmp);
            i -= j;
        } else {
            swapRangeCmpFunc(data, m - i, m + j - i, i, cmp);
            j -= i;
        }
    }
    // i == j
    swapRangeCmpFunc(data, m - i, m, i, cmp);
}

} // end slices_package
