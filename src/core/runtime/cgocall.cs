// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Cgo call and callback support.
//
// To call into the C function f from Go, the cgo-generated code calls
// runtime.cgocall(_cgo_Cfunc_f, frame), where _cgo_Cfunc_f is a
// gcc-compiled function written by cgo.
//
// runtime.cgocall (below) calls entersyscall so as not to block
// other goroutines or the garbage collector, and then calls
// runtime.asmcgocall(_cgo_Cfunc_f, frame).
//
// runtime.asmcgocall (in asm_$GOARCH.s) switches to the m->g0 stack
// (assumed to be an operating system-allocated stack, so safe to run
// gcc-compiled code on) and calls _cgo_Cfunc_f(frame).
//
// _cgo_Cfunc_f invokes the actual C function f with arguments
// taken from the frame structure, records the results in the frame,
// and returns to runtime.asmcgocall.
//
// After it regains control, runtime.asmcgocall switches back to the
// original g (m->curg)'s stack and returns to runtime.cgocall.
//
// After it regains control, runtime.cgocall calls exitsyscall, which blocks
// until this m can run Go code without violating the $GOMAXPROCS limit,
// and then unlocks g from m.
//
// The above description skipped over the possibility of the gcc-compiled
// function f calling back into Go. If that happens, we continue down
// the rabbit hole during the execution of f.
//
// To make it possible for gcc-compiled C code to call a Go function p.GoF,
// cgo writes a gcc-compiled function named GoF (not p.GoF, since gcc doesn't
// know about packages).  The gcc-compiled C function f calls GoF.
//
// GoF initializes "frame", a structure containing all of its
// arguments and slots for p.GoF's results. It calls
// crosscall2(_cgoexp_GoF, frame, framesize, ctxt) using the gcc ABI.
//
// crosscall2 (in cgo/asm_$GOARCH.s) is a four-argument adapter from
// the gcc function call ABI to the gc function call ABI. At this
// point we're in the Go runtime, but we're still running on m.g0's
// stack and outside the $GOMAXPROCS limit. crosscall2 calls
// runtime.cgocallback(_cgoexp_GoF, frame, ctxt) using the gc ABI.
// (crosscall2's framesize argument is no longer used, but there's one
// case where SWIG calls crosscall2 directly and expects to pass this
// argument. See _cgo_panic.)
//
// runtime.cgocallback (in asm_$GOARCH.s) switches from m.g0's stack
// to the original g (m.curg)'s stack, on which it calls
// runtime.cgocallbackg(_cgoexp_GoF, frame, ctxt). As part of the
// stack switch, runtime.cgocallback saves the current SP as
// m.g0.sched.sp, so that any use of m.g0's stack during the execution
// of the callback will be done below the existing stack frames.
// Before overwriting m.g0.sched.sp, it pushes the old value on the
// m.g0 stack, so that it can be restored later.
//
// runtime.cgocallbackg (below) is now running on a real goroutine
// stack (not an m.g0 stack).  First it calls runtime.exitsyscall, which will
// block until the $GOMAXPROCS limit allows running this goroutine.
// Once exitsyscall has returned, it is safe to do things like call the memory
// allocator or invoke the Go callback function.  runtime.cgocallbackg
// first defers a function to unwind m.g0.sched.sp, so that if p.GoF
// panics, m.g0.sched.sp will be restored to its old value: the m.g0 stack
// and the m.curg stack will be unwound in lock step.
// Then it calls _cgoexp_GoF(frame).
//
// _cgoexp_GoF, which was generated by cmd/cgo, unpacks the arguments
// from frame, calls p.GoF, writes the results back to frame, and
// returns. Now we start unwinding this whole process.
//
// runtime.cgocallbackg pops but does not execute the deferred
// function to unwind m.g0.sched.sp, calls runtime.entersyscall, and
// returns to runtime.cgocallback.
//
// After it regains control, runtime.cgocallback switches back to
// m.g0's stack (the pointer is still in m.g0.sched.sp), restores the old
// m.g0.sched.sp value from the stack, and returns to crosscall2.
//
// crosscall2 restores the callee-save registers for gcc and returns
// to GoF, which unpacks any result values and returns to f.
namespace go;

using abi = @internal.abi_package;
using goarch = @internal.goarch_package;
using goexperiment = @internal.goexperiment_package;
using sys = runtime.@internal.sys_package;
using @unsafe = unsafe_package;
using @internal;
using runtime.@internal;
using ꓸꓸꓸuintptr = Span<uintptr>;

partial class runtime_package {

[GoType("[32]uintptr")] partial struct ΔcgoCallers;

// argset matches runtime/cgo/linux_syscall.c:argset_t
[GoType] partial struct argset {
    internal @unsafe.Pointer args;
    internal uintptr retval;
}

// wrapper for syscall package to call cgocall for libc (cgo) calls.
//
//go:linkname syscall_cgocaller syscall.cgocaller
//go:nosplit
//go:uintptrescapes
internal static uintptr syscall_cgocaller(@unsafe.Pointer fn, params ꓸꓸꓸuintptr argsʗp) {
    var args = argsʗp.slice();

    ref var as = ref heap<argset>(out var Ꮡas);
    @as = new argset(args: ((@unsafe.Pointer)(Ꮡ(args, 0))));
    cgocall(fn.val, new @unsafe.Pointer(Ꮡ@as));
    return @as.retval;
}

internal static uint64 ncgocall; // number of cgo calls in total for dead m

// Call from Go to C.
//
// This must be nosplit because it's used for syscalls on some
// platforms. Syscalls may have untyped arguments on the stack, so
// it's not safe to grow or scan the stack.
//
// cgocall should be an internal detail,
// but widely used packages access it using linkname.
// Notable members of the hall of shame include:
//   - github.com/ebitengine/purego
//
// Do not remove or change the type signature.
// See go.dev/issue/67401.
//
//go:linkname cgocall
//go:nosplit
internal static int32 cgocall(@unsafe.Pointer fn, @unsafe.Pointer arg) {
    if (!iscgo && GOOS != "solaris"u8 && GOOS != "illumos"u8 && GOOS != "windows"u8) {
        @throw("cgocall unavailable"u8);
    }
    if (fn == nil) {
        @throw("cgocall nil"u8);
    }
    if (raceenabled) {
        racereleasemerge(new @unsafe.Pointer(Ꮡ(racecgosync)));
    }
    var mp = getg().val.m;
    (~mp).ncgocall++;
    // Reset traceback.
    (~mp).cgoCallers[0] = 0;
    // Announce we are entering a system call
    // so that the scheduler knows to create another
    // M to run goroutines while we are in the
    // foreign code.
    //
    // The call to asmcgocall is guaranteed not to
    // grow the stack and does not allocate memory,
    // so it is safe to call while "in a system call", outside
    // the $GOMAXPROCS accounting.
    //
    // fn may call back into Go code, in which case we'll exit the
    // "system call", run the Go code (which may grow the stack),
    // and then re-enter the "system call" reusing the PC and SP
    // saved by entersyscall here.
    entersyscall();
    // Tell asynchronous preemption that we're entering external
    // code. We do this after entersyscall because this may block
    // and cause an async preemption to fail, but at this point a
    // sync preemption will succeed (though this is not a matter
    // of correctness).
    osPreemptExtEnter(mp);
    mp.val.incgo = true;
    // We use ncgo as a check during execution tracing for whether there is
    // any C on the call stack, which there will be after this point. If
    // there isn't, we can use frame pointer unwinding to collect call
    // stacks efficiently. This will be the case for the first Go-to-C call
    // on a stack, so it's preferable to update it here, after we emit a
    // trace event in entersyscall above.
    (~mp).ncgo++;
    var errno = asmcgocall(fn.val, arg.val);
    // Update accounting before exitsyscall because exitsyscall may
    // reschedule us on to a different M.
    mp.val.incgo = false;
    (~mp).ncgo--;
    osPreemptExtExit(mp);
    // Save current syscall parameters, so m.winsyscall can be
    // used again if callback decide to make syscall.
    var winsyscall = mp.val.winsyscall;
    exitsyscall();
    (~getg()).m.val.winsyscall = winsyscall;
    // Note that raceacquire must be called only after exitsyscall has
    // wired this M to a P.
    if (raceenabled) {
        raceacquire(new @unsafe.Pointer(Ꮡ(racecgosync)));
    }
    // From the garbage collector's perspective, time can move
    // backwards in the sequence above. If there's a callback into
    // Go code, GC will see this function at the call to
    // asmcgocall. When the Go call later returns to C, the
    // syscall PC/SP is rolled back and the GC sees this function
    // back at the call to entersyscall. Normally, fn and arg
    // would be live at entersyscall and dead at asmcgocall, so if
    // time moved backwards, GC would see these arguments as dead
    // and then live. Prevent these undead arguments from crashing
    // GC by forcing them to stay live across this time warp.
    KeepAlive(fn);
    KeepAlive(arg);
    KeepAlive(mp);
    return errno;
}

// Set or reset the system stack bounds for a callback on sp.
//
// Must be nosplit because it is called by needm prior to fully initializing
// the M.
//
//go:nosplit
internal static void callbackUpdateSystemStack(ж<m> Ꮡmp, uintptr sp, bool signal) {
    ref var mp = ref Ꮡmp.val;

    var g0 = mp.g0;
    var inBound = sp > (~g0).stack.lo && sp <= (~g0).stack.hi;
    if (mp.ncgo > 0 && !inBound) {
        // ncgo > 0 indicates that this M was in Go further up the stack
        // (it called C and is now receiving a callback).
        //
        // !inBound indicates that we were called with SP outside the
        // expected system stack bounds (C changed the stack out from
        // under us between the cgocall and cgocallback?).
        //
        // It is not safe for the C call to change the stack out from
        // under us, so throw.
        // Note that this case isn't possible for signal == true, as
        // that is always passing a new M from needm.
        // Stack is bogus, but reset the bounds anyway so we can print.
        var hi = (~g0).stack.hi;
        var lo = (~g0).stack.lo;
        (~g0).stack.hi = sp + 1024;
        (~g0).stack.lo = sp - 32 * 1024;
        g0.val.stackguard0 = (~g0).stack.lo + stackGuard;
        g0.val.stackguard1 = g0.val.stackguard0;
        print("M ", mp.id, " procid ", mp.procid, " runtime: cgocallback with sp=", ((Δhex)sp), " out of bounds [", ((Δhex)lo), ", ", ((Δhex)hi), "]");
        print("\n");
        exit(2);
    }
    if (!mp.isextra) {
        // We allocated the stack for standard Ms. Don't replace the
        // stack bounds with estimated ones when we already initialized
        // with the exact ones.
        return;
    }
    // This M does not have Go further up the stack. However, it may have
    // previously called into Go, initializing the stack bounds. Between
    // that call returning and now the stack may have changed (perhaps the
    // C thread is running a coroutine library). We need to update the
    // stack bounds for this case.
    //
    // N.B. we need to update the stack bounds even if SP appears to
    // already be in bounds. Our "bounds" may actually be estimated dummy
    // bounds (below). The actual stack bounds could have shifted but still
    // have partial overlap with our dummy bounds. If we failed to update
    // in that case, we could find ourselves seemingly called near the
    // bottom of the stack bounds, where we quickly run out of space.
    // Set the stack bounds to match the current stack. If we don't
    // actually know how big the stack is, like we don't know how big any
    // scheduling stack is, but we assume there's at least 32 kB. If we
    // can get a more accurate stack bound from pthread, use that, provided
    // it actually contains SP..
    (~g0).stack.hi = sp + 1024;
    (~g0).stack.lo = sp - 32 * 1024;
    if (!signal && _cgo_getstackbound != nil) {
        // Don't adjust if called from the signal handler.
        // We are on the signal stack, not the pthread stack.
        // (We could get the stack bounds from sigaltstack, but
        // we're getting out of the signal handler very soon
        // anyway. Not worth it.)
        ref var bounds = ref heap(new array<uintptr>(2), out var Ꮡbounds);
        asmcgocall(_cgo_getstackbound, new @unsafe.Pointer(Ꮡbounds));
        // getstackbound is an unsupported no-op on Windows.
        //
        // Don't use these bounds if they don't contain SP. Perhaps we
        // were called by something not using the standard thread
        // stack.
        if (bounds[0] != 0 && sp > bounds[0] && sp <= bounds[1]) {
            (~g0).stack.lo = bounds[0];
            (~g0).stack.hi = bounds[1];
        }
    }
    g0.val.stackguard0 = (~g0).stack.lo + stackGuard;
    g0.val.stackguard1 = g0.val.stackguard0;
}

// Call from C back to Go. fn must point to an ABIInternal Go entry-point.
//
//go:nosplit
internal static void cgocallbackg(@unsafe.Pointer fn, @unsafe.Pointer frame, uintptr ctxt) {
    var gp = getg();
    if (gp != (~(~gp).m).curg) {
        println("runtime: bad g in cgocallback");
        exit(2);
    }
    var sp = (~(~(~gp).m).g0).sched.sp;
    // system sp saved by cgocallback.
    callbackUpdateSystemStack((~gp).m, sp, false);
    // The call from C is on gp.m's g0 stack, so we must ensure
    // that we stay on that M. We have to do this before calling
    // exitsyscall, since it would otherwise be free to move us to
    // a different M. The call to unlockOSThread is in this function
    // after cgocallbackg1, or in the case of panicking, in unwindm.
    lockOSThread();
    var checkm = gp.val.m;
    // Save current syscall parameters, so m.winsyscall can be
    // used again if callback decide to make syscall.
    var winsyscall = (~gp).m.val.winsyscall;
    // entersyscall saves the caller's SP to allow the GC to trace the Go
    // stack. However, since we're returning to an earlier stack frame and
    // need to pair with the entersyscall() call made by cgocall, we must
    // save syscall* and let reentersyscall restore them.
    //
    // Note: savedsp and savedbp MUST be held in locals as an unsafe.Pointer.
    // When we call into Go, the stack is free to be moved. If these locals
    // aren't visible in the stack maps, they won't get updated properly,
    // and will end up being stale when restored by reentersyscall.
    @unsafe.Pointer savedsp = ((@unsafe.Pointer)(~gp).syscallsp);
    var savedpc = gp.val.syscallpc;
    @unsafe.Pointer savedbp = ((@unsafe.Pointer)(~gp).syscallbp);
    exitsyscall();
    // coming out of cgo call
    (~gp).m.val.incgo = false;
    if ((~(~gp).m).isextra) {
        (~gp).m.val.isExtraInC = false;
    }
    osPreemptExtExit((~gp).m);
    if ((~gp).nocgocallback) {
        throw panic("runtime: function marked with #cgo nocallback called back into Go");
    }
    cgocallbackg1(fn.val, frame.val, ctxt);
    // At this point we're about to call unlockOSThread.
    // The following code must not change to a different m.
    // This is enforced by checking incgo in the schedule function.
    (~gp).m.val.incgo = true;
    unlockOSThread();
    if ((~(~gp).m).isextra) {
        (~gp).m.val.isExtraInC = true;
    }
    if ((~gp).m != checkm) {
        @throw("m changed unexpectedly in cgocallbackg"u8);
    }
    osPreemptExtEnter((~gp).m);
    // going back to cgo call
    reentersyscall(savedpc, ((uintptr)savedsp), ((uintptr)savedbp));
    (~gp).m.val.winsyscall = winsyscall;
}

internal static void cgocallbackg1(@unsafe.Pointer fn, @unsafe.Pointer frame, uintptr ctxt) => func((defer, _) => {
    var gp = getg();
    if ((~(~gp).m).needextram || extraMWaiters.Load() > 0) {
        (~gp).m.val.needextram = false;
        systemstack(newextram);
    }
    if (ctxt != 0) {
        var s = append((~gp).cgoCtxt, ctxt);
        // Now we need to set gp.cgoCtxt = s, but we could get
        // a SIGPROF signal while manipulating the slice, and
        // the SIGPROF handler could pick up gp.cgoCtxt while
        // tracing up the stack.  We need to ensure that the
        // handler always sees a valid slice, so set the
        // values in an order such that it always does.
        var Δp = (ж<Δslice>)(uintptr)(new @unsafe.Pointer(Ꮡ((~gp).cgoCtxt)));
        atomicstorep(((@unsafe.Pointer)(Ꮡ((~Δp).Δarray))), ((@unsafe.Pointer)(Ꮡ(s, 0))));
        Δp.val.cap = cap(s);
        Δp.val.len = len(s);
        deferǃ((ж<g> gp) => {
            var pΔ1 = (ж<Δslice>)(uintptr)(new @unsafe.Pointer(Ꮡ((~gpΔ1).cgoCtxt)));
            (~pΔ1).len--;
        }, gp, defer);
    }
    if ((~(~gp).m).ncgo == 0) {
        // The C call to Go came from a thread not currently running
        // any Go. In the case of -buildmode=c-archive or c-shared,
        // this call may be coming in before package initialization
        // is complete. Wait until it is.
        ᐸꟷ(main_init_done);
    }
    // Check whether the profiler needs to be turned on or off; this route to
    // run Go code does not use runtime.execute, so bypasses the check there.
    var hz = sched.profilehz;
    if ((~(~gp).m).profilehz != hz) {
        setThreadCPUProfiler(hz);
    }
    // Add entry to defer stack in case of panic.
    ref var restore = ref heap<bool>(out var Ꮡrestore);
    restore = true;
    deferǃ(unwindm, Ꮡrestore, defer);
    if (raceenabled) {
        raceacquire(new @unsafe.Pointer(Ꮡ(racecgosync)));
    }
    // Invoke callback. This function is generated by cmd/cgo and
    // will unpack the argument frame and call the Go function.
    Action<@unsafe.Pointer> cb = default!;
    ref var cbFV = ref heap<funcval>(out var ᏑcbFV);
    cbFV = new funcval(((uintptr)fn));
    ((ж<@unsafe.Pointer>)(uintptr)(new @unsafe.Pointer(Ꮡ(cb)))).val = (uintptr)noescape(new @unsafe.Pointer(ᏑcbFV));
    cb(frame.val);
    if (raceenabled) {
        racereleasemerge(new @unsafe.Pointer(Ꮡ(racecgosync)));
    }
    // Do not unwind m->g0->sched.sp.
    // Our caller, cgocallback, will do that.
    restore = false;
});

internal static void unwindm(ж<bool> Ꮡrestore) {
    ref var restore = ref Ꮡrestore.val;

    if (restore) {
        // Restore sp saved by cgocallback during
        // unwind of g's stack (see comment at top of file).
        var mp = acquirem();
        var sched = Ꮡ((~(~mp).g0).sched);
        sched.val.sp = ~(ж<uintptr>)(uintptr)(((@unsafe.Pointer)((~sched).sp + alignUp(sys.MinFrameSize, sys.StackAlign))));
        // Do the accounting that cgocall will not have a chance to do
        // during an unwind.
        //
        // In the case where a Go call originates from C, ncgo is 0
        // and there is no matching cgocall to end.
        if ((~mp).ncgo > 0) {
            mp.val.incgo = false;
            (~mp).ncgo--;
            osPreemptExtExit(mp);
        }
        // Undo the call to lockOSThread in cgocallbackg, only on the
        // panicking path. In normal return case cgocallbackg will call
        // unlockOSThread, ensuring no preemption point after the unlock.
        // Here we don't need to worry about preemption, because we're
        // panicking out of the callback and unwinding the g0 stack,
        // instead of reentering cgo (which requires the same thread).
        unlockOSThread();
        releasem(mp);
    }
}

// called from assembly.
internal static void badcgocallback() {
    @throw("misaligned stack in cgocallback"u8);
}

// called from (incomplete) assembly.
internal static void cgounimpl() {
    @throw("cgo not implemented"u8);
}

internal static uint64 racecgosync; // represents possible synchronization in C code

// Pointer checking for cgo code.
// We want to detect all cases where a program that does not use
// unsafe makes a cgo call passing a Go pointer to memory that
// contains an unpinned Go pointer. Here a Go pointer is defined as a
// pointer to memory allocated by the Go runtime. Programs that use
// unsafe can evade this restriction easily, so we don't try to catch
// them. The cgo program will rewrite all possibly bad pointer
// arguments to call cgoCheckPointer, where we can catch cases of a Go
// pointer pointing to an unpinned Go pointer.
// Complicating matters, taking the address of a slice or array
// element permits the C program to access all elements of the slice
// or array. In that case we will see a pointer to a single element,
// but we need to check the entire data structure.
// The cgoCheckPointer call takes additional arguments indicating that
// it was called on an address expression. An additional argument of
// true means that it only needs to check a single element. An
// additional argument of a slice or array means that it needs to
// check the entire slice/array, but nothing else. Otherwise, the
// pointer could be anything, and we check the entire heap object,
// which is conservative but safe.
// When and if we implement a moving garbage collector,
// cgoCheckPointer will pin the pointer for the duration of the cgo
// call.  (This is necessary but not sufficient; the cgo program will
// also have to change to pin Go pointers that cannot point to Go
// pointers.)

// cgoCheckPointer checks if the argument contains a Go pointer that
// points to an unpinned Go pointer, and panics if it does.
internal static void cgoCheckPointer(any ptr, any arg) {
    if (!goexperiment.CgoCheck2 && debug.cgocheck == 0) {
        return;
    }
    var ep = efaceOf(Ꮡ(ptr));
    var t = ep.val._type;
    var top = true;
    if (arg != default! && ((abiꓸKind)((~t).Kind_ & abi.KindMask) == abi.Pointer || (abiꓸKind)((~t).Kind_ & abi.KindMask) == abi.UnsafePointer)) {
        @unsafe.Pointer Δp = ep.val.data;
        if ((abiꓸKind)((~t).Kind_ & abi.KindDirectIface) == 0) {
            Δp = ~(ж<@unsafe.Pointer>)(uintptr)(Δp);
        }
        if (Δp == nil || !cgoIsGoPointer(Δp)) {
            return;
        }
        var aep = efaceOf(Ꮡ(arg));
        var exprᴛ1 = (abiꓸKind)((~(~aep)._type).Kind_ & abi.KindMask);
        if (exprᴛ1 == abi.Bool) {
            if ((abiꓸKind)((~t).Kind_ & abi.KindMask) == abi.UnsafePointer) {
                // We don't know the type of the element.
                break;
            }
            var pt = (ж<ptrtype>)(uintptr)(new @unsafe.Pointer(t));
            cgoCheckArg((~pt).Elem, Δp, true, false, cgoCheckPointerFail);
            return;
        }
        if (exprᴛ1 == abi.Slice) {
            ep = aep;
            t = ep.val._type;
        }
        else if (exprᴛ1 == abi.Array) {
            ep = aep;
            t = ep.val._type;
            top = false;
        }
        else { /* default: */
            @throw("can't happen"u8);
        }

    }
    // Check the slice rather than the pointer.
    // Check the array rather than the pointer.
    // Pass top as false since we have a pointer
    // to the array.
    cgoCheckArg(t, (~ep).data, (abiꓸKind)((~t).Kind_ & abi.KindDirectIface) == 0, top, cgoCheckPointerFail);
}

internal static readonly @string cgoCheckPointerFail = "cgo argument has Go pointer to unpinned Go pointer"u8;

internal static readonly @string cgoResultFail = "cgo result is unpinned Go pointer or points to unpinned Go pointer"u8;

// cgoCheckArg is the real work of cgoCheckPointer. The argument p
// is either a pointer to the value (of type t), or the value itself,
// depending on indir. The top parameter is whether we are at the top
// level, where Go pointers are allowed. Go pointers to pinned objects are
// allowed as long as they don't reference other unpinned pointers.
internal static void cgoCheckArg(ж<_type> Ꮡt, @unsafe.Pointer Δp, bool indir, bool top, @string msg) {
    ref var t = ref Ꮡt.val;

    if (!t.Pointers() || Δp == nil) {
        // If the type has no pointers there is nothing to do.
        return;
    }
    var exprᴛ1 = (abiꓸKind)(t.Kind_ & abi.KindMask);
    { /* default: */
        @throw("can't happen"u8);
    }
    else if (exprᴛ1 == abi.Array) {
        var at = (ж<arraytype>)(uintptr)(new @unsafe.Pointer(Ꮡt));
        if (!indir) {
            if ((~at).Len != 1) {
                @throw("can't happen"u8);
            }
            cgoCheckArg((~at).Elem, p.val, (abiꓸKind)((~(~at).Elem).Kind_ & abi.KindDirectIface) == 0, top, msg);
            return;
        }
        for (var i = ((uintptr)0); i < (~at).Len; i++) {
            cgoCheckArg((~at).Elem, p.val, true, top, msg);
            Δp = (uintptr)add(p.val, (~(~at).Elem).Size_);
        }
    }
    else if (exprᴛ1 == abi.Chan || exprᴛ1 == abi.Map) {
        throw panic(((errorString)msg));
    }
    else if (exprᴛ1 == abi.Func) {
        if (indir) {
            // These types contain internal pointers that will
            // always be allocated in the Go heap. It's never OK
            // to pass them to C.
            Δp = ~(ж<@unsafe.Pointer>)(uintptr)(Δp);
        }
        if (!cgoIsGoPointer(p.val)) {
            return;
        }
        throw panic(((errorString)msg));
    }
    else if (exprᴛ1 == abi.Interface) {
        var it = ~(ж<ж<_type>>)(uintptr)(Δp);
        if (it == nil) {
            return;
        }
        if (inheap(((uintptr)new @unsafe.Pointer(it)))) {
            // A type known at compile time is OK since it's
            // constant. A type not known at compile time will be
            // in the heap and will not be OK.
            throw panic(((errorString)msg));
        }
        Δp = ~(ж<@unsafe.Pointer>)(uintptr)(add(p.val, goarch.PtrSize));
        if (!cgoIsGoPointer(p.val)) {
            return;
        }
        if (!top && !isPinned(p.val)) {
            throw panic(((errorString)msg));
        }
        cgoCheckArg(it, p.val, (abiꓸKind)((~it).Kind_ & abi.KindDirectIface) == 0, false, msg);
    }
    else if (exprᴛ1 == abi.Slice) {
        var st = (ж<slicetype>)(uintptr)(new @unsafe.Pointer(Ꮡt));
        var s = (ж<Δslice>)(uintptr)(Δp);
        Δp = s.val.Δarray;
        if (Δp == nil || !cgoIsGoPointer(p.val)) {
            return;
        }
        if (!top && !isPinned(p.val)) {
            throw panic(((errorString)msg));
        }
        if (!(~st).Elem.Pointers()) {
            return;
        }
        for (nint i = 0; i < (~s).cap; i++) {
            cgoCheckArg((~st).Elem, p.val, true, false, msg);
            Δp = (uintptr)add(p.val, (~(~st).Elem).Size_);
        }
    }
    else if (exprᴛ1 == abi.ΔString) {
        var ss = (ж<stringStruct>)(uintptr)(Δp);
        if (!cgoIsGoPointer((~ss).str)) {
            return;
        }
        if (!top && !isPinned((~ss).str)) {
            throw panic(((errorString)msg));
        }
    }
    else if (exprᴛ1 == abi.Struct) {
        var st = (ж<structtype>)(uintptr)(new @unsafe.Pointer(Ꮡt));
        if (!indir) {
            if (len((~st).Fields) != 1) {
                @throw("can't happen"u8);
            }
            cgoCheckArg((~st).Fields[0].Typ, p.val, (abiꓸKind)((~(~st).Fields[0].Typ).Kind_ & abi.KindDirectIface) == 0, top, msg);
            return;
        }
        ref var f = ref heap(new @internal.abi_package.StructField(), out var Ꮡf);

        foreach (var (_, f) in (~st).Fields) {
            if (!f.Typ.Pointers()) {
                continue;
            }
            cgoCheckArg(f.Typ, (uintptr)add(p.val, f.Offset), true, top, msg);
        }
    }
    else if (exprᴛ1 == abi.Pointer || exprᴛ1 == abi.UnsafePointer) {
        if (indir) {
            Δp = ~(ж<@unsafe.Pointer>)(uintptr)(Δp);
            if (Δp == nil) {
                return;
            }
        }
        if (!cgoIsGoPointer(p.val)) {
            return;
        }
        if (!top && !isPinned(p.val)) {
            throw panic(((errorString)msg));
        }
        cgoCheckUnknownPointer(p.val, msg);
    }

}

// cgoCheckUnknownPointer is called for an arbitrary pointer into Go
// memory. It checks whether that Go memory contains any other
// pointer into unpinned Go memory. If it does, we panic.
// The return values are unused but useful to see in panic tracebacks.
internal static (uintptr @base, uintptr i) cgoCheckUnknownPointer(@unsafe.Pointer Δp, @string msg) {
    uintptr @base = default!;
    uintptr i = default!;

    if (inheap(((uintptr)Δp))) {
        var (b, span, _) = findObject(((uintptr)Δp), 0, 0);
        @base = b;
        if (@base == 0) {
            return (@base, i);
        }
        var tp = span.typePointersOfUnchecked(@base);
        while (ᐧ) {
            uintptr addr = default!;
            {
                (tp, addr) = tp.next(@base + (~span).elemsize); if (addr == 0) {
                    break;
                }
            }
            @unsafe.Pointer pp = ~(ж<@unsafe.Pointer>)(uintptr)(((@unsafe.Pointer)addr));
            if (cgoIsGoPointer(pp) && !isPinned(pp)) {
                throw panic(((errorString)msg));
            }
        }
        return (@base, i);
    }
    foreach (var (_, datap) in activeModules()) {
        if (cgoInRange(p.val, (~datap).data, (~datap).edata) || cgoInRange(p.val, (~datap).bss, (~datap).ebss)) {
            // We have no way to know the size of the object.
            // We have to assume that it might contain a pointer.
            throw panic(((errorString)msg));
        }
    }
    // In the text or noptr sections, we know that the
    // pointer does not point to a Go pointer.
    return (@base, i);
}

// cgoIsGoPointer reports whether the pointer is a Go pointer--a
// pointer to Go memory. We only care about Go memory that might
// contain pointers.
//
//go:nosplit
//go:nowritebarrierrec
internal static bool cgoIsGoPointer(@unsafe.Pointer Δp) {
    if (Δp == nil) {
        return false;
    }
    if (inHeapOrStack(((uintptr)Δp))) {
        return true;
    }
    foreach (var (_, datap) in activeModules()) {
        if (cgoInRange(p.val, (~datap).data, (~datap).edata) || cgoInRange(p.val, (~datap).bss, (~datap).ebss)) {
            return true;
        }
    }
    return false;
}

// cgoInRange reports whether p is between start and end.
//
//go:nosplit
//go:nowritebarrierrec
internal static bool cgoInRange(@unsafe.Pointer Δp, uintptr start, uintptr end) {
    return start <= ((uintptr)Δp) && ((uintptr)Δp) < end;
}

// cgoCheckResult is called to check the result parameter of an
// exported Go function. It panics if the result is or contains any
// other pointer into unpinned Go memory.
internal static void cgoCheckResult(any val) {
    if (!goexperiment.CgoCheck2 && debug.cgocheck == 0) {
        return;
    }
    var ep = efaceOf(Ꮡ(val));
    var t = ep.val._type;
    cgoCheckArg(t, (~ep).data, (abiꓸKind)((~t).Kind_ & abi.KindDirectIface) == 0, false, cgoResultFail);
}

} // end runtime_package
