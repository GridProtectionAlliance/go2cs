// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package log implements a simple logging package. It defines a type, [Logger],
// with methods for formatting output. It also has a predefined 'standard'
// Logger accessible through helper functions Print[f|ln], Fatal[f|ln], and
// Panic[f|ln], which are easier to use than creating a Logger manually.
// That logger writes to standard error and prints the date and time
// of each logged message.
// Every log message is output on a separate line: if the message being
// printed does not end in a newline, the logger will add one.
// The Fatal functions call [os.Exit](1) after writing the log message.
// The Panic functions call panic after writing the log message.
namespace go;

using fmt = fmt_package;
using io = io_package;
using @internal = log.internal_package;
using os = os_package;
using runtime = runtime_package;
using sync = sync_package;
using atomic = sync.atomic_package;
using time = time_package;
using log;
using sync;
using ꓸꓸꓸany = Span<any>;

partial class log_package {

// These flags define which text to prefix to each log entry generated by the [Logger].
// Bits are or'ed together to control what's printed.
// With the exception of the Lmsgprefix flag, there is no
// control over the order they appear (the order listed here)
// or the format they present (as described in the comments).
// The prefix is followed by a colon only when Llongfile or Lshortfile
// is specified.
// For example, flags Ldate | Ltime (or LstdFlags) produce,
//
//	2009/01/23 01:23:23 message
//
// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
//
//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
public static readonly UntypedInt Ldate = /* 1 << iota */ 1; // the date in the local time zone: 2009/01/23

public static readonly UntypedInt Ltime = 2;        // the time in the local time zone: 01:23:23

public static readonly UntypedInt Lmicroseconds = 4; // microsecond resolution: 01:23:23.123123.  assumes Ltime.

public static readonly UntypedInt Llongfile = 8;    // full file name and line number: /a/b/c/d.go:23

public static readonly UntypedInt Lshortfile = 16;   // final file name element and line number: d.go:23. overrides Llongfile

public static readonly UntypedInt LUTC = 32;         // if Ldate or Ltime is set, use UTC rather than the local time zone

public static readonly UntypedInt Lmsgprefix = 64;   // move the "prefix" from the beginning of the line to before the message

public static readonly UntypedInt LstdFlags = /* Ldate | Ltime */ 3; // initial values for the standard logger

// A Logger represents an active logging object that generates lines of
// output to an [io.Writer]. Each logging operation makes a single call to
// the Writer's Write method. A Logger can be used simultaneously from
// multiple goroutines; it guarantees to serialize access to the Writer.
[GoType] partial struct Logger {
    internal sync_package.Mutex outMu;
    internal io_package.Writer @out; // destination for output
    internal sync.atomic_package.Pointer prefix; // prefix on each line to identify the logger (but see Lmsgprefix)
    internal sync.atomic_package.Int32 flag;           // properties
    internal sync.atomic_package.Bool isDiscard;
}

// New creates a new [Logger]. The out variable sets the
// destination to which log data will be written.
// The prefix appears at the beginning of each generated log line, or
// after the log header if the [Lmsgprefix] flag is provided.
// The flag argument defines the logging properties.
public static ж<Logger> New(io.Writer @out, @string prefix, nint flag) {
    var l = @new<Logger>();
    l.SetOutput(@out);
    l.SetPrefix(prefix);
    l.SetFlags(flag);
    return l;
}

// SetOutput sets the output destination for the logger.
[GoRecv] public static void SetOutput(this ref Logger l, io.Writer w) => func((defer, _) => {
    l.outMu.Lock();
    defer(l.outMu.Unlock);
    l.@out = w;
    l.isDiscard.Store(AreEqual(w, io.Discard));
});

internal static ж<Logger> std = New(~os.Stderr, ""u8, LstdFlags);

// Default returns the standard logger used by the package-level output functions.
public static ж<Logger> Default() {
    return std;
}

// Cheap integer to fixed-width decimal ASCII. Give a negative width to avoid zero-padding.
internal static void itoa(ж<slice<byte>> Ꮡbuf, nint i, nint wid) {
    ref var buf = ref Ꮡbuf.val;

    // Assemble decimal in reverse order.
    array<byte> b = new(20);
    nint bp = len(b) - 1;
    while (i >= 10 || wid > 1) {
        wid--;
        nint q = i / 10;
        b[bp] = ((byte)((rune)'0' + i - q * 10));
        bp--;
        i = q;
    }
    // i < 10
    b[bp] = ((byte)((rune)'0' + i));
    buf = append(buf, b[(int)(bp)..].ꓸꓸꓸ);
}

// formatHeader writes log header to buf in following order:
//   - l.prefix (if it's not blank and Lmsgprefix is unset),
//   - date and/or time (if corresponding flags are provided),
//   - file and line number (if corresponding flags are provided),
//   - l.prefix (if it's not blank and Lmsgprefix is set).
internal static void formatHeader(ж<slice<byte>> Ꮡbuf, time.Time t, @string prefix, nint flag, @string file, nint line) {
    ref var buf = ref Ꮡbuf.val;

    if ((nint)(flag & Lmsgprefix) == 0) {
        buf = append(buf, prefix.ꓸꓸꓸ);
    }
    if ((nint)(flag & ((nint)((UntypedInt)(Ldate | Ltime) | Lmicroseconds))) != 0) {
        if ((nint)(flag & LUTC) != 0) {
            t = t.UTC();
        }
        if ((nint)(flag & Ldate) != 0) {
            var (year, month, day) = t.Date();
            itoa(Ꮡbuf, year, 4);
            buf = append(buf, (rune)'/');
            itoa(Ꮡbuf, ((nint)month), 2);
            buf = append(buf, (rune)'/');
            itoa(Ꮡbuf, day, 2);
            buf = append(buf, (rune)' ');
        }
        if ((nint)(flag & ((nint)(Ltime | Lmicroseconds))) != 0) {
            var (hour, min, sec) = t.Clock();
            itoa(Ꮡbuf, hour, 2);
            buf = append(buf, (rune)':');
            itoa(Ꮡbuf, min, 2);
            buf = append(buf, (rune)':');
            itoa(Ꮡbuf, sec, 2);
            if ((nint)(flag & Lmicroseconds) != 0) {
                buf = append(buf, (rune)'.');
                itoa(Ꮡbuf, t.Nanosecond() / 1e3F, 6);
            }
            buf = append(buf, (rune)' ');
        }
    }
    if ((nint)(flag & ((nint)(Lshortfile | Llongfile))) != 0) {
        if ((nint)(flag & Lshortfile) != 0) {
            @string @short = file;
            for (nint i = len(file) - 1; i > 0; i--) {
                if (file[i] == (rune)'/') {
                    @short = file[(int)(i + 1)..];
                    break;
                }
            }
            file = @short;
        }
        buf = append(buf, file.ꓸꓸꓸ);
        buf = append(buf, (rune)':');
        itoa(Ꮡbuf, line, -1);
        buf = append(buf, ": "u8.ꓸꓸꓸ);
    }
    if ((nint)(flag & Lmsgprefix) != 0) {
        buf = append(buf, prefix.ꓸꓸꓸ);
    }
}

internal static sync.Pool bufferPool = new sync.Pool(New: () => @new<slice<byte>>());

internal static unsafe ж<slice<byte>> getBuffer() {
    var p = bufferPool.Get()._<slice<byte>.val>();
    p.val = new Span<ж<slice<byte>>>((slice<byte>**), 0);
    return p;
}

internal static void putBuffer(ж<slice<byte>> Ꮡp) {
    ref var p = ref Ꮡp.val;

    // Proper usage of a sync.Pool requires each entry to have approximately
    // the same memory cost. To obtain this property when the stored type
    // contains a variably-sized buffer, we add a hard limit on the maximum buffer
    // to place back in the pool.
    //
    // See https://go.dev/issue/23199
    if (cap(p) > 64 << (int)(10)) {
        p = default!;
    }
    bufferPool.Put(p);
}

// Output writes the output for a logging event. The string s contains
// the text to print after the prefix specified by the flags of the
// Logger. A newline is appended if the last character of s is not
// already a newline. Calldepth is used to recover the PC and is
// provided for generality, although at the moment on all pre-defined
// paths it will be 2.
[GoRecv] public static error Output(this ref Logger l, nint calldepth, @string s) {
    calldepth++;
    // +1 for this frame.
    return l.output(0, calldepth, (slice<byte> b) => append(b, s.ꓸꓸꓸ));
}

// output can take either a calldepth or a pc to get source line information.
// It uses the pc if it is non-zero.
[GoRecv] internal static error output(this ref Logger l, uintptr pc, nint calldepth, Func<slice<byte>, slice<byte>> appendOutput) => func((defer, _) => {
    if (l.isDiscard.Load()) {
        return default!;
    }
    var now = time.Now();
    // get this early.
    // Load prefix and flag once so that their value is consistent within
    // this call regardless of any concurrent changes to their value.
    @string prefix = l.Prefix();
    nint flag = l.Flags();
    @string file = default!;
    nint line = default!;
    if ((nint)(flag & ((nint)(Lshortfile | Llongfile))) != 0) {
        if (pc == 0){
            bool ok = default!;
            (_, file, line, ok) = runtime.Caller(calldepth);
            if (!ok) {
                file = "???"u8;
                line = 0;
            }
        } else {
            var fs = runtime.CallersFrames(new uintptr[]{pc}.slice());
            var (f, _) = fs.Next();
            file = f.File;
            if (file == ""u8) {
                file = "???"u8;
            }
            line = f.Line;
        }
    }
    var buf = getBuffer();
    deferǃ(putBuffer, buf, defer);
    formatHeader(buf, now, prefix, flag, file, line);
    buf.val = appendOutput(buf.val);
    if (len(buf.val) == 0 || (ж<ж<slice<byte>>>)[len(buf.val) - 1] != (rune)'\n') {
        buf.val = append(buf.val, (rune)'\n');
    }
    l.outMu.Lock();
    defer(l.outMu.Unlock);
    var (_, err) = l.@out.Write(buf.val);
    return err;
});

[GoInit] internal static void init() {
    var @internal.DefaultOutput = (uintptr pc, slice<byte> data) => std.output(pc, 0, 
        var dataʗ1 = data;
        (slice<byte> buf) => append(buf, dataʗ1.ꓸꓸꓸ));
}

// Print calls l.Output to print to the logger.
// Arguments are handled in the manner of [fmt.Print].
[GoRecv] public static void Print(this ref Logger l, params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    l.output(0, 2, 
    var vʗ1 = v;
    (slice<byte> b) => fmt.Append(b, vʗ1.ꓸꓸꓸ));
}

// Printf calls l.Output to print to the logger.
// Arguments are handled in the manner of [fmt.Printf].
[GoRecv] public static void Printf(this ref Logger l, @string format, params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    l.output(0, 2, 
    var vʗ1 = v;
    (slice<byte> b) => fmt.Appendf(b, format, vʗ1.ꓸꓸꓸ));
}

// Println calls l.Output to print to the logger.
// Arguments are handled in the manner of [fmt.Println].
[GoRecv] public static void Println(this ref Logger l, params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    l.output(0, 2, 
    var vʗ1 = v;
    (slice<byte> b) => fmt.Appendln(b, vʗ1.ꓸꓸꓸ));
}

// Fatal is equivalent to l.Print() followed by a call to [os.Exit](1).
[GoRecv] public static void Fatal(this ref Logger l, params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    l.Output(2, fmt.Sprint(v.ꓸꓸꓸ));
    os.Exit(1);
}

// Fatalf is equivalent to l.Printf() followed by a call to [os.Exit](1).
[GoRecv] public static void Fatalf(this ref Logger l, @string format, params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    l.Output(2, fmt.Sprintf(format, v.ꓸꓸꓸ));
    os.Exit(1);
}

// Fatalln is equivalent to l.Println() followed by a call to [os.Exit](1).
[GoRecv] public static void Fatalln(this ref Logger l, params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    l.Output(2, fmt.Sprintln(v.ꓸꓸꓸ));
    os.Exit(1);
}

// Panic is equivalent to l.Print() followed by a call to panic().
[GoRecv] public static void Panic(this ref Logger l, params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    @string s = fmt.Sprint(v.ꓸꓸꓸ);
    l.Output(2, s);
    throw panic(s);
}

// Panicf is equivalent to l.Printf() followed by a call to panic().
[GoRecv] public static void Panicf(this ref Logger l, @string format, params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    @string s = fmt.Sprintf(format, v.ꓸꓸꓸ);
    l.Output(2, s);
    throw panic(s);
}

// Panicln is equivalent to l.Println() followed by a call to panic().
[GoRecv] public static void Panicln(this ref Logger l, params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    @string s = fmt.Sprintln(v.ꓸꓸꓸ);
    l.Output(2, s);
    throw panic(s);
}

// Flags returns the output flags for the logger.
// The flag bits are [Ldate], [Ltime], and so on.
[GoRecv] public static nint Flags(this ref Logger l) {
    return ((nint)l.flag.Load());
}

// SetFlags sets the output flags for the logger.
// The flag bits are [Ldate], [Ltime], and so on.
[GoRecv] public static void SetFlags(this ref Logger l, nint flag) {
    l.flag.Store(((int32)flag));
}

// Prefix returns the output prefix for the logger.
[GoRecv] public static @string Prefix(this ref Logger l) {
    {
        var p = l.prefix.Load(); if (p != nil) {
            return p.val;
        }
    }
    return ""u8;
}

// SetPrefix sets the output prefix for the logger.
[GoRecv] public static void SetPrefix(this ref Logger l, @string prefix) {
    l.prefix.Store(Ꮡ(prefix));
}

// Writer returns the output destination for the logger.
[GoRecv] public static io.Writer Writer(this ref Logger l) => func((defer, _) => {
    l.outMu.Lock();
    defer(l.outMu.Unlock);
    return l.@out;
});

// SetOutput sets the output destination for the standard logger.
public static void SetOutput(io.Writer w) {
    std.SetOutput(w);
}

// Flags returns the output flags for the standard logger.
// The flag bits are [Ldate], [Ltime], and so on.
public static nint Flags() {
    return std.Flags();
}

// SetFlags sets the output flags for the standard logger.
// The flag bits are [Ldate], [Ltime], and so on.
public static void SetFlags(nint flag) {
    std.SetFlags(flag);
}

// Prefix returns the output prefix for the standard logger.
public static @string Prefix() {
    return std.Prefix();
}

// SetPrefix sets the output prefix for the standard logger.
public static void SetPrefix(@string prefix) {
    std.SetPrefix(prefix);
}

// Writer returns the output destination for the standard logger.
public static io.Writer Writer() {
    return std.Writer();
}

// These functions write to the standard logger.

// Print calls Output to print to the standard logger.
// Arguments are handled in the manner of [fmt.Print].
public static void Print(params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    std.output(0, 2, 
    var vʗ1 = v;
    (slice<byte> b) => fmt.Append(b, vʗ1.ꓸꓸꓸ));
}

// Printf calls Output to print to the standard logger.
// Arguments are handled in the manner of [fmt.Printf].
public static void Printf(@string format, params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    std.output(0, 2, 
    var vʗ1 = v;
    (slice<byte> b) => fmt.Appendf(b, format, vʗ1.ꓸꓸꓸ));
}

// Println calls Output to print to the standard logger.
// Arguments are handled in the manner of [fmt.Println].
public static void Println(params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    std.output(0, 2, 
    var vʗ1 = v;
    (slice<byte> b) => fmt.Appendln(b, vʗ1.ꓸꓸꓸ));
}

// Fatal is equivalent to [Print] followed by a call to [os.Exit](1).
public static void Fatal(params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    std.Output(2, fmt.Sprint(v.ꓸꓸꓸ));
    os.Exit(1);
}

// Fatalf is equivalent to [Printf] followed by a call to [os.Exit](1).
public static void Fatalf(@string format, params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    std.Output(2, fmt.Sprintf(format, v.ꓸꓸꓸ));
    os.Exit(1);
}

// Fatalln is equivalent to [Println] followed by a call to [os.Exit](1).
public static void Fatalln(params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    std.Output(2, fmt.Sprintln(v.ꓸꓸꓸ));
    os.Exit(1);
}

// Panic is equivalent to [Print] followed by a call to panic().
public static void Panic(params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    @string s = fmt.Sprint(v.ꓸꓸꓸ);
    std.Output(2, s);
    throw panic(s);
}

// Panicf is equivalent to [Printf] followed by a call to panic().
public static void Panicf(@string format, params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    @string s = fmt.Sprintf(format, v.ꓸꓸꓸ);
    std.Output(2, s);
    throw panic(s);
}

// Panicln is equivalent to [Println] followed by a call to panic().
public static void Panicln(params ꓸꓸꓸany vʗp) {
    var v = vʗp.slice();

    @string s = fmt.Sprintln(v.ꓸꓸꓸ);
    std.Output(2, s);
    throw panic(s);
}

// Output writes the output for a logging event. The string s contains
// the text to print after the prefix specified by the flags of the
// Logger. A newline is appended if the last character of s is not
// already a newline. Calldepth is the count of the number of
// frames to skip when computing the file name and line number
// if [Llongfile] or [Lshortfile] is set; a value of 1 will print the details
// for the caller of Output.
public static error Output(nint calldepth, @string s) {
    return std.Output(calldepth + 1, s);
}

// +1 for this frame.

} // end log_package
