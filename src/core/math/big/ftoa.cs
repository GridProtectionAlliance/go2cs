// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements Float-to-string conversion functions.
// It is closely following the corresponding implementation
// in strconv/ftoa.go, but modified and simplified for Float.
namespace go.math;

using bytes = bytes_package;
using fmt = fmt_package;
using strconv = strconv_package;

partial class big_package {

// Text converts the floating-point number x to a string according
// to the given format and precision prec. The format is one of:
//
//	'e'	-d.dddde±dd, decimal exponent, at least two (possibly 0) exponent digits
//	'E'	-d.ddddE±dd, decimal exponent, at least two (possibly 0) exponent digits
//	'f'	-ddddd.dddd, no exponent
//	'g'	like 'e' for large exponents, like 'f' otherwise
//	'G'	like 'E' for large exponents, like 'f' otherwise
//	'x'	-0xd.dddddp±dd, hexadecimal mantissa, decimal power of two exponent
//	'p'	-0x.dddp±dd, hexadecimal mantissa, decimal power of two exponent (non-standard)
//	'b'	-ddddddp±dd, decimal mantissa, decimal power of two exponent (non-standard)
//
// For the power-of-two exponent formats, the mantissa is printed in normalized form:
//
//	'x'	hexadecimal mantissa in [1, 2), or 0
//	'p'	hexadecimal mantissa in [½, 1), or 0
//	'b'	decimal integer mantissa using x.Prec() bits, or 0
//
// Note that the 'x' form is the one used by most other languages and libraries.
//
// If format is a different character, Text returns a "%" followed by the
// unrecognized format character.
//
// The precision prec controls the number of digits (excluding the exponent)
// printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats.
// For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point.
// For 'g' and 'G' it is the total number of digits. A negative precision selects
// the smallest number of decimal digits necessary to identify the value x uniquely
// using x.Prec() mantissa bits.
// The prec value is ignored for the 'b' and 'p' formats.
[GoRecv] public static @string Text(this ref Float x, byte format, nint prec) {
    nint cap = 10;
    // TODO(gri) determine a good/better value here
    if (prec > 0) {
        cap += prec;
    }
    return ((@string)x.Append(new slice<byte>(0, cap), format, prec));
}

// String formats x like x.Text('g', 10).
// (String must be called explicitly, [Float.Format] does not support %s verb.)
[GoRecv] public static @string String(this ref Float x) {
    return x.Text((rune)'g', 10);
}

// Append appends to buf the string form of the floating-point number x,
// as generated by x.Text, and returns the extended buffer.
[GoRecv] public static slice<byte> Append(this ref Float x, slice<byte> buf, byte fmt, nint prec) {
    // sign
    if (x.neg) {
        buf = append(buf, (rune)'-');
    }
    // Inf
    if (x.form == inf) {
        if (!x.neg) {
            buf = append(buf, (rune)'+');
        }
        return append(buf, "Inf"u8.ꓸꓸꓸ);
    }
    // pick off easy formats
    switch (fmt) {
    case (rune)'b': {
        return x.fmtB(buf);
    }
    case (rune)'p': {
        return x.fmtP(buf);
    }
    case (rune)'x': {
        return x.fmtX(buf, prec);
    }}

    // Algorithm:
    //   1) convert Float to multiprecision decimal
    //   2) round to desired precision
    //   3) read digits out and format
    // 1) convert Float to multiprecision decimal
    ref var d = ref heap(new @decimal(), out var Ꮡd);               // == 0.0
    if (x.form == finite) {
        // x != 0
        d.init(x.mant, ((nint)x.exp) - x.mant.bitLen());
    }
    // 2) round to desired precision
    var shortest = false;
    if (prec < 0){
        shortest = true;
        roundShortest(Ꮡd, x);
        // Precision for shortest representation mode.
        switch (fmt) {
        case (rune)'e' or (rune)'E': {
            prec = len(d.mant) - 1;
            break;
        }
        case (rune)'f': {
            prec = max(len(d.mant) - d.exp, 0);
            break;
        }
        case (rune)'g' or (rune)'G': {
            prec = len(d.mant);
            break;
        }}

    } else {
        // round appropriately
        switch (fmt) {
        case (rune)'e' or (rune)'E': {
            d.round(1 + prec);
            break;
        }
        case (rune)'f': {
            d.round(d.exp + prec);
            break;
        }
        case (rune)'g' or (rune)'G': {
            if (prec == 0) {
                // one digit before and number of digits after decimal point
                // number of digits before and after decimal point
                prec = 1;
            }
            d.round(prec);
            break;
        }}

    }
    // 3) read digits out and format
    switch (fmt) {
    case (rune)'e' or (rune)'E': {
        return fmtE(buf, fmt, prec, d);
    }
    case (rune)'f': {
        return fmtF(buf, prec, d);
    }
    case (rune)'g' or (rune)'G': {
        nint eprec = prec;
        if (eprec > len(d.mant) && len(d.mant) >= d.exp) {
            // trim trailing fractional zeros in %e format
            eprec = len(d.mant);
        }
        if (shortest) {
            // %e is used if the exponent from the conversion
            // is less than -4 or greater than or equal to the precision.
            // If precision was the shortest possible, use eprec = 6 for
            // this decision.
            eprec = 6;
        }
        nint exp = d.exp - 1;
        if (exp < -4 || exp >= eprec) {
            if (prec > len(d.mant)) {
                prec = len(d.mant);
            }
            return fmtE(buf, fmt + (rune)'e' - (rune)'g', prec - 1, d);
        }
        if (prec > d.exp) {
            prec = len(d.mant);
        }
        return fmtF(buf, max(prec - d.exp, 0), d);
    }}

    // unknown format
    if (x.neg) {
        buf = buf[..(int)(len(buf) - 1)];
    }
    // sign was added prematurely - remove it again
    return append(buf, (rune)'%', fmt);
}

internal static void roundShortest(ж<@decimal> Ꮡd, ж<Float> Ꮡx) {
    ref var d = ref Ꮡd.val;
    ref var x = ref Ꮡx.val;

    // if the mantissa is zero, the number is zero - stop now
    if (len(d.mant) == 0) {
        return;
    }
    // Approach: All numbers in the interval [x - 1/2ulp, x + 1/2ulp]
    // (possibly exclusive) round to x for the given precision of x.
    // Compute the lower and upper bound in decimal form and find the
    // shortest decimal number d such that lower <= d <= upper.
    // TODO(gri) strconv/ftoa.do describes a shortcut in some cases.
    // See if we can use it (in adjusted form) here as well.
    // 1) Compute normalized mantissa mant and exponent exp for x such
    // that the lsb of mant corresponds to 1/2 ulp for the precision of
    // x (i.e., for mant we want x.prec + 1 bits).
    var mant = ((nat)default!).set(x.mant);
    nint exp = ((nint)x.exp) - mant.bitLen();
    nint s = mant.bitLen() - ((nint)(x.prec + 1));
    switch (ᐧ) {
    case {} when s is < 0: {
        mant = mant.shl(mant, ((nuint)(-s)));
        break;
    }
    case {} when s is > 0: {
        mant = mant.shr(mant, ((nuint)(+s)));
        break;
    }}

    exp += s;
    // x = mant * 2**exp with lsb(mant) == 1/2 ulp of x.prec
    // 2) Compute lower bound by subtracting 1/2 ulp.
    @decimal lower = default!;
    nat tmp = default!;
    lower.init(tmp.sub(mant, natOne), exp);
    // 3) Compute upper bound by adding 1/2 ulp.
    @decimal upper = default!;
    upper.init(tmp.add(mant, natOne), exp);
    // The upper and lower bounds are possible outputs only if
    // the original mantissa is even, so that ToNearestEven rounding
    // would round to the original mantissa and not the neighbors.
    var inclusive = (Word)(mant[0] & 2) == 0;
    // test bit 1 since original mantissa was shifted by 1
    // Now we can figure out the minimum number of digits required.
    // Walk along until d has distinguished itself from upper and lower.
    foreach (var (i, m) in d.mant) {
        var l = lower.at(i);
        var u = upper.at(i);
        // Okay to round down (truncate) if lower has a different digit
        // or if lower is inclusive and is exactly the result of rounding
        // down (i.e., and we have reached the final digit of lower).
        var okdown = l != m || inclusive && i + 1 == len(lower.mant);
        // Okay to round up if upper has a different digit and either upper
        // is inclusive or upper is bigger than the result of rounding up.
        var okup = m != u && (inclusive || m + 1 < u || i + 1 < len(upper.mant));
        // If it's okay to do either, then round to the nearest one.
        // If it's okay to do only one, do it.
        switch (ᐧ) {
        case {} when okdown && okup: {
            d.round(i + 1);
            return;
        }
        case {} when okdown: {
            d.roundDown(i + 1);
            return;
        }
        case {} when okup: {
            d.roundUp(i + 1);
            return;
        }}

    }
}

// %e: d.ddddde±dd
internal static slice<byte> fmtE(slice<byte> buf, byte fmt, nint prec, @decimal d) {
    // first digit
    var ch = ((byte)(rune)'0');
    if (len(d.mant) > 0) {
        ch = d.mant[0];
    }
    buf = append(buf, ch);
    // .moredigits
    if (prec > 0) {
        buf = append(buf, (rune)'.');
        nint i = 1;
        nint m = min(len(d.mant), prec + 1);
        if (i < m) {
            buf = append(buf, d.mant[(int)(i)..(int)(m)].ꓸꓸꓸ);
            i = m;
        }
        for (; i <= prec; i++) {
            buf = append(buf, (rune)'0');
        }
    }
    // e±
    buf = append(buf, fmt);
    int64 exp = default!;
    if (len(d.mant) > 0) {
        exp = ((int64)d.exp) - 1;
    }
    // -1 because first digit was printed before '.'
    if (exp < 0){
        ch = (rune)'-';
        exp = -exp;
    } else {
        ch = (rune)'+';
    }
    buf = append(buf, ch);
    // dd...d
    if (exp < 10) {
        buf = append(buf, (rune)'0');
    }
    // at least 2 exponent digits
    return strconv.AppendInt(buf, exp, 10);
}

// %f: ddddddd.ddddd
internal static slice<byte> fmtF(slice<byte> buf, nint prec, @decimal d) {
    // integer, padded with zeros as needed
    if (d.exp > 0){
        nint m = min(len(d.mant), d.exp);
        buf = append(buf, d.mant[..(int)(m)].ꓸꓸꓸ);
        for (; m < d.exp; m++) {
            buf = append(buf, (rune)'0');
        }
    } else {
        buf = append(buf, (rune)'0');
    }
    // fraction
    if (prec > 0) {
        buf = append(buf, (rune)'.');
        for (nint i = 0; i < prec; i++) {
            buf = append(buf, d.at(d.exp + i));
        }
    }
    return buf;
}

// fmtB appends the string of x in the format mantissa "p" exponent
// with a decimal mantissa and a binary exponent, or 0" if x is zero,
// and returns the extended buffer.
// The mantissa is normalized such that is uses x.Prec() bits in binary
// representation.
// The sign of x is ignored, and x must not be an Inf.
// (The caller handles Inf before invoking fmtB.)
[GoRecv] internal static slice<byte> fmtB(this ref Float x, slice<byte> buf) {
    if (x.form == zero) {
        return append(buf, (rune)'0');
    }
    if (debugFloat && x.form != finite) {
        throw panic("non-finite float");
    }
    // x != 0
    // adjust mantissa to use exactly x.prec bits
    var m = x.mant;
    {
        var w = ((uint32)len(x.mant)) * _W;
        switch (ᐧ) {
        case {} when w is < x.prec: {
            m = ((nat)default!).shl(m, ((nuint)(x.prec - w)));
            break;
        }
        case {} when w is > x.prec: {
            m = ((nat)default!).shr(m, ((nuint)(w - x.prec)));
            break;
        }}
    }

    buf = append(buf, m.utoa(10).ꓸꓸꓸ);
    buf = append(buf, (rune)'p');
    var e = ((int64)x.exp) - ((int64)x.prec);
    if (e >= 0) {
        buf = append(buf, (rune)'+');
    }
    return strconv.AppendInt(buf, e, 10);
}

// fmtX appends the string of x in the format "0x1." mantissa "p" exponent
// with a hexadecimal mantissa and a binary exponent, or "0x0p0" if x is zero,
// and returns the extended buffer.
// A non-zero mantissa is normalized such that 1.0 <= mantissa < 2.0.
// The sign of x is ignored, and x must not be an Inf.
// (The caller handles Inf before invoking fmtX.)
[GoRecv] internal static slice<byte> fmtX(this ref Float x, slice<byte> buf, nint prec) {
    if (x.form == zero) {
        buf = append(buf, "0x0"u8.ꓸꓸꓸ);
        if (prec > 0) {
            buf = append(buf, (rune)'.');
            for (nint i = 0; i < prec; i++) {
                buf = append(buf, (rune)'0');
            }
        }
        buf = append(buf, "p+00"u8.ꓸꓸꓸ);
        return buf;
    }
    if (debugFloat && x.form != finite) {
        throw panic("non-finite float");
    }
    // round mantissa to n bits
    nuint n = default!;
    if (prec < 0){
        n = 1 + (x.MinPrec() - 1 + 3) / 4 * 4;
    } else {
        // round MinPrec up to 1 mod 4
        n = 1 + 4 * ((nuint)prec);
    }
    // n%4 == 1
    x = @new<Float>().SetPrec(n).SetMode(x.mode).Set(x);
    // adjust mantissa to use exactly n bits
    var m = x.mant;
    {
        nuint w = ((nuint)len(x.mant)) * _W;
        switch (ᐧ) {
        case {} when w is < n: {
            m = ((nat)default!).shl(m, n - w);
            break;
        }
        case {} when w is > n: {
            m = ((nat)default!).shr(m, w - n);
            break;
        }}
    }

    var exp64 = ((int64)x.exp) - 1;
    // avoid wrap-around
    var hm = m.utoa(16);
    if (debugFloat && hm[0] != (rune)'1') {
        throw panic("incorrect mantissa: "u8 + ((@string)hm));
    }
    buf = append(buf, "0x1"u8.ꓸꓸꓸ);
    if (len(hm) > 1) {
        buf = append(buf, (rune)'.');
        buf = append(buf, hm[1..].ꓸꓸꓸ);
    }
    buf = append(buf, (rune)'p');
    if (exp64 >= 0){
        buf = append(buf, (rune)'+');
    } else {
        exp64 = -exp64;
        buf = append(buf, (rune)'-');
    }
    // Force at least two exponent digits, to match fmt.
    if (exp64 < 10) {
        buf = append(buf, (rune)'0');
    }
    return strconv.AppendInt(buf, exp64, 10);
}

// fmtP appends the string of x in the format "0x." mantissa "p" exponent
// with a hexadecimal mantissa and a binary exponent, or "0" if x is zero,
// and returns the extended buffer.
// The mantissa is normalized such that 0.5 <= 0.mantissa < 1.0.
// The sign of x is ignored, and x must not be an Inf.
// (The caller handles Inf before invoking fmtP.)
[GoRecv] internal static slice<byte> fmtP(this ref Float x, slice<byte> buf) {
    if (x.form == zero) {
        return append(buf, (rune)'0');
    }
    if (debugFloat && x.form != finite) {
        throw panic("non-finite float");
    }
    // x != 0
    // remove trailing 0 words early
    // (no need to convert to hex 0's and trim later)
    var m = x.mant;
    nint i = 0;
    while (i < len(m) && m[i] == 0) {
        i++;
    }
    m = m[(int)(i)..];
    buf = append(buf, "0x."u8.ꓸꓸꓸ);
    buf = append(buf, bytes.TrimRight(m.utoa(16), "0"u8).ꓸꓸꓸ);
    buf = append(buf, (rune)'p');
    if (x.exp >= 0) {
        buf = append(buf, (rune)'+');
    }
    return strconv.AppendInt(buf, ((int64)x.exp), 10);
}

internal static fmt.Formatter Δ_ = Ꮡ(floatZero); // *Float must implement fmt.Formatter

// Format implements [fmt.Formatter]. It accepts all the regular
// formats for floating-point numbers ('b', 'e', 'E', 'f', 'F',
// 'g', 'G', 'x') as well as 'p' and 'v'. See (*Float).Text for the
// interpretation of 'p'. The 'v' format is handled like 'g'.
// Format also supports specification of the minimum precision
// in digits, the output field width, as well as the format flags
// '+' and ' ' for sign control, '0' for space or zero padding,
// and '-' for left or right justification. See the fmt package
// for details.
[GoRecv] public static void Format(this ref Float x, fmt.State s, rune format) {
    var (prec, hasPrec) = s.Precision();
    if (!hasPrec) {
        prec = 6;
    }
    // default precision for 'e', 'f'
    var exprᴛ1 = format;
    var matchᴛ1 = false;
    if (exprᴛ1 is (rune)'e' or (rune)'E' or (rune)'f' or (rune)'b' or (rune)'p' or (rune)'x') { matchᴛ1 = true;
    }
    else if (exprᴛ1 is (rune)'F') { matchᴛ1 = true;
        format = (rune)'f';
    }
    else if (exprᴛ1 is (rune)'v') { matchᴛ1 = true;
        format = (rune)'g';
        fallthrough = true;
    }
    if (fallthrough || !matchᴛ1 && (exprᴛ1 is (rune)'g' or (rune)'G')) {
        if (!hasPrec) {
            // nothing to do
            // (*Float).Text doesn't support 'F'; handle like 'f'
            // handle like 'g'
            prec = -1;
        }
    }
    else { /* default: */
        fmt.Fprintf(s, // default precision for 'g', 'G'
 "%%!%c(*big.Float=%s)"u8, format, x.String());
        return;
    }

    slice<byte> buf = default!;
    buf = x.Append(buf, ((byte)format), prec);
    if (len(buf) == 0) {
        buf = slice<byte>("?");
    }
    // should never happen, but don't crash
    // len(buf) > 0
    @string sign = default!;
    switch (ᐧ) {
    case {} when buf[0] is (rune)'-': {
        sign = "-"u8;
        buf = buf[1..];
        break;
    }
    case {} when buf[0] is (rune)'+': {
        sign = "+"u8;
        if (s.Flag((rune)' ')) {
            // +Inf
            sign = " "u8;
        }
        buf = buf[1..];
        break;
    }
    case {} when s.Flag((rune)'+'): {
        sign = "+"u8;
        break;
    }
    case {} when s.Flag((rune)' '): {
        sign = " "u8;
        break;
    }}

    nint padding = default!;
    {
        var (width, hasWidth) = s.Width(); if (hasWidth && width > len(sign) + len(buf)) {
            padding = width - len(sign) - len(buf);
        }
    }
    switch (ᐧ) {
    case {} when s.Flag((rune)'0') && !x.IsInf(): {
        writeMultiple(s, // 0-padding on left
 sign, 1);
        writeMultiple(s, "0"u8, padding);
        s.Write(buf);
        break;
    }
    case {} when s.Flag((rune)'-'): {
        writeMultiple(s, // padding on right
 sign, 1);
        s.Write(buf);
        writeMultiple(s, " "u8, padding);
        break;
    }
    default: {
        writeMultiple(s, // padding on left
 " "u8, padding);
        writeMultiple(s, sign, 1);
        s.Write(buf);
        break;
    }}

}

} // end big_package
