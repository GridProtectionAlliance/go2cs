// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements int-to-string conversion functions.
namespace go.math;

using errors = errors_package;
using fmt = fmt_package;
using io = io_package;

partial class big_package {

// Text returns the string representation of x in the given base.
// Base must be between 2 and 62, inclusive. The result uses the
// lower-case letters 'a' to 'z' for digit values 10 to 35, and
// the upper-case letters 'A' to 'Z' for digit values 36 to 61.
// No prefix (such as "0x") is added to the string. If x is a nil
// pointer it returns "<nil>".
[GoRecv] public static @string Text(this ref ΔInt x, nint @base) {
    if (x == nil) {
        return "<nil>"u8;
    }
    return ((@string)x.abs.itoa(x.neg, @base));
}

// Append appends the string representation of x, as generated by
// x.Text(base), to buf and returns the extended buffer.
[GoRecv] public static slice<byte> Append(this ref ΔInt x, slice<byte> buf, nint @base) {
    if (x == nil) {
        return append(buf, "<nil>"u8.ꓸꓸꓸ);
    }
    return append(buf, x.abs.itoa(x.neg, @base).ꓸꓸꓸ);
}

// String returns the decimal representation of x as generated by
// x.Text(10).
[GoRecv] public static @string String(this ref ΔInt x) {
    return x.Text(10);
}

// write count copies of text to s.
internal static void writeMultiple(fmt.State s, @string text, nint count) {
    if (len(text) > 0) {
        var b = slice<byte>(text);
        for (; count > 0; count--) {
            s.Write(b);
        }
    }
}

internal static fmt.Formatter Δ_ = intOne; // *Int must implement fmt.Formatter

// Format implements [fmt.Formatter]. It accepts the formats
// 'b' (binary), 'o' (octal with 0 prefix), 'O' (octal with 0o prefix),
// 'd' (decimal), 'x' (lowercase hexadecimal), and
// 'X' (uppercase hexadecimal).
// Also supported are the full suite of package fmt's format
// flags for integral types, including '+' and ' ' for sign
// control, '#' for leading zero in octal and for hexadecimal,
// a leading "0x" or "0X" for "%#x" and "%#X" respectively,
// specification of minimum digits precision, output field
// width, space or zero padding, and '-' for left or right
// justification.
[GoRecv] public static void Format(this ref ΔInt x, fmt.State s, rune ch) {
    // determine base
    nint @base = default!;
    switch (ch) {
    case (rune)'b': {
        @base = 2;
        break;
    }
    case (rune)'o' or (rune)'O': {
        @base = 8;
        break;
    }
    case (rune)'d' or (rune)'s' or (rune)'v': {
        @base = 10;
        break;
    }
    case (rune)'x' or (rune)'X': {
        @base = 16;
        break;
    }
    default: {
        fmt.Fprintf(s, // unknown format
 "%%!%c(big.Int=%s)"u8, ch, x.String());
        return;
    }}

    if (x == nil) {
        fmt.Fprint(s, "<nil>");
        return;
    }
    // determine sign character
    @string sign = ""u8;
    switch (ᐧ) {
    case {} when x.neg: {
        sign = "-"u8;
        break;
    }
    case {} when s.Flag((rune)'+'): {
        sign = "+"u8;
        break;
    }
    case {} when s.Flag((rune)' '): {
        sign = " "u8;
        break;
    }}

    // supersedes ' ' when both specified
    // determine prefix characters for indicating output base
    @string prefix = ""u8;
    if (s.Flag((rune)'#')) {
        switch (ch) {
        case (rune)'b': {
            prefix = "0b"u8;
            break;
        }
        case (rune)'o': {
            prefix = "0"u8;
            break;
        }
        case (rune)'x': {
            prefix = "0x"u8;
            break;
        }
        case (rune)'X': {
            prefix = "0X"u8;
            break;
        }}

    }
    // binary
    // octal
    // hexadecimal
    if (ch == (rune)'O') {
        prefix = "0o"u8;
    }
    var digits = x.abs.utoa(@base);
    if (ch == (rune)'X') {
        // faster than bytes.ToUpper
        foreach (var (i, d) in digits) {
            if ((rune)'a' <= d && d <= (rune)'z') {
                digits[i] = (rune)'A' + (d - (rune)'a');
            }
        }
    }
    // number of characters for the three classes of number padding
    nint left = default!;     // space characters to left of digits for right justification ("%8d")
    nint zeros = default!;   // zero characters (actually cs[0]) as left-most digits ("%.8d")
    nint right = default!;   // space characters to right of digits for left justification ("%-8d")
    // determine number padding from precision: the least number of digits to output
    var (precision, precisionSet) = s.Precision();
    if (precisionSet) {
        switch (ᐧ) {
        case {} when len(digits) is < precision: {
            zeros = precision - len(digits);
            break;
        }
        case {} when len(digits) == 1 && digits[0] == (rune)'0' && precision == 0: {
            return;
        }}

    }
    // count of zero padding
    // print nothing if zero value (x == 0) and zero precision ("." or ".0")
    // determine field pad from width: the least number of characters to output
    nint length = len(sign) + len(prefix) + zeros + len(digits);
    {
        var (width, widthSet) = s.Width(); if (widthSet && length < width) {
            // pad as specified
            {
                nint d = width - length;
                switch (ᐧ) {
                case {} when s.Flag((rune)'-'): {
                    right = d;
                    break;
                }
                case {} when s.Flag((rune)'0') && !precisionSet: {
                    zeros = d;
                    break;
                }
                default: {
                    left = d;
                    break;
                }}
            }

        }
    }
    // pad on the right with spaces; supersedes '0' when both specified
    // pad with zeros unless precision also specified
    // pad on the left with spaces
    // print number as [left pad][sign][prefix][zero pad][digits][right pad]
    writeMultiple(s, " "u8, left);
    writeMultiple(s, sign, 1);
    writeMultiple(s, prefix, 1);
    writeMultiple(s, "0"u8, zeros);
    s.Write(digits);
    writeMultiple(s, " "u8, right);
}

// scan sets z to the integer value corresponding to the longest possible prefix
// read from r representing a signed integer number in a given conversion base.
// It returns z, the actual conversion base used, and an error, if any. In the
// error case, the value of z is undefined but the returned value is nil. The
// syntax follows the syntax of integer literals in Go.
//
// The base argument must be 0 or a value from 2 through MaxBase. If the base
// is 0, the string prefix determines the actual conversion base. A prefix of
// “0b” or “0B” selects base 2; a “0”, “0o”, or “0O” prefix selects
// base 8, and a “0x” or “0X” prefix selects base 16. Otherwise the selected
// base is 10.
[GoRecv("capture")] internal static (ж<ΔInt>, nint, error) scan(this ref ΔInt z, io.ByteScanner r, nint @base) {
    // determine sign
    var (neg, err) = scanSign(r);
    if (err != default!) {
        return (default!, 0, err);
    }
    // determine mantissa
    (z.abs, @base, Δ_, err) = z.abs.scan(r, @base, false);
    if (err != default!) {
        return (default!, @base, err);
    }
    z.neg = len(z.abs) > 0 && neg;
    // 0 has no sign
    return (scanꓸᏑz, @base, default!);
}

internal static (bool neg, error err) scanSign(io.ByteScanner r) {
    bool neg = default!;
    error err = default!;

    byte ch = default!;
    {
        (ch, err) = r.ReadByte(); if (err != default!) {
            return (false, err);
        }
    }
    switch (ch) {
    case (rune)'-': {
        neg = true;
        break;
    }
    case (rune)'+': {
        break;
    }
    default: {
        r.UnreadByte();
        break;
    }}

    // nothing to do
    return (neg, err);
}

// byteReader is a local wrapper around fmt.ScanState;
// it implements the ByteReader interface.
[GoType] partial struct byteReader {
    public partial ref fmt_package.ScanState ScanState { get; }
}

internal static (byte, error) ReadByte(this byteReader r) {
    var (ch, size, err) = r.ReadRune();
    if (size != 1 && err == default!) {
        err = fmt.Errorf("invalid rune %#U"u8, ch);
    }
    return (((byte)ch), err);
}

internal static error UnreadByte(this byteReader r) {
    return r.UnreadRune();
}

internal static fmt.Scanner Δ_ = intOne; // *Int must implement fmt.Scanner

// Scan is a support routine for [fmt.Scanner]; it sets z to the value of
// the scanned number. It accepts the formats 'b' (binary), 'o' (octal),
// 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).
[GoRecv] public static error Scan(this ref ΔInt z, fmt.ScanState s, rune ch) {
    s.SkipSpace();
    // skip leading space characters
    nint @base = 0;
    switch (ch) {
    case (rune)'b': {
        @base = 2;
        break;
    }
    case (rune)'o': {
        @base = 8;
        break;
    }
    case (rune)'d': {
        @base = 10;
        break;
    }
    case (rune)'x' or (rune)'X': {
        @base = 16;
        break;
    }
    case (rune)'s' or (rune)'v': {
        break;
    }
    default: {
        return errors.New("Int.Scan: invalid verb"u8);
    }}

    // let scan determine the base
    var (Δ_, Δ_, err) = z.scan(new byteReader(s), @base);
    return err;
}

} // end big_package
