// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package rand implements pseudo-random number generators suitable for tasks
// such as simulation, but it should not be used for security-sensitive work.
//
// Random numbers are generated by a [Source], usually wrapped in a [Rand].
// Both types should be used by a single goroutine at a time: sharing among
// multiple goroutines requires some kind of synchronization.
//
// Top-level functions, such as [Float64] and [Int],
// are safe for concurrent use by multiple goroutines.
//
// This package's outputs might be easily predictable regardless of how it's
// seeded. For random numbers suitable for security-sensitive work, see the
// [crypto/rand] package.
namespace go.math.rand;

using bits = math.bits_package;
using _ = unsafe_package; // for go:linkname
using math;

partial class rand_package {

// A Source is a source of uniformly-distributed
// pseudo-random uint64 values in the range [0, 1<<64).
//
// A Source is not safe for concurrent use by multiple goroutines.
[GoType] partial interface Source {
    uint64 Uint64();
}

// A Rand is a source of random numbers.
[GoType] partial struct Rand {
    internal Source src;
}

// New returns a new Rand that uses random values from src
// to generate other random values.
public static ж<Rand> New(Source src) {
    return Ꮡ(new Rand(src: src));
}

// Int64 returns a non-negative pseudo-random 63-bit integer as an int64.
[GoRecv] public static int64 Int64(this ref Rand r) {
    return ((int64)((uint64)(r.src.Uint64() & ~(1 << (int)(63)))));
}

// Uint32 returns a pseudo-random 32-bit value as a uint32.
[GoRecv] public static uint32 Uint32(this ref Rand r) {
    return ((uint32)(r.src.Uint64() >> (int)(32)));
}

// Uint64 returns a pseudo-random 64-bit value as a uint64.
[GoRecv] public static uint64 Uint64(this ref Rand r) {
    return r.src.Uint64();
}

// Int32 returns a non-negative pseudo-random 31-bit integer as an int32.
[GoRecv] public static int32 Int32(this ref Rand r) {
    return ((int32)(r.src.Uint64() >> (int)(33)));
}

// Int returns a non-negative pseudo-random int.
[GoRecv] public static nint Int(this ref Rand r) {
    return ((nint)(((nuint)r.src.Uint64()) << (int)(1) >> (int)(1)));
}

// Uint returns a pseudo-random uint.
[GoRecv] public static nuint Uint(this ref Rand r) {
    return ((nuint)r.src.Uint64());
}

// Int64N returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n).
// It panics if n <= 0.
[GoRecv] public static int64 Int64N(this ref Rand r, int64 n) {
    if (n <= 0) {
        throw panic("invalid argument to Int64N");
    }
    return ((int64)r.uint64n(((uint64)n)));
}

// Uint64N returns, as a uint64, a non-negative pseudo-random number in the half-open interval [0,n).
// It panics if n == 0.
[GoRecv] public static uint64 Uint64N(this ref Rand r, uint64 n) {
    if (n == 0) {
        throw panic("invalid argument to Uint64N");
    }
    return r.uint64n(n);
}

// uint64n is the no-bounds-checks version of Uint64N.
[GoRecv] internal static uint64 uint64n(this ref Rand r, uint64 n) {
    if (is32bit && ((uint64)((uint32)n)) == n) {
        return ((uint64)r.uint32n(((uint32)n)));
    }
    if ((uint64)(n & (n - 1)) == 0) {
        // n is power of two, can mask
        return (uint64)(r.Uint64() & (n - 1));
    }
    // Suppose we have a uint64 x uniform in the range [0,2⁶⁴)
    // and want to reduce it to the range [0,n) preserving exact uniformity.
    // We can simulate a scaling arbitrary precision x * (n/2⁶⁴) by
    // the high bits of a double-width multiply of x*n, meaning (x*n)/2⁶⁴.
    // Since there are 2⁶⁴ possible inputs x and only n possible outputs,
    // the output is necessarily biased if n does not divide 2⁶⁴.
    // In general (x*n)/2⁶⁴ = k for x*n in [k*2⁶⁴,(k+1)*2⁶⁴).
    // There are either floor(2⁶⁴/n) or ceil(2⁶⁴/n) possible products
    // in that range, depending on k.
    // But suppose we reject the sample and try again when
    // x*n is in [k*2⁶⁴, k*2⁶⁴+(2⁶⁴%n)), meaning rejecting fewer than n possible
    // outcomes out of the 2⁶⁴.
    // Now there are exactly floor(2⁶⁴/n) possible ways to produce
    // each output value k, so we've restored uniformity.
    // To get valid uint64 math, 2⁶⁴ % n = (2⁶⁴ - n) % n = -n % n,
    // so the direct implementation of this algorithm would be:
    //
    //	hi, lo := bits.Mul64(r.Uint64(), n)
    //	thresh := -n % n
    //	for lo < thresh {
    //		hi, lo = bits.Mul64(r.Uint64(), n)
    //	}
    //
    // That still leaves an expensive 64-bit division that we would rather avoid.
    // We know that thresh < n, and n is usually much less than 2⁶⁴, so we can
    // avoid the last four lines unless lo < n.
    //
    // See also:
    // https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction
    // https://lemire.me/blog/2016/06/30/fast-random-shuffling
    var (hi, lo) = bits.Mul64(r.Uint64(), n);
    if (lo < n) {
        var thresh = -n % n;
        while (lo < thresh) {
            (hi, lo) = bits.Mul64(r.Uint64(), n);
        }
    }
    return hi;
}

// uint32n is an identical computation to uint64n
// but optimized for 32-bit systems.
[GoRecv] internal static uint32 uint32n(this ref Rand r, uint32 n) {
    if ((uint32)(n & (n - 1)) == 0) {
        // n is power of two, can mask
        return (uint32)(((uint32)r.Uint64()) & (n - 1));
    }
    // On 64-bit systems we still use the uint64 code below because
    // the probability of a random uint64 lo being < a uint32 n is near zero,
    // meaning the unbiasing loop almost never runs.
    // On 32-bit systems, here we need to implement that same logic in 32-bit math,
    // both to preserve the exact output sequence observed on 64-bit machines
    // and to preserve the optimization that the unbiasing loop almost never runs.
    //
    // We want to compute
    // 	hi, lo := bits.Mul64(r.Uint64(), n)
    // In terms of 32-bit halves, this is:
    // 	x1:x0 := r.Uint64()
    // 	0:hi, lo1:lo0 := bits.Mul64(x1:x0, 0:n)
    // Writing out the multiplication in terms of bits.Mul32 allows
    // using direct hardware instructions and avoiding
    // the computations involving these zeros.
    var x = r.Uint64();
    var (lo1a, lo0) = bits.Mul32(((uint32)x), n);
    var (hi, lo1b) = bits.Mul32(((uint32)(x >> (int)(32))), n);
    var (lo1, c) = bits.Add32(lo1a, lo1b, 0);
    hi += c;
    if (lo1 == 0 && lo0 < ((uint32)n)) {
        var n64 = ((uint64)n);
        var thresh = ((uint32)(-n64 % n64));
        while (lo1 == 0 && lo0 < thresh) {
            var xΔ1 = r.Uint64();
            (lo1a, lo0) = bits.Mul32(((uint32)xΔ1), n);
            (hi, lo1b) = bits.Mul32(((uint32)(xΔ1 >> (int)(32))), n);
            (lo1, c) = bits.Add32(lo1a, lo1b, 0);
            hi += c;
        }
    }
    return hi;
}

// Int32N returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n).
// It panics if n <= 0.
[GoRecv] public static int32 Int32N(this ref Rand r, int32 n) {
    if (n <= 0) {
        throw panic("invalid argument to Int32N");
    }
    return ((int32)r.uint64n(((uint64)n)));
}

// Uint32N returns, as a uint32, a non-negative pseudo-random number in the half-open interval [0,n).
// It panics if n == 0.
[GoRecv] public static uint32 Uint32N(this ref Rand r, uint32 n) {
    if (n == 0) {
        throw panic("invalid argument to Uint32N");
    }
    return ((uint32)r.uint64n(((uint64)n)));
}

internal const bool is32bit = /* ^uint(0)>>32 == 0 */ false;

// IntN returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n).
// It panics if n <= 0.
[GoRecv] public static nint IntN(this ref Rand r, nint n) {
    if (n <= 0) {
        throw panic("invalid argument to IntN");
    }
    return ((nint)r.uint64n(((uint64)n)));
}

// UintN returns, as a uint, a non-negative pseudo-random number in the half-open interval [0,n).
// It panics if n == 0.
[GoRecv] public static nuint UintN(this ref Rand r, nuint n) {
    if (n == 0) {
        throw panic("invalid argument to UintN");
    }
    return ((nuint)r.uint64n(((uint64)n)));
}

// Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0).
[GoRecv] public static float64 Float64(this ref Rand r) {
    // There are exactly 1<<53 float64s in [0,1). Use Intn(1<<53) / (1<<53).
    return ((float64)(r.Uint64() << (int)(11) >> (int)(11))) / (1 << (int)(53));
}

// Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0).
[GoRecv] public static float32 Float32(this ref Rand r) {
    // There are exactly 1<<24 float32s in [0,1). Use Intn(1<<24) / (1<<24).
    return ((float32)(r.Uint32() << (int)(8) >> (int)(8))) / (1 << (int)(24));
}

// Perm returns, as a slice of n ints, a pseudo-random permutation of the integers
// in the half-open interval [0,n).
[GoRecv] public static slice<nint> Perm(this ref Rand r, nint n) {
    var p = new slice<nint>(n);
    foreach (var (i, _) in p) {
        p[i] = i;
    }
    r.Shuffle(len(p), 
    var pʗ1 = p;
    (nint i, nint j) => {
        (pʗ1[i], pʗ1[j]) = (pʗ1[j], pʗ1[i]);
    });
    return p;
}

// Shuffle pseudo-randomizes the order of elements.
// n is the number of elements. Shuffle panics if n < 0.
// swap swaps the elements with indexes i and j.
[GoRecv] public static void Shuffle(this ref Rand r, nint n, Action<nint, nint> swap) {
    if (n < 0) {
        throw panic("invalid argument to Shuffle");
    }
    // Fisher-Yates shuffle: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
    // Shuffle really ought not be called with n that doesn't fit in 32 bits.
    // Not only will it take a very long time, but with 2³¹! possible permutations,
    // there's no way that any PRNG can have a big enough internal state to
    // generate even a minuscule percentage of the possible permutations.
    // Nevertheless, the right API signature accepts an int n, so handle it as best we can.
    for (nint i = n - 1; i > 0; i--) {
        nint j = ((nint)r.uint64n(((uint64)(i + 1))));
        swap(i, j);
    }
}

/*
 * Top-level convenience functions
 */

// globalRand is the source of random numbers for the top-level
// convenience functions.
internal static ж<Rand> globalRand = Ꮡ(new Rand(src: new runtimeSource(nil)));

//go:linkname runtime_rand runtime.rand
internal static partial uint64 runtime_rand();

// runtimeSource is a Source that uses the runtime fastrand functions.
[GoType] partial struct runtimeSource {
}

internal static uint64 Uint64(this runtimeSource _) {
    return runtime_rand();
}

// Int64 returns a non-negative pseudo-random 63-bit integer as an int64
// from the default Source.
public static int64 Int64() {
    return globalRand.Int64();
}

// Uint32 returns a pseudo-random 32-bit value as a uint32
// from the default Source.
public static uint32 Uint32() {
    return globalRand.Uint32();
}

// Uint64N returns, as a uint64, a pseudo-random number in the half-open interval [0,n)
// from the default Source.
// It panics if n <= 0.
public static uint64 Uint64N(uint64 n) {
    return globalRand.Uint64N(n);
}

// Uint32N returns, as a uint32, a pseudo-random number in the half-open interval [0,n)
// from the default Source.
// It panics if n <= 0.
public static uint32 Uint32N(uint32 n) {
    return globalRand.Uint32N(n);
}

// Uint64 returns a pseudo-random 64-bit value as a uint64
// from the default Source.
public static uint64 Uint64() {
    return globalRand.Uint64();
}

// Int32 returns a non-negative pseudo-random 31-bit integer as an int32
// from the default Source.
public static int32 Int32() {
    return globalRand.Int32();
}

// Int returns a non-negative pseudo-random int from the default Source.
public static nint Int() {
    return globalRand.Int();
}

// Uint returns a pseudo-random uint from the default Source.
public static nuint Uint() {
    return globalRand.Uint();
}

// Int64N returns, as an int64, a pseudo-random number in the half-open interval [0,n)
// from the default Source.
// It panics if n <= 0.
public static int64 Int64N(int64 n) {
    return globalRand.Int64N(n);
}

// Int32N returns, as an int32, a pseudo-random number in the half-open interval [0,n)
// from the default Source.
// It panics if n <= 0.
public static int32 Int32N(int32 n) {
    return globalRand.Int32N(n);
}

// IntN returns, as an int, a pseudo-random number in the half-open interval [0,n)
// from the default Source.
// It panics if n <= 0.
public static nint IntN(nint n) {
    return globalRand.IntN(n);
}

// UintN returns, as a uint, a pseudo-random number in the half-open interval [0,n)
// from the default Source.
// It panics if n <= 0.
public static nuint UintN(nuint n) {
    return globalRand.UintN(n);
}

// N returns a pseudo-random number in the half-open interval [0,n) from the default Source.
// The type parameter Int can be any integer type.
// It panics if n <= 0.
public static Int N<Int>(Int n)
    where Int : /* intType */ IAdditionOperators<Int, Int, Int>, ISubtractionOperators<Int, Int, Int>, IMultiplyOperators<Int, Int, Int>, IDivisionOperators<Int, Int, Int>, IModulusOperators<Int, Int, Int>, IBitwiseOperators<Int, Int, Int>, IShiftOperators<Int, Int, Int>, IEqualityOperators<Int, Int, bool>, IComparisonOperators<Int, Int, bool>, new()
{
    if (n <= 0) {
        throw panic("invalid argument to N");
    }
    return ((Int)globalRand.uint64n(((uint64)n)));
}

[GoType("operators = Sum, Arithmetic, Integer, Comparable, Ordered")]
partial interface intType<ΔT> {
    //  Type constraints: ~int | ~int8 | ~int16 | ~int32 | ~int64 |
	~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr
    // Derived operators: +, -, *, /, %, &, |, ^, <<, >>, ==, !=, <, <=, >, >=
}

// Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0)
// from the default Source.
public static float64 Float64() {
    return globalRand.Float64();
}

// Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0)
// from the default Source.
public static float32 Float32() {
    return globalRand.Float32();
}

// Perm returns, as a slice of n ints, a pseudo-random permutation of the integers
// in the half-open interval [0,n) from the default Source.
public static slice<nint> Perm(nint n) {
    return globalRand.Perm(n);
}

// Shuffle pseudo-randomizes the order of elements using the default Source.
// n is the number of elements. Shuffle panics if n < 0.
// swap swaps the elements with indexes i and j.
public static void Shuffle(nint n, Action<nint, nint> swap) {
    globalRand.Shuffle(n, swap);
}

// NormFloat64 returns a normally distributed float64 in the range
// [-math.MaxFloat64, +math.MaxFloat64] with
// standard normal distribution (mean = 0, stddev = 1)
// from the default Source.
// To produce a different normal distribution, callers can
// adjust the output using:
//
//	sample = NormFloat64() * desiredStdDev + desiredMean
public static float64 NormFloat64() {
    return globalRand.NormFloat64();
}

// ExpFloat64 returns an exponentially distributed float64 in the range
// (0, +math.MaxFloat64] with an exponential distribution whose rate parameter
// (lambda) is 1 and whose mean is 1/lambda (1) from the default Source.
// To produce a distribution with a different rate parameter,
// callers can adjust the output using:
//
//	sample = ExpFloat64() / desiredRateParameter
public static float64 ExpFloat64() {
    return globalRand.ExpFloat64();
}

} // end rand_package
