// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package rand implements pseudo-random number generators suitable for tasks
// such as simulation, but it should not be used for security-sensitive work.
//
// Random numbers are generated by a [Source], usually wrapped in a [Rand].
// Both types should be used by a single goroutine at a time: sharing among
// multiple goroutines requires some kind of synchronization.
//
// Top-level functions, such as [Float64] and [Int],
// are safe for concurrent use by multiple goroutines.
//
// This package's outputs might be easily predictable regardless of how it's
// seeded. For random numbers suitable for security-sensitive work, see the
// crypto/rand package.
namespace go.math;

using godebug = @internal.godebug_package;
using sync = sync_package;
using atomic = sync.atomic_package;
using _ = unsafe_package; // for go:linkname
using @internal;
using sync;

partial class rand_package {

// A Source represents a source of uniformly-distributed
// pseudo-random int64 values in the range [0, 1<<63).
//
// A Source is not safe for concurrent use by multiple goroutines.
[GoType] partial interface Source {
    int64 Int63();
    void Seed(int64 seed);
}

// A Source64 is a [Source] that can also generate
// uniformly-distributed pseudo-random uint64 values in
// the range [0, 1<<64) directly.
// If a [Rand] r's underlying [Source] s implements Source64,
// then r.Uint64 returns the result of one call to s.Uint64
// instead of making two calls to s.Int63.
[GoType] partial interface Source64 :
    Source
{
    uint64 Uint64();
}

// NewSource returns a new pseudo-random [Source] seeded with the given value.
// Unlike the default [Source] used by top-level functions, this source is not
// safe for concurrent use by multiple goroutines.
// The returned [Source] implements [Source64].
public static Source NewSource(int64 seed) {
    return ~newSource(seed);
}

internal static ж<rngSource> newSource(int64 seed) {
    ref var rng = ref heap(new rngSource(), out var Ꮡrng);
    rng.Seed(seed);
    return Ꮡrng;
}

// A Rand is a source of random numbers.
[GoType] partial struct Rand {
    internal Source src;
    internal Source64 s64; // non-nil if src is source64
    // readVal contains remainder of 63-bit integer used for bytes
    // generation during most recent Read call.
    // It is saved so next Read call can start where the previous
    // one finished.
    internal int64 readVal;
    // readPos indicates the number of low-order bytes of readVal
    // that are still valid.
    internal int8 readPos;
}

// New returns a new [Rand] that uses random values from src
// to generate other random values.
public static ж<Rand> New(Source src) {
    var (s64, _) = src._<Source64>(ᐧ);
    return Ꮡ(new Rand(src: src, s64: s64));
}

// Seed uses the provided seed value to initialize the generator to a deterministic state.
// Seed should not be called concurrently with any other [Rand] method.
[GoRecv] public static void Seed(this ref Rand r, int64 seed) {
    {
        var (lk, ok) = r.src._<lockedSource.val>(ᐧ); if (ok) {
            lk.seedPos(seed, Ꮡ(r.readPos));
            return;
        }
    }
    r.src.Seed(seed);
    r.readPos = 0;
}

// Int63 returns a non-negative pseudo-random 63-bit integer as an int64.
[GoRecv] public static int64 Int63(this ref Rand r) {
    return r.src.Int63();
}

// Uint32 returns a pseudo-random 32-bit value as a uint32.
[GoRecv] public static uint32 Uint32(this ref Rand r) {
    return ((uint32)(r.Int63() >> (int)(31)));
}

// Uint64 returns a pseudo-random 64-bit value as a uint64.
[GoRecv] public static uint64 Uint64(this ref Rand r) {
    if (r.s64 != default!) {
        return r.s64.Uint64();
    }
    return (uint64)(((uint64)r.Int63()) >> (int)(31) | ((uint64)r.Int63()) << (int)(32));
}

// Int31 returns a non-negative pseudo-random 31-bit integer as an int32.
[GoRecv] public static int32 Int31(this ref Rand r) {
    return ((int32)(r.Int63() >> (int)(32)));
}

// Int returns a non-negative pseudo-random int.
[GoRecv] public static nint Int(this ref Rand r) {
    nuint u = ((nuint)r.Int63());
    return ((nint)(u << (int)(1) >> (int)(1)));
}

// clear sign bit if int == int32

// Int63n returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n).
// It panics if n <= 0.
[GoRecv] public static int64 Int63n(this ref Rand r, int64 n) {
    if (n <= 0) {
        throw panic("invalid argument to Int63n");
    }
    if ((int64)(n & (n - 1)) == 0) {
        // n is power of two, can mask
        return (int64)(r.Int63() & (n - 1));
    }
    var max = ((int64)((1 << (int)(63)) - 1 - (1 << (int)(63)) % ((uint64)n)));
    var v = r.Int63();
    while (v > max) {
        v = r.Int63();
    }
    return v % n;
}

// Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n).
// It panics if n <= 0.
[GoRecv] public static int32 Int31n(this ref Rand r, int32 n) {
    if (n <= 0) {
        throw panic("invalid argument to Int31n");
    }
    if ((int32)(n & (n - 1)) == 0) {
        // n is power of two, can mask
        return (int32)(r.Int31() & (n - 1));
    }
    var max = ((int32)((1 << (int)(31)) - 1 - (1 << (int)(31)) % ((uint32)n)));
    var v = r.Int31();
    while (v > max) {
        v = r.Int31();
    }
    return v % n;
}

// int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n).
// n must be > 0, but int31n does not check this; the caller must ensure it.
// int31n exists because Int31n is inefficient, but Go 1 compatibility
// requires that the stream of values produced by math/rand remain unchanged.
// int31n can thus only be used internally, by newly introduced APIs.
//
// For implementation details, see:
// https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction
// https://lemire.me/blog/2016/06/30/fast-random-shuffling
[GoRecv] internal static int32 int31n(this ref Rand r, int32 n) {
    var v = r.Uint32();
    var prod = ((uint64)v) * ((uint64)n);
    var low = ((uint32)prod);
    if (low < ((uint32)n)) {
        var thresh = ((uint32)(-n)) % ((uint32)n);
        while (low < thresh) {
            v = r.Uint32();
            prod = ((uint64)v) * ((uint64)n);
            low = ((uint32)prod);
        }
    }
    return ((int32)(prod >> (int)(32)));
}

// Intn returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n).
// It panics if n <= 0.
[GoRecv] public static nint Intn(this ref Rand r, nint n) {
    if (n <= 0) {
        throw panic("invalid argument to Intn");
    }
    if (n <= 1 << (int)(31) - 1) {
        return ((nint)r.Int31n(((int32)n)));
    }
    return ((nint)r.Int63n(((int64)n)));
}

// Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0).
[GoRecv] public static float64 Float64(this ref Rand r) {
    // A clearer, simpler implementation would be:
    //	return float64(r.Int63n(1<<53)) / (1<<53)
    // However, Go 1 shipped with
    //	return float64(r.Int63()) / (1 << 63)
    // and we want to preserve that value stream.
    //
    // There is one bug in the value stream: r.Int63() may be so close
    // to 1<<63 that the division rounds up to 1.0, and we've guaranteed
    // that the result is always less than 1.0.
    //
    // We tried to fix this by mapping 1.0 back to 0.0, but since float64
    // values near 0 are much denser than near 1, mapping 1 to 0 caused
    // a theoretically significant overshoot in the probability of returning 0.
    // Instead of that, if we round up to 1, just try again.
    // Getting 1 only happens 1/2⁵³ of the time, so most clients
    // will not observe it anyway.
again:
    var f = ((float64)r.Int63()) / (1 << (int)(63));
    if (f == 1) {
        goto again;
    }
    // resample; this branch is taken O(never)
    return f;
}

// Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0).
[GoRecv] public static float32 Float32(this ref Rand r) {
    // Same rationale as in Float64: we want to preserve the Go 1 value
    // stream except we want to fix it not to return 1.0
    // This only happens 1/2²⁴ of the time (plus the 1/2⁵³ of the time in Float64).
again:
    var f = ((float32)r.Float64());
    if (f == 1) {
        goto again;
    }
    // resample; this branch is taken O(very rarely)
    return f;
}

// Perm returns, as a slice of n ints, a pseudo-random permutation of the integers
// in the half-open interval [0,n).
[GoRecv] public static slice<nint> Perm(this ref Rand r, nint n) {
    var m = new slice<nint>(n);
    // In the following loop, the iteration when i=0 always swaps m[0] with m[0].
    // A change to remove this useless iteration is to assign 1 to i in the init
    // statement. But Perm also effects r. Making this change will affect
    // the final state of r. So this change can't be made for compatibility
    // reasons for Go 1.
    for (nint i = 0; i < n; i++) {
        nint j = r.Intn(i + 1);
        m[i] = m[j];
        m[j] = i;
    }
    return m;
}

// Shuffle pseudo-randomizes the order of elements.
// n is the number of elements. Shuffle panics if n < 0.
// swap swaps the elements with indexes i and j.
[GoRecv] public static void Shuffle(this ref Rand r, nint n, Action<nint, nint> swap) {
    if (n < 0) {
        throw panic("invalid argument to Shuffle");
    }
    // Fisher-Yates shuffle: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
    // Shuffle really ought not be called with n that doesn't fit in 32 bits.
    // Not only will it take a very long time, but with 2³¹! possible permutations,
    // there's no way that any PRNG can have a big enough internal state to
    // generate even a minuscule percentage of the possible permutations.
    // Nevertheless, the right API signature accepts an int n, so handle it as best we can.
    nint i = n - 1;
    for (; i > 1 << (int)(31) - 1 - 1; i--) {
        nint j = ((nint)r.Int63n(((int64)(i + 1))));
        swap(i, j);
    }
    for (; i > 0; i--) {
        nint j = ((nint)r.int31n(((int32)(i + 1))));
        swap(i, j);
    }
}

// Read generates len(p) random bytes and writes them into p. It
// always returns len(p) and a nil error.
// Read should not be called concurrently with any other Rand method.
[GoRecv] public static (nint n, error err) Read(this ref Rand r, slice<byte> p) {
    nint n = default!;
    error err = default!;

    switch (r.src.type()) {
    case lockedSource.val src: {
        return src.read(p, Ꮡ(r.readVal), Ꮡ(r.readPos));
    }
    case runtimeSource.val src: {
        return src.read(p, Ꮡ(r.readVal), Ꮡ(r.readPos));
    }}
    return read(p, r.src, Ꮡ(r.readVal), Ꮡ(r.readPos));
}

internal static (nint n, error err) read(slice<byte> p, Source src, ж<int64> ᏑreadVal, ж<int8> ᏑreadPos) {
    nint n = default!;
    error err = default!;

    ref var readVal = ref ᏑreadVal.val;
    ref var readPos = ref ᏑreadPos.val;
    var pos = readPos;
    var val = readVal;
    var (rng, _) = src._<rngSource.val>(ᐧ);
    for (n = 0; n < len(p); n++) {
        if (pos == 0) {
            if (rng != nil){
                val = rng.Int63();
            } else {
                val = src.Int63();
            }
            pos = 7;
        }
        p[n] = ((byte)val);
        val >>= (UntypedInt)(8);
        pos--;
    }
    readPos = pos;
    readVal = val;
    return (n, err);
}

/*
 * Top-level convenience functions
 */

// globalRandGenerator is the source of random numbers for the top-level
// convenience functions. When possible it uses the runtime fastrand64
// function to avoid locking. This is not possible if the user called Seed,
// either explicitly or implicitly via GODEBUG=randautoseed=0.
internal static atomic.Pointer<Rand> globalRandGenerator;

internal static ж<godebug.Setting> randautoseed = godebug.New("randautoseed"u8);

// globalRand returns the generator to use for the top-level convenience
// functions.
internal static ж<Rand> globalRand() {
    {
        var rΔ1 = globalRandGenerator.Load(); if (rΔ1 != nil) {
            return rΔ1;
        }
    }
    // This is the first call. Initialize based on GODEBUG.
    ж<Rand> r = default!;
    if (randautoseed.Value() == "0"u8){
        randautoseed.IncNonDefault();
        r = New(new lockedSource());
        r.Seed(1);
    } else {
        r = Ꮡ(new Rand(
            src: Ꮡ(new runtimeSource(nil)),
            s64: Ꮡ(new runtimeSource(nil))
        ));
    }
    if (!globalRandGenerator.CompareAndSwap(nil, r)) {
        // Two different goroutines called some top-level
        // function at the same time. While the results in
        // that case are unpredictable, if we just use r here,
        // and we are using a seed, we will most likely return
        // the same value for both calls. That doesn't seem ideal.
        // Just use the first one to get in.
        return globalRandGenerator.Load();
    }
    return r;
}

//go:linkname runtime_rand runtime.rand
internal static partial uint64 runtime_rand();

// runtimeSource is an implementation of Source64 that uses the runtime
// fastrand functions.
[GoType] partial struct runtimeSource {
    // The mutex is used to avoid race conditions in Read.
    internal sync_package.Mutex mu;
}

[GoRecv] internal static int64 Int63(this ref runtimeSource _) {
    return ((int64)((uint64)(runtime_rand() & rngMask)));
}

[GoRecv] internal static void Seed(this ref runtimeSource _, int64 _) {
    throw panic("internal error: call to runtimeSource.Seed");
}

[GoRecv] internal static uint64 Uint64(this ref runtimeSource _) {
    return runtime_rand();
}

[GoRecv] internal static (nint n, error err) read(this ref runtimeSource fs, slice<byte> p, ж<int64> ᏑreadVal, ж<int8> ᏑreadPos) {
    nint n = default!;
    error err = default!;

    ref var readVal = ref ᏑreadVal.val;
    ref var readPos = ref ᏑreadPos.val;
    fs.mu.Lock();
    (n, err) = read(p, ~fs, ᏑreadVal, ᏑreadPos);
    fs.mu.Unlock();
    return (n, err);
}

// Seed uses the provided seed value to initialize the default Source to a
// deterministic state. Seed values that have the same remainder when
// divided by 2³¹-1 generate the same pseudo-random sequence.
// Seed, unlike the [Rand.Seed] method, is safe for concurrent use.
//
// If Seed is not called, the generator is seeded randomly at program startup.
//
// Prior to Go 1.20, the generator was seeded like Seed(1) at program startup.
// To force the old behavior, call Seed(1) at program startup.
// Alternately, set GODEBUG=randautoseed=0 in the environment
// before making any calls to functions in this package.
//
// Deprecated: As of Go 1.20 there is no reason to call Seed with
// a random value. Programs that call Seed with a known value to get
// a specific sequence of results should use New(NewSource(seed)) to
// obtain a local random generator.
public static void Seed(int64 seed) {
    var orig = globalRandGenerator.Load();
    // If we are already using a lockedSource, we can just re-seed it.
    if (orig != nil) {
        {
            var (_, ok) = (~orig).src._<lockedSource.val>(ᐧ); if (ok) {
                orig.Seed(seed);
                return;
            }
        }
    }
    // Otherwise either
    // 1) orig == nil, which is the normal case when Seed is the first
    // top-level function to be called, or
    // 2) orig is already a runtimeSource, in which case we need to change
    // to a lockedSource.
    // Either way we do the same thing.
    var r = New(new lockedSource());
    r.Seed(seed);
    if (!globalRandGenerator.CompareAndSwap(orig, r)) {
        // Something changed underfoot. Retry to be safe.
        Seed(seed);
    }
}

// Int63 returns a non-negative pseudo-random 63-bit integer as an int64
// from the default [Source].
public static int64 Int63() {
    return globalRand().Int63();
}

// Uint32 returns a pseudo-random 32-bit value as a uint32
// from the default [Source].
public static uint32 Uint32() {
    return globalRand().Uint32();
}

// Uint64 returns a pseudo-random 64-bit value as a uint64
// from the default [Source].
public static uint64 Uint64() {
    return globalRand().Uint64();
}

// Int31 returns a non-negative pseudo-random 31-bit integer as an int32
// from the default [Source].
public static int32 Int31() {
    return globalRand().Int31();
}

// Int returns a non-negative pseudo-random int from the default [Source].
public static nint Int() {
    return globalRand().Int();
}

// Int63n returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n)
// from the default [Source].
// It panics if n <= 0.
public static int64 Int63n(int64 n) {
    return globalRand().Int63n(n);
}

// Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n)
// from the default [Source].
// It panics if n <= 0.
public static int32 Int31n(int32 n) {
    return globalRand().Int31n(n);
}

// Intn returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n)
// from the default [Source].
// It panics if n <= 0.
public static nint Intn(nint n) {
    return globalRand().Intn(n);
}

// Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0)
// from the default [Source].
public static float64 Float64() {
    return globalRand().Float64();
}

// Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0)
// from the default [Source].
public static float32 Float32() {
    return globalRand().Float32();
}

// Perm returns, as a slice of n ints, a pseudo-random permutation of the integers
// in the half-open interval [0,n) from the default [Source].
public static slice<nint> Perm(nint n) {
    return globalRand().Perm(n);
}

// Shuffle pseudo-randomizes the order of elements using the default [Source].
// n is the number of elements. Shuffle panics if n < 0.
// swap swaps the elements with indexes i and j.
public static void Shuffle(nint n, Action<nint, nint> swap) {
    globalRand().Shuffle(n, swap);
}

// Read generates len(p) random bytes from the default [Source] and
// writes them into p. It always returns len(p) and a nil error.
// Read, unlike the [Rand.Read] method, is safe for concurrent use.
//
// Deprecated: For almost all use cases, [crypto/rand.Read] is more appropriate.
// If a deterministic source is required, use [math/rand/v2.ChaCha8.Read].
public static (nint n, error err) Read(slice<byte> p) {
    nint n = default!;
    error err = default!;

    return globalRand().Read(p);
}

// NormFloat64 returns a normally distributed float64 in the range
// [-[math.MaxFloat64], +[math.MaxFloat64]] with
// standard normal distribution (mean = 0, stddev = 1)
// from the default [Source].
// To produce a different normal distribution, callers can
// adjust the output using:
//
//	sample = NormFloat64() * desiredStdDev + desiredMean
public static float64 NormFloat64() {
    return globalRand().NormFloat64();
}

// ExpFloat64 returns an exponentially distributed float64 in the range
// (0, +[math.MaxFloat64]] with an exponential distribution whose rate parameter
// (lambda) is 1 and whose mean is 1/lambda (1) from the default [Source].
// To produce a distribution with a different rate parameter,
// callers can adjust the output using:
//
//	sample = ExpFloat64() / desiredRateParameter
public static float64 ExpFloat64() {
    return globalRand().ExpFloat64();
}

[GoType] partial struct lockedSource {
    internal sync_package.Mutex lk;
    internal ж<rngSource> s;
}

[GoRecv] internal static int64 /*n*/ Int63(this ref lockedSource r) {
    int64 n = default!;

    r.lk.Lock();
    n = r.s.Int63();
    r.lk.Unlock();
    return n;
}

[GoRecv] internal static uint64 /*n*/ Uint64(this ref lockedSource r) {
    uint64 n = default!;

    r.lk.Lock();
    n = r.s.Uint64();
    r.lk.Unlock();
    return n;
}

[GoRecv] internal static void Seed(this ref lockedSource r, int64 seed) {
    r.lk.Lock();
    r.seed(seed);
    r.lk.Unlock();
}

// seedPos implements Seed for a lockedSource without a race condition.
[GoRecv] internal static void seedPos(this ref lockedSource r, int64 seed, ж<int8> ᏑreadPos) {
    ref var readPos = ref ᏑreadPos.val;

    r.lk.Lock();
    r.seed(seed);
    readPos = 0;
    r.lk.Unlock();
}

// seed seeds the underlying source.
// The caller must have locked r.lk.
[GoRecv] internal static void seed(this ref lockedSource r, int64 seed) {
    if (r.s == nil){
        r.s = newSource(seed);
    } else {
        r.s.Seed(seed);
    }
}

// read implements Read for a lockedSource without a race condition.
[GoRecv] internal static (nint n, error err) read(this ref lockedSource r, slice<byte> p, ж<int64> ᏑreadVal, ж<int8> ᏑreadPos) {
    nint n = default!;
    error err = default!;

    ref var readVal = ref ᏑreadVal.val;
    ref var readPos = ref ᏑreadPos.val;
    r.lk.Lock();
    (n, err) = read(p, ~r.s, ᏑreadVal, ᏑreadPos);
    r.lk.Unlock();
    return (n, err);
}

} // end rand_package
