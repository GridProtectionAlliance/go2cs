// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package rsa implements RSA encryption as specified in PKCS #1 and RFC 8017.
//
// RSA is a single, fundamental operation that is used in this package to
// implement either public-key encryption or public-key signatures.
//
// The original specification for encryption and signatures with RSA is PKCS #1
// and the terms "RSA encryption" and "RSA signatures" by default refer to
// PKCS #1 version 1.5. However, that specification has flaws and new designs
// should use version 2, usually called by just OAEP and PSS, where
// possible.
//
// Two sets of interfaces are included in this package. When a more abstract
// interface isn't necessary, there are functions for encrypting/decrypting
// with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract
// over the public key primitive, the PrivateKey type implements the
// Decrypter and Signer interfaces from the crypto package.
//
// Operations involving private keys are implemented using constant-time
// algorithms, except for [GenerateKey], [PrivateKey.Precompute], and
// [PrivateKey.Validate].
namespace go.crypto;

using crypto = crypto_package;
using bigmod = crypto.@internal.bigmod_package;
using boring = crypto.@internal.boring_package;
using bbig = crypto.@internal.boring.bbig_package;
using randutil = crypto.@internal.randutil_package;
using rand = crypto.rand_package;
using subtle = crypto.subtle_package;
using errors = errors_package;
using hash = hash_package;
using io = io_package;
using math = math_package;
using big = math.big_package;
using crypto.@internal;
using crypto.@internal.boring;
using math;

partial class rsa_package {

internal static ж<bigꓸInt> bigOne = big.NewInt(1);

// A PublicKey represents the public part of an RSA key.
//
// The value of the modulus N is considered secret by this library and protected
// from leaking through timing side-channels. However, neither the value of the
// exponent E nor the precise bit size of N are similarly protected.
[GoType] partial struct PublicKey {
    public ж<math.big_package.ΔInt> N; // modulus
    public nint E;     // public exponent
}

// Any methods implemented on PublicKey might need to also be implemented on
// PrivateKey, as the latter embeds the former and will expose its methods.

// Size returns the modulus size in bytes. Raw signatures and ciphertexts
// for or by this public key will have the same size.
[GoRecv] public static nint Size(this ref PublicKey pub) {
    return (pub.N.BitLen() + 7) / 8;
}

// Equal reports whether pub and x have the same value.
[GoRecv] public static bool Equal(this ref PublicKey pub, crypto.PublicKey x) {
    var (xx, ok) = x._<PublicKey.val>(ᐧ);
    if (!ok) {
        return false;
    }
    return bigIntEqual(pub.N, (~xx).N) && pub.E == (~xx).E;
}

// OAEPOptions is an interface for passing options to OAEP decryption using the
// crypto.Decrypter interface.
[GoType] partial struct OAEPOptions {
    // Hash is the hash function that will be used when generating the mask.
    public crypto_package.Hash Hash;
    // MGFHash is the hash function used for MGF1.
    // If zero, Hash is used instead.
    public crypto_package.Hash MGFHash;
    // Label is an arbitrary byte string that must be equal to the value
    // used when encrypting.
    public slice<byte> Label;
}

internal static error errPublicModulus = errors.New("crypto/rsa: missing public modulus"u8);
internal static error errPublicExponentSmall = errors.New("crypto/rsa: public exponent too small"u8);
internal static error errPublicExponentLarge = errors.New("crypto/rsa: public exponent too large"u8);

// checkPub sanity checks the public key before we use it.
// We require pub.E to fit into a 32-bit integer so that we
// do not have different behavior depending on whether
// int is 32 or 64 bits. See also
// https://www.imperialviolet.org/2012/03/16/rsae.html.
internal static error checkPub(ж<PublicKey> Ꮡpub) {
    ref var pub = ref Ꮡpub.val;

    if (pub.N == nil) {
        return errPublicModulus;
    }
    if (pub.E < 2) {
        return errPublicExponentSmall;
    }
    if (pub.E > 1 << (int)(31) - 1) {
        return errPublicExponentLarge;
    }
    return default!;
}

// A PrivateKey represents an RSA key
[GoType] partial struct PrivateKey {
    public partial ref PublicKey PublicKey { get; }            // public part.
    public ж<math.big_package.ΔInt> D; // private exponent
    public bigꓸInt Primes; // prime factors of N, has >= 2 elements.
    // Precomputed contains precomputed values that speed up RSA operations,
    // if available. It must be generated by calling PrivateKey.Precompute and
    // must not be modified.
    public PrecomputedValues Precomputed;
}

// Public returns the public key corresponding to priv.
[GoRecv] public static crypto.PublicKey Public(this ref PrivateKey priv) {
    return Ꮡ(priv.PublicKey);
}

// Equal reports whether priv and x have equivalent values. It ignores
// Precomputed values.
[GoRecv] public static bool Equal(this ref PrivateKey priv, crypto.PrivateKey x) {
    var (xx, ok) = x._<PrivateKey.val>(ᐧ);
    if (!ok) {
        return false;
    }
    if (!priv.PublicKey.Equal(Ꮡ((~xx).PublicKey)) || !bigIntEqual(priv.D, (~xx).D)) {
        return false;
    }
    if (len(priv.Primes) != len((~xx).Primes)) {
        return false;
    }
    ref var i = ref heap(new nint(), out var Ꮡi);

    foreach (var (i, _) in priv.Primes) {
        if (!bigIntEqual(priv.Primes[i], (~xx).Primes[i])) {
            return false;
        }
    }
    return true;
}

// bigIntEqual reports whether a and b are equal leaking only their bit length
// through timing side-channels.
internal static bool bigIntEqual(ж<bigꓸInt> Ꮡa, ж<bigꓸInt> Ꮡb) {
    ref var a = ref Ꮡa.val;
    ref var b = ref Ꮡb.val;

    return subtle.ConstantTimeCompare(a.Bytes(), b.Bytes()) == 1;
}

// Sign signs digest with priv, reading randomness from rand. If opts is a
// *[PSSOptions] then the PSS algorithm will be used, otherwise PKCS #1 v1.5 will
// be used. digest must be the result of hashing the input message using
// opts.HashFunc().
//
// This method implements [crypto.Signer], which is an interface to support keys
// where the private part is kept in, for example, a hardware module. Common
// uses should use the Sign* functions in this package directly.
[GoRecv] public static (slice<byte>, error) Sign(this ref PrivateKey priv, io.Reader rand, slice<byte> digest, crypto.SignerOpts opts) {
    {
        var (pssOpts, ok) = opts._<PSSOptions.val>(ᐧ); if (ok) {
            return SignPSS(rand, priv, (~pssOpts).Hash, digest, pssOpts);
        }
    }
    return SignPKCS1v15(rand, priv, opts.HashFunc(), digest);
}

// Decrypt decrypts ciphertext with priv. If opts is nil or of type
// *[PKCS1v15DecryptOptions] then PKCS #1 v1.5 decryption is performed. Otherwise
// opts must have type *[OAEPOptions] and OAEP decryption is done.
[GoRecv] public static (slice<byte> plaintext, error err) Decrypt(this ref PrivateKey priv, io.Reader rand, slice<byte> ciphertext, crypto.DecrypterOpts opts) {
    slice<byte> plaintext = default!;
    error err = default!;

    if (opts == default!) {
        return DecryptPKCS1v15(rand, priv, ciphertext);
    }
    switch (opts.type()) {
    case OAEPOptions.val opts: {
        if ((~opts).MGFHash == 0){
            return decryptOAEP((~opts).Hash.New(), (~opts).Hash.New(), rand, priv, ciphertext, (~opts).Label);
        } else {
            return decryptOAEP((~opts).Hash.New(), (~opts).MGFHash.New(), rand, priv, ciphertext, (~opts).Label);
        }
        break;
    }
    case PKCS1v15DecryptOptions.val opts: {
        {
            nint l = opts.val.SessionKeyLen; if (l > 0){
                plaintext = new slice<byte>(l);
                {
                    var (_, errΔ1) = io.ReadFull(rand, plaintext); if (errΔ1 != default!) {
                        return (default!, errΔ1);
                    }
                }
                {
                    var errΔ2 = DecryptPKCS1v15SessionKey(rand, priv, ciphertext, plaintext); if (errΔ2 != default!) {
                        return (default!, errΔ2);
                    }
                }
                return (plaintext, default!);
            } else {
                return DecryptPKCS1v15(rand, priv, ciphertext);
            }
        }
        break;
    }
    default: {
        var opts = opts.type();
        return (default!, errors.New("crypto/rsa: invalid options for Decrypt"u8));
    }}
}

[GoType] partial struct PrecomputedValues {
    public ж<math.big_package.ΔInt> Dp; // D mod (P-1) (or mod Q-1)
    public ж<math.big_package.ΔInt> Dq;
    public ж<math.big_package.ΔInt> Qinv; // Q^-1 mod P
    // CRTValues is used for the 3rd and subsequent primes. Due to a
    // historical accident, the CRT for the first two primes is handled
    // differently in PKCS #1 and interoperability is sufficiently
    // important that we mirror this.
    //
    // Deprecated: These values are still filled in by Precompute for
    // backwards compatibility but are not used. Multi-prime RSA is very rare,
    // and is implemented by this package without CRT optimizations to limit
    // complexity.
    public slice<CRTValue> CRTValues;
    internal ж<crypto.@internal.bigmod_package.Modulus> n; // moduli for CRT with Montgomery precomputed constants
    internal ж<crypto.@internal.bigmod_package.Modulus> p;
    internal ж<crypto.@internal.bigmod_package.Modulus> q;
}

// CRTValue contains the precomputed Chinese remainder theorem values.
[GoType] partial struct CRTValue {
    public ж<math.big_package.ΔInt> Exp; // D mod (prime-1).
    public ж<math.big_package.ΔInt> Coeff; // R·Coeff ≡ 1 mod Prime.
    public ж<math.big_package.ΔInt> R; // product of primes prior to this (inc p and q).
}

// Validate performs basic sanity checks on the key.
// It returns nil if the key is valid, or else an error describing a problem.
[GoRecv] public static error Validate(this ref PrivateKey priv) {
    {
        var err = checkPub(Ꮡ(priv.PublicKey)); if (err != default!) {
            return err;
        }
    }
    // Check that Πprimes == n.
    var modulus = @new<bigꓸInt>().Set(bigOne);
    foreach (var (_, prime) in priv.Primes) {
        // Any primes ≤ 1 will cause divide-by-zero panics later.
        if (prime.Cmp(bigOne) <= 0) {
            return errors.New("crypto/rsa: invalid prime value"u8);
        }
        modulus.Mul(modulus, prime);
    }
    if (modulus.Cmp(priv.N) != 0) {
        return errors.New("crypto/rsa: invalid modulus"u8);
    }
    // Check that de ≡ 1 mod p-1, for each prime.
    // This implies that e is coprime to each p-1 as e has a multiplicative
    // inverse. Therefore e is coprime to lcm(p-1,q-1,r-1,...) =
    // exponent(ℤ/nℤ). It also implies that a^de ≡ a mod p as a^(p-1) ≡ 1
    // mod p. Thus a^de ≡ a mod n for all a coprime to n, as required.
    var congruence = @new<bigꓸInt>();
    var de = @new<bigꓸInt>().SetInt64(((int64)priv.E));
    de.Mul(de, priv.D);
    foreach (var (_, prime) in priv.Primes) {
        var pminus1 = @new<bigꓸInt>().Sub(prime, bigOne);
        congruence.Mod(de, pminus1);
        if (congruence.Cmp(bigOne) != 0) {
            return errors.New("crypto/rsa: invalid exponents"u8);
        }
    }
    return default!;
}

// GenerateKey generates a random RSA private key of the given bit size.
//
// Most applications should use [crypto/rand.Reader] as rand. Note that the
// returned key does not depend deterministically on the bytes read from rand,
// and may change between calls and/or between versions.
public static (ж<PrivateKey>, error) GenerateKey(io.Reader random, nint bits) {
    return GenerateMultiPrimeKey(random, 2, bits);
}

// GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit
// size and the given random source.
//
// Table 1 in "[On the Security of Multi-prime RSA]" suggests maximum numbers of
// primes for a given bit size.
//
// Although the public keys are compatible (actually, indistinguishable) from
// the 2-prime case, the private keys are not. Thus it may not be possible to
// export multi-prime private keys in certain formats or to subsequently import
// them into other code.
//
// This package does not implement CRT optimizations for multi-prime RSA, so the
// keys with more than two primes will have worse performance.
//
// Deprecated: The use of this function with a number of primes different from
// two is not recommended for the above security, compatibility, and performance
// reasons. Use [GenerateKey] instead.
//
// [On the Security of Multi-prime RSA]: http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf
public static (ж<PrivateKey>, error) GenerateMultiPrimeKey(io.Reader random, nint nprimes, nint bits) {
    randutil.MaybeReadByte(random);
    if (boring.Enabled && random == boring.RandReader && nprimes == 2 && (bits == 2048 || bits == 3072 || bits == 4096)) {
        (bN, bE, bD, bP, bQ, bDp, bDq, bQinv, errΔ1) = boring.GenerateKeyRSA(bits);
        if (errΔ1 != default!) {
            return (default!, errΔ1);
        }
        var N = bbig.Dec(bN);
        var E = bbig.Dec(bE);
        var D = bbig.Dec(bD);
        var P = bbig.Dec(bP);
        var Q = bbig.Dec(bQ);
        var Dp = bbig.Dec(bDp);
        var Dq = bbig.Dec(bDq);
        var Qinv = bbig.Dec(bQinv);
        var e64 = E.Int64();
        if (!E.IsInt64() || ((int64)((nint)e64)) != e64) {
            return (default!, errors.New("crypto/rsa: generated key exponent too large"u8));
        }
        (mn, ) = bigmod.NewModulusFromBig(N);
        if (errΔ1 != default!) {
            return (default!, errΔ1);
        }
        (mp, ) = bigmod.NewModulusFromBig(P);
        if (errΔ1 != default!) {
            return (default!, errΔ1);
        }
        (mq, ) = bigmod.NewModulusFromBig(Q);
        if (errΔ1 != default!) {
            return (default!, errΔ1);
        }
        var key = Ꮡ(new PrivateKey(
            PublicKey: new PublicKey(
                N: N,
                E: ((nint)e64)
            ),
            D: D,
            Primes: new bigꓸInt[]{P, Q}.slice(),
            Precomputed: new PrecomputedValues(
                Dp: Dp,
                Dq: Dq,
                Qinv: Qinv,
                CRTValues: new slice<CRTValue>(0), // non-nil, to match Precompute

                n: mn,
                p: mp,
                q: mq
            )
        ));
        return (key, default!);
    }
    var priv = @new<PrivateKey>();
    priv.E = 65537;
    if (nprimes < 2) {
        return (default!, errors.New("crypto/rsa: GenerateMultiPrimeKey: nprimes must be >= 2"u8));
    }
    if (bits < 64) {
        var primeLimit = ((float64)(((uint64)1) << (int)(((nuint)(bits / nprimes)))));
        // pi approximates the number of primes less than primeLimit
        var pi = primeLimit / (math.Log(primeLimit) - 1);
        // Generated primes start with 11 (in binary) so we can only
        // use a quarter of them.
        pi /= 4;
        // Use a factor of two to ensure that key generation terminates
        // in a reasonable amount of time.
        pi /= 2;
        if (pi <= ((float64)nprimes)) {
            return (default!, errors.New("crypto/rsa: too few primes of given length to generate an RSA key"u8));
        }
    }
    var primes = new slice<bigꓸInt>(nprimes);
NextSetOfPrimes:
    while (ᐧ) {
        nint todo = bits;
        // crypto/rand should set the top two bits in each prime.
        // Thus each prime has the form
        //   p_i = 2^bitlen(p_i) × 0.11... (in base 2).
        // And the product is:
        //   P = 2^todo × α
        // where α is the product of nprimes numbers of the form 0.11...
        //
        // If α < 1/2 (which can happen for nprimes > 2), we need to
        // shift todo to compensate for lost bits: the mean value of 0.11...
        // is 7/8, so todo + shift - nprimes * log2(7/8) ~= bits - 1/2
        // will give good results.
        if (nprimes >= 7) {
            todo += (nprimes - 2) / 5;
        }
        for (nint i = 0; i < nprimes; i++) {
            error err = default!;
            (primes[i], err) = rand.Prime(random, todo / (nprimes - i));
            if (err != default!) {
                return (default!, err);
            }
            todo -= primes[i].BitLen();
        }
        // Make sure that primes is pairwise unequal.
        foreach (var (i, prime) in primes) {
            ref var j = ref heap<nint>(out var Ꮡj);
            for (j = 0; j < i; j++) {
                if (prime.Cmp(primes[j]) == 0) {
                    goto continue_NextSetOfPrimes;
                }
            }
        }
        var n = @new<bigꓸInt>().Set(bigOne);
        var totient = @new<bigꓸInt>().Set(bigOne);
        var pminus1 = @new<bigꓸInt>();
        foreach (var (_, prime) in primes) {
            n.Mul(n, prime);
            pminus1.Sub(prime, bigOne);
            totient.Mul(totient, pminus1);
        }
        if (n.BitLen() != bits) {
            // This should never happen for nprimes == 2 because
            // crypto/rand should set the top two bits in each prime.
            // For nprimes > 2 we hope it does not happen often.
            goto continue_NextSetOfPrimes;
        }
        priv.val.D = @new<bigꓸInt>();
        var e = big.NewInt(((int64)priv.E));
        var ok = (~priv).D.ModInverse(e, totient);
        if (ok != nil) {
            priv.val.Primes = primes;
            priv.N = n;
            break;
        }
continue_NextSetOfPrimes:;
    }
break_NextSetOfPrimes:;
    priv.Precompute();
    return (priv, default!);
}

// incCounter increments a four byte, big-endian counter.
internal static void incCounter(ж<array<byte>> Ꮡc) {
    ref var c = ref Ꮡc.val;

    {
        c[3]++; if (c[3] != 0) {
            return;
        }
    }
    {
        c[2]++; if (c[2] != 0) {
            return;
        }
    }
    {
        c[1]++; if (c[1] != 0) {
            return;
        }
    }
    c[0]++;
}

// mgf1XOR XORs the bytes in out with a mask generated using the MGF1 function
// specified in PKCS #1 v2.1.
internal static void mgf1XOR(slice<byte> @out, hash.Hash hash, slice<byte> seed) {
    ref var counter = ref heap(new array<byte>(4), out var Ꮡcounter);
    slice<byte> digest = default!;
    nint done = 0;
    while (done < len(@out)) {
        hash.Write(seed);
        hash.Write(counter[0..4]);
        digest = hash.Sum(digest[..0]);
        hash.Reset();
        for (nint i = 0; i < len(digest) && done < len(@out); i++) {
            @out[done] ^= (byte)(digest[i]);
            done++;
        }
        incCounter(Ꮡcounter);
    }
}

// ErrMessageTooLong is returned when attempting to encrypt or sign a message
// which is too large for the size of the key. When using [SignPSS], this can also
// be returned if the size of the salt is too large.
public static error ErrMessageTooLong = errors.New("crypto/rsa: message too long for RSA key size"u8);

internal static (slice<byte>, error) encrypt(ж<PublicKey> Ꮡpub, slice<byte> plaintext) {
    ref var pub = ref Ꮡpub.val;

    boring.Unreachable();
    (N, err) = bigmod.NewModulusFromBig(pub.N);
    if (err != default!) {
        return (default!, err);
    }
    (m, err) = bigmod.NewNat().SetBytes(plaintext, N);
    if (err != default!) {
        return (default!, err);
    }
    nuint e = ((nuint)pub.E);
    return (bigmod.NewNat().ExpShortVarTime(m, e, N).Bytes(N), default!);
}

// EncryptOAEP encrypts the given message with RSA-OAEP.
//
// OAEP is parameterised by a hash function that is used as a random oracle.
// Encryption and decryption of a given message must use the same hash function
// and sha256.New() is a reasonable choice.
//
// The random parameter is used as a source of entropy to ensure that
// encrypting the same message twice doesn't result in the same ciphertext.
// Most applications should use [crypto/rand.Reader] as random.
//
// The label parameter may contain arbitrary data that will not be encrypted,
// but which gives important context to the message. For example, if a given
// public key is used to encrypt two types of messages then distinct label
// values could be used to ensure that a ciphertext for one purpose cannot be
// used for another by an attacker. If not required it can be empty.
//
// The message must be no longer than the length of the public modulus minus
// twice the hash length, minus a further 2.
public static (slice<byte>, error) EncryptOAEP(hash.Hash hash, io.Reader random, ж<PublicKey> Ꮡpub, slice<byte> msg, slice<byte> label) {
    ref var pub = ref Ꮡpub.val;

    // Note that while we don't commit to deterministic execution with respect
    // to the random stream, we also don't apply MaybeReadByte, so per Hyrum's
    // Law it's probably relied upon by some. It's a tolerable promise because a
    // well-specified number of random bytes is included in the ciphertext, in a
    // well-specified way.
    {
        var errΔ1 = checkPub(Ꮡpub); if (errΔ1 != default!) {
            return (default!, errΔ1);
        }
    }
    hash.Reset();
    nint k = pub.Size();
    if (len(msg) > k - 2 * hash.Size() - 2) {
        return (default!, ErrMessageTooLong);
    }
    if (boring.Enabled && random == boring.RandReader) {
        (bkeyΔ1, errΔ2) = boringPublicKey(Ꮡpub);
        if (errΔ2 != default!) {
            return (default!, errΔ2);
        }
        return boring.EncryptRSAOAEP(hash, hash, bkeyΔ1, msg, label);
    }
    boring.UnreachableExceptTests();
    hash.Write(label);
    var lHash = hash.Sum(default!);
    hash.Reset();
    var em = new slice<byte>(k);
    var seed = em[1..(int)(1 + hash.Size())];
    var db = em[(int)(1 + hash.Size())..];
    copy(db[0..(int)(hash.Size())], lHash);
    db[len(db) - len(msg) - 1] = 1;
    copy(db[(int)(len(db) - len(msg))..], msg);
    var (_, err) = io.ReadFull(random, seed);
    if (err != default!) {
        return (default!, err);
    }
    mgf1XOR(db, hash, seed);
    mgf1XOR(seed, hash, db);
    if (boring.Enabled) {
        ж<boring.PublicKeyRSA> bkey = default!;
        (bkey, err) = boringPublicKey(Ꮡpub);
        if (err != default!) {
            return (default!, err);
        }
        return boring.EncryptRSANoPadding(bkey, em);
    }
    return encrypt(Ꮡpub, em);
}

// ErrDecryption represents a failure to decrypt a message.
// It is deliberately vague to avoid adaptive attacks.
public static error ErrDecryption = errors.New("crypto/rsa: decryption error"u8);

// ErrVerification represents a failure to verify a signature.
// It is deliberately vague to avoid adaptive attacks.
public static error ErrVerification = errors.New("crypto/rsa: verification error"u8);

// Precompute performs some calculations that speed up private key operations
// in the future.
[GoRecv] public static void Precompute(this ref PrivateKey priv) {
    if (priv.Precomputed.n == nil && len(priv.Primes) == 2) {
        // Precomputed values _should_ always be valid, but if they aren't
        // just return. We could also panic.
        error err = default!;
        (priv.Precomputed.n, err) = bigmod.NewModulusFromBig(priv.N);
        if (err != default!) {
            return;
        }
        (priv.Precomputed.p, err) = bigmod.NewModulusFromBig(priv.Primes[0]);
        if (err != default!) {
            // Unset previous values, so we either have everything or nothing
            priv.Precomputed.n = default!;
            return;
        }
        (priv.Precomputed.q, err) = bigmod.NewModulusFromBig(priv.Primes[1]);
        if (err != default!) {
            // Unset previous values, so we either have everything or nothing
            (priv.Precomputed.n, priv.Precomputed.p) = (default!, default!);
            return;
        }
    }
    // Fill in the backwards-compatibility *big.Int values.
    if (priv.Precomputed.Dp != nil) {
        return;
    }
    priv.Precomputed.Dp = @new<bigꓸInt>().Sub(priv.Primes[0], bigOne);
    priv.Precomputed.Dp.Mod(priv.D, priv.Precomputed.Dp);
    priv.Precomputed.Dq = @new<bigꓸInt>().Sub(priv.Primes[1], bigOne);
    priv.Precomputed.Dq.Mod(priv.D, priv.Precomputed.Dq);
    priv.Precomputed.Qinv = @new<bigꓸInt>().ModInverse(priv.Primes[1], priv.Primes[0]);
    var r = @new<bigꓸInt>().Mul(priv.Primes[0], priv.Primes[1]);
    priv.Precomputed.CRTValues = new slice<CRTValue>(len(priv.Primes) - 2);
    for (nint i = 2; i < len(priv.Primes); i++) {
        var prime = priv.Primes[i];
        var values = Ꮡ(priv.Precomputed.CRTValues[i - 2]);
        values.val.Exp = @new<bigꓸInt>().Sub(prime, bigOne);
        (~values).Exp.Mod(priv.D, (~values).Exp);
        values.val.R = @new<bigꓸInt>().Set(r);
        values.val.Coeff = @new<bigꓸInt>().ModInverse(r, prime);
        r.Mul(r, prime);
    }
}

internal const bool withCheck = true;

internal const bool noCheck = false;

// decrypt performs an RSA decryption of ciphertext into out. If check is true,
// m^e is calculated and compared with ciphertext, in order to defend against
// errors in the CRT computation.
internal static (slice<byte>, error) decrypt(ж<PrivateKey> Ꮡpriv, slice<byte> ciphertext, bool check) {
    ref var priv = ref Ꮡpriv.val;

    if (len(priv.Primes) <= 2) {
        boring.Unreachable();
    }
    error err = default!;
    ж<bigmodꓸNat> m = default!;
    ж<bigmodꓸNat> c = default!;
    ж<bigmod.Modulus> N = default!;
    ж<bigmodꓸNat> t0 = bigmod.NewNat();
    if (priv.Precomputed.n == nil){
        (N, err) = bigmod.NewModulusFromBig(priv.N);
        if (err != default!) {
            return (default!, ErrDecryption);
        }
        (c, err) = bigmod.NewNat().SetBytes(ciphertext, N);
        if (err != default!) {
            return (default!, ErrDecryption);
        }
        m = bigmod.NewNat().Exp(c, priv.D.Bytes(), N);
    } else {
        N = priv.Precomputed.n;
        var P = priv.Precomputed.p;
        var Q = priv.Precomputed.q;
        (Qinv, errΔ1) = bigmod.NewNat().SetBytes(priv.Precomputed.Qinv.Bytes(), P);
        if (errΔ1 != default!) {
            return (default!, ErrDecryption);
        }
        (c, err) = bigmod.NewNat().SetBytes(ciphertext, N);
        if (errΔ1 != default!) {
            return (default!, ErrDecryption);
        }
        // m = c ^ Dp mod p
        m = bigmod.NewNat().Exp(t0.Mod(c, P), priv.Precomputed.Dp.Bytes(), P);
        // m2 = c ^ Dq mod q
        var m2 = bigmod.NewNat().Exp(t0.Mod(c, Q), priv.Precomputed.Dq.Bytes(), Q);
        // m = m - m2 mod p
        m.Sub(t0.Mod(m2, P), P);
        // m = m * Qinv mod p
        m.Mul(Qinv, P);
        // m = m * q mod N
        m.ExpandFor(N).Mul(t0.Mod(Q.Nat(), N), N);
        // m = m + m2 mod N
        m.Add(m2.ExpandFor(N), N);
    }
    if (check) {
        var c1 = bigmod.NewNat().ExpShortVarTime(m, ((nuint)priv.E), N);
        if (c1.Equal(c) != 1) {
            return (default!, ErrDecryption);
        }
    }
    return (m.Bytes(N), default!);
}

// DecryptOAEP decrypts ciphertext using RSA-OAEP.
//
// OAEP is parameterised by a hash function that is used as a random oracle.
// Encryption and decryption of a given message must use the same hash function
// and sha256.New() is a reasonable choice.
//
// The random parameter is legacy and ignored, and it can be nil.
//
// The label parameter must match the value given when encrypting. See
// [EncryptOAEP] for details.
public static (slice<byte>, error) DecryptOAEP(hash.Hash hash, io.Reader random, ж<PrivateKey> Ꮡpriv, slice<byte> ciphertext, slice<byte> label) {
    ref var priv = ref Ꮡpriv.val;

    return decryptOAEP(hash, hash, random, Ꮡpriv, ciphertext, label);
}

internal static (slice<byte>, error) decryptOAEP(hash.Hash hash, hash.Hash mgfHash, io.Reader random, ж<PrivateKey> Ꮡpriv, slice<byte> ciphertext, slice<byte> label) {
    ref var priv = ref Ꮡpriv.val;

    {
        var errΔ1 = checkPub(Ꮡ(priv.PublicKey)); if (errΔ1 != default!) {
            return (default!, errΔ1);
        }
    }
    nint k = priv.Size();
    if (len(ciphertext) > k || k < hash.Size() * 2 + 2) {
        return (default!, ErrDecryption);
    }
    if (boring.Enabled) {
        (bkey, errΔ2) = boringPrivateKey(Ꮡpriv);
        if (errΔ2 != default!) {
            return (default!, errΔ2);
        }
        (@out, ) = boring.DecryptRSAOAEP(hash, mgfHash, bkey, ciphertext, label);
        if (errΔ2 != default!) {
            return (default!, ErrDecryption);
        }
        return (@out, default!);
    }
    (em, err) = decrypt(Ꮡpriv, ciphertext, noCheck);
    if (err != default!) {
        return (default!, err);
    }
    hash.Write(label);
    var lHash = hash.Sum(default!);
    hash.Reset();
    nint firstByteIsZero = subtle.ConstantTimeByteEq(em[0], 0);
    var seed = em[1..(int)(hash.Size() + 1)];
    var db = em[(int)(hash.Size() + 1)..];
    mgf1XOR(seed, mgfHash, db);
    mgf1XOR(db, mgfHash, seed);
    var lHash2 = db[0..(int)(hash.Size())];
    // We have to validate the plaintext in constant time in order to avoid
    // attacks like: J. Manger. A Chosen Ciphertext Attack on RSA Optimal
    // Asymmetric Encryption Padding (OAEP) as Standardized in PKCS #1
    // v2.0. In J. Kilian, editor, Advances in Cryptology.
    nint lHash2Good = subtle.ConstantTimeCompare(lHash, lHash2);
    // The remainder of the plaintext must be zero or more 0x00, followed
    // by 0x01, followed by the message.
    //   lookingForIndex: 1 iff we are still looking for the 0x01
    //   index: the offset of the first 0x01 byte
    //   invalid: 1 iff we saw a non-zero byte before the 0x01.
    nint lookingForIndex = default!;
    nint index = default!;
    nint invalid = default!;
    lookingForIndex = 1;
    var rest = db[(int)(hash.Size())..];
    for (nint i = 0; i < len(rest); i++) {
        nint equals0 = subtle.ConstantTimeByteEq(rest[i], 0);
        nint equals1 = subtle.ConstantTimeByteEq(rest[i], 1);
        index = subtle.ConstantTimeSelect((nint)(lookingForIndex & equals1), i, index);
        lookingForIndex = subtle.ConstantTimeSelect(equals1, 0, lookingForIndex);
        invalid = subtle.ConstantTimeSelect((nint)(lookingForIndex & ~equals0), 1, invalid);
    }
    if ((nint)((nint)((nint)(firstByteIsZero & lHash2Good) & ~invalid) & ~lookingForIndex) != 1) {
        return (default!, ErrDecryption);
    }
    return (rest[(int)(index + 1)..], default!);
}

} // end rsa_package
