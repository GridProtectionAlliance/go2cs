// Copyright (c) 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go.crypto.@internal;

using errors = errors_package;
using byteorder = @internal.byteorder_package;
using @internal;

partial class edwards25519_package {

// A Scalar is an integer modulo
//
//	l = 2^252 + 27742317777372353535851937790883648493
//
// which is the prime order of the edwards25519 group.
//
// This type works similarly to math/big.Int, and all arguments and
// receivers are allowed to alias.
//
// The zero value is a valid zero element.
[GoType] partial struct Scalar {
    // s is the scalar in the Montgomery domain, in the format of the
    // fiat-crypto implementation.
    internal fiatScalarMontgomeryDomainFieldElement s;
}

// The field implementation in scalar_fiat.go is generated by the fiat-crypto
// project (https://github.com/mit-plv/fiat-crypto) at version v0.0.9 (23d2dbc)
// from a formally verified model.
//
// fiat-crypto code comes under the following license.
//
//     Copyright (c) 2015-2020 The fiat-crypto Authors. All rights reserved.
//
//     Redistribution and use in source and binary forms, with or without
//     modification, are permitted provided that the following conditions are
//     met:
//
//         1. Redistributions of source code must retain the above copyright
//         notice, this list of conditions and the following disclaimer.
//
//     THIS SOFTWARE IS PROVIDED BY the fiat-crypto authors "AS IS"
//     AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
//     THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//     PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Berkeley Software Design,
//     Inc. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
//     EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
//     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
//     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//     LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//     NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

// NewScalar returns a new zero Scalar.
public static ж<Scalar> NewScalar() {
    return Ꮡ(new Scalar(nil));
}

// MultiplyAdd sets s = x * y + z mod l, and returns s. It is equivalent to
// using Multiply and then Add.
[GoRecv] public static ж<Scalar> MultiplyAdd(this ref Scalar s, ж<Scalar> Ꮡx, ж<Scalar> Ꮡy, ж<Scalar> Ꮡz) {
    ref var x = ref Ꮡx.val;
    ref var y = ref Ꮡy.val;
    ref var z = ref Ꮡz.val;

    // Make a copy of z in case it aliases s.
    var zCopy = @new<Scalar>().Set(Ꮡz);
    return s.Multiply(Ꮡx, Ꮡy).Add(s, zCopy);
}

// Add sets s = x + y mod l, and returns s.
[GoRecv("capture")] public static ж<Scalar> Add(this ref Scalar s, ж<Scalar> Ꮡx, ж<Scalar> Ꮡy) {
    ref var x = ref Ꮡx.val;
    ref var y = ref Ꮡy.val;

    // s = 1 * x + y mod l
    fiatScalarAdd(Ꮡ(s.s), Ꮡ(x.s), Ꮡ(y.s));
    return AddꓸᏑs;
}

// Subtract sets s = x - y mod l, and returns s.
[GoRecv("capture")] public static ж<Scalar> Subtract(this ref Scalar s, ж<Scalar> Ꮡx, ж<Scalar> Ꮡy) {
    ref var x = ref Ꮡx.val;
    ref var y = ref Ꮡy.val;

    // s = -1 * y + x mod l
    fiatScalarSub(Ꮡ(s.s), Ꮡ(x.s), Ꮡ(y.s));
    return SubtractꓸᏑs;
}

// Negate sets s = -x mod l, and returns s.
[GoRecv("capture")] public static ж<Scalar> Negate(this ref Scalar s, ж<Scalar> Ꮡx) {
    ref var x = ref Ꮡx.val;

    // s = -1 * x + 0 mod l
    fiatScalarOpp(Ꮡ(s.s), Ꮡ(x.s));
    return NegateꓸᏑs;
}

// Multiply sets s = x * y mod l, and returns s.
[GoRecv("capture")] public static ж<Scalar> Multiply(this ref Scalar s, ж<Scalar> Ꮡx, ж<Scalar> Ꮡy) {
    ref var x = ref Ꮡx.val;
    ref var y = ref Ꮡy.val;

    // s = x * y + 0 mod l
    fiatScalarMul(Ꮡ(s.s), Ꮡ(x.s), Ꮡ(y.s));
    return MultiplyꓸᏑs;
}

// Set sets s = x, and returns s.
[GoRecv("capture")] public static ж<Scalar> Set(this ref Scalar s, ж<Scalar> Ꮡx) {
    ref var x = ref Ꮡx.val;

    s = x;
    return SetꓸᏑs;
}

// SetUniformBytes sets s = x mod l, where x is a 64-byte little-endian integer.
// If x is not of the right length, SetUniformBytes returns nil and an error,
// and the receiver is unchanged.
//
// SetUniformBytes can be used to set s to a uniformly distributed value given
// 64 uniformly distributed random bytes.
[GoRecv("capture")] public static (ж<Scalar>, error) SetUniformBytes(this ref Scalar s, slice<byte> x) {
    if (len(x) != 64) {
        return (default!, errors.New("edwards25519: invalid SetUniformBytes input length"u8));
    }
    // We have a value x of 512 bits, but our fiatScalarFromBytes function
    // expects an input lower than l, which is a little over 252 bits.
    //
    // Instead of writing a reduction function that operates on wider inputs, we
    // can interpret x as the sum of three shorter values a, b, and c.
    //
    //    x = a + b * 2^168 + c * 2^336  mod l
    //
    // We then precompute 2^168 and 2^336 modulo l, and perform the reduction
    // with two multiplications and two additions.
    s.setShortBytes(x[..21]);
    var t = @new<Scalar>().setShortBytes(x[21..42]);
    s.Add(s, t.Multiply(t, scalarTwo168));
    t.setShortBytes(x[42..]);
    s.Add(s, t.Multiply(t, scalarTwo336));
    return (SetUniformBytesꓸᏑs, default!);
}

// scalarTwo168 and scalarTwo336 are 2^168 and 2^336 modulo l, encoded as a
// fiatScalarMontgomeryDomainFieldElement, which is a little-endian 4-limb value
// in the 2^256 Montgomery domain.
internal static ж<Scalar> scalarTwo168 = Ꮡ(new Scalar(s: new uint64[]{(nint)6596282735017805720L, (nint)4084727301971498455L,
    (nuint)11727709552089570172UL, (nint)446589182673836592L}.array()
));

internal static ж<Scalar> scalarTwo336 = Ꮡ(new Scalar(s: new uint64[]{(nuint)13636073449544084677UL, (nint)6645684779544594699L,
    (nint)7181719282965082862L, (nint)275308871451790172L}.array()
));

// setShortBytes sets s = x mod l, where x is a little-endian integer shorter
// than 32 bytes.
[GoRecv("capture")] internal static ж<Scalar> setShortBytes(this ref Scalar s, slice<byte> x) {
    if (len(x) >= 32) {
        throw panic("edwards25519: internal error: setShortBytes called with a long string");
    }
    ref var buf = ref heap(new array<byte>(32), out var Ꮡbuf);
    copy(buf[..], x);
    fiatScalarFromBytes((ж<array<uint64>>)(Ꮡ(s.s)), Ꮡbuf);
    fiatScalarToMontgomery(Ꮡ(s.s), ((ж<fiatScalarNonMontgomeryDomainFieldElement>)(Ꮡ(s.s))));
    return setShortBytesꓸᏑs;
}

// SetCanonicalBytes sets s = x, where x is a 32-byte little-endian encoding of
// s, and returns s. If x is not a canonical encoding of s, SetCanonicalBytes
// returns nil and an error, and the receiver is unchanged.
[GoRecv("capture")] public static (ж<Scalar>, error) SetCanonicalBytes(this ref Scalar s, slice<byte> x) {
    if (len(x) != 32) {
        return (default!, errors.New("invalid scalar length"u8));
    }
    if (!isReduced(x)) {
        return (default!, errors.New("invalid scalar encoding"u8));
    }
    fiatScalarFromBytes((ж<array<uint64>>)(Ꮡ(s.s)), (ж<array<byte>>)(x));
    fiatScalarToMontgomery(Ꮡ(s.s), ((ж<fiatScalarNonMontgomeryDomainFieldElement>)(Ꮡ(s.s))));
    return (SetCanonicalBytesꓸᏑs, default!);
}

// scalarMinusOneBytes is l - 1 in little endian.
internal static array<byte> scalarMinusOneBytes = new byte[]{236, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16}.array();

// isReduced returns whether the given scalar in 32-byte little endian encoded
// form is reduced modulo l.
internal static bool isReduced(slice<byte> s) {
    if (len(s) != 32) {
        return false;
    }
    for (nint i = len(s) - 1; i >= 0; i--) {
        switch (ᐧ) {
        case {} when s[i] is > scalarMinusOneBytes[i]: {
            return false;
        }
        case {} when s[i] is < scalarMinusOneBytes[i]: {
            return true;
        }}

    }
    return true;
}

// SetBytesWithClamping applies the buffer pruning described in RFC 8032,
// Section 5.1.5 (also known as clamping) and sets s to the result. The input
// must be 32 bytes, and it is not modified. If x is not of the right length,
// SetBytesWithClamping returns nil and an error, and the receiver is unchanged.
//
// Note that since Scalar values are always reduced modulo the prime order of
// the curve, the resulting value will not preserve any of the cofactor-clearing
// properties that clamping is meant to provide. It will however work as
// expected as long as it is applied to points on the prime order subgroup, like
// in Ed25519. In fact, it is lost to history why RFC 8032 adopted the
// irrelevant RFC 7748 clamping, but it is now required for compatibility.
[GoRecv] public static (ж<Scalar>, error) SetBytesWithClamping(this ref Scalar s, slice<byte> x) {
    // The description above omits the purpose of the high bits of the clamping
    // for brevity, but those are also lost to reductions, and are also
    // irrelevant to edwards25519 as they protect against a specific
    // implementation bug that was once observed in a generic Montgomery ladder.
    if (len(x) != 32) {
        return (default!, errors.New("edwards25519: invalid SetBytesWithClamping input length"u8));
    }
    // We need to use the wide reduction from SetUniformBytes, since clamping
    // sets the 2^254 bit, making the value higher than the order.
    array<byte> wideBytes = new(64);
    copy(wideBytes[..], x[..]);
    wideBytes[0] &= (byte)(248);
    wideBytes[31] &= (byte)(63);
    wideBytes[31] |= (byte)(64);
    return s.SetUniformBytes(wideBytes[..]);
}

// Bytes returns the canonical 32-byte little-endian encoding of s.
[GoRecv] public static slice<byte> Bytes(this ref Scalar s) {
    // This function is outlined to make the allocations inline in the caller
    // rather than happen on the heap.
    ref var encoded = ref heap(new array<byte>(32), out var Ꮡencoded);
    return s.bytes(Ꮡencoded);
}

[GoRecv] public static slice<byte> bytes(this ref Scalar s, ж<array<byte>> Ꮡout) {
    ref var @out = ref Ꮡout.val;

    ref var ss = ref heap(new fiatScalarNonMontgomeryDomainFieldElement(), out var Ꮡss);
    fiatScalarFromMontgomery(Ꮡss, Ꮡ(s.s));
    fiatScalarToBytes(Ꮡout, (ж<array<uint64>>)(Ꮡss));
    return @out[..];
}

// Equal returns 1 if s and t are equal, and 0 otherwise.
[GoRecv] public static nint Equal(this ref Scalar s, ж<Scalar> Ꮡt) {
    ref var t = ref Ꮡt.val;

    ref var diff = ref heap(new fiatScalarMontgomeryDomainFieldElement(), out var Ꮡdiff);
    fiatScalarSub(Ꮡdiff, Ꮡ(s.s), Ꮡ(t.s));
    ref var nonzero = ref heap(new uint64(), out var Ꮡnonzero);
    fiatScalarNonzero(Ꮡnonzero, (ж<array<uint64>>)(Ꮡdiff));
    nonzero |= (uint64)(nonzero >> (int)(32));
    nonzero |= (uint64)(nonzero >> (int)(16));
    nonzero |= (uint64)(nonzero >> (int)(8));
    nonzero |= (uint64)(nonzero >> (int)(4));
    nonzero |= (uint64)(nonzero >> (int)(2));
    nonzero |= (uint64)(nonzero >> (int)(1));
    return (nint)(((nint)(~nonzero)) & 1);
}

// nonAdjacentForm computes a width-w non-adjacent form for this scalar.
//
// w must be between 2 and 8, or nonAdjacentForm will panic.
[GoRecv] internal static array<int8> nonAdjacentForm(this ref Scalar s, nuint w) {
    // This implementation is adapted from the one
    // in curve25519-dalek and is documented there:
    // https://github.com/dalek-cryptography/curve25519-dalek/blob/f630041af28e9a405255f98a8a93adca18e4315b/src/scalar.rs#L800-L871
    var b = s.Bytes();
    if (b[31] > 127) {
        throw panic("scalar has high bit set illegally");
    }
    if (w < 2){
        throw panic("w must be at least 2 by the definition of NAF");
    } else 
    if (w > 8) {
        throw panic("NAF digits must fit in int8");
    }
    array<int8> naf = new(256);
    array<uint64> digits = new(5);
    for (nint i = 0; i < 4; i++) {
        digits[i] = byteorder.LeUint64(b[(int)(i * 8)..]);
    }
    var width = ((uint64)(1 << (int)(w)));
    var windowMask = ((uint64)(width - 1));
    nuint pos = ((nuint)0);
    var carry = ((uint64)0);
    while (pos < 256) {
        nuint indexU64 = pos / 64;
        nuint indexBit = pos % 64;
        uint64 bitBuf = default!;
        if (indexBit < 64 - w){
            // This window's bits are contained in a single u64
            bitBuf = digits[indexU64] >> (int)(indexBit);
        } else {
            // Combine the current 64 bits with bits from the next 64
            bitBuf = (uint64)((digits[indexU64] >> (int)(indexBit)) | (digits[1 + indexU64] << (int)((64 - indexBit))));
        }
        // Add carry into the current window
        var window = carry + ((uint64)(bitBuf & windowMask));
        if ((uint64)(window & 1) == 0) {
            // If the window value is even, preserve the carry and continue.
            // Why is the carry preserved?
            // If carry == 0 and window & 1 == 0,
            //    then the next carry should be 0
            // If carry == 1 and window & 1 == 0,
            //    then bit_buf & 1 == 1 so the next carry should be 1
            pos += 1;
            continue;
        }
        if (window < width / 2){
            carry = 0;
            naf[pos] = ((int8)window);
        } else {
            carry = 1;
            naf[pos] = ((int8)window) - ((int8)width);
        }
        pos += w;
    }
    return naf;
}

[GoRecv] internal static array<int8> signedRadix16(this ref Scalar s) {
    var b = s.Bytes();
    if (b[31] > 127) {
        throw panic("scalar has high bit set illegally");
    }
    array<int8> digits = new(64);
    // Compute unsigned radix-16 digits:
    for (nint i = 0; i < 32; i++) {
        digits[2 * i] = ((int8)((byte)(b[i] & 15)));
        digits[2 * i + 1] = ((int8)((byte)((b[i] >> (int)(4)) & 15)));
    }
    // Recenter coefficients:
    for (nint i = 0; i < 63; i++) {
        var carry = (digits[i] + 8) >> (int)(4);
        digits[i] -= carry << (int)(4);
        digits[i + 1] += carry;
    }
    return digits;
}

} // end edwards25519_package
