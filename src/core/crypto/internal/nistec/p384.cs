// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Code generated by generate.go. DO NOT EDIT.
namespace go.crypto.@internal;

using fiat = crypto.@internal.nistec.fiat_package;
using subtle = crypto.subtle_package;
using errors = errors_package;
using sync = sync_package;
using crypto;
using crypto.@internal.nistec;

partial class nistec_package {

// p384ElementLength is the length of an element of the base or scalar field,
// which have the same bytes length for all NIST P curves.
internal static readonly UntypedInt p384ElementLength = 48;

// P384Point is a P384 point. The zero value is NOT valid.
[GoType] partial struct P384Point {
    // The point is represented in projective coordinates (X:Y:Z),
    // where x = X/Z and y = Y/Z.
    internal ж<crypto.@internal.nistec.fiat_package.P384Element> x;
    internal ж<crypto.@internal.nistec.fiat_package.P384Element> y;
    internal ж<crypto.@internal.nistec.fiat_package.P384Element> z;
}

// NewP384Point returns a new P384Point representing the point at infinity point.
public static ж<P384Point> NewP384Point() {
    return Ꮡ(new P384Point(
        x: @new<fiat.P384Element>(),
        y: @new<fiat.P384Element>().One(),
        z: @new<fiat.P384Element>()
    ));
}

// SetGenerator sets p to the canonical generator and returns p.
[GoRecv("capture")] public static ж<P384Point> SetGenerator(this ref P384Point p) {
    p.x.SetBytes(new byte[]{170, 135, 202, 34, 190, 139, 5, 55, 142, 177, 199, 30, 243, 32, 173, 116, 110, 29, 59, 98, 139, 167, 155, 152, 89, 247, 65, 224, 130, 84, 42, 56, 85, 2, 242, 93, 191, 85, 41, 108, 58, 84, 94, 56, 114, 118, 10, 183}.slice());
    p.y.SetBytes(new byte[]{54, 23, 222, 74, 150, 38, 44, 111, 93, 158, 152, 191, 146, 146, 220, 41, 248, 244, 29, 189, 40, 154, 20, 124, 233, 218, 49, 19, 181, 240, 184, 192, 10, 96, 177, 206, 29, 126, 129, 157, 122, 67, 29, 124, 144, 234, 14, 95}.slice());
    p.z.One();
    return SetGeneratorꓸᏑp;
}

// Set sets p = q and returns p.
[GoRecv("capture")] public static ж<P384Point> Set(this ref P384Point p, ж<P384Point> Ꮡq) {
    ref var q = ref Ꮡq.val;

    p.x.Set(q.x);
    p.y.Set(q.y);
    p.z.Set(q.z);
    return SetꓸᏑp;
}

// SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
// b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
// the curve, it returns nil and an error, and the receiver is unchanged.
// Otherwise, it returns p.
[GoRecv("capture")] public static (ж<P384Point>, error) SetBytes(this ref P384Point p, slice<byte> b) {
    switch (ᐧ) {
    case {} when len(b) == 1 && b[0] == 0: {
        return (p.Set(NewP384Point()), default!);
    }
    case {} when len(b) == 1 + 2 * p384ElementLength && b[0] == 4: {
        (x, err) = @new<fiat.P384Element>().SetBytes(b[1..(int)(1 + p384ElementLength)]);
        if (err != default!) {
            // Point at infinity.
            // Uncompressed form.
            return (default!, err);
        }
        (y, err) = @new<fiat.P384Element>().SetBytes(b[(int)(1 + p384ElementLength)..]);
        if (err != default!) {
            return (default!, err);
        }
        {
            var errΔ1 = p384CheckOnCurve(x, y); if (errΔ1 != default!) {
                return (default!, errΔ1);
            }
        }
        p.x.Set(x);
        p.y.Set(y);
        p.z.One();
        return (SetBytesꓸᏑp, default!);
    }
    case {} when len(b) == 1 + p384ElementLength && (b[0] == 2 || b[0] == 3): {
        (x, err) = @new<fiat.P384Element>().SetBytes(b[1..]);
        if (err != default!) {
            // Compressed form.
            return (default!, err);
        }
        var y = p384Polynomial(@new<fiat.P384Element>(), // y² = x³ - 3x + b
 x);
        if (!p384Sqrt(y, y)) {
            return (default!, errors.New("invalid P384 compressed point encoding"u8));
        }
        var otherRoot = @new<fiat.P384Element>();
        otherRoot.Sub(otherRoot, // Select the positive or negative root, as indicated by the least
 // significant bit, based on the encoding type byte.
 y);
        var cond = (byte)((byte)(y.Bytes()[p384ElementLength - 1] & 1) ^ (byte)(b[0] & 1));
        y.Select(otherRoot, y, ((nint)cond));
        p.x.Set(x);
        p.y.Set(y);
        p.z.One();
        return (SetBytesꓸᏑp, default!);
    }
    default: {
        return (default!, errors.New("invalid P384 point encoding"u8));
    }}

}

internal static ж<fiat.P384Element> _p384B;

internal static sync.Once _p384BOnce;

internal static ж<fiat.P384Element> p384B() {
    _p384BOnce.Do(() => {
        (_p384B, _) = @new<fiat.P384Element>().SetBytes(new byte[]{179, 49, 47, 167, 226, 62, 231, 228, 152, 142, 5, 107, 227, 248, 45, 25, 24, 29, 156, 110, 254, 129, 65, 18, 3, 20, 8, 143, 80, 19, 135, 90, 198, 86, 57, 141, 138, 46, 209, 157, 42, 133, 200, 237, 211, 236, 42, 239}.slice());
    });
    return _p384B;
}

// p384Polynomial sets y2 to x³ - 3x + b, and returns y2.
internal static ж<fiat.P384Element> p384Polynomial(ж<fiat.P384Element> Ꮡy2, ж<fiat.P384Element> Ꮡx) {
    ref var y2 = ref Ꮡy2.val;
    ref var x = ref Ꮡx.val;

    y2.Square(Ꮡx);
    y2.Mul(Ꮡy2, Ꮡx);
    var threeX = @new<fiat.P384Element>().Add(Ꮡx, Ꮡx);
    threeX.Add(threeX, Ꮡx);
    y2.Sub(Ꮡy2, threeX);
    return y2.Add(Ꮡy2, p384B());
}

internal static error p384CheckOnCurve(ж<fiat.P384Element> Ꮡx, ж<fiat.P384Element> Ꮡy) {
    ref var x = ref Ꮡx.val;
    ref var y = ref Ꮡy.val;

    // y² = x³ - 3x + b
    var rhs = p384Polynomial(@new<fiat.P384Element>(), Ꮡx);
    var lhs = @new<fiat.P384Element>().Square(Ꮡy);
    if (rhs.Equal(lhs) != 1) {
        return errors.New("P384 point not on curve"u8);
    }
    return default!;
}

// Bytes returns the uncompressed or infinity encoding of p, as specified in
// SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
// infinity is shorter than all other encodings.
[GoRecv] public static slice<byte> Bytes(this ref P384Point p) {
    // This function is outlined to make the allocations inline in the caller
    // rather than happen on the heap.
    ref var out = ref heap(new array<byte>(97), out var Ꮡout);
    return p.bytes(Ꮡ@out);
}

[GoRecv] public static slice<byte> bytes(this ref P384Point p, ж<array<byte>> Ꮡout) {
    ref var @out = ref Ꮡout.val;

    if (p.z.IsZero() == 1) {
        return append(@out[..0], 0);
    }
    var zinv = @new<fiat.P384Element>().Invert(p.z);
    var x = @new<fiat.P384Element>().Mul(p.x, zinv);
    var y = @new<fiat.P384Element>().Mul(p.y, zinv);
    var buf = append(@out[..0], 4);
    buf = append(buf, x.Bytes().ꓸꓸꓸ);
    buf = append(buf, y.Bytes().ꓸꓸꓸ);
    return buf;
}

// BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
// Version 2.0, Section 2.3.5, or an error if p is the point at infinity.
[GoRecv] public static (slice<byte>, error) BytesX(this ref P384Point p) {
    // This function is outlined to make the allocations inline in the caller
    // rather than happen on the heap.
    ref var out = ref heap(new array<byte>(48), out var Ꮡout);
    return p.bytesX(Ꮡ@out);
}

[GoRecv] public static (slice<byte>, error) bytesX(this ref P384Point p, ж<array<byte>> Ꮡout) {
    ref var @out = ref Ꮡout.val;

    if (p.z.IsZero() == 1) {
        return (default!, errors.New("P384 point is the point at infinity"u8));
    }
    var zinv = @new<fiat.P384Element>().Invert(p.z);
    var x = @new<fiat.P384Element>().Mul(p.x, zinv);
    return (append(@out[..0], x.Bytes().ꓸꓸꓸ), default!);
}

// BytesCompressed returns the compressed or infinity encoding of p, as
// specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
// point at infinity is shorter than all other encodings.
[GoRecv] public static slice<byte> BytesCompressed(this ref P384Point p) {
    // This function is outlined to make the allocations inline in the caller
    // rather than happen on the heap.
    ref var out = ref heap(new array<byte>(49), out var Ꮡout);
    return p.bytesCompressed(Ꮡ@out);
}

[GoRecv] public static slice<byte> bytesCompressed(this ref P384Point p, ж<array<byte>> Ꮡout) {
    ref var @out = ref Ꮡout.val;

    if (p.z.IsZero() == 1) {
        return append(@out[..0], 0);
    }
    var zinv = @new<fiat.P384Element>().Invert(p.z);
    var x = @new<fiat.P384Element>().Mul(p.x, zinv);
    var y = @new<fiat.P384Element>().Mul(p.y, zinv);
    // Encode the sign of the y coordinate (indicated by the least significant
    // bit) as the encoding type (2 or 3).
    var buf = append(@out[..0], 2);
    buf[0] |= (byte)((byte)(y.Bytes()[p384ElementLength - 1] & 1));
    buf = append(buf, x.Bytes().ꓸꓸꓸ);
    return buf;
}

// Add sets q = p1 + p2, and returns q. The points may overlap.
[GoRecv("capture")] public static ж<P384Point> Add(this ref P384Point q, ж<P384Point> Ꮡp1, ж<P384Point> Ꮡp2) {
    ref var p1 = ref Ꮡp1.val;
    ref var p2 = ref Ꮡp2.val;

    // Complete addition formula for a = -3 from "Complete addition formulas for
    // prime order elliptic curves" (https://eprint.iacr.org/2015/1060), §A.2.
    var t0 = @new<fiat.P384Element>().Mul(p1.x, p2.x);
    // t0 := X1 * X2
    var t1 = @new<fiat.P384Element>().Mul(p1.y, p2.y);
    // t1 := Y1 * Y2
    var t2 = @new<fiat.P384Element>().Mul(p1.z, p2.z);
    // t2 := Z1 * Z2
    var t3 = @new<fiat.P384Element>().Add(p1.x, p1.y);
    // t3 := X1 + Y1
    var t4 = @new<fiat.P384Element>().Add(p2.x, p2.y);
    // t4 := X2 + Y2
    t3.Mul(t3, t4);
    // t3 := t3 * t4
    t4.Add(t0, t1);
    // t4 := t0 + t1
    t3.Sub(t3, t4);
    // t3 := t3 - t4
    t4.Add(p1.y, p1.z);
    // t4 := Y1 + Z1
    var x3 = @new<fiat.P384Element>().Add(p2.y, p2.z);
    // X3 := Y2 + Z2
    t4.Mul(t4, x3);
    // t4 := t4 * X3
    x3.Add(t1, t2);
    // X3 := t1 + t2
    t4.Sub(t4, x3);
    // t4 := t4 - X3
    x3.Add(p1.x, p1.z);
    // X3 := X1 + Z1
    var y3 = @new<fiat.P384Element>().Add(p2.x, p2.z);
    // Y3 := X2 + Z2
    x3.Mul(x3, y3);
    // X3 := X3 * Y3
    y3.Add(t0, t2);
    // Y3 := t0 + t2
    y3.Sub(x3, y3);
    // Y3 := X3 - Y3
    var z3 = @new<fiat.P384Element>().Mul(p384B(), t2);
    // Z3 := b * t2
    x3.Sub(y3, z3);
    // X3 := Y3 - Z3
    z3.Add(x3, x3);
    // Z3 := X3 + X3
    x3.Add(x3, z3);
    // X3 := X3 + Z3
    z3.Sub(t1, x3);
    // Z3 := t1 - X3
    x3.Add(t1, x3);
    // X3 := t1 + X3
    y3.Mul(p384B(), y3);
    // Y3 := b * Y3
    t1.Add(t2, t2);
    // t1 := t2 + t2
    t2.Add(t1, t2);
    // t2 := t1 + t2
    y3.Sub(y3, t2);
    // Y3 := Y3 - t2
    y3.Sub(y3, t0);
    // Y3 := Y3 - t0
    t1.Add(y3, y3);
    // t1 := Y3 + Y3
    y3.Add(t1, y3);
    // Y3 := t1 + Y3
    t1.Add(t0, t0);
    // t1 := t0 + t0
    t0.Add(t1, t0);
    // t0 := t1 + t0
    t0.Sub(t0, t2);
    // t0 := t0 - t2
    t1.Mul(t4, y3);
    // t1 := t4 * Y3
    t2.Mul(t0, y3);
    // t2 := t0 * Y3
    y3.Mul(x3, z3);
    // Y3 := X3 * Z3
    y3.Add(y3, t2);
    // Y3 := Y3 + t2
    x3.Mul(t3, x3);
    // X3 := t3 * X3
    x3.Sub(x3, t1);
    // X3 := X3 - t1
    z3.Mul(t4, z3);
    // Z3 := t4 * Z3
    t1.Mul(t3, t0);
    // t1 := t3 * t0
    z3.Add(z3, t1);
    // Z3 := Z3 + t1
    q.x.Set(x3);
    q.y.Set(y3);
    q.z.Set(z3);
    return AddꓸᏑq;
}

// Double sets q = p + p, and returns q. The points may overlap.
[GoRecv("capture")] public static ж<P384Point> Double(this ref P384Point q, ж<P384Point> Ꮡp) {
    ref var p = ref Ꮡp.val;

    // Complete addition formula for a = -3 from "Complete addition formulas for
    // prime order elliptic curves" (https://eprint.iacr.org/2015/1060), §A.2.
    var t0 = @new<fiat.P384Element>().Square(p.x);
    // t0 := X ^ 2
    var t1 = @new<fiat.P384Element>().Square(p.y);
    // t1 := Y ^ 2
    var t2 = @new<fiat.P384Element>().Square(p.z);
    // t2 := Z ^ 2
    var t3 = @new<fiat.P384Element>().Mul(p.x, p.y);
    // t3 := X * Y
    t3.Add(t3, t3);
    // t3 := t3 + t3
    var z3 = @new<fiat.P384Element>().Mul(p.x, p.z);
    // Z3 := X * Z
    z3.Add(z3, z3);
    // Z3 := Z3 + Z3
    var y3 = @new<fiat.P384Element>().Mul(p384B(), t2);
    // Y3 := b * t2
    y3.Sub(y3, z3);
    // Y3 := Y3 - Z3
    var x3 = @new<fiat.P384Element>().Add(y3, y3);
    // X3 := Y3 + Y3
    y3.Add(x3, y3);
    // Y3 := X3 + Y3
    x3.Sub(t1, y3);
    // X3 := t1 - Y3
    y3.Add(t1, y3);
    // Y3 := t1 + Y3
    y3.Mul(x3, y3);
    // Y3 := X3 * Y3
    x3.Mul(x3, t3);
    // X3 := X3 * t3
    t3.Add(t2, t2);
    // t3 := t2 + t2
    t2.Add(t2, t3);
    // t2 := t2 + t3
    z3.Mul(p384B(), z3);
    // Z3 := b * Z3
    z3.Sub(z3, t2);
    // Z3 := Z3 - t2
    z3.Sub(z3, t0);
    // Z3 := Z3 - t0
    t3.Add(z3, z3);
    // t3 := Z3 + Z3
    z3.Add(z3, t3);
    // Z3 := Z3 + t3
    t3.Add(t0, t0);
    // t3 := t0 + t0
    t0.Add(t3, t0);
    // t0 := t3 + t0
    t0.Sub(t0, t2);
    // t0 := t0 - t2
    t0.Mul(t0, z3);
    // t0 := t0 * Z3
    y3.Add(y3, t0);
    // Y3 := Y3 + t0
    t0.Mul(p.y, p.z);
    // t0 := Y * Z
    t0.Add(t0, t0);
    // t0 := t0 + t0
    z3.Mul(t0, z3);
    // Z3 := t0 * Z3
    x3.Sub(x3, z3);
    // X3 := X3 - Z3
    z3.Mul(t0, t1);
    // Z3 := t0 * t1
    z3.Add(z3, z3);
    // Z3 := Z3 + Z3
    z3.Add(z3, z3);
    // Z3 := Z3 + Z3
    q.x.Set(x3);
    q.y.Set(y3);
    q.z.Set(z3);
    return DoubleꓸᏑq;
}

// Select sets q to p1 if cond == 1, and to p2 if cond == 0.
[GoRecv("capture")] public static ж<P384Point> Select(this ref P384Point q, ж<P384Point> Ꮡp1, ж<P384Point> Ꮡp2, nint cond) {
    ref var p1 = ref Ꮡp1.val;
    ref var p2 = ref Ꮡp2.val;

    q.x.Select(p1.x, p2.x, cond);
    q.y.Select(p1.y, p2.y, cond);
    q.z.Select(p1.z, p2.z, cond);
    return SelectꓸᏑq;
}

[GoType("[15]P384Point")] partial struct p384Table;

// Select selects the n-th multiple of the table base point into p. It works in
// constant time by iterating over every entry of the table. n must be in [0, 15].
[GoRecv] internal static void Select(this ref p384Table table, ж<P384Point> Ꮡp, uint8 n) {
    ref var p = ref Ꮡp.val;

    if (n >= 16) {
        throw panic("nistec: internal error: p384Table called with out-of-bounds value");
    }
    p.Set(NewP384Point());
    ref var i = ref heap<uint8>(out var Ꮡi);
    for (i = ((uint8)1); i < 16; i++) {
        nint cond = subtle.ConstantTimeByteEq(i, n);
        p.Select(table.val[i - 1], Ꮡp, cond);
    }
}

// ScalarMult sets p = scalar * q, and returns p.
[GoRecv("capture")] public static (ж<P384Point>, error) ScalarMult(this ref P384Point p, ж<P384Point> Ꮡq, slice<byte> scalar) {
    ref var q = ref Ꮡq.val;

    // Compute a p384Table for the base point q. The explicit NewP384Point
    // calls get inlined, letting the allocations live on the stack.
    ref var table = ref heap(new p384Table(), out var Ꮡtable);

    table = new p384Table{NewP384Point(), NewP384Point(), NewP384Point(),
        NewP384Point(), NewP384Point(), NewP384Point(), NewP384Point(),
        NewP384Point(), NewP384Point(), NewP384Point(), NewP384Point(),
        NewP384Point(), NewP384Point(), NewP384Point(), NewP384Point()};
    table[0].Set(Ꮡq);
    ref var i = ref heap<nint>(out var Ꮡi);
    for (i = 1; i < 15; i += 2) {
        table[i].Double(table[i / 2]);
        table[i + 1].Add(table[i], Ꮡq);
    }
    // Instead of doing the classic double-and-add chain, we do it with a
    // four-bit window: we double four times, and then add [0-15]P.
    var t = NewP384Point();
    p.Set(NewP384Point());
    foreach (var (i, @byte) in scalar) {
        // No need to double on the first iteration, as p is the identity at
        // this point, and [N]∞ = ∞.
        if (i != 0) {
            p.Double(p);
            p.Double(p);
            p.Double(p);
            p.Double(p);
        }
        var windowValue = @byte >> (int)(4);
        table.Select(t, windowValue);
        p.Add(p, t);
        p.Double(p);
        p.Double(p);
        p.Double(p);
        p.Double(p);
        windowValue = (byte)(@byte & 15);
        table.Select(t, windowValue);
        p.Add(p, t);
    }
    return (ScalarMultꓸᏑp, default!);
}

internal static ж<array<p384Table>> p384GeneratorTable;

internal static sync.Once p384GeneratorTableOnce;

// generatorTable returns a sequence of p384Tables. The first table contains
// multiples of G. Each successive table is the previous table doubled four
// times.
[GoRecv] internal static ж<array<p384Table>> generatorTable(this ref P384Point p) {
    p384GeneratorTableOnce.Do(() => {
        p384GeneratorTable = @new<array<p384Table>>();
        var @base = NewP384Point().SetGenerator();
        ref var i = ref heap<nint>(out var Ꮡi);
        for (i = 0; i < p384ElementLength * 2; i++) {
            p384GeneratorTable.val[i][0] = NewP384Point().Set(@base);
            ref var j = ref heap<nint>(out var Ꮡj);
            for (j = 1; j < 15; j++) {
                p384GeneratorTable.val[i][j] = NewP384Point().Add(p384GeneratorTable.val[i][j - 1], @base);
            }
            @base.Double(@base);
            @base.Double(@base);
            @base.Double(@base);
            @base.Double(@base);
        }
    });
    return p384GeneratorTable;
}

// ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and
// returns p.
[GoRecv("capture")] public static (ж<P384Point>, error) ScalarBaseMult(this ref P384Point p, slice<byte> scalar) {
    if (len(scalar) != p384ElementLength) {
        return (default!, errors.New("invalid scalar length"u8));
    }
    var tables = p.generatorTable();
    // This is also a scalar multiplication with a four-bit window like in
    // ScalarMult, but in this case the doublings are precomputed. The value
    // [windowValue]G added at iteration k would normally get doubled
    // (totIterations-k)×4 times, but with a larger precomputation we can
    // instead add [2^((totIterations-k)×4)][windowValue]G and avoid the
    // doublings between iterations.
    var t = NewP384Point();
    p.Set(NewP384Point());
    nint tableIndex = len(tables) - 1;
    foreach (var (_, @byte) in scalar) {
        var windowValue = @byte >> (int)(4);
        tables.val[tableIndex].Select(t, windowValue);
        p.Add(p, t);
        tableIndex--;
        windowValue = (byte)(@byte & 15);
        tables.val[tableIndex].Select(t, windowValue);
        p.Add(p, t);
        tableIndex--;
    }
    return (ScalarBaseMultꓸᏑp, default!);
}

// p384Sqrt sets e to a square root of x. If x is not a square, p384Sqrt returns
// false and e is unchanged. e and x can overlap.
internal static bool /*isSquare*/ p384Sqrt(ж<fiat.P384Element> Ꮡe, ж<fiat.P384Element> Ꮡx) {
    bool isSquare = default!;

    ref var e = ref Ꮡe.val;
    ref var x = ref Ꮡx.val;
    var candidate = @new<fiat.P384Element>();
    p384SqrtCandidate(candidate, Ꮡx);
    var square = @new<fiat.P384Element>().Square(candidate);
    if (square.Equal(Ꮡx) != 1) {
        return false;
    }
    e.Set(candidate);
    return true;
}

// p384SqrtCandidate sets z to a square root candidate for x. z and x must not overlap.
internal static void p384SqrtCandidate(ж<fiat.P384Element> Ꮡz, ж<fiat.P384Element> Ꮡx) {
    ref var z = ref Ꮡz.val;
    ref var x = ref Ꮡx.val;

    // Since p = 3 mod 4, exponentiation by (p + 1) / 4 yields a square root candidate.
    //
    // The sequence of 14 multiplications and 381 squarings is derived from the
    // following addition chain generated with github.com/mmcloughlin/addchain v0.4.0.
    //
    //	_10      = 2*1
    //	_11      = 1 + _10
    //	_110     = 2*_11
    //	_111     = 1 + _110
    //	_111000  = _111 << 3
    //	_111111  = _111 + _111000
    //	_1111110 = 2*_111111
    //	_1111111 = 1 + _1111110
    //	x12      = _1111110 << 5 + _111111
    //	x24      = x12 << 12 + x12
    //	x31      = x24 << 7 + _1111111
    //	x32      = 2*x31 + 1
    //	x63      = x32 << 31 + x31
    //	x126     = x63 << 63 + x63
    //	x252     = x126 << 126 + x126
    //	x255     = x252 << 3 + _111
    //	return     ((x255 << 33 + x32) << 64 + 1) << 30
    //
    ж<fiat.P384Element> t0 = @new<fiat.P384Element>();
    ж<fiat.P384Element> t1 = @new<fiat.P384Element>();
    ж<fiat.P384Element> t2 = @new<fiat.P384Element>();
    z.Square(Ꮡx);
    z.Mul(Ꮡx, Ꮡz);
    z.Square(Ꮡz);
    t0.Mul(Ꮡx, Ꮡz);
    z.Square(t0);
    for (nint s = 1; s < 3; s++) {
        z.Square(Ꮡz);
    }
    t1.Mul(t0, Ꮡz);
    t2.Square(t1);
    z.Mul(Ꮡx, t2);
    for (nint s = 0; s < 5; s++) {
        t2.Square(t2);
    }
    t1.Mul(t1, t2);
    t2.Square(t1);
    for (nint s = 1; s < 12; s++) {
        t2.Square(t2);
    }
    t1.Mul(t1, t2);
    for (nint s = 0; s < 7; s++) {
        t1.Square(t1);
    }
    t1.Mul(Ꮡz, t1);
    z.Square(t1);
    z.Mul(Ꮡx, Ꮡz);
    t2.Square(Ꮡz);
    for (nint s = 1; s < 31; s++) {
        t2.Square(t2);
    }
    t1.Mul(t1, t2);
    t2.Square(t1);
    for (nint s = 1; s < 63; s++) {
        t2.Square(t2);
    }
    t1.Mul(t1, t2);
    t2.Square(t1);
    for (nint s = 1; s < 126; s++) {
        t2.Square(t2);
    }
    t1.Mul(t1, t2);
    for (nint s = 0; s < 3; s++) {
        t1.Square(t1);
    }
    t0.Mul(t0, t1);
    for (nint s = 0; s < 33; s++) {
        t0.Square(t0);
    }
    z.Mul(Ꮡz, t0);
    for (nint s = 0; s < 64; s++) {
        z.Square(Ꮡz);
    }
    z.Mul(Ꮡx, Ꮡz);
    for (nint s = 0; s < 30; s++) {
        z.Square(Ꮡz);
    }
}

} // end nistec_package
