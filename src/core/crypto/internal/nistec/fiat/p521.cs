// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Code generated by generate.go. DO NOT EDIT.
global using p521UntypedFieldElement = go.array<uint64>;

namespace go.crypto.@internal.nistec;

using subtle = crypto.subtle_package;
using errors = errors_package;
using crypto;

partial class fiat_package {

// P521Element is an integer modulo 2^521 - 1.
//
// The zero value is a valid zero element.
[GoType] partial struct P521Element {
    // Values are represented internally always in the Montgomery domain, and
    // converted in Bytes and SetBytes.
    internal p521MontgomeryDomainFieldElement x;
}

internal static readonly UntypedInt p521ElementLen = 66;

// One sets e = 1, and returns e.
[GoRecv("capture")] public static ж<P521Element> One(this ref P521Element e) {
    p521SetOne(Ꮡ(e.x));
    return OneꓸᏑe;
}

// Equal returns 1 if e == t, and zero otherwise.
[GoRecv] public static nint Equal(this ref P521Element e, ж<P521Element> Ꮡt) {
    ref var t = ref Ꮡt.val;

    var eBytes = e.Bytes();
    var tBytes = t.Bytes();
    return subtle.ConstantTimeCompare(eBytes, tBytes);
}

// IsZero returns 1 if e == 0, and zero otherwise.
[GoRecv] public static nint IsZero(this ref P521Element e) {
    var zero = new slice<byte>(p521ElementLen);
    var eBytes = e.Bytes();
    return subtle.ConstantTimeCompare(eBytes, zero);
}

// Set sets e = t, and returns e.
[GoRecv("capture")] public static ж<P521Element> Set(this ref P521Element e, ж<P521Element> Ꮡt) {
    ref var t = ref Ꮡt.val;

    e.x = t.x;
    return SetꓸᏑe;
}

// Bytes returns the 66-byte big-endian encoding of e.
[GoRecv] public static slice<byte> Bytes(this ref P521Element e) {
    // This function is outlined to make the allocations inline in the caller
    // rather than happen on the heap.
    ref var out = ref heap(new array<byte>(66), out var Ꮡout);
    return e.bytes(Ꮡ@out);
}

[GoRecv] public static slice<byte> bytes(this ref P521Element e, ж<array<byte>> Ꮡout) {
    ref var @out = ref Ꮡout.val;

    ref var tmp = ref heap(new p521NonMontgomeryDomainFieldElement(), out var Ꮡtmp);
    p521FromMontgomery(Ꮡtmp, Ꮡ(e.x));
    p521ToBytes(Ꮡout, ((ж<p521UntypedFieldElement>)(Ꮡtmp)));
    p521InvertEndianness(@out[..]);
    return @out[..];
}

// SetBytes sets e = v, where v is a big-endian 66-byte encoding, and returns e.
// If v is not 66 bytes or it encodes a value higher than 2^521 - 1,
// SetBytes returns nil and an error, and e is unchanged.
[GoRecv("capture")] public static (ж<P521Element>, error) SetBytes(this ref P521Element e, slice<byte> v) {
    if (len(v) != p521ElementLen) {
        return (default!, errors.New("invalid P521Element encoding"u8));
    }
    // Check for non-canonical encodings (p + k, 2p + k, etc.) by comparing to
    // the encoding of -1 mod p, so p - 1, the highest canonical encoding.
    slice<byte> minusOneEncoding = @new<P521Element>().Sub(
        @new<P521Element>(), @new<P521Element>().One()).Bytes();
    foreach (var (i, _) in v) {
        if (v[i] < minusOneEncoding[i]) {
            break;
        }
        if (v[i] > minusOneEncoding[i]) {
            return (default!, errors.New("invalid P521Element encoding"u8));
        }
    }
    ref var in = ref heap(new array<byte>(66), out var Ꮡin);
    copy(@in[..], v);
    p521InvertEndianness(@in[..]);
    ref var tmp = ref heap(new p521NonMontgomeryDomainFieldElement(), out var Ꮡtmp);
    p521FromBytes(((ж<p521UntypedFieldElement>)(Ꮡtmp)), Ꮡ@in);
    p521ToMontgomery(Ꮡ(e.x), Ꮡtmp);
    return (SetBytesꓸᏑe, default!);
}

// Add sets e = t1 + t2, and returns e.
[GoRecv("capture")] public static ж<P521Element> Add(this ref P521Element e, ж<P521Element> Ꮡt1, ж<P521Element> Ꮡt2) {
    ref var t1 = ref Ꮡt1.val;
    ref var t2 = ref Ꮡt2.val;

    p521Add(Ꮡ(e.x), Ꮡ(t1.x), Ꮡ(t2.x));
    return AddꓸᏑe;
}

// Sub sets e = t1 - t2, and returns e.
[GoRecv("capture")] public static ж<P521Element> Sub(this ref P521Element e, ж<P521Element> Ꮡt1, ж<P521Element> Ꮡt2) {
    ref var t1 = ref Ꮡt1.val;
    ref var t2 = ref Ꮡt2.val;

    p521Sub(Ꮡ(e.x), Ꮡ(t1.x), Ꮡ(t2.x));
    return SubꓸᏑe;
}

// Mul sets e = t1 * t2, and returns e.
[GoRecv("capture")] public static ж<P521Element> Mul(this ref P521Element e, ж<P521Element> Ꮡt1, ж<P521Element> Ꮡt2) {
    ref var t1 = ref Ꮡt1.val;
    ref var t2 = ref Ꮡt2.val;

    p521Mul(Ꮡ(e.x), Ꮡ(t1.x), Ꮡ(t2.x));
    return MulꓸᏑe;
}

// Square sets e = t * t, and returns e.
[GoRecv("capture")] public static ж<P521Element> Square(this ref P521Element e, ж<P521Element> Ꮡt) {
    ref var t = ref Ꮡt.val;

    p521Square(Ꮡ(e.x), Ꮡ(t.x));
    return SquareꓸᏑe;
}

// Select sets v to a if cond == 1, and to b if cond == 0.
[GoRecv("capture")] public static ж<P521Element> Select(this ref P521Element v, ж<P521Element> Ꮡa, ж<P521Element> Ꮡb, nint cond) {
    ref var a = ref Ꮡa.val;
    ref var b = ref Ꮡb.val;

    p521Selectznz(((ж<p521UntypedFieldElement>)(Ꮡ(v.x))), ((p521Uint1)cond),
        ((ж<p521UntypedFieldElement>)(Ꮡ(b.x))), ((ж<p521UntypedFieldElement>)(Ꮡ(a.x))));
    return SelectꓸᏑv;
}

internal static void p521InvertEndianness(slice<byte> v) {
    for (nint i = 0; i < len(v) / 2; i++) {
        (v[i], v[len(v) - 1 - i]) = (v[len(v) - 1 - i], v[i]);
    }
}

} // end fiat_package
