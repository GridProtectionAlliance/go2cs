// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Code generated by generate.go. DO NOT EDIT.
global using p224UntypedFieldElement = go.array<uint64>;

namespace go.crypto.@internal.nistec;

using subtle = crypto.subtle_package;
using errors = errors_package;
using crypto;

partial class fiat_package {

// P224Element is an integer modulo 2^224 - 2^96 + 1.
//
// The zero value is a valid zero element.
[GoType] partial struct P224Element {
    // Values are represented internally always in the Montgomery domain, and
    // converted in Bytes and SetBytes.
    internal p224MontgomeryDomainFieldElement x;
}

internal static readonly UntypedInt p224ElementLen = 28;

// One sets e = 1, and returns e.
[GoRecv("capture")] public static ж<P224Element> One(this ref P224Element e) {
    p224SetOne(Ꮡ(e.x));
    return OneꓸᏑe;
}

// Equal returns 1 if e == t, and zero otherwise.
[GoRecv] public static nint Equal(this ref P224Element e, ж<P224Element> Ꮡt) {
    ref var t = ref Ꮡt.val;

    var eBytes = e.Bytes();
    var tBytes = t.Bytes();
    return subtle.ConstantTimeCompare(eBytes, tBytes);
}

// IsZero returns 1 if e == 0, and zero otherwise.
[GoRecv] public static nint IsZero(this ref P224Element e) {
    var zero = new slice<byte>(p224ElementLen);
    var eBytes = e.Bytes();
    return subtle.ConstantTimeCompare(eBytes, zero);
}

// Set sets e = t, and returns e.
[GoRecv("capture")] public static ж<P224Element> Set(this ref P224Element e, ж<P224Element> Ꮡt) {
    ref var t = ref Ꮡt.val;

    e.x = t.x;
    return SetꓸᏑe;
}

// Bytes returns the 28-byte big-endian encoding of e.
[GoRecv] public static slice<byte> Bytes(this ref P224Element e) {
    // This function is outlined to make the allocations inline in the caller
    // rather than happen on the heap.
    ref var out = ref heap(new array<byte>(28), out var Ꮡout);
    return e.bytes(Ꮡ@out);
}

[GoRecv] public static slice<byte> bytes(this ref P224Element e, ж<array<byte>> Ꮡout) {
    ref var @out = ref Ꮡout.val;

    ref var tmp = ref heap(new p224NonMontgomeryDomainFieldElement(), out var Ꮡtmp);
    p224FromMontgomery(Ꮡtmp, Ꮡ(e.x));
    p224ToBytes(Ꮡout, ((ж<p224UntypedFieldElement>)(Ꮡtmp)));
    p224InvertEndianness(@out[..]);
    return @out[..];
}

// SetBytes sets e = v, where v is a big-endian 28-byte encoding, and returns e.
// If v is not 28 bytes or it encodes a value higher than 2^224 - 2^96 + 1,
// SetBytes returns nil and an error, and e is unchanged.
[GoRecv("capture")] public static (ж<P224Element>, error) SetBytes(this ref P224Element e, slice<byte> v) {
    if (len(v) != p224ElementLen) {
        return (default!, errors.New("invalid P224Element encoding"u8));
    }
    // Check for non-canonical encodings (p + k, 2p + k, etc.) by comparing to
    // the encoding of -1 mod p, so p - 1, the highest canonical encoding.
    slice<byte> minusOneEncoding = @new<P224Element>().Sub(
        @new<P224Element>(), @new<P224Element>().One()).Bytes();
    foreach (var (i, _) in v) {
        if (v[i] < minusOneEncoding[i]) {
            break;
        }
        if (v[i] > minusOneEncoding[i]) {
            return (default!, errors.New("invalid P224Element encoding"u8));
        }
    }
    ref var in = ref heap(new array<byte>(28), out var Ꮡin);
    copy(@in[..], v);
    p224InvertEndianness(@in[..]);
    ref var tmp = ref heap(new p224NonMontgomeryDomainFieldElement(), out var Ꮡtmp);
    p224FromBytes(((ж<p224UntypedFieldElement>)(Ꮡtmp)), Ꮡ@in);
    p224ToMontgomery(Ꮡ(e.x), Ꮡtmp);
    return (SetBytesꓸᏑe, default!);
}

// Add sets e = t1 + t2, and returns e.
[GoRecv("capture")] public static ж<P224Element> Add(this ref P224Element e, ж<P224Element> Ꮡt1, ж<P224Element> Ꮡt2) {
    ref var t1 = ref Ꮡt1.val;
    ref var t2 = ref Ꮡt2.val;

    p224Add(Ꮡ(e.x), Ꮡ(t1.x), Ꮡ(t2.x));
    return AddꓸᏑe;
}

// Sub sets e = t1 - t2, and returns e.
[GoRecv("capture")] public static ж<P224Element> Sub(this ref P224Element e, ж<P224Element> Ꮡt1, ж<P224Element> Ꮡt2) {
    ref var t1 = ref Ꮡt1.val;
    ref var t2 = ref Ꮡt2.val;

    p224Sub(Ꮡ(e.x), Ꮡ(t1.x), Ꮡ(t2.x));
    return SubꓸᏑe;
}

// Mul sets e = t1 * t2, and returns e.
[GoRecv("capture")] public static ж<P224Element> Mul(this ref P224Element e, ж<P224Element> Ꮡt1, ж<P224Element> Ꮡt2) {
    ref var t1 = ref Ꮡt1.val;
    ref var t2 = ref Ꮡt2.val;

    p224Mul(Ꮡ(e.x), Ꮡ(t1.x), Ꮡ(t2.x));
    return MulꓸᏑe;
}

// Square sets e = t * t, and returns e.
[GoRecv("capture")] public static ж<P224Element> Square(this ref P224Element e, ж<P224Element> Ꮡt) {
    ref var t = ref Ꮡt.val;

    p224Square(Ꮡ(e.x), Ꮡ(t.x));
    return SquareꓸᏑe;
}

// Select sets v to a if cond == 1, and to b if cond == 0.
[GoRecv("capture")] public static ж<P224Element> Select(this ref P224Element v, ж<P224Element> Ꮡa, ж<P224Element> Ꮡb, nint cond) {
    ref var a = ref Ꮡa.val;
    ref var b = ref Ꮡb.val;

    p224Selectznz(((ж<p224UntypedFieldElement>)(Ꮡ(v.x))), ((p224Uint1)cond),
        ((ж<p224UntypedFieldElement>)(Ꮡ(b.x))), ((ж<p224UntypedFieldElement>)(Ꮡ(a.x))));
    return SelectꓸᏑv;
}

internal static void p224InvertEndianness(slice<byte> v) {
    for (nint i = 0; i < len(v) / 2; i++) {
        (v[i], v[len(v) - 1 - i]) = (v[len(v) - 1 - i], v[i]);
    }
}

} // end fiat_package
