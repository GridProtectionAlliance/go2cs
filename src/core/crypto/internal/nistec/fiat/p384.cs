// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Code generated by generate.go. DO NOT EDIT.
global using p384UntypedFieldElement = go.array<uint64>;

namespace go.crypto.@internal.nistec;

using subtle = crypto.subtle_package;
using errors = errors_package;
using crypto;

partial class fiat_package {

// P384Element is an integer modulo 2^384 - 2^128 - 2^96 + 2^32 - 1.
//
// The zero value is a valid zero element.
[GoType] partial struct P384Element {
    // Values are represented internally always in the Montgomery domain, and
    // converted in Bytes and SetBytes.
    internal p384MontgomeryDomainFieldElement x;
}

internal static readonly UntypedInt p384ElementLen = 48;

// One sets e = 1, and returns e.
[GoRecv("capture")] public static ж<P384Element> One(this ref P384Element e) {
    p384SetOne(Ꮡ(e.x));
    return OneꓸᏑe;
}

// Equal returns 1 if e == t, and zero otherwise.
[GoRecv] public static nint Equal(this ref P384Element e, ж<P384Element> Ꮡt) {
    ref var t = ref Ꮡt.val;

    var eBytes = e.Bytes();
    var tBytes = t.Bytes();
    return subtle.ConstantTimeCompare(eBytes, tBytes);
}

// IsZero returns 1 if e == 0, and zero otherwise.
[GoRecv] public static nint IsZero(this ref P384Element e) {
    var zero = new slice<byte>(p384ElementLen);
    var eBytes = e.Bytes();
    return subtle.ConstantTimeCompare(eBytes, zero);
}

// Set sets e = t, and returns e.
[GoRecv("capture")] public static ж<P384Element> Set(this ref P384Element e, ж<P384Element> Ꮡt) {
    ref var t = ref Ꮡt.val;

    e.x = t.x;
    return SetꓸᏑe;
}

// Bytes returns the 48-byte big-endian encoding of e.
[GoRecv] public static slice<byte> Bytes(this ref P384Element e) {
    // This function is outlined to make the allocations inline in the caller
    // rather than happen on the heap.
    ref var out = ref heap(new array<byte>(48), out var Ꮡout);
    return e.bytes(Ꮡ@out);
}

[GoRecv] public static slice<byte> bytes(this ref P384Element e, ж<array<byte>> Ꮡout) {
    ref var @out = ref Ꮡout.val;

    ref var tmp = ref heap(new p384NonMontgomeryDomainFieldElement(), out var Ꮡtmp);
    p384FromMontgomery(Ꮡtmp, Ꮡ(e.x));
    p384ToBytes(Ꮡout, ((ж<p384UntypedFieldElement>)(Ꮡtmp)));
    p384InvertEndianness(@out[..]);
    return @out[..];
}

// SetBytes sets e = v, where v is a big-endian 48-byte encoding, and returns e.
// If v is not 48 bytes or it encodes a value higher than 2^384 - 2^128 - 2^96 + 2^32 - 1,
// SetBytes returns nil and an error, and e is unchanged.
[GoRecv("capture")] public static (ж<P384Element>, error) SetBytes(this ref P384Element e, slice<byte> v) {
    if (len(v) != p384ElementLen) {
        return (default!, errors.New("invalid P384Element encoding"u8));
    }
    // Check for non-canonical encodings (p + k, 2p + k, etc.) by comparing to
    // the encoding of -1 mod p, so p - 1, the highest canonical encoding.
    slice<byte> minusOneEncoding = @new<P384Element>().Sub(
        @new<P384Element>(), @new<P384Element>().One()).Bytes();
    foreach (var (i, _) in v) {
        if (v[i] < minusOneEncoding[i]) {
            break;
        }
        if (v[i] > minusOneEncoding[i]) {
            return (default!, errors.New("invalid P384Element encoding"u8));
        }
    }
    ref var in = ref heap(new array<byte>(48), out var Ꮡin);
    copy(@in[..], v);
    p384InvertEndianness(@in[..]);
    ref var tmp = ref heap(new p384NonMontgomeryDomainFieldElement(), out var Ꮡtmp);
    p384FromBytes(((ж<p384UntypedFieldElement>)(Ꮡtmp)), Ꮡ@in);
    p384ToMontgomery(Ꮡ(e.x), Ꮡtmp);
    return (SetBytesꓸᏑe, default!);
}

// Add sets e = t1 + t2, and returns e.
[GoRecv("capture")] public static ж<P384Element> Add(this ref P384Element e, ж<P384Element> Ꮡt1, ж<P384Element> Ꮡt2) {
    ref var t1 = ref Ꮡt1.val;
    ref var t2 = ref Ꮡt2.val;

    p384Add(Ꮡ(e.x), Ꮡ(t1.x), Ꮡ(t2.x));
    return AddꓸᏑe;
}

// Sub sets e = t1 - t2, and returns e.
[GoRecv("capture")] public static ж<P384Element> Sub(this ref P384Element e, ж<P384Element> Ꮡt1, ж<P384Element> Ꮡt2) {
    ref var t1 = ref Ꮡt1.val;
    ref var t2 = ref Ꮡt2.val;

    p384Sub(Ꮡ(e.x), Ꮡ(t1.x), Ꮡ(t2.x));
    return SubꓸᏑe;
}

// Mul sets e = t1 * t2, and returns e.
[GoRecv("capture")] public static ж<P384Element> Mul(this ref P384Element e, ж<P384Element> Ꮡt1, ж<P384Element> Ꮡt2) {
    ref var t1 = ref Ꮡt1.val;
    ref var t2 = ref Ꮡt2.val;

    p384Mul(Ꮡ(e.x), Ꮡ(t1.x), Ꮡ(t2.x));
    return MulꓸᏑe;
}

// Square sets e = t * t, and returns e.
[GoRecv("capture")] public static ж<P384Element> Square(this ref P384Element e, ж<P384Element> Ꮡt) {
    ref var t = ref Ꮡt.val;

    p384Square(Ꮡ(e.x), Ꮡ(t.x));
    return SquareꓸᏑe;
}

// Select sets v to a if cond == 1, and to b if cond == 0.
[GoRecv("capture")] public static ж<P384Element> Select(this ref P384Element v, ж<P384Element> Ꮡa, ж<P384Element> Ꮡb, nint cond) {
    ref var a = ref Ꮡa.val;
    ref var b = ref Ꮡb.val;

    p384Selectznz(((ж<p384UntypedFieldElement>)(Ꮡ(v.x))), ((p384Uint1)cond),
        ((ж<p384UntypedFieldElement>)(Ꮡ(b.x))), ((ж<p384UntypedFieldElement>)(Ꮡ(a.x))));
    return SelectꓸᏑv;
}

internal static void p384InvertEndianness(slice<byte> v) {
    for (nint i = 0; i < len(v) / 2; i++) {
        (v[i], v[len(v) - 1 - i]) = (v[len(v) - 1 - i], v[i]);
    }
}

} // end fiat_package
