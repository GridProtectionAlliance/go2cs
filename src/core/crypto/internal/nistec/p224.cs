// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Code generated by generate.go. DO NOT EDIT.
namespace go.crypto.@internal;

using fiat = crypto.@internal.nistec.fiat_package;
using subtle = crypto.subtle_package;
using errors = errors_package;
using sync = sync_package;
using crypto;
using crypto.@internal.nistec;

partial class nistec_package {

// p224ElementLength is the length of an element of the base or scalar field,
// which have the same bytes length for all NIST P curves.
internal static readonly UntypedInt p224ElementLength = 28;

// P224Point is a P224 point. The zero value is NOT valid.
[GoType] partial struct P224Point {
    // The point is represented in projective coordinates (X:Y:Z),
    // where x = X/Z and y = Y/Z.
    internal ж<crypto.@internal.nistec.fiat_package.P224Element> x;
    internal ж<crypto.@internal.nistec.fiat_package.P224Element> y;
    internal ж<crypto.@internal.nistec.fiat_package.P224Element> z;
}

// NewP224Point returns a new P224Point representing the point at infinity point.
public static ж<P224Point> NewP224Point() {
    return Ꮡ(new P224Point(
        x: @new<fiat.P224Element>(),
        y: @new<fiat.P224Element>().One(),
        z: @new<fiat.P224Element>()
    ));
}

// SetGenerator sets p to the canonical generator and returns p.
[GoRecv("capture")] public static ж<P224Point> SetGenerator(this ref P224Point p) {
    p.x.SetBytes(new byte[]{183, 14, 12, 189, 107, 180, 191, 127, 50, 19, 144, 185, 74, 3, 193, 211, 86, 194, 17, 34, 52, 50, 128, 214, 17, 92, 29, 33}.slice());
    p.y.SetBytes(new byte[]{189, 55, 99, 136, 181, 247, 35, 251, 76, 34, 223, 230, 205, 67, 117, 160, 90, 7, 71, 100, 68, 213, 129, 153, 133, 0, 126, 52}.slice());
    p.z.One();
    return SetGeneratorꓸᏑp;
}

// Set sets p = q and returns p.
[GoRecv("capture")] public static ж<P224Point> Set(this ref P224Point p, ж<P224Point> Ꮡq) {
    ref var q = ref Ꮡq.val;

    p.x.Set(q.x);
    p.y.Set(q.y);
    p.z.Set(q.z);
    return SetꓸᏑp;
}

// SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
// b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
// the curve, it returns nil and an error, and the receiver is unchanged.
// Otherwise, it returns p.
[GoRecv("capture")] public static (ж<P224Point>, error) SetBytes(this ref P224Point p, slice<byte> b) {
    switch (ᐧ) {
    case {} when len(b) == 1 && b[0] == 0: {
        return (p.Set(NewP224Point()), default!);
    }
    case {} when len(b) == 1 + 2 * p224ElementLength && b[0] == 4: {
        (x, err) = @new<fiat.P224Element>().SetBytes(b[1..(int)(1 + p224ElementLength)]);
        if (err != default!) {
            // Point at infinity.
            // Uncompressed form.
            return (default!, err);
        }
        (y, err) = @new<fiat.P224Element>().SetBytes(b[(int)(1 + p224ElementLength)..]);
        if (err != default!) {
            return (default!, err);
        }
        {
            var errΔ1 = p224CheckOnCurve(x, y); if (errΔ1 != default!) {
                return (default!, errΔ1);
            }
        }
        p.x.Set(x);
        p.y.Set(y);
        p.z.One();
        return (SetBytesꓸᏑp, default!);
    }
    case {} when len(b) == 1 + p224ElementLength && (b[0] == 2 || b[0] == 3): {
        (x, err) = @new<fiat.P224Element>().SetBytes(b[1..]);
        if (err != default!) {
            // Compressed form.
            return (default!, err);
        }
        var y = p224Polynomial(@new<fiat.P224Element>(), // y² = x³ - 3x + b
 x);
        if (!p224Sqrt(y, y)) {
            return (default!, errors.New("invalid P224 compressed point encoding"u8));
        }
        var otherRoot = @new<fiat.P224Element>();
        otherRoot.Sub(otherRoot, // Select the positive or negative root, as indicated by the least
 // significant bit, based on the encoding type byte.
 y);
        var cond = (byte)((byte)(y.Bytes()[p224ElementLength - 1] & 1) ^ (byte)(b[0] & 1));
        y.Select(otherRoot, y, ((nint)cond));
        p.x.Set(x);
        p.y.Set(y);
        p.z.One();
        return (SetBytesꓸᏑp, default!);
    }
    default: {
        return (default!, errors.New("invalid P224 point encoding"u8));
    }}

}

internal static ж<fiat.P224Element> _p224B;

internal static sync.Once _p224BOnce;

internal static ж<fiat.P224Element> p224B() {
    _p224BOnce.Do(() => {
        (_p224B, _) = @new<fiat.P224Element>().SetBytes(new byte[]{180, 5, 10, 133, 12, 4, 179, 171, 245, 65, 50, 86, 80, 68, 176, 183, 215, 191, 216, 186, 39, 11, 57, 67, 35, 85, 255, 180}.slice());
    });
    return _p224B;
}

// p224Polynomial sets y2 to x³ - 3x + b, and returns y2.
internal static ж<fiat.P224Element> p224Polynomial(ж<fiat.P224Element> Ꮡy2, ж<fiat.P224Element> Ꮡx) {
    ref var y2 = ref Ꮡy2.val;
    ref var x = ref Ꮡx.val;

    y2.Square(Ꮡx);
    y2.Mul(Ꮡy2, Ꮡx);
    var threeX = @new<fiat.P224Element>().Add(Ꮡx, Ꮡx);
    threeX.Add(threeX, Ꮡx);
    y2.Sub(Ꮡy2, threeX);
    return y2.Add(Ꮡy2, p224B());
}

internal static error p224CheckOnCurve(ж<fiat.P224Element> Ꮡx, ж<fiat.P224Element> Ꮡy) {
    ref var x = ref Ꮡx.val;
    ref var y = ref Ꮡy.val;

    // y² = x³ - 3x + b
    var rhs = p224Polynomial(@new<fiat.P224Element>(), Ꮡx);
    var lhs = @new<fiat.P224Element>().Square(Ꮡy);
    if (rhs.Equal(lhs) != 1) {
        return errors.New("P224 point not on curve"u8);
    }
    return default!;
}

// Bytes returns the uncompressed or infinity encoding of p, as specified in
// SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
// infinity is shorter than all other encodings.
[GoRecv] public static slice<byte> Bytes(this ref P224Point p) {
    // This function is outlined to make the allocations inline in the caller
    // rather than happen on the heap.
    ref var out = ref heap(new array<byte>(57), out var Ꮡout);
    return p.bytes(Ꮡ@out);
}

[GoRecv] public static slice<byte> bytes(this ref P224Point p, ж<array<byte>> Ꮡout) {
    ref var @out = ref Ꮡout.val;

    if (p.z.IsZero() == 1) {
        return append(@out[..0], 0);
    }
    var zinv = @new<fiat.P224Element>().Invert(p.z);
    var x = @new<fiat.P224Element>().Mul(p.x, zinv);
    var y = @new<fiat.P224Element>().Mul(p.y, zinv);
    var buf = append(@out[..0], 4);
    buf = append(buf, x.Bytes().ꓸꓸꓸ);
    buf = append(buf, y.Bytes().ꓸꓸꓸ);
    return buf;
}

// BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
// Version 2.0, Section 2.3.5, or an error if p is the point at infinity.
[GoRecv] public static (slice<byte>, error) BytesX(this ref P224Point p) {
    // This function is outlined to make the allocations inline in the caller
    // rather than happen on the heap.
    ref var out = ref heap(new array<byte>(28), out var Ꮡout);
    return p.bytesX(Ꮡ@out);
}

[GoRecv] public static (slice<byte>, error) bytesX(this ref P224Point p, ж<array<byte>> Ꮡout) {
    ref var @out = ref Ꮡout.val;

    if (p.z.IsZero() == 1) {
        return (default!, errors.New("P224 point is the point at infinity"u8));
    }
    var zinv = @new<fiat.P224Element>().Invert(p.z);
    var x = @new<fiat.P224Element>().Mul(p.x, zinv);
    return (append(@out[..0], x.Bytes().ꓸꓸꓸ), default!);
}

// BytesCompressed returns the compressed or infinity encoding of p, as
// specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
// point at infinity is shorter than all other encodings.
[GoRecv] public static slice<byte> BytesCompressed(this ref P224Point p) {
    // This function is outlined to make the allocations inline in the caller
    // rather than happen on the heap.
    ref var out = ref heap(new array<byte>(29), out var Ꮡout);
    return p.bytesCompressed(Ꮡ@out);
}

[GoRecv] public static slice<byte> bytesCompressed(this ref P224Point p, ж<array<byte>> Ꮡout) {
    ref var @out = ref Ꮡout.val;

    if (p.z.IsZero() == 1) {
        return append(@out[..0], 0);
    }
    var zinv = @new<fiat.P224Element>().Invert(p.z);
    var x = @new<fiat.P224Element>().Mul(p.x, zinv);
    var y = @new<fiat.P224Element>().Mul(p.y, zinv);
    // Encode the sign of the y coordinate (indicated by the least significant
    // bit) as the encoding type (2 or 3).
    var buf = append(@out[..0], 2);
    buf[0] |= (byte)((byte)(y.Bytes()[p224ElementLength - 1] & 1));
    buf = append(buf, x.Bytes().ꓸꓸꓸ);
    return buf;
}

// Add sets q = p1 + p2, and returns q. The points may overlap.
[GoRecv("capture")] public static ж<P224Point> Add(this ref P224Point q, ж<P224Point> Ꮡp1, ж<P224Point> Ꮡp2) {
    ref var p1 = ref Ꮡp1.val;
    ref var p2 = ref Ꮡp2.val;

    // Complete addition formula for a = -3 from "Complete addition formulas for
    // prime order elliptic curves" (https://eprint.iacr.org/2015/1060), §A.2.
    var t0 = @new<fiat.P224Element>().Mul(p1.x, p2.x);
    // t0 := X1 * X2
    var t1 = @new<fiat.P224Element>().Mul(p1.y, p2.y);
    // t1 := Y1 * Y2
    var t2 = @new<fiat.P224Element>().Mul(p1.z, p2.z);
    // t2 := Z1 * Z2
    var t3 = @new<fiat.P224Element>().Add(p1.x, p1.y);
    // t3 := X1 + Y1
    var t4 = @new<fiat.P224Element>().Add(p2.x, p2.y);
    // t4 := X2 + Y2
    t3.Mul(t3, t4);
    // t3 := t3 * t4
    t4.Add(t0, t1);
    // t4 := t0 + t1
    t3.Sub(t3, t4);
    // t3 := t3 - t4
    t4.Add(p1.y, p1.z);
    // t4 := Y1 + Z1
    var x3 = @new<fiat.P224Element>().Add(p2.y, p2.z);
    // X3 := Y2 + Z2
    t4.Mul(t4, x3);
    // t4 := t4 * X3
    x3.Add(t1, t2);
    // X3 := t1 + t2
    t4.Sub(t4, x3);
    // t4 := t4 - X3
    x3.Add(p1.x, p1.z);
    // X3 := X1 + Z1
    var y3 = @new<fiat.P224Element>().Add(p2.x, p2.z);
    // Y3 := X2 + Z2
    x3.Mul(x3, y3);
    // X3 := X3 * Y3
    y3.Add(t0, t2);
    // Y3 := t0 + t2
    y3.Sub(x3, y3);
    // Y3 := X3 - Y3
    var z3 = @new<fiat.P224Element>().Mul(p224B(), t2);
    // Z3 := b * t2
    x3.Sub(y3, z3);
    // X3 := Y3 - Z3
    z3.Add(x3, x3);
    // Z3 := X3 + X3
    x3.Add(x3, z3);
    // X3 := X3 + Z3
    z3.Sub(t1, x3);
    // Z3 := t1 - X3
    x3.Add(t1, x3);
    // X3 := t1 + X3
    y3.Mul(p224B(), y3);
    // Y3 := b * Y3
    t1.Add(t2, t2);
    // t1 := t2 + t2
    t2.Add(t1, t2);
    // t2 := t1 + t2
    y3.Sub(y3, t2);
    // Y3 := Y3 - t2
    y3.Sub(y3, t0);
    // Y3 := Y3 - t0
    t1.Add(y3, y3);
    // t1 := Y3 + Y3
    y3.Add(t1, y3);
    // Y3 := t1 + Y3
    t1.Add(t0, t0);
    // t1 := t0 + t0
    t0.Add(t1, t0);
    // t0 := t1 + t0
    t0.Sub(t0, t2);
    // t0 := t0 - t2
    t1.Mul(t4, y3);
    // t1 := t4 * Y3
    t2.Mul(t0, y3);
    // t2 := t0 * Y3
    y3.Mul(x3, z3);
    // Y3 := X3 * Z3
    y3.Add(y3, t2);
    // Y3 := Y3 + t2
    x3.Mul(t3, x3);
    // X3 := t3 * X3
    x3.Sub(x3, t1);
    // X3 := X3 - t1
    z3.Mul(t4, z3);
    // Z3 := t4 * Z3
    t1.Mul(t3, t0);
    // t1 := t3 * t0
    z3.Add(z3, t1);
    // Z3 := Z3 + t1
    q.x.Set(x3);
    q.y.Set(y3);
    q.z.Set(z3);
    return AddꓸᏑq;
}

// Double sets q = p + p, and returns q. The points may overlap.
[GoRecv("capture")] public static ж<P224Point> Double(this ref P224Point q, ж<P224Point> Ꮡp) {
    ref var p = ref Ꮡp.val;

    // Complete addition formula for a = -3 from "Complete addition formulas for
    // prime order elliptic curves" (https://eprint.iacr.org/2015/1060), §A.2.
    var t0 = @new<fiat.P224Element>().Square(p.x);
    // t0 := X ^ 2
    var t1 = @new<fiat.P224Element>().Square(p.y);
    // t1 := Y ^ 2
    var t2 = @new<fiat.P224Element>().Square(p.z);
    // t2 := Z ^ 2
    var t3 = @new<fiat.P224Element>().Mul(p.x, p.y);
    // t3 := X * Y
    t3.Add(t3, t3);
    // t3 := t3 + t3
    var z3 = @new<fiat.P224Element>().Mul(p.x, p.z);
    // Z3 := X * Z
    z3.Add(z3, z3);
    // Z3 := Z3 + Z3
    var y3 = @new<fiat.P224Element>().Mul(p224B(), t2);
    // Y3 := b * t2
    y3.Sub(y3, z3);
    // Y3 := Y3 - Z3
    var x3 = @new<fiat.P224Element>().Add(y3, y3);
    // X3 := Y3 + Y3
    y3.Add(x3, y3);
    // Y3 := X3 + Y3
    x3.Sub(t1, y3);
    // X3 := t1 - Y3
    y3.Add(t1, y3);
    // Y3 := t1 + Y3
    y3.Mul(x3, y3);
    // Y3 := X3 * Y3
    x3.Mul(x3, t3);
    // X3 := X3 * t3
    t3.Add(t2, t2);
    // t3 := t2 + t2
    t2.Add(t2, t3);
    // t2 := t2 + t3
    z3.Mul(p224B(), z3);
    // Z3 := b * Z3
    z3.Sub(z3, t2);
    // Z3 := Z3 - t2
    z3.Sub(z3, t0);
    // Z3 := Z3 - t0
    t3.Add(z3, z3);
    // t3 := Z3 + Z3
    z3.Add(z3, t3);
    // Z3 := Z3 + t3
    t3.Add(t0, t0);
    // t3 := t0 + t0
    t0.Add(t3, t0);
    // t0 := t3 + t0
    t0.Sub(t0, t2);
    // t0 := t0 - t2
    t0.Mul(t0, z3);
    // t0 := t0 * Z3
    y3.Add(y3, t0);
    // Y3 := Y3 + t0
    t0.Mul(p.y, p.z);
    // t0 := Y * Z
    t0.Add(t0, t0);
    // t0 := t0 + t0
    z3.Mul(t0, z3);
    // Z3 := t0 * Z3
    x3.Sub(x3, z3);
    // X3 := X3 - Z3
    z3.Mul(t0, t1);
    // Z3 := t0 * t1
    z3.Add(z3, z3);
    // Z3 := Z3 + Z3
    z3.Add(z3, z3);
    // Z3 := Z3 + Z3
    q.x.Set(x3);
    q.y.Set(y3);
    q.z.Set(z3);
    return DoubleꓸᏑq;
}

// Select sets q to p1 if cond == 1, and to p2 if cond == 0.
[GoRecv("capture")] public static ж<P224Point> Select(this ref P224Point q, ж<P224Point> Ꮡp1, ж<P224Point> Ꮡp2, nint cond) {
    ref var p1 = ref Ꮡp1.val;
    ref var p2 = ref Ꮡp2.val;

    q.x.Select(p1.x, p2.x, cond);
    q.y.Select(p1.y, p2.y, cond);
    q.z.Select(p1.z, p2.z, cond);
    return SelectꓸᏑq;
}

[GoType("[15]P224Point")] partial struct p224Table;

// Select selects the n-th multiple of the table base point into p. It works in
// constant time by iterating over every entry of the table. n must be in [0, 15].
[GoRecv] internal static void Select(this ref p224Table table, ж<P224Point> Ꮡp, uint8 n) {
    ref var p = ref Ꮡp.val;

    if (n >= 16) {
        throw panic("nistec: internal error: p224Table called with out-of-bounds value");
    }
    p.Set(NewP224Point());
    ref var i = ref heap<uint8>(out var Ꮡi);
    for (i = ((uint8)1); i < 16; i++) {
        nint cond = subtle.ConstantTimeByteEq(i, n);
        p.Select(table.val[i - 1], Ꮡp, cond);
    }
}

// ScalarMult sets p = scalar * q, and returns p.
[GoRecv("capture")] public static (ж<P224Point>, error) ScalarMult(this ref P224Point p, ж<P224Point> Ꮡq, slice<byte> scalar) {
    ref var q = ref Ꮡq.val;

    // Compute a p224Table for the base point q. The explicit NewP224Point
    // calls get inlined, letting the allocations live on the stack.
    ref var table = ref heap(new p224Table(), out var Ꮡtable);

    table = new p224Table{NewP224Point(), NewP224Point(), NewP224Point(),
        NewP224Point(), NewP224Point(), NewP224Point(), NewP224Point(),
        NewP224Point(), NewP224Point(), NewP224Point(), NewP224Point(),
        NewP224Point(), NewP224Point(), NewP224Point(), NewP224Point()};
    table[0].Set(Ꮡq);
    ref var i = ref heap<nint>(out var Ꮡi);
    for (i = 1; i < 15; i += 2) {
        table[i].Double(table[i / 2]);
        table[i + 1].Add(table[i], Ꮡq);
    }
    // Instead of doing the classic double-and-add chain, we do it with a
    // four-bit window: we double four times, and then add [0-15]P.
    var t = NewP224Point();
    p.Set(NewP224Point());
    foreach (var (i, @byte) in scalar) {
        // No need to double on the first iteration, as p is the identity at
        // this point, and [N]∞ = ∞.
        if (i != 0) {
            p.Double(p);
            p.Double(p);
            p.Double(p);
            p.Double(p);
        }
        var windowValue = @byte >> (int)(4);
        table.Select(t, windowValue);
        p.Add(p, t);
        p.Double(p);
        p.Double(p);
        p.Double(p);
        p.Double(p);
        windowValue = (byte)(@byte & 15);
        table.Select(t, windowValue);
        p.Add(p, t);
    }
    return (ScalarMultꓸᏑp, default!);
}

internal static ж<array<p224Table>> p224GeneratorTable;

internal static sync.Once p224GeneratorTableOnce;

// generatorTable returns a sequence of p224Tables. The first table contains
// multiples of G. Each successive table is the previous table doubled four
// times.
[GoRecv] internal static ж<array<p224Table>> generatorTable(this ref P224Point p) {
    p224GeneratorTableOnce.Do(() => {
        p224GeneratorTable = @new<array<p224Table>>();
        var @base = NewP224Point().SetGenerator();
        ref var i = ref heap<nint>(out var Ꮡi);
        for (i = 0; i < p224ElementLength * 2; i++) {
            p224GeneratorTable.val[i][0] = NewP224Point().Set(@base);
            ref var j = ref heap<nint>(out var Ꮡj);
            for (j = 1; j < 15; j++) {
                p224GeneratorTable.val[i][j] = NewP224Point().Add(p224GeneratorTable.val[i][j - 1], @base);
            }
            @base.Double(@base);
            @base.Double(@base);
            @base.Double(@base);
            @base.Double(@base);
        }
    });
    return p224GeneratorTable;
}

// ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and
// returns p.
[GoRecv("capture")] public static (ж<P224Point>, error) ScalarBaseMult(this ref P224Point p, slice<byte> scalar) {
    if (len(scalar) != p224ElementLength) {
        return (default!, errors.New("invalid scalar length"u8));
    }
    var tables = p.generatorTable();
    // This is also a scalar multiplication with a four-bit window like in
    // ScalarMult, but in this case the doublings are precomputed. The value
    // [windowValue]G added at iteration k would normally get doubled
    // (totIterations-k)×4 times, but with a larger precomputation we can
    // instead add [2^((totIterations-k)×4)][windowValue]G and avoid the
    // doublings between iterations.
    var t = NewP224Point();
    p.Set(NewP224Point());
    nint tableIndex = len(tables) - 1;
    foreach (var (_, @byte) in scalar) {
        var windowValue = @byte >> (int)(4);
        tables.val[tableIndex].Select(t, windowValue);
        p.Add(p, t);
        tableIndex--;
        windowValue = (byte)(@byte & 15);
        tables.val[tableIndex].Select(t, windowValue);
        p.Add(p, t);
        tableIndex--;
    }
    return (ScalarBaseMultꓸᏑp, default!);
}

// p224Sqrt sets e to a square root of x. If x is not a square, p224Sqrt returns
// false and e is unchanged. e and x can overlap.
internal static bool /*isSquare*/ p224Sqrt(ж<fiat.P224Element> Ꮡe, ж<fiat.P224Element> Ꮡx) {
    bool isSquare = default!;

    ref var e = ref Ꮡe.val;
    ref var x = ref Ꮡx.val;
    var candidate = @new<fiat.P224Element>();
    p224SqrtCandidate(candidate, Ꮡx);
    var square = @new<fiat.P224Element>().Square(candidate);
    if (square.Equal(Ꮡx) != 1) {
        return false;
    }
    e.Set(candidate);
    return true;
}

} // end nistec_package
