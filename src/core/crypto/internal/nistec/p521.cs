// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Code generated by generate.go. DO NOT EDIT.
namespace go.crypto.@internal;

using fiat = crypto.@internal.nistec.fiat_package;
using subtle = crypto.subtle_package;
using errors = errors_package;
using sync = sync_package;
using crypto;
using crypto.@internal.nistec;

partial class nistec_package {

// p521ElementLength is the length of an element of the base or scalar field,
// which have the same bytes length for all NIST P curves.
internal static readonly UntypedInt p521ElementLength = 66;

// P521Point is a P521 point. The zero value is NOT valid.
[GoType] partial struct P521Point {
    // The point is represented in projective coordinates (X:Y:Z),
    // where x = X/Z and y = Y/Z.
    internal ж<crypto.@internal.nistec.fiat_package.P521Element> x;
    internal ж<crypto.@internal.nistec.fiat_package.P521Element> y;
    internal ж<crypto.@internal.nistec.fiat_package.P521Element> z;
}

// NewP521Point returns a new P521Point representing the point at infinity point.
public static ж<P521Point> NewP521Point() {
    return Ꮡ(new P521Point(
        x: @new<fiat.P521Element>(),
        y: @new<fiat.P521Element>().One(),
        z: @new<fiat.P521Element>()
    ));
}

// SetGenerator sets p to the canonical generator and returns p.
[GoRecv("capture")] public static ж<P521Point> SetGenerator(this ref P521Point p) {
    p.x.SetBytes(new byte[]{0, 198, 133, 142, 6, 183, 4, 4, 233, 205, 158, 62, 203, 102, 35, 149, 180, 66, 156, 100, 129, 57, 5, 63, 181, 33, 248, 40, 175, 96, 107, 77, 61, 186, 161, 75, 94, 119, 239, 231, 89, 40, 254, 29, 193, 39, 162, 255, 168, 222, 51, 72, 179, 193, 133, 106, 66, 155, 249, 126, 126, 49, 194, 229, 189, 102}.slice());
    p.y.SetBytes(new byte[]{1, 24, 57, 41, 106, 120, 154, 59, 192, 4, 92, 138, 95, 180, 44, 125, 27, 217, 152, 245, 68, 73, 87, 155, 68, 104, 23, 175, 189, 23, 39, 62, 102, 44, 151, 238, 114, 153, 94, 244, 38, 64, 197, 80, 185, 1, 63, 173, 7, 97, 53, 60, 112, 134, 162, 114, 194, 64, 136, 190, 148, 118, 159, 209, 102, 80}.slice());
    p.z.One();
    return SetGeneratorꓸᏑp;
}

// Set sets p = q and returns p.
[GoRecv("capture")] public static ж<P521Point> Set(this ref P521Point p, ж<P521Point> Ꮡq) {
    ref var q = ref Ꮡq.val;

    p.x.Set(q.x);
    p.y.Set(q.y);
    p.z.Set(q.z);
    return SetꓸᏑp;
}

// SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
// b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
// the curve, it returns nil and an error, and the receiver is unchanged.
// Otherwise, it returns p.
[GoRecv("capture")] public static (ж<P521Point>, error) SetBytes(this ref P521Point p, slice<byte> b) {
    switch (ᐧ) {
    case {} when len(b) == 1 && b[0] == 0: {
        return (p.Set(NewP521Point()), default!);
    }
    case {} when len(b) == 1 + 2 * p521ElementLength && b[0] == 4: {
        (x, err) = @new<fiat.P521Element>().SetBytes(b[1..(int)(1 + p521ElementLength)]);
        if (err != default!) {
            // Point at infinity.
            // Uncompressed form.
            return (default!, err);
        }
        (y, err) = @new<fiat.P521Element>().SetBytes(b[(int)(1 + p521ElementLength)..]);
        if (err != default!) {
            return (default!, err);
        }
        {
            var errΔ1 = p521CheckOnCurve(x, y); if (errΔ1 != default!) {
                return (default!, errΔ1);
            }
        }
        p.x.Set(x);
        p.y.Set(y);
        p.z.One();
        return (SetBytesꓸᏑp, default!);
    }
    case {} when len(b) == 1 + p521ElementLength && (b[0] == 2 || b[0] == 3): {
        (x, err) = @new<fiat.P521Element>().SetBytes(b[1..]);
        if (err != default!) {
            // Compressed form.
            return (default!, err);
        }
        var y = p521Polynomial(@new<fiat.P521Element>(), // y² = x³ - 3x + b
 x);
        if (!p521Sqrt(y, y)) {
            return (default!, errors.New("invalid P521 compressed point encoding"u8));
        }
        var otherRoot = @new<fiat.P521Element>();
        otherRoot.Sub(otherRoot, // Select the positive or negative root, as indicated by the least
 // significant bit, based on the encoding type byte.
 y);
        var cond = (byte)((byte)(y.Bytes()[p521ElementLength - 1] & 1) ^ (byte)(b[0] & 1));
        y.Select(otherRoot, y, ((nint)cond));
        p.x.Set(x);
        p.y.Set(y);
        p.z.One();
        return (SetBytesꓸᏑp, default!);
    }
    default: {
        return (default!, errors.New("invalid P521 point encoding"u8));
    }}

}

internal static ж<fiat.P521Element> _p521B;

internal static sync.Once _p521BOnce;

internal static ж<fiat.P521Element> p521B() {
    _p521BOnce.Do(() => {
        (_p521B, _) = @new<fiat.P521Element>().SetBytes(new byte[]{0, 81, 149, 62, 185, 97, 142, 28, 154, 31, 146, 154, 33, 160, 182, 133, 64, 238, 162, 218, 114, 91, 153, 179, 21, 243, 184, 180, 137, 145, 142, 241, 9, 225, 86, 25, 57, 81, 236, 126, 147, 123, 22, 82, 192, 189, 59, 177, 191, 7, 53, 115, 223, 136, 61, 44, 52, 241, 239, 69, 31, 212, 107, 80, 63, 0}.slice());
    });
    return _p521B;
}

// p521Polynomial sets y2 to x³ - 3x + b, and returns y2.
internal static ж<fiat.P521Element> p521Polynomial(ж<fiat.P521Element> Ꮡy2, ж<fiat.P521Element> Ꮡx) {
    ref var y2 = ref Ꮡy2.val;
    ref var x = ref Ꮡx.val;

    y2.Square(Ꮡx);
    y2.Mul(Ꮡy2, Ꮡx);
    var threeX = @new<fiat.P521Element>().Add(Ꮡx, Ꮡx);
    threeX.Add(threeX, Ꮡx);
    y2.Sub(Ꮡy2, threeX);
    return y2.Add(Ꮡy2, p521B());
}

internal static error p521CheckOnCurve(ж<fiat.P521Element> Ꮡx, ж<fiat.P521Element> Ꮡy) {
    ref var x = ref Ꮡx.val;
    ref var y = ref Ꮡy.val;

    // y² = x³ - 3x + b
    var rhs = p521Polynomial(@new<fiat.P521Element>(), Ꮡx);
    var lhs = @new<fiat.P521Element>().Square(Ꮡy);
    if (rhs.Equal(lhs) != 1) {
        return errors.New("P521 point not on curve"u8);
    }
    return default!;
}

// Bytes returns the uncompressed or infinity encoding of p, as specified in
// SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
// infinity is shorter than all other encodings.
[GoRecv] public static slice<byte> Bytes(this ref P521Point p) {
    // This function is outlined to make the allocations inline in the caller
    // rather than happen on the heap.
    ref var out = ref heap(new array<byte>(133), out var Ꮡout);
    return p.bytes(Ꮡ@out);
}

[GoRecv] public static slice<byte> bytes(this ref P521Point p, ж<array<byte>> Ꮡout) {
    ref var @out = ref Ꮡout.val;

    if (p.z.IsZero() == 1) {
        return append(@out[..0], 0);
    }
    var zinv = @new<fiat.P521Element>().Invert(p.z);
    var x = @new<fiat.P521Element>().Mul(p.x, zinv);
    var y = @new<fiat.P521Element>().Mul(p.y, zinv);
    var buf = append(@out[..0], 4);
    buf = append(buf, x.Bytes().ꓸꓸꓸ);
    buf = append(buf, y.Bytes().ꓸꓸꓸ);
    return buf;
}

// BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
// Version 2.0, Section 2.3.5, or an error if p is the point at infinity.
[GoRecv] public static (slice<byte>, error) BytesX(this ref P521Point p) {
    // This function is outlined to make the allocations inline in the caller
    // rather than happen on the heap.
    ref var out = ref heap(new array<byte>(66), out var Ꮡout);
    return p.bytesX(Ꮡ@out);
}

[GoRecv] public static (slice<byte>, error) bytesX(this ref P521Point p, ж<array<byte>> Ꮡout) {
    ref var @out = ref Ꮡout.val;

    if (p.z.IsZero() == 1) {
        return (default!, errors.New("P521 point is the point at infinity"u8));
    }
    var zinv = @new<fiat.P521Element>().Invert(p.z);
    var x = @new<fiat.P521Element>().Mul(p.x, zinv);
    return (append(@out[..0], x.Bytes().ꓸꓸꓸ), default!);
}

// BytesCompressed returns the compressed or infinity encoding of p, as
// specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
// point at infinity is shorter than all other encodings.
[GoRecv] public static slice<byte> BytesCompressed(this ref P521Point p) {
    // This function is outlined to make the allocations inline in the caller
    // rather than happen on the heap.
    ref var out = ref heap(new array<byte>(67), out var Ꮡout);
    return p.bytesCompressed(Ꮡ@out);
}

[GoRecv] public static slice<byte> bytesCompressed(this ref P521Point p, ж<array<byte>> Ꮡout) {
    ref var @out = ref Ꮡout.val;

    if (p.z.IsZero() == 1) {
        return append(@out[..0], 0);
    }
    var zinv = @new<fiat.P521Element>().Invert(p.z);
    var x = @new<fiat.P521Element>().Mul(p.x, zinv);
    var y = @new<fiat.P521Element>().Mul(p.y, zinv);
    // Encode the sign of the y coordinate (indicated by the least significant
    // bit) as the encoding type (2 or 3).
    var buf = append(@out[..0], 2);
    buf[0] |= (byte)((byte)(y.Bytes()[p521ElementLength - 1] & 1));
    buf = append(buf, x.Bytes().ꓸꓸꓸ);
    return buf;
}

// Add sets q = p1 + p2, and returns q. The points may overlap.
[GoRecv("capture")] public static ж<P521Point> Add(this ref P521Point q, ж<P521Point> Ꮡp1, ж<P521Point> Ꮡp2) {
    ref var p1 = ref Ꮡp1.val;
    ref var p2 = ref Ꮡp2.val;

    // Complete addition formula for a = -3 from "Complete addition formulas for
    // prime order elliptic curves" (https://eprint.iacr.org/2015/1060), §A.2.
    var t0 = @new<fiat.P521Element>().Mul(p1.x, p2.x);
    // t0 := X1 * X2
    var t1 = @new<fiat.P521Element>().Mul(p1.y, p2.y);
    // t1 := Y1 * Y2
    var t2 = @new<fiat.P521Element>().Mul(p1.z, p2.z);
    // t2 := Z1 * Z2
    var t3 = @new<fiat.P521Element>().Add(p1.x, p1.y);
    // t3 := X1 + Y1
    var t4 = @new<fiat.P521Element>().Add(p2.x, p2.y);
    // t4 := X2 + Y2
    t3.Mul(t3, t4);
    // t3 := t3 * t4
    t4.Add(t0, t1);
    // t4 := t0 + t1
    t3.Sub(t3, t4);
    // t3 := t3 - t4
    t4.Add(p1.y, p1.z);
    // t4 := Y1 + Z1
    var x3 = @new<fiat.P521Element>().Add(p2.y, p2.z);
    // X3 := Y2 + Z2
    t4.Mul(t4, x3);
    // t4 := t4 * X3
    x3.Add(t1, t2);
    // X3 := t1 + t2
    t4.Sub(t4, x3);
    // t4 := t4 - X3
    x3.Add(p1.x, p1.z);
    // X3 := X1 + Z1
    var y3 = @new<fiat.P521Element>().Add(p2.x, p2.z);
    // Y3 := X2 + Z2
    x3.Mul(x3, y3);
    // X3 := X3 * Y3
    y3.Add(t0, t2);
    // Y3 := t0 + t2
    y3.Sub(x3, y3);
    // Y3 := X3 - Y3
    var z3 = @new<fiat.P521Element>().Mul(p521B(), t2);
    // Z3 := b * t2
    x3.Sub(y3, z3);
    // X3 := Y3 - Z3
    z3.Add(x3, x3);
    // Z3 := X3 + X3
    x3.Add(x3, z3);
    // X3 := X3 + Z3
    z3.Sub(t1, x3);
    // Z3 := t1 - X3
    x3.Add(t1, x3);
    // X3 := t1 + X3
    y3.Mul(p521B(), y3);
    // Y3 := b * Y3
    t1.Add(t2, t2);
    // t1 := t2 + t2
    t2.Add(t1, t2);
    // t2 := t1 + t2
    y3.Sub(y3, t2);
    // Y3 := Y3 - t2
    y3.Sub(y3, t0);
    // Y3 := Y3 - t0
    t1.Add(y3, y3);
    // t1 := Y3 + Y3
    y3.Add(t1, y3);
    // Y3 := t1 + Y3
    t1.Add(t0, t0);
    // t1 := t0 + t0
    t0.Add(t1, t0);
    // t0 := t1 + t0
    t0.Sub(t0, t2);
    // t0 := t0 - t2
    t1.Mul(t4, y3);
    // t1 := t4 * Y3
    t2.Mul(t0, y3);
    // t2 := t0 * Y3
    y3.Mul(x3, z3);
    // Y3 := X3 * Z3
    y3.Add(y3, t2);
    // Y3 := Y3 + t2
    x3.Mul(t3, x3);
    // X3 := t3 * X3
    x3.Sub(x3, t1);
    // X3 := X3 - t1
    z3.Mul(t4, z3);
    // Z3 := t4 * Z3
    t1.Mul(t3, t0);
    // t1 := t3 * t0
    z3.Add(z3, t1);
    // Z3 := Z3 + t1
    q.x.Set(x3);
    q.y.Set(y3);
    q.z.Set(z3);
    return AddꓸᏑq;
}

// Double sets q = p + p, and returns q. The points may overlap.
[GoRecv("capture")] public static ж<P521Point> Double(this ref P521Point q, ж<P521Point> Ꮡp) {
    ref var p = ref Ꮡp.val;

    // Complete addition formula for a = -3 from "Complete addition formulas for
    // prime order elliptic curves" (https://eprint.iacr.org/2015/1060), §A.2.
    var t0 = @new<fiat.P521Element>().Square(p.x);
    // t0 := X ^ 2
    var t1 = @new<fiat.P521Element>().Square(p.y);
    // t1 := Y ^ 2
    var t2 = @new<fiat.P521Element>().Square(p.z);
    // t2 := Z ^ 2
    var t3 = @new<fiat.P521Element>().Mul(p.x, p.y);
    // t3 := X * Y
    t3.Add(t3, t3);
    // t3 := t3 + t3
    var z3 = @new<fiat.P521Element>().Mul(p.x, p.z);
    // Z3 := X * Z
    z3.Add(z3, z3);
    // Z3 := Z3 + Z3
    var y3 = @new<fiat.P521Element>().Mul(p521B(), t2);
    // Y3 := b * t2
    y3.Sub(y3, z3);
    // Y3 := Y3 - Z3
    var x3 = @new<fiat.P521Element>().Add(y3, y3);
    // X3 := Y3 + Y3
    y3.Add(x3, y3);
    // Y3 := X3 + Y3
    x3.Sub(t1, y3);
    // X3 := t1 - Y3
    y3.Add(t1, y3);
    // Y3 := t1 + Y3
    y3.Mul(x3, y3);
    // Y3 := X3 * Y3
    x3.Mul(x3, t3);
    // X3 := X3 * t3
    t3.Add(t2, t2);
    // t3 := t2 + t2
    t2.Add(t2, t3);
    // t2 := t2 + t3
    z3.Mul(p521B(), z3);
    // Z3 := b * Z3
    z3.Sub(z3, t2);
    // Z3 := Z3 - t2
    z3.Sub(z3, t0);
    // Z3 := Z3 - t0
    t3.Add(z3, z3);
    // t3 := Z3 + Z3
    z3.Add(z3, t3);
    // Z3 := Z3 + t3
    t3.Add(t0, t0);
    // t3 := t0 + t0
    t0.Add(t3, t0);
    // t0 := t3 + t0
    t0.Sub(t0, t2);
    // t0 := t0 - t2
    t0.Mul(t0, z3);
    // t0 := t0 * Z3
    y3.Add(y3, t0);
    // Y3 := Y3 + t0
    t0.Mul(p.y, p.z);
    // t0 := Y * Z
    t0.Add(t0, t0);
    // t0 := t0 + t0
    z3.Mul(t0, z3);
    // Z3 := t0 * Z3
    x3.Sub(x3, z3);
    // X3 := X3 - Z3
    z3.Mul(t0, t1);
    // Z3 := t0 * t1
    z3.Add(z3, z3);
    // Z3 := Z3 + Z3
    z3.Add(z3, z3);
    // Z3 := Z3 + Z3
    q.x.Set(x3);
    q.y.Set(y3);
    q.z.Set(z3);
    return DoubleꓸᏑq;
}

// Select sets q to p1 if cond == 1, and to p2 if cond == 0.
[GoRecv("capture")] public static ж<P521Point> Select(this ref P521Point q, ж<P521Point> Ꮡp1, ж<P521Point> Ꮡp2, nint cond) {
    ref var p1 = ref Ꮡp1.val;
    ref var p2 = ref Ꮡp2.val;

    q.x.Select(p1.x, p2.x, cond);
    q.y.Select(p1.y, p2.y, cond);
    q.z.Select(p1.z, p2.z, cond);
    return SelectꓸᏑq;
}

[GoType("[15]P521Point")] partial struct p521Table;

// Select selects the n-th multiple of the table base point into p. It works in
// constant time by iterating over every entry of the table. n must be in [0, 15].
[GoRecv] internal static void Select(this ref p521Table table, ж<P521Point> Ꮡp, uint8 n) {
    ref var p = ref Ꮡp.val;

    if (n >= 16) {
        throw panic("nistec: internal error: p521Table called with out-of-bounds value");
    }
    p.Set(NewP521Point());
    ref var i = ref heap<uint8>(out var Ꮡi);
    for (i = ((uint8)1); i < 16; i++) {
        nint cond = subtle.ConstantTimeByteEq(i, n);
        p.Select(table[i - 1], Ꮡp, cond);
    }
}

// ScalarMult sets p = scalar * q, and returns p.
[GoRecv("capture")] public static (ж<P521Point>, error) ScalarMult(this ref P521Point p, ж<P521Point> Ꮡq, slice<byte> scalar) {
    ref var q = ref Ꮡq.val;

    // Compute a p521Table for the base point q. The explicit NewP521Point
    // calls get inlined, letting the allocations live on the stack.
    ref var table = ref heap(new p521Table(), out var Ꮡtable);

    table = new p521Table{NewP521Point(), NewP521Point(), NewP521Point(),
        NewP521Point(), NewP521Point(), NewP521Point(), NewP521Point(),
        NewP521Point(), NewP521Point(), NewP521Point(), NewP521Point(),
        NewP521Point(), NewP521Point(), NewP521Point(), NewP521Point()};
    table[0].Set(Ꮡq);
    ref var i = ref heap<nint>(out var Ꮡi);
    for (i = 1; i < 15; i += 2) {
        table[i].Double(table[i / 2]);
        table[i + 1].Add(table[i], Ꮡq);
    }
    // Instead of doing the classic double-and-add chain, we do it with a
    // four-bit window: we double four times, and then add [0-15]P.
    var t = NewP521Point();
    p.Set(NewP521Point());
    foreach (var (i, @byte) in scalar) {
        // No need to double on the first iteration, as p is the identity at
        // this point, and [N]∞ = ∞.
        if (i != 0) {
            p.Double(p);
            p.Double(p);
            p.Double(p);
            p.Double(p);
        }
        var windowValue = @byte >> (int)(4);
        table.Select(t, windowValue);
        p.Add(p, t);
        p.Double(p);
        p.Double(p);
        p.Double(p);
        p.Double(p);
        windowValue = (byte)(@byte & 15);
        table.Select(t, windowValue);
        p.Add(p, t);
    }
    return (ScalarMultꓸᏑp, default!);
}

internal static ж<array<p521Table>> p521GeneratorTable;

internal static sync.Once p521GeneratorTableOnce;

// generatorTable returns a sequence of p521Tables. The first table contains
// multiples of G. Each successive table is the previous table doubled four
// times.
[GoRecv] internal static ж<array<p521Table>> generatorTable(this ref P521Point p) {
    p521GeneratorTableOnce.Do(() => {
        p521GeneratorTable = @new<array<p521Table>>();
        var @base = NewP521Point().SetGenerator();
        ref var i = ref heap<nint>(out var Ꮡi);
        for (i = 0; i < p521ElementLength * 2; i++) {
            p521GeneratorTable[i][0] = NewP521Point().Set(@base);
            ref var j = ref heap<nint>(out var Ꮡj);
            for (j = 1; j < 15; j++) {
                p521GeneratorTable[i][j] = NewP521Point().Add(p521GeneratorTable[i][j - 1], @base);
            }
            @base.Double(@base);
            @base.Double(@base);
            @base.Double(@base);
            @base.Double(@base);
        }
    });
    return p521GeneratorTable;
}

// ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and
// returns p.
[GoRecv("capture")] public static (ж<P521Point>, error) ScalarBaseMult(this ref P521Point p, slice<byte> scalar) {
    if (len(scalar) != p521ElementLength) {
        return (default!, errors.New("invalid scalar length"u8));
    }
    var tables = p.generatorTable();
    // This is also a scalar multiplication with a four-bit window like in
    // ScalarMult, but in this case the doublings are precomputed. The value
    // [windowValue]G added at iteration k would normally get doubled
    // (totIterations-k)×4 times, but with a larger precomputation we can
    // instead add [2^((totIterations-k)×4)][windowValue]G and avoid the
    // doublings between iterations.
    var t = NewP521Point();
    p.Set(NewP521Point());
    nint tableIndex = len(tables) - 1;
    foreach (var (_, @byte) in scalar) {
        var windowValue = @byte >> (int)(4);
        tables[tableIndex].Select(t, windowValue);
        p.Add(p, t);
        tableIndex--;
        windowValue = (byte)(@byte & 15);
        tables[tableIndex].Select(t, windowValue);
        p.Add(p, t);
        tableIndex--;
    }
    return (ScalarBaseMultꓸᏑp, default!);
}

// p521Sqrt sets e to a square root of x. If x is not a square, p521Sqrt returns
// false and e is unchanged. e and x can overlap.
internal static bool /*isSquare*/ p521Sqrt(ж<fiat.P521Element> Ꮡe, ж<fiat.P521Element> Ꮡx) {
    bool isSquare = default!;

    ref var e = ref Ꮡe.val;
    ref var x = ref Ꮡx.val;
    var candidate = @new<fiat.P521Element>();
    p521SqrtCandidate(candidate, Ꮡx);
    var square = @new<fiat.P521Element>().Square(candidate);
    if (square.Equal(Ꮡx) != 1) {
        return false;
    }
    e.Set(candidate);
    return true;
}

// p521SqrtCandidate sets z to a square root candidate for x. z and x must not overlap.
internal static void p521SqrtCandidate(ж<fiat.P521Element> Ꮡz, ж<fiat.P521Element> Ꮡx) {
    ref var z = ref Ꮡz.val;
    ref var x = ref Ꮡx.val;

    // Since p = 3 mod 4, exponentiation by (p + 1) / 4 yields a square root candidate.
    //
    // The sequence of 0 multiplications and 519 squarings is derived from the
    // following addition chain generated with github.com/mmcloughlin/addchain v0.4.0.
    //
    //	return  1 << 519
    //
    z.Square(Ꮡx);
    for (nint s = 1; s < 519; s++) {
        z.Square(Ꮡz);
    }
}

} // end nistec_package
