// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as
// defined in FIPS 186-4 and SEC 1, Version 2.0.
//
// Signatures generated by this package are not deterministic, but entropy is
// mixed with the private key and the message, achieving the same level of
// security in case of randomness source failure.
//
// Operations involving private keys are implemented using constant-time
// algorithms, as long as an [elliptic.Curve] returned by [elliptic.P224],
// [elliptic.P256], [elliptic.P384], or [elliptic.P521] is used.
namespace go.crypto;

// [FIPS 186-4] references ANSI X9.62-2005 for the bulk of the ECDSA algorithm.
// That standard is not freely available, which is a problem in an open source
// implementation, because not only the implementer, but also any maintainer,
// contributor, reviewer, auditor, and learner needs access to it. Instead, this
// package references and follows the equivalent [SEC 1, Version 2.0].
//
// [FIPS 186-4]: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
// [SEC 1, Version 2.0]: https://www.secg.org/sec1-v2.pdf
using bytes = bytes_package;
using crypto = crypto_package;
using aes = crypto.aes_package;
using cipher = crypto.cipher_package;
using ecdh = crypto.ecdh_package;
using elliptic = crypto.elliptic_package;
using bigmod = crypto.@internal.bigmod_package;
using boring = crypto.@internal.boring_package;
using bbig = crypto.@internal.boring.bbig_package;
using nistec = crypto.@internal.nistec_package;
using randutil = crypto.@internal.randutil_package;
using sha512 = crypto.sha512_package;
using subtle = crypto.subtle_package;
using errors = errors_package;
using io = io_package;
using big = math.big_package;
using sync = sync_package;
using cryptobyte = golang.org.x.crypto.cryptobyte_package;
using asn1 = golang.org.x.crypto.cryptobyte.asn1_package;
using crypto.@internal;
using crypto.@internal.boring;
using golang.org.x.crypto;
using golang.org.x.crypto.cryptobyte;
using math;

partial class ecdsa_package {

// PublicKey represents an ECDSA public key.
[GoType] partial struct PublicKey {
    public partial ref crypto.elliptic_package.Curve Curve { get; }
    public ж<math.big_package.ΔInt> X;
    public ж<math.big_package.ΔInt> Y;
}

// Any methods implemented on PublicKey might need to also be implemented on
// PrivateKey, as the latter embeds the former and will expose its methods.

// ECDH returns k as a [ecdh.PublicKey]. It returns an error if the key is
// invalid according to the definition of [ecdh.Curve.NewPublicKey], or if the
// Curve is not supported by crypto/ecdh.
[GoRecv] public static (ж<ecdhꓸPublicKey>, error) ECDH(this ref PublicKey k) {
    var c = curveToECDH(k.Curve);
    if (c == default!) {
        return (default!, errors.New("ecdsa: unsupported curve by crypto/ecdh"u8));
    }
    if (!k.Curve.IsOnCurve(k.X, k.Y)) {
        return (default!, errors.New("ecdsa: invalid public key"u8));
    }
    return c.NewPublicKey(elliptic.Marshal(k.Curve, k.X, k.Y));
}

// Equal reports whether pub and x have the same value.
//
// Two keys are only considered to have the same value if they have the same Curve value.
// Note that for example [elliptic.P256] and elliptic.P256().Params() are different
// values, as the latter is a generic not constant time implementation.
[GoRecv] public static bool Equal(this ref PublicKey pub, crypto.PublicKey x) {
    var (xx, ok) = x._<PublicKey.val>(ᐧ);
    if (!ok) {
        return false;
    }
    return bigIntEqual(pub.X, (~xx).X) && bigIntEqual(pub.Y, (~xx).Y) && AreEqual(pub.Curve, (~xx).Curve);
}

// Standard library Curve implementations are singletons, so this check
// will work for those. Other Curves might be equivalent even if not
// singletons, but there is no definitive way to check for that, and
// better to err on the side of safety.

// PrivateKey represents an ECDSA private key.
[GoType] partial struct PrivateKey {
    public partial ref PublicKey PublicKey { get; }
    public ж<math.big_package.ΔInt> D;
}

// ECDH returns k as a [ecdh.PrivateKey]. It returns an error if the key is
// invalid according to the definition of [ecdh.Curve.NewPrivateKey], or if the
// Curve is not supported by [crypto/ecdh].
[GoRecv] public static (ж<ecdh.PrivateKey>, error) ECDH(this ref PrivateKey k) {
    var c = curveToECDH(k.Curve);
    if (c == default!) {
        return (default!, errors.New("ecdsa: unsupported curve by crypto/ecdh"u8));
    }
    nint size = ((~k.Curve.Params()).N.BitLen() + 7) / 8;
    if (k.D.BitLen() > size * 8) {
        return (default!, errors.New("ecdsa: invalid private key"u8));
    }
    return c.NewPrivateKey(k.D.FillBytes(new slice<byte>(size)));
}

internal static ecdhꓸCurve curveToECDH(elliptic.Curve c) {
    var exprᴛ1 = c;
    if (exprᴛ1 == elliptic.P256()) {
        return ecdh.P256();
    }
    if (exprᴛ1 == elliptic.P384()) {
        return ecdh.P384();
    }
    if (exprᴛ1 == elliptic.P521()) {
        return ecdh.P521();
    }
    { /* default: */
        return default!;
    }

}

// Public returns the public key corresponding to priv.
[GoRecv] public static crypto.PublicKey Public(this ref PrivateKey priv) {
    return Ꮡ(priv.PublicKey);
}

// Equal reports whether priv and x have the same value.
//
// See [PublicKey.Equal] for details on how Curve is compared.
[GoRecv] public static bool Equal(this ref PrivateKey priv, crypto.PrivateKey x) {
    var (xx, ok) = x._<PrivateKey.val>(ᐧ);
    if (!ok) {
        return false;
    }
    return priv.PublicKey.Equal(Ꮡ((~xx).PublicKey)) && bigIntEqual(priv.D, (~xx).D);
}

// bigIntEqual reports whether a and b are equal leaking only their bit length
// through timing side-channels.
internal static bool bigIntEqual(ж<bigꓸInt> Ꮡa, ж<bigꓸInt> Ꮡb) {
    ref var a = ref Ꮡa.val;
    ref var b = ref Ꮡb.val;

    return subtle.ConstantTimeCompare(a.Bytes(), b.Bytes()) == 1;
}

// Sign signs digest with priv, reading randomness from rand. The opts argument
// is not currently used but, in keeping with the crypto.Signer interface,
// should be the hash function used to digest the message.
//
// This method implements crypto.Signer, which is an interface to support keys
// where the private part is kept in, for example, a hardware module. Common
// uses can use the [SignASN1] function in this package directly.
[GoRecv] public static (slice<byte>, error) Sign(this ref PrivateKey priv, io.Reader rand, slice<byte> digest, crypto.SignerOpts opts) {
    return SignASN1(rand, priv, digest);
}

// GenerateKey generates a new ECDSA private key for the specified curve.
//
// Most applications should use [crypto/rand.Reader] as rand. Note that the
// returned key does not depend deterministically on the bytes read from rand,
// and may change between calls and/or between versions.
public static (ж<PrivateKey>, error) GenerateKey(elliptic.Curve c, io.Reader rand) {
    randutil.MaybeReadByte(rand);
    if (boring.Enabled && rand == boring.RandReader) {
        (x, y, d, err) = boring.GenerateKeyECDSA((~c.Params()).Name);
        if (err != default!) {
            return (default!, err);
        }
        return (Ꮡ(new PrivateKey(PublicKey: new PublicKey(Curve: c, X: bbig.Dec(x), Y: bbig.Dec(y)), D: bbig.Dec(d))), default!);
    }
    boring.UnreachableExceptTests();
    var exprᴛ1 = c.Params();
    if (exprᴛ1 == elliptic.P224().Params()) {
        return generateNISTEC(p224(), rand);
    }
    if (exprᴛ1 == elliptic.P256().Params()) {
        return generateNISTEC(p256(), rand);
    }
    if (exprᴛ1 == elliptic.P384().Params()) {
        return generateNISTEC(p384(), rand);
    }
    if (exprᴛ1 == elliptic.P521().Params()) {
        return generateNISTEC(p521(), rand);
    }
    { /* default: */
        return generateLegacy(c, rand);
    }

}

internal static (ж<PrivateKey>, error) generateNISTEC<Point>(ж<nistCurve<Point>> Ꮡc, io.Reader rand)
    where Point : nistPoint[Point]<Point>, new()
{
    ref var c = ref Ꮡc.val;

    (k, Q, err) = randomPoint(Ꮡc, rand);
    if (err != default!) {
        return (default!, err);
    }
    var priv = @new<PrivateKey>();
    (~priv).PublicKey.Curve = c.curve;
    priv.val.D = @new<bigꓸInt>().SetBytes(k.Bytes(c.N));
    ((~priv).PublicKey.X, (~priv).PublicKey.Y, err) = c.pointToAffine(Q);
    if (err != default!) {
        return (default!, err);
    }
    return (priv, default!);
}

// randomPoint returns a random scalar and the corresponding point using the
// procedure given in FIPS 186-4, Appendix B.5.2 (rejection sampling).
internal static (ж<bigmodꓸNat> k, Point p, error err) randomPoint<Point>(ж<nistCurve<Point>> Ꮡc, io.Reader rand)
    where Point : nistPoint[Point]<Point>, new()
{
    ж<bigmodꓸNat> k = default!;
    Point p = default!;
    error err = default!;

    ref var c = ref Ꮡc.val;
    k = bigmod.NewNat();
    while (ᐧ) {
        var b = new slice<byte>(c.N.Size());
        {
            (_, err) = io.ReadFull(rand, b); if (err != default!) {
                return (k, p, err);
            }
        }
        // Mask off any excess bits to increase the chance of hitting a value in
        // (0, N). These are the most dangerous lines in the package and maybe in
        // the library: a single bit of bias in the selection of nonces would likely
        // lead to key recovery, but no tests would fail. Look but DO NOT TOUCH.
        {
            nint excess = len(b) * 8 - c.N.BitLen(); if (excess > 0) {
                // Just to be safe, assert that this only happens for the one curve that
                // doesn't have a round number of bits.
                if (excess != 0 && (~c.curve.Params()).Name != "P-521"u8) {
                    throw panic("ecdsa: internal error: unexpectedly masking off bits");
                }
                b[0] >>= (nint)(excess);
            }
        }
        // FIPS 186-4 makes us check k <= N - 2 and then add one.
        // Checking 0 < k <= N - 1 is strictly equivalent.
        // None of this matters anyway because the chance of selecting
        // zero is cryptographically negligible.
        {
            (_, err) = k.SetBytes(b, c.N); if (err == default! && k.IsZero() == 0) {
                break;
            }
        }
        if (testingOnlyRejectionSamplingLooped != default!) {
            testingOnlyRejectionSamplingLooped();
        }
    }
    (p, err) = c.newPoint().ScalarBaseMult(k.Bytes(c.N));
    return (k, p, err);
}

// testingOnlyRejectionSamplingLooped is called when rejection sampling in
// randomPoint rejects a candidate for being higher than the modulus.
internal static Action testingOnlyRejectionSamplingLooped;

// errNoAsm is returned by signAsm and verifyAsm when the assembly
// implementation is not available.
internal static error errNoAsm = errors.New("no assembly implementation available"u8);

// SignASN1 signs a hash (which should be the result of hashing a larger message)
// using the private key, priv. If the hash is longer than the bit-length of the
// private key's curve order, the hash will be truncated to that length. It
// returns the ASN.1 encoded signature.
//
// The signature is randomized. Most applications should use [crypto/rand.Reader]
// as rand. Note that the returned signature does not depend deterministically on
// the bytes read from rand, and may change between calls and/or between versions.
public static (slice<byte>, error) SignASN1(io.Reader rand, ж<PrivateKey> Ꮡpriv, slice<byte> hash) {
    ref var priv = ref Ꮡpriv.val;

    randutil.MaybeReadByte(rand);
    if (boring.Enabled && rand == boring.RandReader) {
        (b, errΔ1) = boringPrivateKey(Ꮡpriv);
        if (errΔ1 != default!) {
            return (default!, errΔ1);
        }
        return boring.SignMarshalECDSA(b, hash);
    }
    boring.UnreachableExceptTests();
    (csprng, err) = mixedCSPRNG(rand, Ꮡpriv, hash);
    if (err != default!) {
        return (default!, err);
    }
    {
        (sig, errΔ2) = signAsm(Ꮡpriv, csprng, hash); if (!AreEqual(errΔ2, errNoAsm)) {
            return (sig, errΔ2);
        }
    }
    var exprᴛ1 = priv.Curve.Params();
    if (exprᴛ1 == elliptic.P224().Params()) {
        return signNISTEC(p224(), Ꮡpriv, csprng, hash);
    }
    if (exprᴛ1 == elliptic.P256().Params()) {
        return signNISTEC(p256(), Ꮡpriv, csprng, hash);
    }
    if (exprᴛ1 == elliptic.P384().Params()) {
        return signNISTEC(p384(), Ꮡpriv, csprng, hash);
    }
    if (exprᴛ1 == elliptic.P521().Params()) {
        return signNISTEC(p521(), Ꮡpriv, csprng, hash);
    }
    { /* default: */
        return signLegacy(Ꮡpriv, csprng, hash);
    }

}

internal static (slice<byte> sig, error err) signNISTEC<Point>(ж<nistCurve<Point>> Ꮡc, ж<PrivateKey> Ꮡpriv, io.Reader csprng, slice<byte> hash)
    where Point : nistPoint[Point]<Point>, new()
{
    slice<byte> sig = default!;
    error err = default!;

    ref var c = ref Ꮡc.val;
    ref var priv = ref Ꮡpriv.val;
    // SEC 1, Version 2.0, Section 4.1.3
    (k, R, err) = randomPoint(Ꮡc, csprng);
    if (err != default!) {
        return (default!, err);
    }
    // kInv = k⁻¹
    var kInv = bigmod.NewNat();
    inverse(Ꮡc, kInv, k);
    (Rx, err) = R.BytesX();
    if (err != default!) {
        return (default!, err);
    }
    (r, err) = bigmod.NewNat().SetOverflowingBytes(Rx, c.N);
    if (err != default!) {
        return (default!, err);
    }
    // The spec wants us to retry here, but the chance of hitting this condition
    // on a large prime-order group like the NIST curves we support is
    // cryptographically negligible. If we hit it, something is awfully wrong.
    if (r.IsZero() == 1) {
        return (default!, errors.New("ecdsa: internal error: r is zero"u8));
    }
    var e = bigmod.NewNat();
    hashToNat(Ꮡc, e, hash);
    (s, err) = bigmod.NewNat().SetBytes(priv.D.Bytes(), c.N);
    if (err != default!) {
        return (default!, err);
    }
    s.Mul(r, c.N);
    s.Add(e, c.N);
    s.Mul(kInv, c.N);
    // Again, the chance of this happening is cryptographically negligible.
    if (s.IsZero() == 1) {
        return (default!, errors.New("ecdsa: internal error: s is zero"u8));
    }
    return encodeSignature(r.Bytes(c.N), s.Bytes(c.N));
}

internal static (slice<byte>, error) encodeSignature(slice<byte> r, slice<byte> s) {
    cryptobyte.Builder b = default!;
    b.AddASN1(asn1.SEQUENCE, 
    var rʗ1 = r;
    var sʗ1 = s;
    (ж<cryptobyte.Builder> b) => {
        addASN1IntBytes(bΔ1, rʗ1);
        addASN1IntBytes(bΔ1, sʗ1);
    });
    return b.Bytes();
}

// addASN1IntBytes encodes in ASN.1 a positive integer represented as
// a big-endian byte slice with zero or more leading zeroes.
internal static void addASN1IntBytes(ж<cryptobyte.Builder> Ꮡb, slice<byte> bytes) {
    ref var b = ref Ꮡb.val;

    while (len(bytes) > 0 && bytes[0] == 0) {
        bytes = bytes[1..];
    }
    if (len(bytes) == 0) {
        b.SetError(errors.New("invalid integer"u8));
        return;
    }
    b.AddASN1(asn1.INTEGER, 
    var bytesʗ1 = bytes;
    (ж<cryptobyte.Builder> c) => {
        if ((byte)(bytesʗ1[0] & 128) != 0) {
            c.AddUint8(0);
        }
        c.AddBytes(bytesʗ1);
    });
}

// inverse sets kInv to the inverse of k modulo the order of the curve.
internal static void inverse<Point>(ж<nistCurve<Point>> Ꮡc, ж<bigmodꓸNat> ᏑkInv, ж<bigmodꓸNat> Ꮡk)
    where Point : nistPoint[Point]<Point>, new()
{
    ref var c = ref Ꮡc.val;
    ref var kInv = ref ᏑkInv.val;
    ref var k = ref Ꮡk.val;

    if ((~c.curve.Params()).Name == "P-256"u8) {
        (kBytes, err) = nistec.P256OrdInverse(k.Bytes(c.N));
        // Some platforms don't implement P256OrdInverse, and always return an error.
        if (err == default!) {
            (_, errΔ1) = kInv.SetBytes(kBytes, c.N);
            if (errΔ1 != default!) {
                throw panic("ecdsa: internal error: P256OrdInverse produced an invalid value");
            }
            return;
        }
    }
    // Calculate the inverse of s in GF(N) using Fermat's method
    // (exponentiation modulo P - 2, per Euler's theorem)
    kInv.Exp(Ꮡk, c.nMinus2, c.N);
}

// hashToNat sets e to the left-most bits of hash, according to
// SEC 1, Section 4.1.3, point 5 and Section 4.1.4, point 3.
internal static void hashToNat<Point>(ж<nistCurve<Point>> Ꮡc, ж<bigmodꓸNat> Ꮡe, slice<byte> hash)
    where Point : nistPoint[Point]<Point>, new()
{
    ref var c = ref Ꮡc.val;
    ref var e = ref Ꮡe.val;

    // ECDSA asks us to take the left-most log2(N) bits of hash, and use them as
    // an integer modulo N. This is the absolute worst of all worlds: we still
    // have to reduce, because the result might still overflow N, but to take
    // the left-most bits for P-521 we have to do a right shift.
    {
        nint size = c.N.Size(); if (len(hash) >= size) {
            hash = hash[..(int)(size)];
            {
                nint excess = len(hash) * 8 - c.N.BitLen(); if (excess > 0) {
                    hash = bytes.Clone(hash);
                    for (nint i = len(hash) - 1; i >= 0; i--) {
                        hash[i] >>= (nint)(excess);
                        if (i > 0) {
                            hash[i] |= (byte)(hash[i - 1] << (int)((8 - excess)));
                        }
                    }
                }
            }
        }
    }
    (_, err) = e.SetOverflowingBytes(hash, c.N);
    if (err != default!) {
        throw panic("ecdsa: internal error: truncated hash is too long");
    }
}

// mixedCSPRNG returns a CSPRNG that mixes entropy from rand with the message
// and the private key, to protect the key in case rand fails. This is
// equivalent in security to RFC 6979 deterministic nonce generation, but still
// produces randomized signatures.
internal static (io.Reader, error) mixedCSPRNG(io.Reader rand, ж<PrivateKey> Ꮡpriv, slice<byte> hash) {
    ref var priv = ref Ꮡpriv.val;

    // This implementation derives the nonce from an AES-CTR CSPRNG keyed by:
    //
    //    SHA2-512(priv.D || entropy || hash)[:32]
    //
    // The CSPRNG key is indifferentiable from a random oracle as shown in
    // [Coron], the AES-CTR stream is indifferentiable from a random oracle
    // under standard cryptographic assumptions (see [Larsson] for examples).
    //
    // [Coron]: https://cs.nyu.edu/~dodis/ps/merkle.pdf
    // [Larsson]: https://web.archive.org/web/20040719170906/https://www.nada.kth.se/kurser/kth/2D1441/semteo03/lecturenotes/assump.pdf
    // Get 256 bits of entropy from rand.
    var entropy = new slice<byte>(32);
    {
        var (_, errΔ1) = io.ReadFull(rand, entropy); if (errΔ1 != default!) {
            return (default!, errΔ1);
        }
    }
    // Initialize an SHA-512 hash context; digest...
    var md = sha512.New();
    md.Write(priv.D.Bytes());
    // the private key,
    md.Write(entropy);
    // the entropy,
    md.Write(hash);
    // and the input hash;
    var key = md.Sum(default!)[..32];
    // and compute ChopMD-256(SHA-512),
    // which is an indifferentiable MAC.
    // Create an AES-CTR instance to use as a CSPRNG.
    (block, err) = aes.NewCipher(key);
    if (err != default!) {
        return (default!, err);
    }
    // Create a CSPRNG that xors a stream of zeros with
    // the output of the AES-CTR instance.
    @string aesIV = "IV for ECDSA CTR"u8;
    return (new cipher.StreamReader(
        R: zeroReader,
        S: cipher.NewCTR(block, slice<byte>(aesIV))
    ), default!);
}

[GoType] partial struct zr {
}

internal static zr zeroReader = new zr(nil);

// Read replaces the contents of dst with zeros. It is safe for concurrent use.
internal static (nint n, error err) Read(this zr _, slice<byte> dst) {
    nint n = default!;
    error err = default!;

    clear(dst);
    return (len(dst), default!);
}

// VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the
// public key, pub. Its return value records whether the signature is valid.
//
// The inputs are not considered confidential, and may leak through timing side
// channels, or if an attacker has control of part of the inputs.
public static bool VerifyASN1(ж<PublicKey> Ꮡpub, slice<byte> hash, slice<byte> sig) {
    ref var pub = ref Ꮡpub.val;

    if (boring.Enabled) {
        (key, err) = boringPublicKey(Ꮡpub);
        if (err != default!) {
            return false;
        }
        return boring.VerifyECDSA(key, hash, sig);
    }
    boring.UnreachableExceptTests();
    {
        var err = verifyAsm(Ꮡpub, hash, sig); if (!AreEqual(err, errNoAsm)) {
            return err == default!;
        }
    }
    var exprᴛ1 = pub.Curve.Params();
    if (exprᴛ1 == elliptic.P224().Params()) {
        return verifyNISTEC(p224(), Ꮡpub, hash, sig);
    }
    if (exprᴛ1 == elliptic.P256().Params()) {
        return verifyNISTEC(p256(), Ꮡpub, hash, sig);
    }
    if (exprᴛ1 == elliptic.P384().Params()) {
        return verifyNISTEC(p384(), Ꮡpub, hash, sig);
    }
    if (exprᴛ1 == elliptic.P521().Params()) {
        return verifyNISTEC(p521(), Ꮡpub, hash, sig);
    }
    { /* default: */
        return verifyLegacy(Ꮡpub, hash, sig);
    }

}

internal static bool verifyNISTEC<Point>(ж<nistCurve<Point>> Ꮡc, ж<PublicKey> Ꮡpub, slice<byte> hash, slice<byte> sig)
    where Point : nistPoint[Point]<Point>, new()
{
    ref var c = ref Ꮡc.val;
    ref var pub = ref Ꮡpub.val;

    (rBytes, sBytes, err) = parseSignature(sig);
    if (err != default!) {
        return false;
    }
    (Q, err) = c.pointFromAffine(pub.X, pub.Y);
    if (err != default!) {
        return false;
    }
    // SEC 1, Version 2.0, Section 4.1.4
    (r, err) = bigmod.NewNat().SetBytes(rBytes, c.N);
    if (err != default! || r.IsZero() == 1) {
        return false;
    }
    (s, err) = bigmod.NewNat().SetBytes(sBytes, c.N);
    if (err != default! || s.IsZero() == 1) {
        return false;
    }
    var e = bigmod.NewNat();
    hashToNat(Ꮡc, e, hash);
    // w = s⁻¹
    var w = bigmod.NewNat();
    inverse(Ꮡc, w, s);
    // p₁ = [e * s⁻¹]G
    (p1, err) = c.newPoint().ScalarBaseMult(e.Mul(w, c.N).Bytes(c.N));
    if (err != default!) {
        return false;
    }
    // p₂ = [r * s⁻¹]Q
    (p2, err) = Q.ScalarMult(Q, w.Mul(r, c.N).Bytes(c.N));
    if (err != default!) {
        return false;
    }
    // BytesX returns an error for the point at infinity.
    (Rx, err) = p1.Add(p1, p2).BytesX();
    if (err != default!) {
        return false;
    }
    (v, err) = bigmod.NewNat().SetOverflowingBytes(Rx, c.N);
    if (err != default!) {
        return false;
    }
    return v.Equal(r) == 1;
}

internal static (slice<byte> r, slice<byte> s, error err) parseSignature(slice<byte> sig) {
    slice<byte> r = default!;
    slice<byte> s = default!;
    error err = default!;

    cryptobyte.String inner = default!;
    var input = ((cryptobyte.String)sig);
    if (!input.ReadASN1(Ꮡ(inner), asn1.SEQUENCE) || !input.Empty() || !inner.ReadASN1Integer(Ꮡ(r)) || !inner.ReadASN1Integer(Ꮡ(s)) || !inner.Empty()) {
        return (default!, default!, errors.New("invalid ASN.1"u8));
    }
    return (r, s, default!);
}

[GoType] partial struct nistCurve<Point>
    where Point : nistPoint[Point]<Point>, new()
{
    internal Func<Point> newPoint;
    internal crypto.elliptic_package.Curve curve;
    public ж<crypto.@internal.bigmod_package.Modulus> N;
    internal slice<byte> nMinus2;
}

// nistPoint is a generic constraint for the nistec Point types.
[GoType] partial interface nistPoint {
    slice<byte> Bytes();
    (slice<byte>, error) BytesX();
    (T, error) SetBytes(slice<byte> _);
    T Add(T _, T _);
    (T, error) ScalarMult(T _, slice<byte> _);
    (T, error) ScalarBaseMult(slice<byte> _);
}

// pointFromAffine is used to convert the PublicKey to a nistec Point.
[GoRecv] internal static (Point p, error err) pointFromAffine<Point>(this ref nistCurve<Point> curve, ж<bigꓸInt> Ꮡx, ж<bigꓸInt> Ꮡy)
    where Point : nistPoint[Point]<Point>, new()
{
    Point p = default!;
    error err = default!;

    ref var x = ref Ꮡx.val;
    ref var y = ref Ꮡy.val;
    nint bitSize = curve.curve.Params().val.BitSize;
    // Reject values that would not get correctly encoded.
    if (x.Sign() < 0 || y.Sign() < 0) {
        return (p, errors.New("negative coordinate"u8));
    }
    if (x.BitLen() > bitSize || y.BitLen() > bitSize) {
        return (p, errors.New("overflowing coordinate"u8));
    }
    // Encode the coordinates and let SetBytes reject invalid points.
    nint byteLen = (bitSize + 7) / 8;
    var buf = new slice<byte>(1 + 2 * byteLen);
    buf[0] = 4;
    // uncompressed point
    x.FillBytes(buf[1..(int)(1 + byteLen)]);
    y.FillBytes(buf[(int)(1 + byteLen)..(int)(1 + 2 * byteLen)]);
    return curve.newPoint().SetBytes(buf);
}

// pointToAffine is used to convert a nistec Point to a PublicKey.
[GoRecv] internal static (ж<bigꓸInt> x, ж<bigꓸInt> y, error err) pointToAffine<Point>(this ref nistCurve<Point> curve, Point p)
    where Point : nistPoint[Point]<Point>, new()
{
    ж<bigꓸInt> x = default!;
    ж<bigꓸInt> y = default!;
    error err = default!;

    var @out = p.Bytes();
    if (len(@out) == 1 && @out[0] == 0) {
        // This is the encoding of the point at infinity.
        return (default!, default!, errors.New("ecdsa: public key point is the infinity"u8));
    }
    nint byteLen = ((~curve.curve.Params()).BitSize + 7) / 8;
    x = @new<bigꓸInt>().SetBytes(@out[1..(int)(1 + byteLen)]);
    y = @new<bigꓸInt>().SetBytes(@out[(int)(1 + byteLen)..]);
    return (x, y, default!);
}

internal static sync.Once p224Once;

internal static ж<nistec.P224Point>> _p224;

internal static ж<nistec.P224Point>> p224() {
    p224Once.Do(() => {
        _p224 = Ꮡ(new nistCurve[ж<nistec.P224Point>](
            newPoint: () => nistec.NewP224Point()
        ));
        precomputeParams(_p224, elliptic.P224());
    });
    return _p224;
}

internal static sync.Once p256Once;

internal static ж<nistec.P256Point>> _p256;

internal static ж<nistec.P256Point>> p256() {
    p256Once.Do(() => {
        _p256 = Ꮡ(new nistCurve[ж<nistec.P256Point>](
            newPoint: () => nistec.NewP256Point()
        ));
        precomputeParams(_p256, elliptic.P256());
    });
    return _p256;
}

internal static sync.Once p384Once;

internal static ж<nistec.P384Point>> _p384;

internal static ж<nistec.P384Point>> p384() {
    p384Once.Do(() => {
        _p384 = Ꮡ(new nistCurve[ж<nistec.P384Point>](
            newPoint: () => nistec.NewP384Point()
        ));
        precomputeParams(_p384, elliptic.P384());
    });
    return _p384;
}

internal static sync.Once p521Once;

internal static ж<nistec.P521Point>> _p521;

internal static ж<nistec.P521Point>> p521() {
    p521Once.Do(() => {
        _p521 = Ꮡ(new nistCurve[ж<nistec.P521Point>](
            newPoint: () => nistec.NewP521Point()
        ));
        precomputeParams(_p521, elliptic.P521());
    });
    return _p521;
}

internal static void precomputeParams<Point>(ж<nistCurve<Point>> Ꮡc, elliptic.Curve curve)
    where Point : nistPoint[Point]<Point>, new()
{
    ref var c = ref Ꮡc.val;

    var @params = curve.Params();
    c.curve = curve;
    error err = default!;
    (c.N, err) = bigmod.NewModulusFromBig((~@params).N);
    if (err != default!) {
        throw panic(err);
    }
    c.nMinus2 = @new<bigꓸInt>().Sub((~@params).N, big.NewInt(2)).Bytes();
}

} // end ecdsa_package
