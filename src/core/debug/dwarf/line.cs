// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go.debug;

using errors = errors_package;
using fmt = fmt_package;
using io = io_package;
using path = path_package;
using strings = strings_package;

partial class dwarf_package {

// A LineReader reads a sequence of [LineEntry] structures from a DWARF
// "line" section for a single compilation unit. LineEntries occur in
// order of increasing PC and each [LineEntry] gives metadata for the
// instructions from that [LineEntry]'s PC to just before the next
// [LineEntry]'s PC. The last entry will have the [LineEntry.EndSequence] field set.
[GoType] partial struct ΔLineReader {
    internal buf buf;
    // Original .debug_line section data. Used by Seek.
    internal slice<byte> section;
    internal slice<byte> str; // .debug_str
    internal slice<byte> lineStr; // .debug_line_str
    // Header information
    internal uint16 version;
    internal nint addrsize;
    internal nint segmentSelectorSize;
    internal nint minInstructionLength;
    internal nint maxOpsPerInstruction;
    internal bool defaultIsStmt;
    internal nint lineBase;
    internal nint lineRange;
    internal nint opcodeBase;
    internal slice<nint> opcodeLengths;
    internal slice<@string> directories;
    internal slice<ж<LineFile>> fileEntries;
    internal Offset programOffset; // section offset of line number program
    internal Offset endOffset; // section offset of byte following program
    internal nint initialFileEntries; // initial length of fileEntries
    // Current line number program state machine registers
    internal LineEntry state; // public state
    internal nint fileIndex;      // private state
}

// A LineEntry is a row in a DWARF line table.
[GoType] partial struct LineEntry {
    // Address is the program-counter value of a machine
    // instruction generated by the compiler. This LineEntry
    // applies to each instruction from Address to just before the
    // Address of the next LineEntry.
    public uint64 Address;
    // OpIndex is the index of an operation within a VLIW
    // instruction. The index of the first operation is 0. For
    // non-VLIW architectures, it will always be 0. Address and
    // OpIndex together form an operation pointer that can
    // reference any individual operation within the instruction
    // stream.
    public nint OpIndex;
    // File is the source file corresponding to these
    // instructions.
    public ж<LineFile> File;
    // Line is the source code line number corresponding to these
    // instructions. Lines are numbered beginning at 1. It may be
    // 0 if these instructions cannot be attributed to any source
    // line.
    public nint Line;
    // Column is the column number within the source line of these
    // instructions. Columns are numbered beginning at 1. It may
    // be 0 to indicate the "left edge" of the line.
    public nint Column;
    // IsStmt indicates that Address is a recommended breakpoint
    // location, such as the beginning of a line, statement, or a
    // distinct subpart of a statement.
    public bool IsStmt;
    // BasicBlock indicates that Address is the beginning of a
    // basic block.
    public bool BasicBlock;
    // PrologueEnd indicates that Address is one (of possibly
    // many) PCs where execution should be suspended for a
    // breakpoint on entry to the containing function.
    //
    // Added in DWARF 3.
    public bool PrologueEnd;
    // EpilogueBegin indicates that Address is one (of possibly
    // many) PCs where execution should be suspended for a
    // breakpoint on exit from this function.
    //
    // Added in DWARF 3.
    public bool EpilogueBegin;
    // ISA is the instruction set architecture for these
    // instructions. Possible ISA values should be defined by the
    // applicable ABI specification.
    //
    // Added in DWARF 3.
    public nint ISA;
    // Discriminator is an arbitrary integer indicating the block
    // to which these instructions belong. It serves to
    // distinguish among multiple blocks that may all have with
    // the same source file, line, and column. Where only one
    // block exists for a given source position, it should be 0.
    //
    // Added in DWARF 3.
    public nint Discriminator;
    // EndSequence indicates that Address is the first byte after
    // the end of a sequence of target machine instructions. If it
    // is set, only this and the Address field are meaningful. A
    // line number table may contain information for multiple
    // potentially disjoint instruction sequences. The last entry
    // in a line table should always have EndSequence set.
    public bool EndSequence;
}

// A LineFile is a source file referenced by a DWARF line table entry.
[GoType] partial struct LineFile {
    public @string Name;
    public uint64 Mtime; // Implementation defined modification time, or 0 if unknown
    public nint Length;   // File length, or 0 if unknown
}

// LineReader returns a new reader for the line table of compilation
// unit cu, which must be an [Entry] with tag [TagCompileUnit].
//
// If this compilation unit has no line table, it returns nil, nil.
[GoRecv] public static (ж<ΔLineReader>, error) LineReader(this ref Data d, ж<Entry> Ꮡcu) {
    ref var cu = ref Ꮡcu.val;

    if (d.line == default!) {
        // No line tables available.
        return (default!, default!);
    }
    // Get line table information from cu.
    var (off, ok) = cu.Val(AttrStmtList)._<int64>(ᐧ);
    if (!ok) {
        // cu has no line table.
        return (default!, default!);
    }
    if (off < 0 || off > ((int64)len(d.line))) {
        return (default!, errors.New("AttrStmtList value out of range"u8));
    }
    // AttrCompDir is optional if all file names are absolute. Use
    // the empty string if it's not present.
    var (compDir, _) = cu.Val(AttrCompDir)._<@string>(ᐧ);
    // Create the LineReader.
    var u = Ꮡ(d.unit[d.offsetToUnit(cu.Offset)]);
    var buf = makeBuf(d, ~u, "line"u8, ((Offset)off), d.line[(int)(off)..]);
    // The compilation directory is implicitly directories[0].
    ref var r = ref heap<ΔLineReader>(out var Ꮡr);
    r = new ΔLineReader(
        buf: buf,
        section: d.line,
        str: d.str,
        lineStr: d.lineStr
    );
    // Read the header.
    {
        var err = r.readHeader(compDir); if (err != default!) {
            return (default!, err);
        }
    }
    // Initialize line reader state.
    r.Reset();
    return (Ꮡr, default!);
}

// readHeader reads the line number program header from r.buf and sets
// all of the header fields in r.
[GoRecv] internal static error readHeader(this ref ΔLineReader r, @string compDir) {
    var buf = Ꮡ(r.buf);
    // Read basic header fields [DWARF2 6.2.4].
    var hdrOffset = buf.val.off;
    var (unitLength, dwarf64) = buf.unitLength();
    r.endOffset = (~buf).off + unitLength;
    if (r.endOffset > (~buf).off + ((Offset)len((~buf).data))) {
        return new DecodeError("line", hdrOffset, fmt.Sprintf("line table end %d exceeds section size %d"u8, r.endOffset, (~buf).off + ((Offset)len((~buf).data))));
    }
    r.version = buf.uint16();
    if ((~buf).err == default! && (r.version < 2 || r.version > 5)) {
        // DWARF goes to all this effort to make new opcodes
        // backward-compatible, and then adds fields right in
        // the middle of the header in new versions, so we're
        // picky about only supporting known line table
        // versions.
        return new DecodeError("line", hdrOffset, fmt.Sprintf("unknown line table version %d"u8, r.version));
    }
    if (r.version >= 5){
        r.addrsize = ((nint)buf.uint8());
        r.segmentSelectorSize = ((nint)buf.uint8());
    } else {
        r.addrsize = (~buf).format.addrsize();
        r.segmentSelectorSize = 0;
    }
    Offset headerLength = default!;
    if (dwarf64){
        headerLength = ((Offset)buf.uint64());
    } else {
        headerLength = ((Offset)buf.uint32());
    }
    var programOffset = (~buf).off + headerLength;
    if (programOffset > r.endOffset) {
        return new DecodeError("line", hdrOffset, fmt.Sprintf("malformed line table: program offset %d exceeds end offset %d"u8, programOffset, r.endOffset));
    }
    r.programOffset = programOffset;
    r.minInstructionLength = ((nint)buf.uint8());
    if (r.version >= 4){
        // [DWARF4 6.2.4]
        r.maxOpsPerInstruction = ((nint)buf.uint8());
    } else {
        r.maxOpsPerInstruction = 1;
    }
    r.defaultIsStmt = buf.uint8() != 0;
    r.lineBase = ((nint)((int8)buf.uint8()));
    r.lineRange = ((nint)buf.uint8());
    // Validate header.
    if ((~buf).err != default!) {
        return (~buf).err;
    }
    if (r.maxOpsPerInstruction == 0) {
        return new DecodeError("line", hdrOffset, "invalid maximum operations per instruction: 0");
    }
    if (r.lineRange == 0) {
        return new DecodeError("line", hdrOffset, "invalid line range: 0");
    }
    // Read standard opcode length table. This table starts with opcode 1.
    r.opcodeBase = ((nint)buf.uint8());
    r.opcodeLengths = new slice<nint>(r.opcodeBase);
    for (nint i = 1; i < r.opcodeBase; i++) {
        r.opcodeLengths[i] = ((nint)buf.uint8());
    }
    // Validate opcode lengths.
    if ((~buf).err != default!) {
        return (~buf).err;
    }
    foreach (var (i, length) in r.opcodeLengths) {
        {
            nint known = knownOpcodeLengths[i];
            var ok = knownOpcodeLengths[i]; if (ok && known != length) {
                return new DecodeError("line", hdrOffset, fmt.Sprintf("opcode %d expected to have length %d, but has length %d"u8, i, known, length));
            }
        }
    }
    if (r.version < 5){
        // Read include directories table.
        r.directories = new @string[]{compDir}.slice();
        while (ᐧ) {
            @string directory = buf.@string();
            if ((~buf).err != default!) {
                return (~buf).err;
            }
            if (len(directory) == 0) {
                break;
            }
            if (!pathIsAbs(directory)) {
                // Relative paths are implicitly relative to
                // the compilation directory.
                directory = pathJoin(compDir, directory);
            }
            r.directories = append(r.directories, directory);
        }
        // Read file name list. File numbering starts with 1,
        // so leave the first entry nil.
        r.fileEntries = new slice<ж<LineFile>>(1);
        while (ᐧ) {
            {
                var (done, err) = r.readFileEntry(); if (err != default!){
                    return err;
                } else 
                if (done) {
                    break;
                }
            }
        }
    } else {
        var dirFormat = r.readLNCTFormat();
        var c = buf.@uint();
        r.directories = new slice<@string>(c);
        foreach (var (i, _) in r.directories) {
            var (dir, _, _, err) = r.readLNCT(dirFormat, dwarf64);
            if (err != default!) {
                return err;
            }
            r.directories[i] = dir;
        }
        var fileFormat = r.readLNCTFormat();
        c = buf.@uint();
        r.fileEntries = new slice<ж<LineFile>>(c);
        foreach (var (i, _) in r.fileEntries) {
            var (name, mtime, size, err) = r.readLNCT(fileFormat, dwarf64);
            if (err != default!) {
                return err;
            }
            r.fileEntries[i] = Ꮡ(new LineFile(name, mtime, ((nint)size)));
        }
    }
    r.initialFileEntries = len(r.fileEntries);
    return (~buf).err;
}

// lnctForm is a pair of an LNCT code and a form. This represents an
// entry in the directory name or file name description in the DWARF 5
// line number program header.
[GoType] partial struct lnctForm {
    internal nint lnct;
    internal format form;
}

// readLNCTFormat reads an LNCT format description.
[GoRecv] internal static slice<lnctForm> readLNCTFormat(this ref ΔLineReader r) {
    var c = r.buf.uint8();
    var ret = new slice<lnctForm>(c);
    foreach (var (i, _) in ret) {
        ret[i].lnct = ((nint)r.buf.@uint());
        ret[i].form = ((format)r.buf.@uint());
    }
    return ret;
}

// readLNCT reads a sequence of LNCT entries and returns path information.
[GoRecv] internal static (@string path, uint64 mtime, uint64 size, error err) readLNCT(this ref ΔLineReader r, slice<lnctForm> s, bool dwarf64) {
    @string path = default!;
    uint64 mtime = default!;
    uint64 size = default!;
    error err = default!;

    @string dir = default!;
    foreach (var (_, lf) in s) {
        @string str = default!;
        uint64 val = default!;
        var exprᴛ1 = lf.form;
        if (exprᴛ1 == formString) {
            str = r.buf.@string();
        }
        else if (exprᴛ1 == formStrp || exprᴛ1 == formLineStrp) {
            uint64 off = default!;
            if (dwarf64){
                off = r.buf.uint64();
            } else {
                off = ((uint64)r.buf.uint32());
            }
            if (((uint64)((nint)off)) != off) {
                return ("", 0, 0, new DecodeError("line", r.buf.off, "strp/line_strp offset out of range"));
            }
            buf b1 = default!;
            if (lf.form == formStrp){
                b1 = makeBuf(r.buf.dwarf, r.buf.format, "str"u8, 0, r.str);
            } else {
                b1 = makeBuf(r.buf.dwarf, r.buf.format, "line_str"u8, 0, r.lineStr);
            }
            b1.skip(((nint)off));
            str = b1.@string();
            if (b1.err != default!) {
                return ("", 0, 0, new DecodeError("line", r.buf.off, b1.err.Error()));
            }
        }
        if (exprᴛ1 == formStrpSup) {
            if (dwarf64){
                // Supplemental sections not yet supported.
                r.buf.uint64();
            } else {
                r.buf.uint32();
            }
        }
        else if (exprᴛ1 == formStrx) {
            r.buf.@uint();
        }
        else if (exprᴛ1 == formStrx1) {
            r.buf.uint8();
        }
        else if (exprᴛ1 == formStrx2) {
            r.buf.uint16();
        }
        else if (exprᴛ1 == formStrx3) {
            r.buf.uint24();
        }
        else if (exprᴛ1 == formStrx4) {
            r.buf.uint32();
        }
        else if (exprᴛ1 == formData1) {
            val = ((uint64)r.buf.uint8());
        }
        else if (exprᴛ1 == formData2) {
            val = ((uint64)r.buf.uint16());
        }
        else if (exprᴛ1 == formData4) {
            val = ((uint64)r.buf.uint32());
        }
        else if (exprᴛ1 == formData8) {
            val = r.buf.uint64();
        }
        else if (exprᴛ1 == formData16) {
            r.buf.bytes(16);
        }
        else if (exprᴛ1 == formDwarfBlock) {
            r.buf.bytes(((nint)r.buf.@uint()));
        }
        else if (exprᴛ1 == formUdata) {
            val = r.buf.@uint();
        }

        // .debug_line.dwo sections not yet supported.
        var exprᴛ2 = lf.lnct;
        if (exprᴛ2 == lnctPath) {
            path = str;
        }
        else if (exprᴛ2 == lnctDirectoryIndex) {
            if (val >= ((uint64)len(r.directories))) {
                return ("", 0, 0, new DecodeError("line", r.buf.off, "directory index out of range"));
            }
            dir = r.directories[val];
        }
        else if (exprᴛ2 == lnctTimestamp) {
            mtime = val;
        }
        else if (exprᴛ2 == lnctSize) {
            size = val;
        }
        else if (exprᴛ2 == lnctMD5) {
        }

    }
    // Ignored.
    if (dir != ""u8 && path != ""u8) {
        path = pathJoin(dir, path);
    }
    return (path, mtime, size, default!);
}

// readFileEntry reads a file entry from either the header or a
// DW_LNE_define_file extended opcode and adds it to r.fileEntries. A
// true return value indicates that there are no more entries to read.
[GoRecv] internal static (bool, error) readFileEntry(this ref ΔLineReader r) {
    @string name = r.buf.@string();
    if (r.buf.err != default!) {
        return (false, r.buf.err);
    }
    if (len(name) == 0) {
        return (true, default!);
    }
    var off = r.buf.off;
    nint dirIndex = ((nint)r.buf.@uint());
    if (!pathIsAbs(name)) {
        if (dirIndex >= len(r.directories)) {
            return (false, new DecodeError("line", off, "directory index too large"));
        }
        name = pathJoin(r.directories[dirIndex], name);
    }
    ref var mtime = ref heap<uint64>(out var Ꮡmtime);
    mtime = r.buf.@uint();
    ref var length = ref heap<nint>(out var Ꮡlength);
    length = ((nint)r.buf.@uint());
    // If this is a dynamically added path and the cursor was
    // backed up, we may have already added this entry. Avoid
    // updating existing line table entries in this case. This
    // avoids an allocation and potential racy access to the slice
    // backing store if the user called Files.
    if (len(r.fileEntries) < cap(r.fileEntries)) {
        var fe = r.fileEntries[..(int)(len(r.fileEntries) + 1)];
        if (fe[len(fe) - 1] != nil) {
            // We already processed this addition.
            r.fileEntries = fe;
            return (false, default!);
        }
    }
    r.fileEntries = append(r.fileEntries, Ꮡ(new LineFile(name, mtime, length)));
    return (false, default!);
}

// updateFile updates r.state.File after r.fileIndex has
// changed or r.fileEntries has changed.
[GoRecv] internal static void updateFile(this ref ΔLineReader r) {
    if (r.fileIndex < len(r.fileEntries)){
        r.state.File = r.fileEntries[r.fileIndex];
    } else {
        r.state.File = default!;
    }
}

// Next sets *entry to the next row in this line table and moves to
// the next row. If there are no more entries and the line table is
// properly terminated, it returns [io.EOF].
//
// Rows are always in order of increasing entry.Address, but
// entry.Line may go forward or backward.
[GoRecv] public static error Next(this ref ΔLineReader r, ж<LineEntry> Ꮡentry) {
    ref var entry = ref Ꮡentry.val;

    if (r.buf.err != default!) {
        return r.buf.err;
    }
    // Execute opcodes until we reach an opcode that emits a line
    // table entry.
    while (ᐧ) {
        if (len(r.buf.data) == 0) {
            return io.EOF;
        }
        var emit = r.step(Ꮡentry);
        if (r.buf.err != default!) {
            return r.buf.err;
        }
        if (emit) {
            return default!;
        }
    }
}

// lnsFixedAdvancePC takes a uint8 rather than a varint; it's
// unclear what length the header is supposed to claim, so
// ignore it.
// knownOpcodeLengths gives the opcode lengths (in varint arguments)
// of known standard opcodes.
internal static map<nint, nint> knownOpcodeLengths = new map<nint, nint>{
    [lnsCopy] = 0,
    [lnsAdvancePC] = 1,
    [lnsAdvanceLine] = 1,
    [lnsSetFile] = 1,
    [lnsNegateStmt] = 0,
    [lnsSetBasicBlock] = 0,
    [lnsConstAddPC] = 0,
    [lnsSetPrologueEnd] = 0,
    [lnsSetEpilogueBegin] = 0,
    [lnsSetISA] = 1
};

// step processes the next opcode and updates r.state. If the opcode
// emits a row in the line table, this updates *entry and returns
// true.
[GoRecv] public static bool step(this ref ΔLineReader r, ж<LineEntry> Ꮡentry) {
    ref var entry = ref Ꮡentry.val;

    nint opcode = ((nint)r.buf.uint8());
    if (opcode >= r.opcodeBase) {
        // Special opcode [DWARF2 6.2.5.1, DWARF4 6.2.5.1]
        nint adjustedOpcode = opcode - r.opcodeBase;
        r.advancePC(adjustedOpcode / r.lineRange);
        nint lineDelta = r.lineBase + adjustedOpcode % r.lineRange;
        r.state.Line += lineDelta;
        goto emit;
    }
    var exprᴛ1 = opcode;
    if (exprᴛ1 is 0) {
        var length = ((Offset)r.buf.@uint());
        var startOff = r.buf.off;
        var opcodeΔ2 = r.buf.uint8();
        var exprᴛ2 = opcodeΔ2;
        if (exprᴛ2 == lneEndSequence) {
            r.state.EndSequence = true;
            entry = r.state;
            r.resetState();
        }
        else if (exprᴛ2 == lneSetAddress) {
            switch (r.addrsize) {
            case 1: {
                r.state.Address = ((uint64)r.buf.uint8());
                break;
            }
            case 2: {
                r.state.Address = ((uint64)r.buf.uint16());
                break;
            }
            case 4: {
                r.state.Address = ((uint64)r.buf.uint32());
                break;
            }
            case 8: {
                r.state.Address = r.buf.uint64();
                break;
            }
            default: {
                r.buf.error("unknown address size"u8);
                break;
            }}

        }
        else if (exprᴛ2 == lneDefineFile) {
            {
                var (done, err) = r.readFileEntry(); if (err != default!){
                    // Extended opcode [DWARF2 6.2.5.3]
                    r.buf.err = err;
                    return false;
                } else 
                if (done) {
                    r.buf.err = new DecodeError("line", startOff, "malformed DW_LNE_define_file operation");
                    return false;
                }
            }
            r.updateFile();
        }
        else if (exprᴛ2 == lneSetDiscriminator) {
            r.state.Discriminator = ((nint)r.buf.@uint());
        }

        r.buf.skip(((nint)(startOff + length - r.buf.off)));
        if (opcodeΔ2 == lneEndSequence) {
            // [DWARF4 6.2.5.3]
            return true;
        }
    }
    if (exprᴛ1 == lnsCopy) {
        goto emit;
    }
    else if (exprᴛ1 == lnsAdvancePC) {
        r.advancePC(((nint)r.buf.@uint()));
    }
    else if (exprᴛ1 == lnsAdvanceLine) {
        r.state.Line += ((nint)r.buf.@int());
    }
    else if (exprᴛ1 == lnsSetFile) {
        r.fileIndex = ((nint)r.buf.@uint());
        r.updateFile();
    }
    else if (exprᴛ1 == lnsSetColumn) {
        r.state.Column = ((nint)r.buf.@uint());
    }
    else if (exprᴛ1 == lnsNegateStmt) {
        r.state.IsStmt = !r.state.IsStmt;
    }
    else if (exprᴛ1 == lnsSetBasicBlock) {
        r.state.BasicBlock = true;
    }
    else if (exprᴛ1 == lnsConstAddPC) {
        r.advancePC((255 - r.opcodeBase) / r.lineRange);
    }
    else if (exprᴛ1 == lnsFixedAdvancePC) {
        r.state.Address += ((uint64)r.buf.uint16());
    }
    else if (exprᴛ1 == lnsSetPrologueEnd) {
        r.state.PrologueEnd = true;
    }
    else if (exprᴛ1 == lnsSetEpilogueBegin) {
        r.state.EpilogueBegin = true;
    }
    else if (exprᴛ1 == lnsSetISA) {
        r.state.ISA = ((nint)r.buf.@uint());
    }
    else { /* default: */
        for (nint i = 0; i < r.opcodeLengths[opcode]; i++) {
            // Standard opcodes [DWARF2 6.2.5.2]
            // DWARF3 standard opcodes [DWARF3 6.2.5.2]
            // Unhandled standard opcode. Skip the number of
            // arguments that the prologue says this opcode has.
            r.buf.@uint();
        }
    }

    return false;
emit:
    entry = r.state;
    r.state.BasicBlock = false;
    r.state.PrologueEnd = false;
    r.state.EpilogueBegin = false;
    r.state.Discriminator = 0;
    return true;
}

// advancePC advances "operation pointer" (the combination of Address
// and OpIndex) in r.state by opAdvance steps.
[GoRecv] internal static void advancePC(this ref ΔLineReader r, nint opAdvance) {
    nint opIndex = r.state.OpIndex + opAdvance;
    r.state.Address += ((uint64)(r.minInstructionLength * (opIndex / r.maxOpsPerInstruction)));
    r.state.OpIndex = opIndex % r.maxOpsPerInstruction;
}

// A LineReaderPos represents a position in a line table.
[GoType] partial struct LineReaderPos {
    // off is the current offset in the DWARF line section.
    internal Offset off;
    // numFileEntries is the length of fileEntries.
    internal nint numFileEntries;
    // state and fileIndex are the statement machine state at
    // offset off.
    internal LineEntry state;
    internal nint fileIndex;
}

// Tell returns the current position in the line table.
[GoRecv] public static LineReaderPos Tell(this ref ΔLineReader r) {
    return new LineReaderPos(r.buf.off, len(r.fileEntries), r.state, r.fileIndex);
}

// Seek restores the line table reader to a position returned by [LineReader.Tell].
//
// The argument pos must have been returned by a call to [LineReader.Tell] on this
// line table.
[GoRecv] public static void Seek(this ref ΔLineReader r, LineReaderPos pos) {
    r.buf.off = pos.off;
    r.buf.data = r.section[(int)(r.buf.off)..(int)(r.endOffset)];
    r.fileEntries = r.fileEntries[..(int)(pos.numFileEntries)];
    r.state = pos.state;
    r.fileIndex = pos.fileIndex;
}

// Reset repositions the line table reader at the beginning of the
// line table.
[GoRecv] public static void Reset(this ref ΔLineReader r) {
    // Reset buffer to the line number program offset.
    r.buf.off = r.programOffset;
    r.buf.data = r.section[(int)(r.buf.off)..(int)(r.endOffset)];
    // Reset file entries list.
    r.fileEntries = r.fileEntries[..(int)(r.initialFileEntries)];
    // Reset line number program state.
    r.resetState();
}

// resetState resets r.state to its default values
[GoRecv] internal static void resetState(this ref ΔLineReader r) {
    // Reset the state machine registers to the defaults given in
    // [DWARF4 6.2.2].
    r.state = new LineEntry(
        Address: 0,
        OpIndex: 0,
        File: default!,
        Line: 1,
        Column: 0,
        IsStmt: r.defaultIsStmt,
        BasicBlock: false,
        PrologueEnd: false,
        EpilogueBegin: false,
        ISA: 0,
        Discriminator: 0
    );
    r.fileIndex = 1;
    r.updateFile();
}

// Files returns the file name table of this compilation unit as of
// the current position in the line table. The file name table may be
// referenced from attributes in this compilation unit such as
// [AttrDeclFile].
//
// Entry 0 is always nil, since file index 0 represents "no file".
//
// The file name table of a compilation unit is not fixed. Files
// returns the file table as of the current position in the line
// table. This may contain more entries than the file table at an
// earlier position in the line table, though existing entries never
// change.
[GoRecv] public static slice<ж<LineFile>> Files(this ref ΔLineReader r) {
    return r.fileEntries;
}

// ErrUnknownPC is the error returned by LineReader.ScanPC when the
// seek PC is not covered by any entry in the line table.
public static error ErrUnknownPC = errors.New("ErrUnknownPC"u8);

// SeekPC sets *entry to the [LineEntry] that includes pc and positions
// the reader on the next entry in the line table. If necessary, this
// will seek backwards to find pc.
//
// If pc is not covered by any entry in this line table, SeekPC
// returns [ErrUnknownPC]. In this case, *entry and the final seek
// position are unspecified.
//
// Note that DWARF line tables only permit sequential, forward scans.
// Hence, in the worst case, this takes time linear in the size of the
// line table. If the caller wishes to do repeated fast PC lookups, it
// should build an appropriate index of the line table.
[GoRecv] public static error SeekPC(this ref ΔLineReader r, uint64 pc, ж<LineEntry> Ꮡentry) {
    ref var entry = ref Ꮡentry.val;

    {
        var err = r.Next(Ꮡentry); if (err != default!) {
            return err;
        }
    }
    if (entry.Address > pc) {
        // We're too far. Start at the beginning of the table.
        r.Reset();
        {
            var err = r.Next(Ꮡentry); if (err != default!) {
                return err;
            }
        }
        if (entry.Address > pc) {
            // The whole table starts after pc.
            r.Reset();
            return ErrUnknownPC;
        }
    }
    // Scan until we pass pc, then back up one.
    while (ᐧ) {
        ref var next = ref heap(new LineEntry(), out var Ꮡnext);
        var pos = r.Tell();
        {
            var err = r.Next(Ꮡnext); if (err != default!) {
                if (AreEqual(err, io.EOF)) {
                    return ErrUnknownPC;
                }
                return err;
            }
        }
        if (next.Address > pc) {
            if (entry.EndSequence) {
                // pc is in a hole in the table.
                return ErrUnknownPC;
            }
            // entry is the desired entry. Back up the
            // cursor to "next" and return success.
            r.Seek(pos);
            return default!;
        }
        entry = next;
    }
}

// pathIsAbs reports whether path is an absolute path (or "full path
// name" in DWARF parlance). This is in "whatever form makes sense for
// the host system", so this accepts both UNIX-style and DOS-style
// absolute paths. We avoid the filepath package because we want this
// to behave the same regardless of our host system and because we
// don't know what system the paths came from.
internal static bool pathIsAbs(@string path) {
    (_, path) = splitDrive(path);
    return len(path) > 0 && (path[0] == (rune)'/' || path[0] == (rune)'\\');
}

// pathJoin joins dirname and filename. filename must be relative.
// DWARF paths can be UNIX-style or DOS-style, so this handles both.
internal static @string pathJoin(@string dirname, @string filename) {
    if (len(dirname) == 0) {
        return filename;
    }
    // dirname should be absolute, which means we can determine
    // whether it's a DOS path reasonably reliably by looking for
    // a drive letter or UNC path.
    var (drive, dirname) = splitDrive(dirname);
    if (drive == ""u8) {
        // UNIX-style path.
        return path.Join(dirname, filename);
    }
    // DOS-style path.
    var (drive2, filename) = splitDrive(filename);
    if (drive2 != ""u8) {
        if (!strings.EqualFold(drive, drive2)) {
            // Different drives. There's not much we can
            // do here, so just ignore the directory.
            return drive2 + filename;
        }
    }
    // Drives are the same. Ignore drive on filename.
    if (!(strings.HasSuffix(dirname, "/"u8) || strings.HasSuffix(dirname, @"\"u8)) && dirname != ""u8) {
        @string sep = @"\"u8;
        if (strings.HasPrefix(dirname, "/"u8)) {
            sep = @"/"u8;
        }
        dirname += sep;
    }
    return drive + dirname + filename;
}

// splitDrive splits the DOS drive letter or UNC share point from
// path, if any. path == drive + rest
internal static (@string drive, @string rest) splitDrive(@string path) {
    @string drive = default!;
    @string rest = default!;

    if (len(path) >= 2 && path[1] == (rune)':') {
        {
            var c = path[0]; if ((rune)'a' <= c && c <= (rune)'z' || (rune)'A' <= c && c <= (rune)'Z') {
                return (path[..2], path[2..]);
            }
        }
    }
    if (len(path) > 3 && (path[0] == (rune)'\\' || path[0] == (rune)'/') && (path[1] == (rune)'\\' || path[1] == (rune)'/')) {
        // Normalize the path so we can search for just \ below.
        @string npath = strings.Replace(path, "/"u8, @"\"u8, -1);
        // Get the host part, which must be non-empty.
        nint slash1 = strings.IndexByte(npath[2..], (rune)'\\') + 2;
        if (slash1 > 2) {
            // Get the mount-point part, which must be non-empty.
            nint slash2 = strings.IndexByte(npath[(int)(slash1 + 1)..], (rune)'\\') + slash1 + 1;
            if (slash2 > slash1) {
                return (path[..(int)(slash2)], path[(int)(slash2)..]);
            }
        }
    }
    return ("", path);
}

} // end dwarf_package
