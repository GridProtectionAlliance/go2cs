// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go;

using errors = errors_package;
using bytealg = @internal.bytealg_package;
using itoa = @internal.itoa_package;
using _ = unsafe_package; // for go:linkname
using @internal;

partial class os_package {

// random number source provided by runtime.
// We generate random temporary file names so that there's a good
// chance the file doesn't exist yet - keeps the number of tries in
// TempFile to a minimum.
//
//go:linkname runtime_rand runtime.rand
internal static partial uint64 runtime_rand();

internal static @string nextRandom() {
    return itoa.Uitoa(((nuint)((uint32)runtime_rand())));
}

// CreateTemp creates a new temporary file in the directory dir,
// opens the file for reading and writing, and returns the resulting file.
// The filename is generated by taking pattern and adding a random string to the end.
// If pattern includes a "*", the random string replaces the last "*".
// The file is created with mode 0o600 (before umask).
// If dir is the empty string, CreateTemp uses the default directory for temporary files, as returned by [TempDir].
// Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file.
// The caller can use the file's Name method to find the pathname of the file.
// It is the caller's responsibility to remove the file when it is no longer needed.
public static (ж<File>, error) CreateTemp(@string dir, @string pattern) {
    if (dir == ""u8) {
        dir = TempDir();
    }
    var (prefix, suffix, err) = prefixAndSuffix(pattern);
    if (err != default!) {
        return (default!, new PathError{Op: "createtemp"u8, Path: pattern, Err: err});
    }
    prefix = joinPath(dir, prefix);
    nint @try = 0;
    while (ᐧ) {
        @string name = prefix + nextRandom() + suffix;
        (f, errΔ1) = OpenFile(name, (nint)((nint)(O_RDWR | O_CREATE) | O_EXCL), 384);
        if (IsExist(errΔ1)) {
            {
                @try++; if (@try < 10000) {
                    continue;
                }
            }
            return (default!, new PathError{Op: "createtemp"u8, Path: prefix + "*"u8 + suffix, Err: ErrExist});
        }
        return (f, errΔ1);
    }
}

internal static error errPatternHasSeparator = errors.New("pattern contains path separator"u8);

// prefixAndSuffix splits pattern by the last wildcard "*", if applicable,
// returning prefix as the part before "*" and suffix as the part after "*".
internal static (@string prefix, @string suffix, error err) prefixAndSuffix(@string pattern) {
    @string prefix = default!;
    @string suffix = default!;
    error err = default!;

    for (nint i = 0; i < len(pattern); i++) {
        if (IsPathSeparator(pattern[i])) {
            return ("", "", errPatternHasSeparator);
        }
    }
    {
        nint pos = bytealg.LastIndexByteString(pattern, (rune)'*'); if (pos != -1){
            (prefix, suffix) = (pattern[..(int)(pos)], pattern[(int)(pos + 1)..]);
        } else {
            prefix = pattern;
        }
    }
    return (prefix, suffix, default!);
}

// MkdirTemp creates a new temporary directory in the directory dir
// and returns the pathname of the new directory.
// The new directory's name is generated by adding a random string to the end of pattern.
// If pattern includes a "*", the random string replaces the last "*" instead.
// The directory is created with mode 0o700 (before umask).
// If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir.
// Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory.
// It is the caller's responsibility to remove the directory when it is no longer needed.
public static (@string, error) MkdirTemp(@string dir, @string pattern) {
    if (dir == ""u8) {
        dir = TempDir();
    }
    var (prefix, suffix, err) = prefixAndSuffix(pattern);
    if (err != default!) {
        return ("", new PathError{Op: "mkdirtemp"u8, Path: pattern, Err: err});
    }
    prefix = joinPath(dir, prefix);
    nint @try = 0;
    while (ᐧ) {
        @string name = prefix + nextRandom() + suffix;
        var errΔ1 = Mkdir(name, 448);
        if (errΔ1 == default!) {
            return (name, default!);
        }
        if (IsExist(errΔ1)) {
            {
                @try++; if (@try < 10000) {
                    continue;
                }
            }
            return ("", new PathError{Op: "mkdirtemp"u8, Path: dir + ((@string)PathSeparator) + prefix + "*"u8 + suffix, Err: ErrExist});
        }
        if (IsNotExist(errΔ1)) {
            {
                (_, errΔ2) = Stat(dir); if (IsNotExist(errΔ2)) {
                    return ("", errΔ2);
                }
            }
        }
        return ("", errΔ1);
    }
}

internal static @string joinPath(@string dir, @string name) {
    if (len(dir) > 0 && IsPathSeparator(dir[len(dir) - 1])) {
        return dir + name;
    }
    return dir + ((@string)PathSeparator) + name;
}

} // end os_package
