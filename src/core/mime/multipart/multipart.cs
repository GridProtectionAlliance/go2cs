// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//

/*
Package multipart implements MIME multipart parsing, as defined in RFC
2046.

The implementation is sufficient for HTTP (RFC 2388) and the multipart
bodies generated by popular browsers.

# Limits

To protect against malicious inputs, this package sets limits on the size
of the MIME data it processes.

[Reader.NextPart] and [Reader.NextRawPart] limit the number of headers in a
part to 10000 and [Reader.ReadForm] limits the total number of headers in all
FileHeaders to 10000.
These limits may be adjusted with the GODEBUG=multipartmaxheaders=<values>
setting.

Reader.ReadForm further limits the number of parts in a form to 1000.
This limit may be adjusted with the GODEBUG=multipartmaxparts=<value>
setting.
*/
namespace go.mime;

using bufio = bufio_package;
using bytes = bytes_package;
using fmt = fmt_package;
using godebug = @internal.godebug_package;
using io = io_package;
using mime = mime_package;
using quotedprintable = mime.quotedprintable_package;
using textproto = net.textproto_package;
using filepath = path.filepath_package;
using strconv = strconv_package;
using strings = strings_package;
using @internal;
using net;
using path;

partial class multipart_package {

internal static map<@string, @string> emptyParams = new map<@string, @string>();

// This constant needs to be at least 76 for this package to work correctly.
// This is because \r\n--separator_of_len_70- would fill the buffer and it
// wouldn't be safe to consume a single byte from it.
internal static readonly UntypedInt peekBufferSize = 4096;

// A Part represents a single part in a multipart body.
[GoType] partial struct Part {
    // The headers of the body, if any, with the keys canonicalized
    // in the same fashion that the Go http.Request headers are.
    // For example, "foo-bar" changes case to "Foo-Bar"
    public net.textproto_package.MIMEHeader Header;
    internal ж<Reader> mr;
    internal @string disposition;
    internal map<@string, @string> dispositionParams;
    // r is either a reader directly reading from mr, or it's a
    // wrapper around such a reader, decoding the
    // Content-Transfer-Encoding
    internal io_package.Reader r;
    internal nint n;  // known data bytes waiting in mr.bufReader
    internal int64 total; // total data bytes read already
    internal error err; // error to return when n == 0
    internal error readErr; // read error observed from mr.bufReader
}

// FormName returns the name parameter if p has a Content-Disposition
// of type "form-data".  Otherwise it returns the empty string.
[GoRecv] public static @string FormName(this ref Part p) {
    // See https://tools.ietf.org/html/rfc2183 section 2 for EBNF
    // of Content-Disposition value format.
    if (p.dispositionParams == default!) {
        p.parseContentDisposition();
    }
    if (p.disposition != "form-data"u8) {
        return ""u8;
    }
    return p.dispositionParams["name"u8];
}

// FileName returns the filename parameter of the [Part]'s Content-Disposition
// header. If not empty, the filename is passed through filepath.Base (which is
// platform dependent) before being returned.
[GoRecv] public static @string FileName(this ref Part p) {
    if (p.dispositionParams == default!) {
        p.parseContentDisposition();
    }
    @string filename = p.dispositionParams["filename"u8];
    if (filename == ""u8) {
        return ""u8;
    }
    // RFC 7578, Section 4.2 requires that if a filename is provided, the
    // directory path information must not be used.
    return filepath.Base(filename);
}

[GoRecv] internal static void parseContentDisposition(this ref Part p) {
    @string v = p.Header.Get("Content-Disposition"u8);
    error err = default!;
    (p.disposition, p.dispositionParams, err) = mime.ParseMediaType(v);
    if (err != default!) {
        p.dispositionParams = emptyParams;
    }
}

// NewReader creates a new multipart [Reader] reading from r using the
// given MIME boundary.
//
// The boundary is usually obtained from the "boundary" parameter of
// the message's "Content-Type" header. Use [mime.ParseMediaType] to
// parse such headers.
public static ж<Reader> NewReader(io.Reader r, @string boundary) {
    var b = slice<byte>("\r\n--"u8 + boundary + "--"u8);
    return Ꮡ(new Reader(
        bufReader: bufio.NewReaderSize(new stickyErrorReader(r: r), peekBufferSize),
        nl: b[..2],
        nlDashBoundary: b[..(int)(len(b) - 2)],
        dashBoundaryDash: b[2..],
        dashBoundary: b[2..(int)(len(b) - 2)]
    ));
}

// stickyErrorReader is an io.Reader which never calls Read on its
// underlying Reader once an error has been seen. (the io.Reader
// interface's contract promises nothing about the return values of
// Read calls after an error, yet this package does do multiple Reads
// after error)
[GoType] partial struct stickyErrorReader {
    internal io_package.Reader r;
    internal error err;
}

[GoRecv] internal static (nint n, error _) Read(this ref stickyErrorReader r, slice<byte> p) {
    nint n = default!;

    if (r.err != default!) {
        return (0, r.err);
    }
    (n, r.err) = r.r.Read(p);
    return (n, r.err);
}

internal static (ж<Part>, error) newPart(ж<Reader> Ꮡmr, bool rawPart, int64 maxMIMEHeaderSize, int64 maxMIMEHeaders) {
    ref var mr = ref Ꮡmr.val;

    var bp = Ꮡ(new Part(
        Header: new map<@string, slice<@string>>(),
        mr: mr
    ));
    {
        var err = bp.populateHeaders(maxMIMEHeaderSize, maxMIMEHeaders); if (err != default!) {
            return (default!, err);
        }
    }
    bp.val.r = new partReader(bp);
    // rawPart is used to switch between Part.NextPart and Part.NextRawPart.
    if (!rawPart) {
        @string cte = "Content-Transfer-Encoding"u8;
        if (strings.EqualFold((~bp).Header.Get(cte), "quoted-printable"u8)) {
            (~bp).Header.Del(cte);
            bp.val.r = quotedprintable.NewReader((~bp).r);
        }
    }
    return (bp, default!);
}

[GoRecv] internal static error populateHeaders(this ref Part p, int64 maxMIMEHeaderSize, int64 maxMIMEHeaders) {
    var r = textproto.NewReader(p.mr.bufReader);
    (header, err) = readMIMEHeader(r, maxMIMEHeaderSize, maxMIMEHeaders);
    if (err == default!) {
        p.Header = header;
    }
    // TODO: Add a distinguishable error to net/textproto.
    if (err != default! && err.Error() == "message too large"u8) {
        err = ErrMessageTooLarge;
    }
    return err;
}

// Read reads the body of a part, after its headers and before the
// next part (if any) begins.
[GoRecv] public static (nint n, error err) Read(this ref Part p, slice<byte> d) {
    nint n = default!;
    error err = default!;

    return p.r.Read(d);
}

// partReader implements io.Reader by reading raw bytes directly from the
// wrapped *Part, without doing any Transfer-Encoding decoding.
[GoType] partial struct partReader {
    internal ж<Part> p;
}

internal static (nint, error) Read(this partReader pr, slice<byte> d) {
    var p = pr.p;
    var br = (~p).mr.val.bufReader;
    // Read into buffer until we identify some data to return,
    // or we find a reason to stop (boundary or read error).
    while ((~p).n == 0 && (~p).err == default!) {
        (peek, _) = br.Peek(br.Buffered());
        (p.val.n, p.val.err) = scanUntilBoundary(peek, (~(~p).mr).dashBoundary, (~(~p).mr).nlDashBoundary, (~p).total, (~p).readErr);
        if ((~p).n == 0 && (~p).err == default!) {
            // Force buffered I/O to read more into buffer.
            (_, p.val.readErr) = br.Peek(len(peek) + 1);
            if (AreEqual((~p).readErr, io.EOF)) {
                p.val.readErr = io.ErrUnexpectedEOF;
            }
        }
    }
    // Read out from "data to return" part of buffer.
    if ((~p).n == 0) {
        return (0, (~p).err);
    }
    nint n = len(d);
    if (n > (~p).n) {
        n = p.val.n;
    }
    (n, _) = br.Read(d[..(int)(n)]);
    p.val.total += ((int64)n);
    p.val.n -= n;
    if ((~p).n == 0) {
        return (n, (~p).err);
    }
    return (n, default!);
}

// scanUntilBoundary scans buf to identify how much of it can be safely
// returned as part of the Part body.
// dashBoundary is "--boundary".
// nlDashBoundary is "\r\n--boundary" or "\n--boundary", depending on what mode we are in.
// The comments below (and the name) assume "\n--boundary", but either is accepted.
// total is the number of bytes read out so far. If total == 0, then a leading "--boundary" is recognized.
// readErr is the read error, if any, that followed reading the bytes in buf.
// scanUntilBoundary returns the number of data bytes from buf that can be
// returned as part of the Part body and also the error to return (if any)
// once those data bytes are done.
internal static (nint, error) scanUntilBoundary(slice<byte> buf, slice<byte> dashBoundary, slice<byte> nlDashBoundary, int64 total, error readErr) {
    if (total == 0) {
        // At beginning of body, allow dashBoundary.
        if (bytes.HasPrefix(buf, dashBoundary)) {
            switch (matchAfterPrefix(buf, dashBoundary, readErr)) {
            case -1: {
                return (len(dashBoundary), default!);
            }
            case 0: {
                return (0, default!);
            }
            case +1: {
                return (0, io.EOF);
            }}

        }
        if (bytes.HasPrefix(dashBoundary, buf)) {
            return (0, readErr);
        }
    }
    // Search for "\n--boundary".
    {
        nint iΔ1 = bytes.Index(buf, nlDashBoundary); if (iΔ1 >= 0) {
            switch (matchAfterPrefix(buf[(int)(iΔ1)..], nlDashBoundary, readErr)) {
            case -1: {
                return (iΔ1 + len(nlDashBoundary), default!);
            }
            case 0: {
                return (iΔ1, default!);
            }
            case +1: {
                return (iΔ1, io.EOF);
            }}

        }
    }
    if (bytes.HasPrefix(nlDashBoundary, buf)) {
        return (0, readErr);
    }
    // Otherwise, anything up to the final \n is not part of the boundary
    // and so must be part of the body.
    // Also if the section from the final \n onward is not a prefix of the boundary,
    // it too must be part of the body.
    nint i = bytes.LastIndexByte(buf, nlDashBoundary[0]);
    if (i >= 0 && bytes.HasPrefix(nlDashBoundary, buf[(int)(i)..])) {
        return (i, default!);
    }
    return (len(buf), readErr);
}

// matchAfterPrefix checks whether buf should be considered to match the boundary.
// The prefix is "--boundary" or "\r\n--boundary" or "\n--boundary",
// and the caller has verified already that bytes.HasPrefix(buf, prefix) is true.
//
// matchAfterPrefix returns +1 if the buffer does match the boundary,
// meaning the prefix is followed by a double dash, space, tab, cr, nl,
// or end of input.
// It returns -1 if the buffer definitely does NOT match the boundary,
// meaning the prefix is followed by some other character.
// For example, "--foobar" does not match "--foo".
// It returns 0 more input needs to be read to make the decision,
// meaning that len(buf) == len(prefix) and readErr == nil.
internal static nint matchAfterPrefix(slice<byte> buf, slice<byte> prefix, error readErr) {
    if (len(buf) == len(prefix)) {
        if (readErr != default!) {
            return +1;
        }
        return 0;
    }
    var c = buf[len(prefix)];
    if (c == (rune)' ' || c == (rune)'\t' || c == (rune)'\r' || c == (rune)'\n') {
        return +1;
    }
    // Try to detect boundaryDash
    if (c == (rune)'-') {
        if (len(buf) == len(prefix) + 1) {
            if (readErr != default!) {
                // Prefix + "-" does not match
                return -1;
            }
            return 0;
        }
        if (buf[len(prefix) + 1] == (rune)'-') {
            return +1;
        }
    }
    return -1;
}

[GoRecv] public static error Close(this ref Part p) {
    io.Copy(io.Discard, ~p);
    return default!;
}

// Reader is an iterator over parts in a MIME multipart body.
// Reader's underlying parser consumes its input as needed. Seeking
// isn't supported.
[GoType] partial struct Reader {
    internal ж<bufio_package.Reader> bufReader;
    internal @string tempDir; // used in tests
    internal ж<Part> currentPart;
    internal nint partsRead;
    internal slice<byte> nl; // "\r\n" or "\n" (set after seeing first boundary line)
    internal slice<byte> nlDashBoundary; // nl + "--boundary"
    internal slice<byte> dashBoundaryDash; // "--boundary--"
    internal slice<byte> dashBoundary; // "--boundary"
}

// maxMIMEHeaderSize is the maximum size of a MIME header we will parse,
// including header keys, values, and map overhead.
internal static readonly UntypedInt maxMIMEHeaderSize = /* 10 << 20 */ 10485760;

// multipartmaxheaders is the maximum number of header entries NextPart will return,
// as well as the maximum combined total of header entries Reader.ReadForm will return
// in FileHeaders.
internal static ж<godebug.Setting> multipartmaxheaders = godebug.New("multipartmaxheaders"u8);

internal static int64 maxMIMEHeaders() {
    {
        @string s = multipartmaxheaders.Value(); if (s != ""u8) {
            {
                var (v, err) = strconv.ParseInt(s, 10, 64); if (err == default! && v >= 0) {
                    multipartmaxheaders.IncNonDefault();
                    return v;
                }
            }
        }
    }
    return 10000;
}

// NextPart returns the next part in the multipart or an error.
// When there are no more parts, the error [io.EOF] is returned.
//
// As a special case, if the "Content-Transfer-Encoding" header
// has a value of "quoted-printable", that header is instead
// hidden and the body is transparently decoded during Read calls.
[GoRecv] public static (ж<Part>, error) NextPart(this ref Reader r) {
    return r.nextPart(false, maxMIMEHeaderSize, maxMIMEHeaders());
}

// NextRawPart returns the next part in the multipart or an error.
// When there are no more parts, the error [io.EOF] is returned.
//
// Unlike [Reader.NextPart], it does not have special handling for
// "Content-Transfer-Encoding: quoted-printable".
[GoRecv] public static (ж<Part>, error) NextRawPart(this ref Reader r) {
    return r.nextPart(true, maxMIMEHeaderSize, maxMIMEHeaders());
}

[GoRecv] internal static (ж<Part>, error) nextPart(this ref Reader r, bool rawPart, int64 maxMIMEHeaderSize, int64 maxMIMEHeaders) {
    if (r.currentPart != nil) {
        r.currentPart.Close();
    }
    if (((@string)r.dashBoundary) == "--"u8) {
        return (default!, fmt.Errorf("multipart: boundary is empty"u8));
    }
    var expectNewPart = false;
    while (ᐧ) {
        (line, err) = r.bufReader.ReadSlice((rune)'\n');
        if (AreEqual(err, io.EOF) && r.isFinalBoundary(line)) {
            // If the buffer ends in "--boundary--" without the
            // trailing "\r\n", ReadSlice will return an error
            // (since it's missing the '\n'), but this is a valid
            // multipart EOF so we need to return io.EOF instead of
            // a fmt-wrapped one.
            return (default!, io.EOF);
        }
        if (err != default!) {
            return (default!, fmt.Errorf("multipart: NextPart: %w"u8, err));
        }
        if (r.isBoundaryDelimiterLine(line)) {
            r.partsRead++;
            (bp, errΔ1) = newPart(r, rawPart, maxMIMEHeaderSize, maxMIMEHeaders);
            if (errΔ1 != default!) {
                return (default!, errΔ1);
            }
            r.currentPart = bp;
            return (bp, default!);
        }
        if (r.isFinalBoundary(line)) {
            // Expected EOF
            return (default!, io.EOF);
        }
        if (expectNewPart) {
            return (default!, fmt.Errorf("multipart: expecting a new Part; got line %q"u8, ((@string)line)));
        }
        if (r.partsRead == 0) {
            // skip line
            continue;
        }
        // Consume the "\n" or "\r\n" separator between the
        // body of the previous part and the boundary line we
        // now expect will follow. (either a new part or the
        // end boundary)
        if (bytes.Equal(line, r.nl)) {
            expectNewPart = true;
            continue;
        }
        return (default!, fmt.Errorf("multipart: unexpected line in Next(): %q"u8, line));
    }
}

// isFinalBoundary reports whether line is the final boundary line
// indicating that all parts are over.
// It matches `^--boundary--[ \t]*(\r\n)?$`
[GoRecv] internal static bool isFinalBoundary(this ref Reader r, slice<byte> line) {
    if (!bytes.HasPrefix(line, r.dashBoundaryDash)) {
        return false;
    }
    var rest = line[(int)(len(r.dashBoundaryDash))..];
    rest = skipLWSPChar(rest);
    return len(rest) == 0 || bytes.Equal(rest, r.nl);
}

[GoRecv] internal static bool /*ret*/ isBoundaryDelimiterLine(this ref Reader r, slice<byte> line) {
    bool ret = default!;

    // https://tools.ietf.org/html/rfc2046#section-5.1
    //   The boundary delimiter line is then defined as a line
    //   consisting entirely of two hyphen characters ("-",
    //   decimal value 45) followed by the boundary parameter
    //   value from the Content-Type header field, optional linear
    //   whitespace, and a terminating CRLF.
    if (!bytes.HasPrefix(line, r.dashBoundary)) {
        return false;
    }
    var rest = line[(int)(len(r.dashBoundary))..];
    rest = skipLWSPChar(rest);
    // On the first part, see our lines are ending in \n instead of \r\n
    // and switch into that mode if so. This is a violation of the spec,
    // but occurs in practice.
    if (r.partsRead == 0 && len(rest) == 1 && rest[0] == (rune)'\n') {
        r.nl = r.nl[1..];
        r.nlDashBoundary = r.nlDashBoundary[1..];
    }
    return bytes.Equal(rest, r.nl);
}

// skipLWSPChar returns b with leading spaces and tabs removed.
// RFC 822 defines:
//
//	LWSP-char = SPACE / HTAB
internal static slice<byte> skipLWSPChar(slice<byte> b) {
    while (len(b) > 0 && (b[0] == (rune)' ' || b[0] == (rune)'\t')) {
        b = b[1..];
    }
    return b;
}

} // end multipart_package
