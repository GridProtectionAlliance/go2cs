// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package slogtest implements support for testing implementations of log/slog.Handler.
namespace go.testing;

using context = context_package;
using errors = errors_package;
using fmt = fmt_package;
using slog = log.slog_package;
using reflect = reflect_package;
using runtime = runtime_package;
using testing = testing_package;
using time = time_package;
using log;

partial class slogtest_package {

[GoType] partial struct testCase {
    // Subtest name.
    internal @string name;
    // If non-empty, explanation explains the violated constraint.
    internal @string explanation;
    // f executes a single log event using its argument logger.
    // So that mkdescs.sh can generate the right description,
    // the body of f must appear on a single line whose first
    // non-whitespace characters are "l.".
    internal slog.Logger) f;
    // If mod is not nil, it is called to modify the Record
    // generated by the Logger before it is passed to the Handler.
    internal slog.Record) mod;
    // checks is a list of checks to run on the result.
    internal slice<check> checks;
}

internal static slice<testCase> cases = new testCase[]{
    new(
        name: "built-ins"u8,
        explanation: withSource("this test expects slog.TimeKey, slog.LevelKey and slog.MessageKey"u8),
        f: (ж<slog.Logger> l) => {
            l.Info("message"u8);
        },
        checks: new check[]{
            hasKey(slog.TimeKey),
            hasKey(slog.LevelKey),
            hasAttr(slog.MessageKey, "message")
        }.slice()
    ),
    new(
        name: "attrs"u8,
        explanation: withSource("a Handler should output attributes passed to the logging function"u8),
        f: (ж<slog.Logger> l) => {
            l.Info("message"u8, "k", "v");
        },
        checks: new check[]{
            hasAttr("k"u8, "v")
        }.slice()
    ),
    new(
        name: "empty-attr"u8,
        explanation: withSource("a Handler should ignore an empty Attr"u8),
        f: (ж<slog.Logger> l) => {
            l.Info("msg"u8, "a", "b", "", default!, "c", "d");
        },
        checks: new check[]{
            hasAttr("a"u8, "b"),
            missingKey(""u8),
            hasAttr("c"u8, "d")
        }.slice()
    ),
    new(
        name: "zero-time"u8,
        explanation: withSource("a Handler should ignore a zero Record.Time"u8),
        f: (ж<slog.Logger> l) => {
            l.Info("msg"u8, "k", "v");
        },
        mod: (ж<slog.Record> r) => {
            var r.val.Time = new time.Time(nil);
        },
        checks: new check[]{
            missingKey(slog.TimeKey)
        }.slice()
    ),
    new(
        name: "WithAttrs"u8,
        explanation: withSource("a Handler should include the attributes from the WithAttrs method"u8),
        f: (ж<slog.Logger> l) => {
            l.With("a", "b").Info("msg"u8, "k", "v");
        },
        checks: new check[]{
            hasAttr("a"u8, "b"),
            hasAttr("k"u8, "v")
        }.slice()
    ),
    new(
        name: "groups"u8,
        explanation: withSource("a Handler should handle Group attributes"u8),
        f: (ж<slog.Logger> l) => {
            l.Info("msg"u8, "a", "b", slog.Group("G"u8, slog.String("c"u8, "d"u8)), "e", "f");
        },
        checks: new check[]{
            hasAttr("a"u8, "b"),
            inGroup("G"u8, hasAttr("c"u8, "d")),
            hasAttr("e"u8, "f")
        }.slice()
    ),
    new(
        name: "empty-group"u8,
        explanation: withSource("a Handler should ignore an empty group"u8),
        f: (ж<slog.Logger> l) => {
            l.Info("msg"u8, "a", "b", slog.Group("G"u8), "e", "f");
        },
        checks: new check[]{
            hasAttr("a"u8, "b"),
            missingKey("G"u8),
            hasAttr("e"u8, "f")
        }.slice()
    ),
    new(
        name: "inline-group"u8,
        explanation: withSource("a Handler should inline the Attrs of a group with an empty key"u8),
        f: (ж<slog.Logger> l) => {
            l.Info("msg"u8, "a", "b", slog.Group(""u8, slog.String("c"u8, "d"u8)), "e", "f");
        },
        checks: new check[]{
            hasAttr("a"u8, "b"),
            hasAttr("c"u8, "d"),
            hasAttr("e"u8, "f")
        }.slice()
    ),
    new(
        name: "WithGroup"u8,
        explanation: withSource("a Handler should handle the WithGroup method"u8),
        f: (ж<slog.Logger> l) => {
            l.WithGroup("G"u8).Info("msg"u8, "a", "b");
        },
        checks: new check[]{
            hasKey(slog.TimeKey),
            hasKey(slog.LevelKey),
            hasAttr(slog.MessageKey, "msg"),
            missingKey("a"u8),
            inGroup("G"u8, hasAttr("a"u8, "b"))
        }.slice()
    ),
    new(
        name: "multi-With"u8,
        explanation: withSource("a Handler should handle multiple WithGroup and WithAttr calls"u8),
        f: (ж<slog.Logger> l) => {
            l.With("a", "b").WithGroup("G"u8).With("c", "d").WithGroup("H"u8).Info("msg"u8, "e", "f");
        },
        checks: new check[]{
            hasKey(slog.TimeKey),
            hasKey(slog.LevelKey),
            hasAttr(slog.MessageKey, "msg"),
            hasAttr("a"u8, "b"),
            inGroup("G"u8, hasAttr("c"u8, "d")),
            inGroup("G"u8, inGroup("H"u8, hasAttr("e"u8, "f")))
        }.slice()
    ),
    new(
        name: "empty-group-record"u8,
        explanation: withSource("a Handler should not output groups if there are no attributes"u8),
        f: (ж<slog.Logger> l) => {
            l.With("a", "b").WithGroup("G"u8).With("c", "d").WithGroup("H"u8).Info("msg"u8);
        },
        checks: new check[]{
            hasKey(slog.TimeKey),
            hasKey(slog.LevelKey),
            hasAttr(slog.MessageKey, "msg"),
            hasAttr("a"u8, "b"),
            inGroup("G"u8, hasAttr("c"u8, "d")),
            inGroup("G"u8, missingKey("H"u8))
        }.slice()
    ),
    new(
        name: "resolve"u8,
        explanation: withSource("a Handler should call Resolve on attribute values"u8),
        f: (ж<slog.Logger> l) => {
            l.Info("msg"u8, "k", Ꮡ(new replace("replaced")));
        },
        checks: new check[]{hasAttr("k"u8, "replaced")}.slice()
    ),
    new(
        name: "resolve-groups"u8,
        explanation: withSource("a Handler should call Resolve on attribute values in groups"u8),
        f: (ж<slog.Logger> l) => {
            l.Info("msg"u8,
                slog.Group("G"u8,
                    slog.String("a"u8, "v1"u8),
                    slog.Any("b"u8, Ꮡ(new replace("v2")))));
        },
        checks: new check[]{
            inGroup("G"u8, hasAttr("a"u8, "v1")),
            inGroup("G"u8, hasAttr("b"u8, "v2"))
        }.slice()
    ),
    new(
        name: "resolve-WithAttrs"u8,
        explanation: withSource("a Handler should call Resolve on attribute values from WithAttrs"u8),
        f: (ж<slog.Logger> l) => {
            var l = l.With("k", Ꮡ(new replace("replaced")));
            l.Info("msg"u8);
        },
        checks: new check[]{hasAttr("k"u8, "replaced")}.slice()
    ),
    new(
        name: "resolve-WithAttrs-groups"u8,
        explanation: withSource("a Handler should call Resolve on attribute values in groups from WithAttrs"u8),
        f: (ж<slog.Logger> l) => {
            var l = l.With(slog.Group("G"u8,
                slog.String("a"u8, "v1"u8),
                slog.Any("b"u8, Ꮡ(new replace("v2")))));
            l.Info("msg"u8);
        },
        checks: new check[]{
            inGroup("G"u8, hasAttr("a"u8, "v1")),
            inGroup("G"u8, hasAttr("b"u8, "v2"))
        }.slice()
    ),
    new(
        name: "empty-PC"u8,
        explanation: withSource("a Handler should not output SourceKey if the PC is zero"u8),
        f: (ж<slog.Logger> l) => {
            l.Info("message"u8);
        },
        mod: (ж<slog.Record> r) => {
            var r.val.PC = 0;
        },
        checks: new check[]{
            missingKey(slog.SourceKey)
        }.slice()
    )
}.slice();

// TestHandler tests a [slog.Handler].
// If TestHandler finds any misbehaviors, it returns an error for each,
// combined into a single error with [errors.Join].
//
// TestHandler installs the given Handler in a [slog.Logger] and
// makes several calls to the Logger's output methods.
// The Handler should be enabled for levels Info and above.
//
// The results function is invoked after all such calls.
// It should return a slice of map[string]any, one for each call to a Logger output method.
// The keys and values of the map should correspond to the keys and values of the Handler's
// output. Each group in the output should be represented as its own nested map[string]any.
// The standard keys [slog.TimeKey], [slog.LevelKey] and [slog.MessageKey] should be used.
//
// If the Handler outputs JSON, then calling [encoding/json.Unmarshal] with a `map[string]any`
// will create the right data structure.
//
// If a Handler intentionally drops an attribute that is checked by a test,
// then the results function should check for its absence and add it to the map it returns.
public static error TestHandler(slogꓸHandler h, Func<slice<map<@string, any>>> results) {
    // Run the handler on the test cases.
    foreach (var (_, c) in cases) {
        var ht = h;
        if (c.mod != default!) {
            Ꮡht = new wrapper(h, c.mod); ht = ref Ꮡht.val;
        }
        var l = slog.New(ht);
        c.f(l);
    }
    // Collect and check the results.
    slice<error> errs = default!;
    var res = results();
    {
        nint g = len(res);
        nint w = len(cases); if (g != w) {
            return fmt.Errorf("got %d results, want %d"u8, g, w);
        }
    }
    foreach (var (i, got) in results()) {
        var c = cases[i];
        foreach (var (_, check) in c.checks) {
            {
                @string problem = check(got); if (problem != ""u8) {
                    errs = append(errs, fmt.Errorf("%s: %s"u8, problem, c.explanation));
                }
            }
        }
    }
    return errors.Join(errs.ꓸꓸꓸ);
}

// Run exercises a [slog.Handler] on the same test cases as [TestHandler], but
// runs each case in a subtest. For each test case, it first calls newHandler to
// get an instance of the handler under test, then runs the test case, then
// calls result to get the result. If the test case fails, it calls t.Error.
public static void Run(ж<testing.T> Ꮡt, slogꓸHandler newHandler, Func<ж<testing.T>, map<@string, any>> result) {
    ref var t = ref Ꮡt.val;

    ref var c = ref heap(new testCase(), out var Ꮡc);

    foreach (var (_, c) in cases) {
        t.Run(c.name, 
        var cʗ1 = c;
        (ж<testing.T> t) => {
            var h = newHandler(ᏑtΔ1);
            if (cʗ1.mod != default!) {
                Ꮡh = new wrapper(h, cʗ1.mod); h = ref Ꮡh.val;
            }
            var l = slog.New(h);
            cʗ1.f(l);
            var got = result(ᏑtΔ1);
            foreach (var (_, check) in cʗ1.checks) {
                {
                    @string p = check(got); if (p != ""u8) {
                        tΔ1.Errorf("%s: %s"u8, p, cʗ1.explanation);
                    }
                }
            }
        });
    }
}

internal delegate @string check(map<@string, any> _);

internal static check hasKey(@string key) {
    return (map<@string, any> m) => {
        {
            var _ = m[key];
            var ok = m[key]; if (!ok) {
                return fmt.Sprintf("missing key %q"u8, key);
            }
        }
        return ""u8;
    };
}

internal static check missingKey(@string key) {
    return (map<@string, any> m) => {
        {
            var _ = m[key];
            var ok = m[key]; if (ok) {
                return fmt.Sprintf("unexpected key %q"u8, key);
            }
        }
        return ""u8;
    };
}

internal static check hasAttr(@string key, any wantVal) {
    return (map<@string, any> m) => {
        {
            @string s = hasKey(key)(m); if (s != ""u8) {
                return s;
            }
        }
        var gotVal = m[key];
        if (!reflect.DeepEqual(gotVal, wantVal)) {
            return fmt.Sprintf("%q: got %#v, want %#v"u8, key, gotVal, wantVal);
        }
        return ""u8;
    };
}

internal static check inGroup(@string name, check c) {
    return (map<@string, any> m) => {
        var v = m[name];
        var ok = m[name];
        if (!ok) {
            return fmt.Sprintf("missing group %q"u8, name);
        }
        (g, ok) = v._<map<@string, any, >>(ᐧ);
        if (!ok) {
            return fmt.Sprintf("value for group %q is not map[string]any"u8, name);
        }
        return c(g);
    };
}

[GoType] partial struct wrapper {
    public partial ref log.slog_package.ΔHandler Handler { get; }
    internal slog.Record) mod;
}

[GoRecv] internal static error Handle(this ref wrapper h, context.Context ctx, slog.Record r) {
    h.mod(Ꮡ(r));
    return h.Handler.Handle(ctx, r);
}

internal static @string withSource(@string s) {
    var (_, file, line, ok) = runtime.Caller(1);
    if (!ok) {
        throw panic("runtime.Caller failed");
    }
    return fmt.Sprintf("%s (%s:%d)"u8, s, file, line);
}

[GoType] partial struct replace {
    internal any v;
}

[GoRecv] internal static slog.Value LogValue(this ref replace r) {
    return slog.AnyValue(r.v);
}

[GoRecv] internal static @string String(this ref replace r) {
    return fmt.Sprintf("<replace(%v)>"u8, r.v);
}

} // end slogtest_package
