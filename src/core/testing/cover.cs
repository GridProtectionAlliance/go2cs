// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Support for test coverage.
namespace go;

using fmt = fmt_package;
using goexperiment = @internal.goexperiment_package;
using os = os_package;
using atomic = sync.atomic_package;

partial class testing_package {

// CoverBlock records the coverage data for a single basic block.
// The fields are 1-indexed, as in an editor: The opening line of
// the file is number 1, for example. Columns are measured
// in bytes.
// NOTE: This struct is internal to the testing infrastructure and may change.
// It is not covered (yet) by the Go 1 compatibility guidelines.
[GoType] partial struct CoverBlock {
    public uint32 Line0; // Line number for block start.
    public uint16 Col0; // Column number for block start.
    public uint32 Line1; // Line number for block end.
    public uint16 Col1; // Column number for block end.
    public uint16 Stmts; // Number of statements included in this block.
}

internal static Cover cover;
// Cover records information about test coverage checking.
// NOTE: This struct is internal to the testing infrastructure and may change.
// It is not covered (yet) by the Go 1 compatibility guidelines.
[GoType] partial struct Cover {
    public @string Mode;
    public map<@string, slice<uint32>> Counters;
    public map<@string, slice<CoverBlock>> Blocks;
    public @string CoveredPackages;
}

// Coverage reports the current code coverage as a fraction in the range [0, 1].
// If coverage is not enabled, Coverage returns 0.
//
// When running a large set of sequential test cases, checking Coverage after each one
// can be useful for identifying which test cases exercise new code paths.
// It is not a replacement for the reports generated by 'go test -cover' and
// 'go tool cover'.
public static float64 Coverage() {
    if (goexperiment.CoverageRedesign) {
        return coverage2();
    }
    int64 n = default!;
    int64 d = default!;
    foreach (var (_, counters) in cover.Counters) {
        ref var i = ref heap(new nint(), out var Ꮡi);

        foreach (var (i, _) in counters) {
            if (atomic.LoadUint32(Ꮡ(counters, i)) > 0) {
                n++;
            }
            d++;
        }
    }
    if (d == 0) {
        return 0;
    }
    return ((float64)n) / ((float64)d);
}

// RegisterCover records the coverage data accumulators for the tests.
// NOTE: This function is internal to the testing infrastructure and may change.
// It is not covered (yet) by the Go 1 compatibility guidelines.
public static void RegisterCover(Cover c) {
    cover = c;
}

// mustBeNil checks the error and, if present, reports it and exits.
internal static void mustBeNil(error err) {
    if (err != default!) {
        fmt.Fprintf(~os.Stderr, "testing: %s\n"u8, err);
        os.Exit(2);
    }
}

// coverReport reports the coverage percentage and writes a coverage profile if requested.
internal static void coverReport() => func((defer, _) => {
    if (goexperiment.CoverageRedesign) {
        coverReport2();
        return;
    }
    ж<os.File> f = default!;
    error err = default!;
    if (coverProfile.val != ""u8) {
        (f, err) = os.Create(toOutputDir(coverProfile.val));
        mustBeNil(err);
        fmt.Fprintf(~f, "mode: %s\n"u8, cover.Mode);
        var fʗ1 = f;
        defer(() => {
            mustBeNil(fʗ1.Close());
        });
    }
    int64 active = default!;
    int64 total = default!;
    uint32 count = default!;
    foreach (var (name, counts) in cover.Counters) {
        var blocks = cover.Blocks[name];
        ref var i = ref heap(new nint(), out var Ꮡi);

        foreach (var (i, _) in counts) {
            var stmts = ((int64)blocks[i].Stmts);
            total += stmts;
            count = atomic.LoadUint32(Ꮡ(counts, i));
            // For -mode=atomic.
            if (count > 0) {
                active += stmts;
            }
            if (f != default!) {
                var (_, errΔ1) = fmt.Fprintf(~f, "%s:%d.%d,%d.%d %d %d\n"u8, name,
                    blocks[i].Line0, blocks[i].Col0,
                    blocks[i].Line1, blocks[i].Col1,
                    stmts,
                    count);
                mustBeNil(errΔ1);
            }
        }
    }
    if (total == 0) {
        fmt.Println("coverage: [no statements]");
        return;
    }
    fmt.Printf("coverage: %.1f%% of statements%s\n"u8, 100 * ((float64)active) / ((float64)total), cover.CoveredPackages);
});

} // end testing_package
