// Code generated by 'go generate'; DO NOT EDIT.
namespace go;

using sysdll = @internal.syscall.windows.sysdll_package;
using @unsafe = unsafe_package;
using @internal.syscall.windows;

partial class syscall_package {

internal static @unsafe.Pointer _ᴛ1ʗ;

// Do the interface allocations only once for common
// Errno values.
internal static readonly UntypedInt errnoERROR_IO_PENDING = 997;

internal static Errno errERROR_IO_PENDING = ((Errno)errnoERROR_IO_PENDING);
internal static Errno errERROR_EINVAL = EINVAL;

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
internal static error errnoErr(Errno e) {
    var exprᴛ1 = e;
    if (exprᴛ1 == 0) {
        return errERROR_EINVAL;
    }
    if (exprᴛ1 == errnoERROR_IO_PENDING) {
        return errERROR_IO_PENDING;
    }

    // TODO: add more here, after collecting data on the common
    // error values see on Windows. (perhaps when running
    // all.bat?)
    return e;
}

internal static ж<LazyDLL> modadvapi32 = NewLazyDLL(sysdll.Add("advapi32.dll"u8));
internal static ж<LazyDLL> modcrypt32 = NewLazyDLL(sysdll.Add("crypt32.dll"u8));
internal static ж<LazyDLL> moddnsapi = NewLazyDLL(sysdll.Add("dnsapi.dll"u8));
internal static ж<LazyDLL> modiphlpapi = NewLazyDLL(sysdll.Add("iphlpapi.dll"u8));
internal static ж<LazyDLL> modkernel32 = NewLazyDLL(sysdll.Add("kernel32.dll"u8));
internal static ж<LazyDLL> modmswsock = NewLazyDLL(sysdll.Add("mswsock.dll"u8));
internal static ж<LazyDLL> modnetapi32 = NewLazyDLL(sysdll.Add("netapi32.dll"u8));
internal static ж<LazyDLL> modsecur32 = NewLazyDLL(sysdll.Add("secur32.dll"u8));
internal static ж<LazyDLL> modshell32 = NewLazyDLL(sysdll.Add("shell32.dll"u8));
internal static ж<LazyDLL> moduserenv = NewLazyDLL(sysdll.Add("userenv.dll"u8));
internal static ж<LazyDLL> modws2_32 = NewLazyDLL(sysdll.Add("ws2_32.dll"u8));
internal static ж<LazyProc> procConvertSidToStringSidW = modadvapi32.NewProc("ConvertSidToStringSidW"u8);
internal static ж<LazyProc> procConvertStringSidToSidW = modadvapi32.NewProc("ConvertStringSidToSidW"u8);
internal static ж<LazyProc> procCopySid = modadvapi32.NewProc("CopySid"u8);
internal static ж<LazyProc> procCreateProcessAsUserW = modadvapi32.NewProc("CreateProcessAsUserW"u8);
internal static ж<LazyProc> procCryptAcquireContextW = modadvapi32.NewProc("CryptAcquireContextW"u8);
internal static ж<LazyProc> procCryptGenRandom = modadvapi32.NewProc("CryptGenRandom"u8);
internal static ж<LazyProc> procCryptReleaseContext = modadvapi32.NewProc("CryptReleaseContext"u8);
internal static ж<LazyProc> procGetLengthSid = modadvapi32.NewProc("GetLengthSid"u8);
internal static ж<LazyProc> procGetTokenInformation = modadvapi32.NewProc("GetTokenInformation"u8);
internal static ж<LazyProc> procLookupAccountNameW = modadvapi32.NewProc("LookupAccountNameW"u8);
internal static ж<LazyProc> procLookupAccountSidW = modadvapi32.NewProc("LookupAccountSidW"u8);
internal static ж<LazyProc> procOpenProcessToken = modadvapi32.NewProc("OpenProcessToken"u8);
internal static ж<LazyProc> procRegCloseKey = modadvapi32.NewProc("RegCloseKey"u8);
internal static ж<LazyProc> procRegEnumKeyExW = modadvapi32.NewProc("RegEnumKeyExW"u8);
internal static ж<LazyProc> procRegOpenKeyExW = modadvapi32.NewProc("RegOpenKeyExW"u8);
internal static ж<LazyProc> procRegQueryInfoKeyW = modadvapi32.NewProc("RegQueryInfoKeyW"u8);
internal static ж<LazyProc> procRegQueryValueExW = modadvapi32.NewProc("RegQueryValueExW"u8);
internal static ж<LazyProc> procCertAddCertificateContextToStore = modcrypt32.NewProc("CertAddCertificateContextToStore"u8);
internal static ж<LazyProc> procCertCloseStore = modcrypt32.NewProc("CertCloseStore"u8);
internal static ж<LazyProc> procCertCreateCertificateContext = modcrypt32.NewProc("CertCreateCertificateContext"u8);
internal static ж<LazyProc> procCertEnumCertificatesInStore = modcrypt32.NewProc("CertEnumCertificatesInStore"u8);
internal static ж<LazyProc> procCertFreeCertificateChain = modcrypt32.NewProc("CertFreeCertificateChain"u8);
internal static ж<LazyProc> procCertFreeCertificateContext = modcrypt32.NewProc("CertFreeCertificateContext"u8);
internal static ж<LazyProc> procCertGetCertificateChain = modcrypt32.NewProc("CertGetCertificateChain"u8);
internal static ж<LazyProc> procCertOpenStore = modcrypt32.NewProc("CertOpenStore"u8);
internal static ж<LazyProc> procCertOpenSystemStoreW = modcrypt32.NewProc("CertOpenSystemStoreW"u8);
internal static ж<LazyProc> procCertVerifyCertificateChainPolicy = modcrypt32.NewProc("CertVerifyCertificateChainPolicy"u8);
internal static ж<LazyProc> procDnsNameCompare_W = moddnsapi.NewProc("DnsNameCompare_W"u8);
internal static ж<LazyProc> procDnsQuery_W = moddnsapi.NewProc("DnsQuery_W"u8);
internal static ж<LazyProc> procDnsRecordListFree = moddnsapi.NewProc("DnsRecordListFree"u8);
internal static ж<LazyProc> procGetAdaptersInfo = modiphlpapi.NewProc("GetAdaptersInfo"u8);
internal static ж<LazyProc> procGetIfEntry = modiphlpapi.NewProc("GetIfEntry"u8);
internal static ж<LazyProc> procCancelIo = modkernel32.NewProc("CancelIo"u8);
internal static ж<LazyProc> procCancelIoEx = modkernel32.NewProc("CancelIoEx"u8);
internal static ж<LazyProc> procCloseHandle = modkernel32.NewProc("CloseHandle"u8);
internal static ж<LazyProc> procCreateDirectoryW = modkernel32.NewProc("CreateDirectoryW"u8);
internal static ж<LazyProc> procCreateFileMappingW = modkernel32.NewProc("CreateFileMappingW"u8);
internal static ж<LazyProc> procCreateFileW = modkernel32.NewProc("CreateFileW"u8);
internal static ж<LazyProc> procCreateHardLinkW = modkernel32.NewProc("CreateHardLinkW"u8);
internal static ж<LazyProc> procCreateIoCompletionPort = modkernel32.NewProc("CreateIoCompletionPort"u8);
internal static ж<LazyProc> procCreatePipe = modkernel32.NewProc("CreatePipe"u8);
internal static ж<LazyProc> procCreateProcessW = modkernel32.NewProc("CreateProcessW"u8);
internal static ж<LazyProc> procCreateSymbolicLinkW = modkernel32.NewProc("CreateSymbolicLinkW"u8);
internal static ж<LazyProc> procCreateToolhelp32Snapshot = modkernel32.NewProc("CreateToolhelp32Snapshot"u8);
internal static ж<LazyProc> procDeleteFileW = modkernel32.NewProc("DeleteFileW"u8);
internal static ж<LazyProc> procDeleteProcThreadAttributeList = modkernel32.NewProc("DeleteProcThreadAttributeList"u8);
internal static ж<LazyProc> procDeviceIoControl = modkernel32.NewProc("DeviceIoControl"u8);
internal static ж<LazyProc> procDuplicateHandle = modkernel32.NewProc("DuplicateHandle"u8);
internal static ж<LazyProc> procExitProcess = modkernel32.NewProc("ExitProcess"u8);
internal static ж<LazyProc> procFindClose = modkernel32.NewProc("FindClose"u8);
internal static ж<LazyProc> procFindFirstFileW = modkernel32.NewProc("FindFirstFileW"u8);
internal static ж<LazyProc> procFindNextFileW = modkernel32.NewProc("FindNextFileW"u8);
internal static ж<LazyProc> procFlushFileBuffers = modkernel32.NewProc("FlushFileBuffers"u8);
internal static ж<LazyProc> procFlushViewOfFile = modkernel32.NewProc("FlushViewOfFile"u8);
internal static ж<LazyProc> procFormatMessageW = modkernel32.NewProc("FormatMessageW"u8);
internal static ж<LazyProc> procFreeEnvironmentStringsW = modkernel32.NewProc("FreeEnvironmentStringsW"u8);
internal static ж<LazyProc> procFreeLibrary = modkernel32.NewProc("FreeLibrary"u8);
internal static ж<LazyProc> procGetCommandLineW = modkernel32.NewProc("GetCommandLineW"u8);
internal static ж<LazyProc> procGetComputerNameW = modkernel32.NewProc("GetComputerNameW"u8);
internal static ж<LazyProc> procGetConsoleMode = modkernel32.NewProc("GetConsoleMode"u8);
internal static ж<LazyProc> procGetCurrentDirectoryW = modkernel32.NewProc("GetCurrentDirectoryW"u8);
internal static ж<LazyProc> procGetCurrentProcess = modkernel32.NewProc("GetCurrentProcess"u8);
internal static ж<LazyProc> procGetCurrentProcessId = modkernel32.NewProc("GetCurrentProcessId"u8);
internal static ж<LazyProc> procGetEnvironmentStringsW = modkernel32.NewProc("GetEnvironmentStringsW"u8);
internal static ж<LazyProc> procGetEnvironmentVariableW = modkernel32.NewProc("GetEnvironmentVariableW"u8);
internal static ж<LazyProc> procGetExitCodeProcess = modkernel32.NewProc("GetExitCodeProcess"u8);
internal static ж<LazyProc> procGetFileAttributesExW = modkernel32.NewProc("GetFileAttributesExW"u8);
internal static ж<LazyProc> procGetFileAttributesW = modkernel32.NewProc("GetFileAttributesW"u8);
internal static ж<LazyProc> procGetFileInformationByHandle = modkernel32.NewProc("GetFileInformationByHandle"u8);
internal static ж<LazyProc> procGetFileType = modkernel32.NewProc("GetFileType"u8);
internal static ж<LazyProc> procGetFinalPathNameByHandleW = modkernel32.NewProc("GetFinalPathNameByHandleW"u8);
internal static ж<LazyProc> procGetFullPathNameW = modkernel32.NewProc("GetFullPathNameW"u8);
internal static ж<LazyProc> procGetLastError = modkernel32.NewProc("GetLastError"u8);
internal static ж<LazyProc> procGetLongPathNameW = modkernel32.NewProc("GetLongPathNameW"u8);
internal static ж<LazyProc> procGetProcAddress = modkernel32.NewProc("GetProcAddress"u8);
internal static ж<LazyProc> procGetProcessTimes = modkernel32.NewProc("GetProcessTimes"u8);
internal static ж<LazyProc> procGetQueuedCompletionStatus = modkernel32.NewProc("GetQueuedCompletionStatus"u8);
internal static ж<LazyProc> procGetShortPathNameW = modkernel32.NewProc("GetShortPathNameW"u8);
internal static ж<LazyProc> procGetStartupInfoW = modkernel32.NewProc("GetStartupInfoW"u8);
internal static ж<LazyProc> procGetStdHandle = modkernel32.NewProc("GetStdHandle"u8);
internal static ж<LazyProc> procGetSystemTimeAsFileTime = modkernel32.NewProc("GetSystemTimeAsFileTime"u8);
internal static ж<LazyProc> procGetTempPathW = modkernel32.NewProc("GetTempPathW"u8);
internal static ж<LazyProc> procGetTimeZoneInformation = modkernel32.NewProc("GetTimeZoneInformation"u8);
internal static ж<LazyProc> procGetVersion = modkernel32.NewProc("GetVersion"u8);
internal static ж<LazyProc> procInitializeProcThreadAttributeList = modkernel32.NewProc("InitializeProcThreadAttributeList"u8);
internal static ж<LazyProc> procLoadLibraryW = modkernel32.NewProc("LoadLibraryW"u8);
internal static ж<LazyProc> procLocalFree = modkernel32.NewProc("LocalFree"u8);
internal static ж<LazyProc> procMapViewOfFile = modkernel32.NewProc("MapViewOfFile"u8);
internal static ж<LazyProc> procMoveFileW = modkernel32.NewProc("MoveFileW"u8);
internal static ж<LazyProc> procOpenProcess = modkernel32.NewProc("OpenProcess"u8);
internal static ж<LazyProc> procPostQueuedCompletionStatus = modkernel32.NewProc("PostQueuedCompletionStatus"u8);
internal static ж<LazyProc> procProcess32FirstW = modkernel32.NewProc("Process32FirstW"u8);
internal static ж<LazyProc> procProcess32NextW = modkernel32.NewProc("Process32NextW"u8);
internal static ж<LazyProc> procReadConsoleW = modkernel32.NewProc("ReadConsoleW"u8);
internal static ж<LazyProc> procReadDirectoryChangesW = modkernel32.NewProc("ReadDirectoryChangesW"u8);
internal static ж<LazyProc> procReadFile = modkernel32.NewProc("ReadFile"u8);
internal static ж<LazyProc> procRemoveDirectoryW = modkernel32.NewProc("RemoveDirectoryW"u8);
internal static ж<LazyProc> procSetCurrentDirectoryW = modkernel32.NewProc("SetCurrentDirectoryW"u8);
internal static ж<LazyProc> procSetEndOfFile = modkernel32.NewProc("SetEndOfFile"u8);
internal static ж<LazyProc> procSetEnvironmentVariableW = modkernel32.NewProc("SetEnvironmentVariableW"u8);
internal static ж<LazyProc> procSetFileAttributesW = modkernel32.NewProc("SetFileAttributesW"u8);
internal static ж<LazyProc> procSetFileCompletionNotificationModes = modkernel32.NewProc("SetFileCompletionNotificationModes"u8);
internal static ж<LazyProc> procSetFilePointer = modkernel32.NewProc("SetFilePointer"u8);
internal static ж<LazyProc> procSetFileTime = modkernel32.NewProc("SetFileTime"u8);
internal static ж<LazyProc> procSetHandleInformation = modkernel32.NewProc("SetHandleInformation"u8);
internal static ж<LazyProc> procTerminateProcess = modkernel32.NewProc("TerminateProcess"u8);
internal static ж<LazyProc> procUnmapViewOfFile = modkernel32.NewProc("UnmapViewOfFile"u8);
internal static ж<LazyProc> procUpdateProcThreadAttribute = modkernel32.NewProc("UpdateProcThreadAttribute"u8);
internal static ж<LazyProc> procVirtualLock = modkernel32.NewProc("VirtualLock"u8);
internal static ж<LazyProc> procVirtualUnlock = modkernel32.NewProc("VirtualUnlock"u8);
internal static ж<LazyProc> procWaitForSingleObject = modkernel32.NewProc("WaitForSingleObject"u8);
internal static ж<LazyProc> procWriteConsoleW = modkernel32.NewProc("WriteConsoleW"u8);
internal static ж<LazyProc> procWriteFile = modkernel32.NewProc("WriteFile"u8);
internal static ж<LazyProc> procAcceptEx = modmswsock.NewProc("AcceptEx"u8);
internal static ж<LazyProc> procGetAcceptExSockaddrs = modmswsock.NewProc("GetAcceptExSockaddrs"u8);
internal static ж<LazyProc> procTransmitFile = modmswsock.NewProc("TransmitFile"u8);
internal static ж<LazyProc> procNetApiBufferFree = modnetapi32.NewProc("NetApiBufferFree"u8);
internal static ж<LazyProc> procNetGetJoinInformation = modnetapi32.NewProc("NetGetJoinInformation"u8);
internal static ж<LazyProc> procNetUserGetInfo = modnetapi32.NewProc("NetUserGetInfo"u8);
internal static ж<LazyProc> procGetUserNameExW = modsecur32.NewProc("GetUserNameExW"u8);
internal static ж<LazyProc> procTranslateNameW = modsecur32.NewProc("TranslateNameW"u8);
internal static ж<LazyProc> procCommandLineToArgvW = modshell32.NewProc("CommandLineToArgvW"u8);
internal static ж<LazyProc> procGetUserProfileDirectoryW = moduserenv.NewProc("GetUserProfileDirectoryW"u8);
internal static ж<LazyProc> procFreeAddrInfoW = modws2_32.NewProc("FreeAddrInfoW"u8);
internal static ж<LazyProc> procGetAddrInfoW = modws2_32.NewProc("GetAddrInfoW"u8);
internal static ж<LazyProc> procWSACleanup = modws2_32.NewProc("WSACleanup"u8);
internal static ж<LazyProc> procWSAEnumProtocolsW = modws2_32.NewProc("WSAEnumProtocolsW"u8);
internal static ж<LazyProc> procWSAIoctl = modws2_32.NewProc("WSAIoctl"u8);
internal static ж<LazyProc> procWSARecv = modws2_32.NewProc("WSARecv"u8);
internal static ж<LazyProc> procWSARecvFrom = modws2_32.NewProc("WSARecvFrom"u8);
internal static ж<LazyProc> procWSASend = modws2_32.NewProc("WSASend"u8);
internal static ж<LazyProc> procWSASendTo = modws2_32.NewProc("WSASendTo"u8);
internal static ж<LazyProc> procWSAStartup = modws2_32.NewProc("WSAStartup"u8);
internal static ж<LazyProc> procbind = modws2_32.NewProc("bind"u8);
internal static ж<LazyProc> procclosesocket = modws2_32.NewProc("closesocket"u8);
internal static ж<LazyProc> procconnect = modws2_32.NewProc("connect"u8);
internal static ж<LazyProc> procgethostbyname = modws2_32.NewProc("gethostbyname"u8);
internal static ж<LazyProc> procgetpeername = modws2_32.NewProc("getpeername"u8);
internal static ж<LazyProc> procgetprotobyname = modws2_32.NewProc("getprotobyname"u8);
internal static ж<LazyProc> procgetservbyname = modws2_32.NewProc("getservbyname"u8);
internal static ж<LazyProc> procgetsockname = modws2_32.NewProc("getsockname"u8);
internal static ж<LazyProc> procgetsockopt = modws2_32.NewProc("getsockopt"u8);
internal static ж<LazyProc> proclisten = modws2_32.NewProc("listen"u8);
internal static ж<LazyProc> procntohs = modws2_32.NewProc("ntohs"u8);
internal static ж<LazyProc> procsetsockopt = modws2_32.NewProc("setsockopt"u8);
internal static ж<LazyProc> procshutdown = modws2_32.NewProc("shutdown"u8);
internal static ж<LazyProc> procsocket = modws2_32.NewProc("socket"u8);

public static error /*err*/ ConvertSidToStringSid(ж<SID> Ꮡsid, ж<ж<uint16>> ᏑstringSid) {
    error err = default!;

    ref var sid = ref Ꮡsid.val;
    ref var stringSid = ref ᏑstringSid.val;
    var (r1, _, e1) = Syscall(procConvertSidToStringSidW.Addr(), 2, ((uintptr)new @unsafe.Pointer(Ꮡsid)), ((uintptr)((@unsafe.Pointer)stringSid)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ ConvertStringSidToSid(ж<uint16> ᏑstringSid, ж<ж<SID>> Ꮡsid) {
    error err = default!;

    ref var stringSid = ref ᏑstringSid.val;
    ref var sid = ref Ꮡsid.val;
    var (r1, _, e1) = Syscall(procConvertStringSidToSidW.Addr(), 2, ((uintptr)new @unsafe.Pointer(ᏑstringSid)), ((uintptr)((@unsafe.Pointer)sid)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ CopySid(uint32 destSidLen, ж<SID> ᏑdestSid, ж<SID> ᏑsrcSid) {
    error err = default!;

    ref var destSid = ref ᏑdestSid.val;
    ref var srcSid = ref ᏑsrcSid.val;
    var (r1, _, e1) = Syscall(procCopySid.Addr(), 3, ((uintptr)destSidLen), ((uintptr)new @unsafe.Pointer(ᏑdestSid)), ((uintptr)new @unsafe.Pointer(ᏑsrcSid)));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ CreateProcessAsUser(Token token, ж<uint16> ᏑappName, ж<uint16> ᏑcommandLine, ж<SecurityAttributes> ᏑprocSecurity, ж<SecurityAttributes> ᏑthreadSecurity, bool inheritHandles, uint32 creationFlags, ж<uint16> Ꮡenv, ж<uint16> ᏑcurrentDir, ж<StartupInfo> ᏑstartupInfo, ж<ProcessInformation> ᏑoutProcInfo) {
    error err = default!;

    ref var appName = ref ᏑappName.val;
    ref var commandLine = ref ᏑcommandLine.val;
    ref var procSecurity = ref ᏑprocSecurity.val;
    ref var threadSecurity = ref ᏑthreadSecurity.val;
    ref var env = ref Ꮡenv.val;
    ref var currentDir = ref ᏑcurrentDir.val;
    ref var startupInfo = ref ᏑstartupInfo.val;
    ref var outProcInfo = ref ᏑoutProcInfo.val;
    uint32 _p0 = default!;
    if (inheritHandles) {
        _p0 = 1;
    }
    var (r1, _, e1) = Syscall12(procCreateProcessAsUserW.Addr(), 11, ((uintptr)token), ((uintptr)new @unsafe.Pointer(ᏑappName)), ((uintptr)new @unsafe.Pointer(ᏑcommandLine)), ((uintptr)new @unsafe.Pointer(ᏑprocSecurity)), ((uintptr)new @unsafe.Pointer(ᏑthreadSecurity)), ((uintptr)_p0), ((uintptr)creationFlags), ((uintptr)new @unsafe.Pointer(Ꮡenv)), ((uintptr)new @unsafe.Pointer(ᏑcurrentDir)), ((uintptr)new @unsafe.Pointer(ᏑstartupInfo)), ((uintptr)new @unsafe.Pointer(ᏑoutProcInfo)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ CryptAcquireContext(ж<ΔHandle> Ꮡprovhandle, ж<uint16> Ꮡcontainer, ж<uint16> Ꮡprovider, uint32 provtype, uint32 flags) {
    error err = default!;

    ref var provhandle = ref Ꮡprovhandle.val;
    ref var container = ref Ꮡcontainer.val;
    ref var provider = ref Ꮡprovider.val;
    var (r1, _, e1) = Syscall6(procCryptAcquireContextW.Addr(), 5, ((uintptr)((@unsafe.Pointer)provhandle)), ((uintptr)new @unsafe.Pointer(Ꮡcontainer)), ((uintptr)new @unsafe.Pointer(Ꮡprovider)), ((uintptr)provtype), ((uintptr)flags), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ CryptGenRandom(ΔHandle provhandle, uint32 buflen, ж<byte> Ꮡbuf) {
    error err = default!;

    ref var buf = ref Ꮡbuf.val;
    var (r1, _, e1) = Syscall(procCryptGenRandom.Addr(), 3, ((uintptr)provhandle), ((uintptr)buflen), ((uintptr)new @unsafe.Pointer(Ꮡbuf)));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ CryptReleaseContext(ΔHandle provhandle, uint32 flags) {
    error err = default!;

    var (r1, _, e1) = Syscall(procCryptReleaseContext.Addr(), 2, ((uintptr)provhandle), ((uintptr)flags), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static uint32 /*len*/ GetLengthSid(ж<SID> Ꮡsid) {
    uint32 len = default!;

    ref var sid = ref Ꮡsid.val;
    var (r0, _, _) = Syscall(procGetLengthSid.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡsid)), 0, 0);
    len = ((uint32)r0);
    return len;
}

public static error /*err*/ GetTokenInformation(Token t, uint32 infoClass, ж<byte> Ꮡinfo, uint32 infoLen, ж<uint32> ᏑreturnedLen) {
    error err = default!;

    ref var info = ref Ꮡinfo.val;
    ref var returnedLen = ref ᏑreturnedLen.val;
    var (r1, _, e1) = Syscall6(procGetTokenInformation.Addr(), 5, ((uintptr)t), ((uintptr)infoClass), ((uintptr)new @unsafe.Pointer(Ꮡinfo)), ((uintptr)infoLen), ((uintptr)new @unsafe.Pointer(ᏑreturnedLen)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ LookupAccountName(ж<uint16> ᏑsystemName, ж<uint16> ᏑaccountName, ж<SID> Ꮡsid, ж<uint32> ᏑsidLen, ж<uint16> ᏑrefdDomainName, ж<uint32> ᏑrefdDomainNameLen, ж<uint32> Ꮡuse) {
    error err = default!;

    ref var systemName = ref ᏑsystemName.val;
    ref var accountName = ref ᏑaccountName.val;
    ref var sid = ref Ꮡsid.val;
    ref var sidLen = ref ᏑsidLen.val;
    ref var refdDomainName = ref ᏑrefdDomainName.val;
    ref var refdDomainNameLen = ref ᏑrefdDomainNameLen.val;
    ref var use = ref Ꮡuse.val;
    var (r1, _, e1) = Syscall9(procLookupAccountNameW.Addr(), 7, ((uintptr)new @unsafe.Pointer(ᏑsystemName)), ((uintptr)new @unsafe.Pointer(ᏑaccountName)), ((uintptr)new @unsafe.Pointer(Ꮡsid)), ((uintptr)new @unsafe.Pointer(ᏑsidLen)), ((uintptr)new @unsafe.Pointer(ᏑrefdDomainName)), ((uintptr)new @unsafe.Pointer(ᏑrefdDomainNameLen)), ((uintptr)new @unsafe.Pointer(Ꮡuse)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ LookupAccountSid(ж<uint16> ᏑsystemName, ж<SID> Ꮡsid, ж<uint16> Ꮡname, ж<uint32> ᏑnameLen, ж<uint16> ᏑrefdDomainName, ж<uint32> ᏑrefdDomainNameLen, ж<uint32> Ꮡuse) {
    error err = default!;

    ref var systemName = ref ᏑsystemName.val;
    ref var sid = ref Ꮡsid.val;
    ref var name = ref Ꮡname.val;
    ref var nameLen = ref ᏑnameLen.val;
    ref var refdDomainName = ref ᏑrefdDomainName.val;
    ref var refdDomainNameLen = ref ᏑrefdDomainNameLen.val;
    ref var use = ref Ꮡuse.val;
    var (r1, _, e1) = Syscall9(procLookupAccountSidW.Addr(), 7, ((uintptr)new @unsafe.Pointer(ᏑsystemName)), ((uintptr)new @unsafe.Pointer(Ꮡsid)), ((uintptr)new @unsafe.Pointer(Ꮡname)), ((uintptr)new @unsafe.Pointer(ᏑnameLen)), ((uintptr)new @unsafe.Pointer(ᏑrefdDomainName)), ((uintptr)new @unsafe.Pointer(ᏑrefdDomainNameLen)), ((uintptr)new @unsafe.Pointer(Ꮡuse)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ OpenProcessToken(ΔHandle h, uint32 access, ж<Token> Ꮡtoken) {
    error err = default!;

    ref var token = ref Ꮡtoken.val;
    var (r1, _, e1) = Syscall(procOpenProcessToken.Addr(), 3, ((uintptr)h), ((uintptr)access), ((uintptr)((@unsafe.Pointer)token)));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*regerrno*/ RegCloseKey(ΔHandle key) {
    error regerrno = default!;

    var (r0, _, _) = Syscall(procRegCloseKey.Addr(), 1, ((uintptr)key), 0, 0);
    if (r0 != 0) {
        regerrno = ((Errno)r0);
    }
    return regerrno;
}

internal static error /*regerrno*/ regEnumKeyEx(ΔHandle key, uint32 index, ж<uint16> Ꮡname, ж<uint32> ᏑnameLen, ж<uint32> Ꮡreserved, ж<uint16> Ꮡclass, ж<uint32> ᏑclassLen, ж<Filetime> ᏑlastWriteTime) {
    error regerrno = default!;

    ref var name = ref Ꮡname.val;
    ref var nameLen = ref ᏑnameLen.val;
    ref var reserved = ref Ꮡreserved.val;
    ref var @class = ref Ꮡclass.val;
    ref var classLen = ref ᏑclassLen.val;
    ref var lastWriteTime = ref ᏑlastWriteTime.val;
    var (r0, _, _) = Syscall9(procRegEnumKeyExW.Addr(), 8, ((uintptr)key), ((uintptr)index), ((uintptr)new @unsafe.Pointer(Ꮡname)), ((uintptr)new @unsafe.Pointer(ᏑnameLen)), ((uintptr)new @unsafe.Pointer(Ꮡreserved)), ((uintptr)new @unsafe.Pointer(Ꮡclass)), ((uintptr)new @unsafe.Pointer(ᏑclassLen)), ((uintptr)new @unsafe.Pointer(ᏑlastWriteTime)), 0);
    if (r0 != 0) {
        regerrno = ((Errno)r0);
    }
    return regerrno;
}

public static error /*regerrno*/ RegOpenKeyEx(ΔHandle key, ж<uint16> Ꮡsubkey, uint32 options, uint32 desiredAccess, ж<ΔHandle> Ꮡresult) {
    error regerrno = default!;

    ref var subkey = ref Ꮡsubkey.val;
    ref var result = ref Ꮡresult.val;
    var (r0, _, _) = Syscall6(procRegOpenKeyExW.Addr(), 5, ((uintptr)key), ((uintptr)new @unsafe.Pointer(Ꮡsubkey)), ((uintptr)options), ((uintptr)desiredAccess), ((uintptr)((@unsafe.Pointer)result)), 0);
    if (r0 != 0) {
        regerrno = ((Errno)r0);
    }
    return regerrno;
}

public static error /*regerrno*/ RegQueryInfoKey(ΔHandle key, ж<uint16> Ꮡclass, ж<uint32> ᏑclassLen, ж<uint32> Ꮡreserved, ж<uint32> ᏑsubkeysLen, ж<uint32> ᏑmaxSubkeyLen, ж<uint32> ᏑmaxClassLen, ж<uint32> ᏑvaluesLen, ж<uint32> ᏑmaxValueNameLen, ж<uint32> ᏑmaxValueLen, ж<uint32> ᏑsaLen, ж<Filetime> ᏑlastWriteTime) {
    error regerrno = default!;

    ref var @class = ref Ꮡclass.val;
    ref var classLen = ref ᏑclassLen.val;
    ref var reserved = ref Ꮡreserved.val;
    ref var subkeysLen = ref ᏑsubkeysLen.val;
    ref var maxSubkeyLen = ref ᏑmaxSubkeyLen.val;
    ref var maxClassLen = ref ᏑmaxClassLen.val;
    ref var valuesLen = ref ᏑvaluesLen.val;
    ref var maxValueNameLen = ref ᏑmaxValueNameLen.val;
    ref var maxValueLen = ref ᏑmaxValueLen.val;
    ref var saLen = ref ᏑsaLen.val;
    ref var lastWriteTime = ref ᏑlastWriteTime.val;
    var (r0, _, _) = Syscall12(procRegQueryInfoKeyW.Addr(), 12, ((uintptr)key), ((uintptr)new @unsafe.Pointer(Ꮡclass)), ((uintptr)new @unsafe.Pointer(ᏑclassLen)), ((uintptr)new @unsafe.Pointer(Ꮡreserved)), ((uintptr)new @unsafe.Pointer(ᏑsubkeysLen)), ((uintptr)new @unsafe.Pointer(ᏑmaxSubkeyLen)), ((uintptr)new @unsafe.Pointer(ᏑmaxClassLen)), ((uintptr)new @unsafe.Pointer(ᏑvaluesLen)), ((uintptr)new @unsafe.Pointer(ᏑmaxValueNameLen)), ((uintptr)new @unsafe.Pointer(ᏑmaxValueLen)), ((uintptr)new @unsafe.Pointer(ᏑsaLen)), ((uintptr)new @unsafe.Pointer(ᏑlastWriteTime)));
    if (r0 != 0) {
        regerrno = ((Errno)r0);
    }
    return regerrno;
}

public static error /*regerrno*/ RegQueryValueEx(ΔHandle key, ж<uint16> Ꮡname, ж<uint32> Ꮡreserved, ж<uint32> Ꮡvaltype, ж<byte> Ꮡbuf, ж<uint32> Ꮡbuflen) {
    error regerrno = default!;

    ref var name = ref Ꮡname.val;
    ref var reserved = ref Ꮡreserved.val;
    ref var valtype = ref Ꮡvaltype.val;
    ref var buf = ref Ꮡbuf.val;
    ref var buflen = ref Ꮡbuflen.val;
    var (r0, _, _) = Syscall6(procRegQueryValueExW.Addr(), 6, ((uintptr)key), ((uintptr)new @unsafe.Pointer(Ꮡname)), ((uintptr)new @unsafe.Pointer(Ꮡreserved)), ((uintptr)new @unsafe.Pointer(Ꮡvaltype)), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), ((uintptr)new @unsafe.Pointer(Ꮡbuflen)));
    if (r0 != 0) {
        regerrno = ((Errno)r0);
    }
    return regerrno;
}

public static error /*err*/ CertAddCertificateContextToStore(ΔHandle store, ж<CertContext> ᏑcertContext, uint32 addDisposition, ж<ж<CertContext>> ᏑstoreContext) {
    error err = default!;

    ref var certContext = ref ᏑcertContext.val;
    ref var storeContext = ref ᏑstoreContext.val;
    var (r1, _, e1) = Syscall6(procCertAddCertificateContextToStore.Addr(), 4, ((uintptr)store), ((uintptr)new @unsafe.Pointer(ᏑcertContext)), ((uintptr)addDisposition), ((uintptr)((@unsafe.Pointer)storeContext)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ CertCloseStore(ΔHandle store, uint32 flags) {
    error err = default!;

    var (r1, _, e1) = Syscall(procCertCloseStore.Addr(), 2, ((uintptr)store), ((uintptr)flags), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (ж<CertContext> context, error err) CertCreateCertificateContext(uint32 certEncodingType, ж<byte> ᏑcertEncoded, uint32 encodedLen) {
    ж<CertContext> context = default!;
    error err = default!;

    ref var certEncoded = ref ᏑcertEncoded.val;
    var (r0, _, e1) = Syscall(procCertCreateCertificateContext.Addr(), 3, ((uintptr)certEncodingType), ((uintptr)new @unsafe.Pointer(ᏑcertEncoded)), ((uintptr)encodedLen));
    context = (ж<CertContext>)(uintptr)(((@unsafe.Pointer)r0));
    if (context == nil) {
        err = errnoErr(e1);
    }
    return (context, err);
}

public static (ж<CertContext> context, error err) CertEnumCertificatesInStore(ΔHandle store, ж<CertContext> ᏑprevContext) {
    ж<CertContext> context = default!;
    error err = default!;

    ref var prevContext = ref ᏑprevContext.val;
    var (r0, _, e1) = Syscall(procCertEnumCertificatesInStore.Addr(), 2, ((uintptr)store), ((uintptr)new @unsafe.Pointer(ᏑprevContext)), 0);
    context = (ж<CertContext>)(uintptr)(((@unsafe.Pointer)r0));
    if (context == nil) {
        err = errnoErr(e1);
    }
    return (context, err);
}

public static void CertFreeCertificateChain(ж<CertChainContext> Ꮡctx) {
    ref var ctx = ref Ꮡctx.val;

    Syscall(procCertFreeCertificateChain.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡctx)), 0, 0);
    return;
}

public static error /*err*/ CertFreeCertificateContext(ж<CertContext> Ꮡctx) {
    error err = default!;

    ref var ctx = ref Ꮡctx.val;
    var (r1, _, e1) = Syscall(procCertFreeCertificateContext.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡctx)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ CertGetCertificateChain(ΔHandle engine, ж<CertContext> Ꮡleaf, ж<Filetime> Ꮡtime, ΔHandle additionalStore, ж<CertChainPara> Ꮡpara, uint32 flags, uintptr reserved, ж<ж<CertChainContext>> ᏑchainCtx) {
    error err = default!;

    ref var leaf = ref Ꮡleaf.val;
    ref var time = ref Ꮡtime.val;
    ref var para = ref Ꮡpara.val;
    ref var chainCtx = ref ᏑchainCtx.val;
    var (r1, _, e1) = Syscall9(procCertGetCertificateChain.Addr(), 8, ((uintptr)engine), ((uintptr)new @unsafe.Pointer(Ꮡleaf)), ((uintptr)new @unsafe.Pointer(Ꮡtime)), ((uintptr)additionalStore), ((uintptr)new @unsafe.Pointer(Ꮡpara)), ((uintptr)flags), ((uintptr)reserved), ((uintptr)((@unsafe.Pointer)chainCtx)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (ΔHandle handle, error err) CertOpenStore(uintptr storeProvider, uint32 msgAndCertEncodingType, uintptr cryptProv, uint32 flags, uintptr para) {
    ΔHandle handle = default!;
    error err = default!;

    var (r0, _, e1) = Syscall6(procCertOpenStore.Addr(), 5, ((uintptr)storeProvider), ((uintptr)msgAndCertEncodingType), ((uintptr)cryptProv), ((uintptr)flags), ((uintptr)para), 0);
    handle = ((ΔHandle)r0);
    if (handle == 0) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

public static (ΔHandle store, error err) CertOpenSystemStore(ΔHandle hprov, ж<uint16> Ꮡname) {
    ΔHandle store = default!;
    error err = default!;

    ref var name = ref Ꮡname.val;
    var (r0, _, e1) = Syscall(procCertOpenSystemStoreW.Addr(), 2, ((uintptr)hprov), ((uintptr)new @unsafe.Pointer(Ꮡname)), 0);
    store = ((ΔHandle)r0);
    if (store == 0) {
        err = errnoErr(e1);
    }
    return (store, err);
}

public static error /*err*/ CertVerifyCertificateChainPolicy(uintptr policyOID, ж<CertChainContext> Ꮡchain, ж<CertChainPolicyPara> Ꮡpara, ж<CertChainPolicyStatus> Ꮡstatus) {
    error err = default!;

    ref var chain = ref Ꮡchain.val;
    ref var para = ref Ꮡpara.val;
    ref var status = ref Ꮡstatus.val;
    var (r1, _, e1) = Syscall6(procCertVerifyCertificateChainPolicy.Addr(), 4, ((uintptr)policyOID), ((uintptr)new @unsafe.Pointer(Ꮡchain)), ((uintptr)new @unsafe.Pointer(Ꮡpara)), ((uintptr)new @unsafe.Pointer(Ꮡstatus)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static bool /*same*/ DnsNameCompare(ж<uint16> Ꮡname1, ж<uint16> Ꮡname2) {
    bool same = default!;

    ref var name1 = ref Ꮡname1.val;
    ref var name2 = ref Ꮡname2.val;
    var (r0, _, _) = Syscall(procDnsNameCompare_W.Addr(), 2, ((uintptr)new @unsafe.Pointer(Ꮡname1)), ((uintptr)new @unsafe.Pointer(Ꮡname2)), 0);
    same = r0 != 0;
    return same;
}

public static error /*status*/ DnsQuery(@string name, uint16 qtype, uint32 options, ж<byte> Ꮡextra, ж<ж<DNSRecord>> Ꮡqrs, ж<byte> Ꮡpr) {
    error status = default!;

    ref var extra = ref Ꮡextra.val;
    ref var qrs = ref Ꮡqrs.val;
    ref var pr = ref Ꮡpr.val;
    ж<uint16> _p0 = default!;
    (_p0, status) = UTF16PtrFromString(name);
    if (status != default!) {
        return status;
    }
    return _DnsQuery(_p0, qtype, options, Ꮡextra, Ꮡqrs, Ꮡpr);
}

internal static error /*status*/ _DnsQuery(ж<uint16> Ꮡname, uint16 qtype, uint32 options, ж<byte> Ꮡextra, ж<ж<DNSRecord>> Ꮡqrs, ж<byte> Ꮡpr) {
    error status = default!;

    ref var name = ref Ꮡname.val;
    ref var extra = ref Ꮡextra.val;
    ref var qrs = ref Ꮡqrs.val;
    ref var pr = ref Ꮡpr.val;
    var (r0, _, _) = Syscall6(procDnsQuery_W.Addr(), 6, ((uintptr)new @unsafe.Pointer(Ꮡname)), ((uintptr)qtype), ((uintptr)options), ((uintptr)new @unsafe.Pointer(Ꮡextra)), ((uintptr)((@unsafe.Pointer)qrs)), ((uintptr)new @unsafe.Pointer(Ꮡpr)));
    if (r0 != 0) {
        status = ((Errno)r0);
    }
    return status;
}

public static void DnsRecordListFree(ж<DNSRecord> Ꮡrl, uint32 freetype) {
    ref var rl = ref Ꮡrl.val;

    Syscall(procDnsRecordListFree.Addr(), 2, ((uintptr)new @unsafe.Pointer(Ꮡrl)), ((uintptr)freetype), 0);
    return;
}

public static error /*errcode*/ GetAdaptersInfo(ж<IpAdapterInfo> Ꮡai, ж<uint32> Ꮡol) {
    error errcode = default!;

    ref var ai = ref Ꮡai.val;
    ref var ol = ref Ꮡol.val;
    var (r0, _, _) = Syscall(procGetAdaptersInfo.Addr(), 2, ((uintptr)new @unsafe.Pointer(Ꮡai)), ((uintptr)new @unsafe.Pointer(Ꮡol)), 0);
    if (r0 != 0) {
        errcode = ((Errno)r0);
    }
    return errcode;
}

public static error /*errcode*/ GetIfEntry(ж<MibIfRow> ᏑpIfRow) {
    error errcode = default!;

    ref var pIfRow = ref ᏑpIfRow.val;
    var (r0, _, _) = Syscall(procGetIfEntry.Addr(), 1, ((uintptr)new @unsafe.Pointer(ᏑpIfRow)), 0, 0);
    if (r0 != 0) {
        errcode = ((Errno)r0);
    }
    return errcode;
}

public static error /*err*/ CancelIo(ΔHandle s) {
    error err = default!;

    var (r1, _, e1) = Syscall(procCancelIo.Addr(), 1, ((uintptr)s), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ CancelIoEx(ΔHandle s, ж<Overlapped> Ꮡo) {
    error err = default!;

    ref var o = ref Ꮡo.val;
    var (r1, _, e1) = Syscall(procCancelIoEx.Addr(), 2, ((uintptr)s), ((uintptr)new @unsafe.Pointer(Ꮡo)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ CloseHandle(ΔHandle handle) {
    error err = default!;

    var (r1, _, e1) = Syscall(procCloseHandle.Addr(), 1, ((uintptr)handle), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ CreateDirectory(ж<uint16> Ꮡpath, ж<SecurityAttributes> Ꮡsa) {
    error err = default!;

    ref var path = ref Ꮡpath.val;
    ref var sa = ref Ꮡsa.val;
    var (r1, _, e1) = Syscall(procCreateDirectoryW.Addr(), 2, ((uintptr)new @unsafe.Pointer(Ꮡpath)), ((uintptr)new @unsafe.Pointer(Ꮡsa)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (ΔHandle handle, error err) CreateFileMapping(ΔHandle fhandle, ж<SecurityAttributes> Ꮡsa, uint32 prot, uint32 maxSizeHigh, uint32 maxSizeLow, ж<uint16> Ꮡname) {
    ΔHandle handle = default!;
    error err = default!;

    ref var sa = ref Ꮡsa.val;
    ref var name = ref Ꮡname.val;
    var (r0, _, e1) = Syscall6(procCreateFileMappingW.Addr(), 6, ((uintptr)fhandle), ((uintptr)new @unsafe.Pointer(Ꮡsa)), ((uintptr)prot), ((uintptr)maxSizeHigh), ((uintptr)maxSizeLow), ((uintptr)new @unsafe.Pointer(Ꮡname)));
    handle = ((ΔHandle)r0);
    if (handle == 0) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

public static (ΔHandle handle, error err) CreateFile(ж<uint16> Ꮡname, uint32 access, uint32 mode, ж<SecurityAttributes> Ꮡsa, uint32 createmode, uint32 attrs, int32 templatefile) {
    ΔHandle handle = default!;
    error err = default!;

    ref var name = ref Ꮡname.val;
    ref var sa = ref Ꮡsa.val;
    var (r0, _, e1) = Syscall9(procCreateFileW.Addr(), 7, ((uintptr)new @unsafe.Pointer(Ꮡname)), ((uintptr)access), ((uintptr)mode), ((uintptr)new @unsafe.Pointer(Ꮡsa)), ((uintptr)createmode), ((uintptr)attrs), ((uintptr)templatefile), 0, 0);
    handle = ((ΔHandle)r0);
    if (handle == InvalidHandle) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

public static error /*err*/ CreateHardLink(ж<uint16> Ꮡfilename, ж<uint16> Ꮡexistingfilename, uintptr reserved) {
    error err = default!;

    ref var filename = ref Ꮡfilename.val;
    ref var existingfilename = ref Ꮡexistingfilename.val;
    var (r1, _, e1) = Syscall(procCreateHardLinkW.Addr(), 3, ((uintptr)new @unsafe.Pointer(Ꮡfilename)), ((uintptr)new @unsafe.Pointer(Ꮡexistingfilename)), ((uintptr)reserved));
    if ((uintptr)(r1 & 255) == 0) {
        err = errnoErr(e1);
    }
    return err;
}

internal static (ΔHandle handle, error err) createIoCompletionPort(ΔHandle filehandle, ΔHandle cphandle, uintptr key, uint32 threadcnt) {
    ΔHandle handle = default!;
    error err = default!;

    var (r0, _, e1) = Syscall6(procCreateIoCompletionPort.Addr(), 4, ((uintptr)filehandle), ((uintptr)cphandle), ((uintptr)key), ((uintptr)threadcnt), 0, 0);
    handle = ((ΔHandle)r0);
    if (handle == 0) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

public static error /*err*/ CreatePipe(ж<ΔHandle> Ꮡreadhandle, ж<ΔHandle> Ꮡwritehandle, ж<SecurityAttributes> Ꮡsa, uint32 size) {
    error err = default!;

    ref var readhandle = ref Ꮡreadhandle.val;
    ref var writehandle = ref Ꮡwritehandle.val;
    ref var sa = ref Ꮡsa.val;
    var (r1, _, e1) = Syscall6(procCreatePipe.Addr(), 4, ((uintptr)((@unsafe.Pointer)readhandle)), ((uintptr)((@unsafe.Pointer)writehandle)), ((uintptr)new @unsafe.Pointer(Ꮡsa)), ((uintptr)size), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ CreateProcess(ж<uint16> ᏑappName, ж<uint16> ᏑcommandLine, ж<SecurityAttributes> ᏑprocSecurity, ж<SecurityAttributes> ᏑthreadSecurity, bool inheritHandles, uint32 creationFlags, ж<uint16> Ꮡenv, ж<uint16> ᏑcurrentDir, ж<StartupInfo> ᏑstartupInfo, ж<ProcessInformation> ᏑoutProcInfo) {
    error err = default!;

    ref var appName = ref ᏑappName.val;
    ref var commandLine = ref ᏑcommandLine.val;
    ref var procSecurity = ref ᏑprocSecurity.val;
    ref var threadSecurity = ref ᏑthreadSecurity.val;
    ref var env = ref Ꮡenv.val;
    ref var currentDir = ref ᏑcurrentDir.val;
    ref var startupInfo = ref ᏑstartupInfo.val;
    ref var outProcInfo = ref ᏑoutProcInfo.val;
    uint32 _p0 = default!;
    if (inheritHandles) {
        _p0 = 1;
    }
    var (r1, _, e1) = Syscall12(procCreateProcessW.Addr(), 10, ((uintptr)new @unsafe.Pointer(ᏑappName)), ((uintptr)new @unsafe.Pointer(ᏑcommandLine)), ((uintptr)new @unsafe.Pointer(ᏑprocSecurity)), ((uintptr)new @unsafe.Pointer(ᏑthreadSecurity)), ((uintptr)_p0), ((uintptr)creationFlags), ((uintptr)new @unsafe.Pointer(Ꮡenv)), ((uintptr)new @unsafe.Pointer(ᏑcurrentDir)), ((uintptr)new @unsafe.Pointer(ᏑstartupInfo)), ((uintptr)new @unsafe.Pointer(ᏑoutProcInfo)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ CreateSymbolicLink(ж<uint16> Ꮡsymlinkfilename, ж<uint16> Ꮡtargetfilename, uint32 flags) {
    error err = default!;

    ref var symlinkfilename = ref Ꮡsymlinkfilename.val;
    ref var targetfilename = ref Ꮡtargetfilename.val;
    var (r1, _, e1) = Syscall(procCreateSymbolicLinkW.Addr(), 3, ((uintptr)new @unsafe.Pointer(Ꮡsymlinkfilename)), ((uintptr)new @unsafe.Pointer(Ꮡtargetfilename)), ((uintptr)flags));
    if ((uintptr)(r1 & 255) == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (ΔHandle handle, error err) CreateToolhelp32Snapshot(uint32 flags, uint32 processId) {
    ΔHandle handle = default!;
    error err = default!;

    var (r0, _, e1) = Syscall(procCreateToolhelp32Snapshot.Addr(), 2, ((uintptr)flags), ((uintptr)processId), 0);
    handle = ((ΔHandle)r0);
    if (handle == InvalidHandle) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

public static error /*err*/ DeleteFile(ж<uint16> Ꮡpath) {
    error err = default!;

    ref var path = ref Ꮡpath.val;
    var (r1, _, e1) = Syscall(procDeleteFileW.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡpath)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

internal static void deleteProcThreadAttributeList(ж<_PROC_THREAD_ATTRIBUTE_LIST> Ꮡattrlist) {
    ref var attrlist = ref Ꮡattrlist.val;

    Syscall(procDeleteProcThreadAttributeList.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡattrlist)), 0, 0);
    return;
}

public static error /*err*/ DeviceIoControl(ΔHandle handle, uint32 ioControlCode, ж<byte> ᏑinBuffer, uint32 inBufferSize, ж<byte> ᏑoutBuffer, uint32 outBufferSize, ж<uint32> ᏑbytesReturned, ж<Overlapped> Ꮡoverlapped) {
    error err = default!;

    ref var inBuffer = ref ᏑinBuffer.val;
    ref var outBuffer = ref ᏑoutBuffer.val;
    ref var bytesReturned = ref ᏑbytesReturned.val;
    ref var overlapped = ref Ꮡoverlapped.val;
    var (r1, _, e1) = Syscall9(procDeviceIoControl.Addr(), 8, ((uintptr)handle), ((uintptr)ioControlCode), ((uintptr)new @unsafe.Pointer(ᏑinBuffer)), ((uintptr)inBufferSize), ((uintptr)new @unsafe.Pointer(ᏑoutBuffer)), ((uintptr)outBufferSize), ((uintptr)new @unsafe.Pointer(ᏑbytesReturned)), ((uintptr)new @unsafe.Pointer(Ꮡoverlapped)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ DuplicateHandle(ΔHandle hSourceProcessHandle, ΔHandle hSourceHandle, ΔHandle hTargetProcessHandle, ж<ΔHandle> ᏑlpTargetHandle, uint32 dwDesiredAccess, bool bInheritHandle, uint32 dwOptions) {
    error err = default!;

    ref var lpTargetHandle = ref ᏑlpTargetHandle.val;
    uint32 _p0 = default!;
    if (bInheritHandle) {
        _p0 = 1;
    }
    var (r1, _, e1) = Syscall9(procDuplicateHandle.Addr(), 7, ((uintptr)hSourceProcessHandle), ((uintptr)hSourceHandle), ((uintptr)hTargetProcessHandle), ((uintptr)((@unsafe.Pointer)lpTargetHandle)), ((uintptr)dwDesiredAccess), ((uintptr)_p0), ((uintptr)dwOptions), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static void ExitProcess(uint32 exitcode) {
    Syscall(procExitProcess.Addr(), 1, ((uintptr)exitcode), 0, 0);
    return;
}

public static error /*err*/ FindClose(ΔHandle handle) {
    error err = default!;

    var (r1, _, e1) = Syscall(procFindClose.Addr(), 1, ((uintptr)handle), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

internal static (ΔHandle handle, error err) findFirstFile1(ж<uint16> Ꮡname, ж<win32finddata1> Ꮡdata) {
    ΔHandle handle = default!;
    error err = default!;

    ref var name = ref Ꮡname.val;
    ref var data = ref Ꮡdata.val;
    var (r0, _, e1) = Syscall(procFindFirstFileW.Addr(), 2, ((uintptr)new @unsafe.Pointer(Ꮡname)), ((uintptr)new @unsafe.Pointer(Ꮡdata)), 0);
    handle = ((ΔHandle)r0);
    if (handle == InvalidHandle) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

internal static error /*err*/ findNextFile1(ΔHandle handle, ж<win32finddata1> Ꮡdata) {
    error err = default!;

    ref var data = ref Ꮡdata.val;
    var (r1, _, e1) = Syscall(procFindNextFileW.Addr(), 2, ((uintptr)handle), ((uintptr)new @unsafe.Pointer(Ꮡdata)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ FlushFileBuffers(ΔHandle handle) {
    error err = default!;

    var (r1, _, e1) = Syscall(procFlushFileBuffers.Addr(), 1, ((uintptr)handle), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ FlushViewOfFile(uintptr addr, uintptr length) {
    error err = default!;

    var (r1, _, e1) = Syscall(procFlushViewOfFile.Addr(), 2, ((uintptr)addr), ((uintptr)length), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

internal static (uint32 n, error err) formatMessage(uint32 flags, uintptr msgsrc, uint32 msgid, uint32 langid, slice<uint16> buf, ж<byte> Ꮡargs) {
    uint32 n = default!;
    error err = default!;

    ref var args = ref Ꮡargs.val;
    ж<uint16> _p0 = default!;
    if (len(buf) > 0) {
        _p0 = Ꮡ(buf, 0);
    }
    var (r0, _, e1) = Syscall9(procFormatMessageW.Addr(), 7, ((uintptr)flags), ((uintptr)msgsrc), ((uintptr)msgid), ((uintptr)langid), ((uintptr)new @unsafe.Pointer(_p0)), ((uintptr)len(buf)), ((uintptr)new @unsafe.Pointer(Ꮡargs)), 0, 0);
    n = ((uint32)r0);
    if (n == 0) {
        err = errnoErr(e1);
    }
    return (n, err);
}

public static error /*err*/ FreeEnvironmentStrings(ж<uint16> Ꮡenvs) {
    error err = default!;

    ref var envs = ref Ꮡenvs.val;
    var (r1, _, e1) = Syscall(procFreeEnvironmentStringsW.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡenvs)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ FreeLibrary(ΔHandle handle) {
    error err = default!;

    var (r1, _, e1) = Syscall(procFreeLibrary.Addr(), 1, ((uintptr)handle), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static ж<uint16> /*cmd*/ GetCommandLine() {
    ж<uint16> cmd = default!;

    var (r0, _, _) = Syscall(procGetCommandLineW.Addr(), 0, 0, 0, 0);
    cmd = (ж<uint16>)(uintptr)(((@unsafe.Pointer)r0));
    return cmd;
}

public static error /*err*/ GetComputerName(ж<uint16> Ꮡbuf, ж<uint32> Ꮡn) {
    error err = default!;

    ref var buf = ref Ꮡbuf.val;
    ref var n = ref Ꮡn.val;
    var (r1, _, e1) = Syscall(procGetComputerNameW.Addr(), 2, ((uintptr)new @unsafe.Pointer(Ꮡbuf)), ((uintptr)new @unsafe.Pointer(Ꮡn)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ GetConsoleMode(ΔHandle console, ж<uint32> Ꮡmode) {
    error err = default!;

    ref var mode = ref Ꮡmode.val;
    var (r1, _, e1) = Syscall(procGetConsoleMode.Addr(), 2, ((uintptr)console), ((uintptr)new @unsafe.Pointer(Ꮡmode)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (uint32 n, error err) GetCurrentDirectory(uint32 buflen, ж<uint16> Ꮡbuf) {
    uint32 n = default!;
    error err = default!;

    ref var buf = ref Ꮡbuf.val;
    var (r0, _, e1) = Syscall(procGetCurrentDirectoryW.Addr(), 2, ((uintptr)buflen), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), 0);
    n = ((uint32)r0);
    if (n == 0) {
        err = errnoErr(e1);
    }
    return (n, err);
}

public static (ΔHandle pseudoHandle, error err) GetCurrentProcess() {
    ΔHandle pseudoHandle = default!;
    error err = default!;

    var (r0, _, e1) = Syscall(procGetCurrentProcess.Addr(), 0, 0, 0, 0);
    pseudoHandle = ((ΔHandle)r0);
    if (pseudoHandle == 0) {
        err = errnoErr(e1);
    }
    return (pseudoHandle, err);
}

internal static uint32 /*pid*/ getCurrentProcessId() {
    uint32 pid = default!;

    var (r0, _, _) = Syscall(procGetCurrentProcessId.Addr(), 0, 0, 0, 0);
    pid = ((uint32)r0);
    return pid;
}

public static (ж<uint16> envs, error err) GetEnvironmentStrings() {
    ж<uint16> envs = default!;
    error err = default!;

    var (r0, _, e1) = Syscall(procGetEnvironmentStringsW.Addr(), 0, 0, 0, 0);
    envs = (ж<uint16>)(uintptr)(((@unsafe.Pointer)r0));
    if (envs == nil) {
        err = errnoErr(e1);
    }
    return (envs, err);
}

public static (uint32 n, error err) GetEnvironmentVariable(ж<uint16> Ꮡname, ж<uint16> Ꮡbuffer, uint32 size) {
    uint32 n = default!;
    error err = default!;

    ref var name = ref Ꮡname.val;
    ref var buffer = ref Ꮡbuffer.val;
    var (r0, _, e1) = Syscall(procGetEnvironmentVariableW.Addr(), 3, ((uintptr)new @unsafe.Pointer(Ꮡname)), ((uintptr)new @unsafe.Pointer(Ꮡbuffer)), ((uintptr)size));
    n = ((uint32)r0);
    if (n == 0) {
        err = errnoErr(e1);
    }
    return (n, err);
}

public static error /*err*/ GetExitCodeProcess(ΔHandle handle, ж<uint32> Ꮡexitcode) {
    error err = default!;

    ref var exitcode = ref Ꮡexitcode.val;
    var (r1, _, e1) = Syscall(procGetExitCodeProcess.Addr(), 2, ((uintptr)handle), ((uintptr)new @unsafe.Pointer(Ꮡexitcode)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ GetFileAttributesEx(ж<uint16> Ꮡname, uint32 level, ж<byte> Ꮡinfo) {
    error err = default!;

    ref var name = ref Ꮡname.val;
    ref var info = ref Ꮡinfo.val;
    var (r1, _, e1) = Syscall(procGetFileAttributesExW.Addr(), 3, ((uintptr)new @unsafe.Pointer(Ꮡname)), ((uintptr)level), ((uintptr)new @unsafe.Pointer(Ꮡinfo)));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (uint32 attrs, error err) GetFileAttributes(ж<uint16> Ꮡname) {
    uint32 attrs = default!;
    error err = default!;

    ref var name = ref Ꮡname.val;
    var (r0, _, e1) = Syscall(procGetFileAttributesW.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡname)), 0, 0);
    attrs = ((uint32)r0);
    if (attrs == INVALID_FILE_ATTRIBUTES) {
        err = errnoErr(e1);
    }
    return (attrs, err);
}

public static error /*err*/ GetFileInformationByHandle(ΔHandle handle, ж<ByHandleFileInformation> Ꮡdata) {
    error err = default!;

    ref var data = ref Ꮡdata.val;
    var (r1, _, e1) = Syscall(procGetFileInformationByHandle.Addr(), 2, ((uintptr)handle), ((uintptr)new @unsafe.Pointer(Ꮡdata)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (uint32 n, error err) GetFileType(ΔHandle filehandle) {
    uint32 n = default!;
    error err = default!;

    var (r0, _, e1) = Syscall(procGetFileType.Addr(), 1, ((uintptr)filehandle), 0, 0);
    n = ((uint32)r0);
    if (n == 0) {
        err = errnoErr(e1);
    }
    return (n, err);
}

internal static (uint32 n, error err) getFinalPathNameByHandle(ΔHandle file, ж<uint16> ᏑfilePath, uint32 filePathSize, uint32 flags) {
    uint32 n = default!;
    error err = default!;

    ref var filePath = ref ᏑfilePath.val;
    var (r0, _, e1) = Syscall6(procGetFinalPathNameByHandleW.Addr(), 4, ((uintptr)file), ((uintptr)new @unsafe.Pointer(ᏑfilePath)), ((uintptr)filePathSize), ((uintptr)flags), 0, 0);
    n = ((uint32)r0);
    if (n == 0 || n >= filePathSize) {
        err = errnoErr(e1);
    }
    return (n, err);
}

public static (uint32 n, error err) GetFullPathName(ж<uint16> Ꮡpath, uint32 buflen, ж<uint16> Ꮡbuf, ж<ж<uint16>> Ꮡfname) {
    uint32 n = default!;
    error err = default!;

    ref var path = ref Ꮡpath.val;
    ref var buf = ref Ꮡbuf.val;
    ref var fname = ref Ꮡfname.val;
    var (r0, _, e1) = Syscall6(procGetFullPathNameW.Addr(), 4, ((uintptr)new @unsafe.Pointer(Ꮡpath)), ((uintptr)buflen), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), ((uintptr)((@unsafe.Pointer)fname)), 0, 0);
    n = ((uint32)r0);
    if (n == 0) {
        err = errnoErr(e1);
    }
    return (n, err);
}

public static error /*lasterr*/ GetLastError() {
    error lasterr = default!;

    var (r0, _, _) = Syscall(procGetLastError.Addr(), 0, 0, 0, 0);
    if (r0 != 0) {
        lasterr = ((Errno)r0);
    }
    return lasterr;
}

public static (uint32 n, error err) GetLongPathName(ж<uint16> Ꮡpath, ж<uint16> Ꮡbuf, uint32 buflen) {
    uint32 n = default!;
    error err = default!;

    ref var path = ref Ꮡpath.val;
    ref var buf = ref Ꮡbuf.val;
    var (r0, _, e1) = Syscall(procGetLongPathNameW.Addr(), 3, ((uintptr)new @unsafe.Pointer(Ꮡpath)), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), ((uintptr)buflen));
    n = ((uint32)r0);
    if (n == 0) {
        err = errnoErr(e1);
    }
    return (n, err);
}

public static (uintptr proc, error err) GetProcAddress(ΔHandle module, @string procname) {
    uintptr proc = default!;
    error err = default!;

    ж<byte> _p0 = default!;
    (_p0, err) = BytePtrFromString(procname);
    if (err != default!) {
        return (proc, err);
    }
    return _GetProcAddress(module, _p0);
}

internal static (uintptr proc, error err) _GetProcAddress(ΔHandle module, ж<byte> Ꮡprocname) {
    uintptr proc = default!;
    error err = default!;

    ref var procname = ref Ꮡprocname.val;
    var (r0, _, e1) = Syscall(procGetProcAddress.Addr(), 2, ((uintptr)module), ((uintptr)new @unsafe.Pointer(Ꮡprocname)), 0);
    proc = ((uintptr)r0);
    if (proc == 0) {
        err = errnoErr(e1);
    }
    return (proc, err);
}

public static error /*err*/ GetProcessTimes(ΔHandle handle, ж<Filetime> ᏑcreationTime, ж<Filetime> ᏑexitTime, ж<Filetime> ᏑkernelTime, ж<Filetime> ᏑuserTime) {
    error err = default!;

    ref var creationTime = ref ᏑcreationTime.val;
    ref var exitTime = ref ᏑexitTime.val;
    ref var kernelTime = ref ᏑkernelTime.val;
    ref var userTime = ref ᏑuserTime.val;
    var (r1, _, e1) = Syscall6(procGetProcessTimes.Addr(), 5, ((uintptr)handle), ((uintptr)new @unsafe.Pointer(ᏑcreationTime)), ((uintptr)new @unsafe.Pointer(ᏑexitTime)), ((uintptr)new @unsafe.Pointer(ᏑkernelTime)), ((uintptr)new @unsafe.Pointer(ᏑuserTime)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

internal static error /*err*/ getQueuedCompletionStatus(ΔHandle cphandle, ж<uint32> Ꮡqty, ж<uintptr> Ꮡkey, ж<ж<Overlapped>> Ꮡoverlapped, uint32 timeout) {
    error err = default!;

    ref var qty = ref Ꮡqty.val;
    ref var key = ref Ꮡkey.val;
    ref var overlapped = ref Ꮡoverlapped.val;
    var (r1, _, e1) = Syscall6(procGetQueuedCompletionStatus.Addr(), 5, ((uintptr)cphandle), ((uintptr)new @unsafe.Pointer(Ꮡqty)), ((uintptr)((@unsafe.Pointer)key)), ((uintptr)((@unsafe.Pointer)overlapped)), ((uintptr)timeout), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (uint32 n, error err) GetShortPathName(ж<uint16> Ꮡlongpath, ж<uint16> Ꮡshortpath, uint32 buflen) {
    uint32 n = default!;
    error err = default!;

    ref var longpath = ref Ꮡlongpath.val;
    ref var shortpath = ref Ꮡshortpath.val;
    var (r0, _, e1) = Syscall(procGetShortPathNameW.Addr(), 3, ((uintptr)new @unsafe.Pointer(Ꮡlongpath)), ((uintptr)new @unsafe.Pointer(Ꮡshortpath)), ((uintptr)buflen));
    n = ((uint32)r0);
    if (n == 0) {
        err = errnoErr(e1);
    }
    return (n, err);
}

internal static void getStartupInfo(ж<StartupInfo> ᏑstartupInfo) {
    ref var startupInfo = ref ᏑstartupInfo.val;

    Syscall(procGetStartupInfoW.Addr(), 1, ((uintptr)new @unsafe.Pointer(ᏑstartupInfo)), 0, 0);
    return;
}

public static (ΔHandle handle, error err) GetStdHandle(nint stdhandle) {
    ΔHandle handle = default!;
    error err = default!;

    var (r0, _, e1) = Syscall(procGetStdHandle.Addr(), 1, ((uintptr)stdhandle), 0, 0);
    handle = ((ΔHandle)r0);
    if (handle == InvalidHandle) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

public static void GetSystemTimeAsFileTime(ж<Filetime> Ꮡtime) {
    ref var time = ref Ꮡtime.val;

    Syscall(procGetSystemTimeAsFileTime.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡtime)), 0, 0);
    return;
}

public static (uint32 n, error err) GetTempPath(uint32 buflen, ж<uint16> Ꮡbuf) {
    uint32 n = default!;
    error err = default!;

    ref var buf = ref Ꮡbuf.val;
    var (r0, _, e1) = Syscall(procGetTempPathW.Addr(), 2, ((uintptr)buflen), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), 0);
    n = ((uint32)r0);
    if (n == 0) {
        err = errnoErr(e1);
    }
    return (n, err);
}

public static (uint32 rc, error err) GetTimeZoneInformation(ж<Timezoneinformation> Ꮡtzi) {
    uint32 rc = default!;
    error err = default!;

    ref var tzi = ref Ꮡtzi.val;
    var (r0, _, e1) = Syscall(procGetTimeZoneInformation.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡtzi)), 0, 0);
    rc = ((uint32)r0);
    if (rc == (nint)4294967295L) {
        err = errnoErr(e1);
    }
    return (rc, err);
}

public static (uint32 ver, error err) GetVersion() {
    uint32 ver = default!;
    error err = default!;

    var (r0, _, e1) = Syscall(procGetVersion.Addr(), 0, 0, 0, 0);
    ver = ((uint32)r0);
    if (ver == 0) {
        err = errnoErr(e1);
    }
    return (ver, err);
}

internal static error /*err*/ initializeProcThreadAttributeList(ж<_PROC_THREAD_ATTRIBUTE_LIST> Ꮡattrlist, uint32 attrcount, uint32 flags, ж<uintptr> Ꮡsize) {
    error err = default!;

    ref var attrlist = ref Ꮡattrlist.val;
    ref var size = ref Ꮡsize.val;
    var (r1, _, e1) = Syscall6(procInitializeProcThreadAttributeList.Addr(), 4, ((uintptr)new @unsafe.Pointer(Ꮡattrlist)), ((uintptr)attrcount), ((uintptr)flags), ((uintptr)((@unsafe.Pointer)size)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (ΔHandle handle, error err) LoadLibrary(@string libname) {
    ΔHandle handle = default!;
    error err = default!;

    ж<uint16> _p0 = default!;
    (_p0, err) = UTF16PtrFromString(libname);
    if (err != default!) {
        return (handle, err);
    }
    return _LoadLibrary(_p0);
}

internal static (ΔHandle handle, error err) _LoadLibrary(ж<uint16> Ꮡlibname) {
    ΔHandle handle = default!;
    error err = default!;

    ref var libname = ref Ꮡlibname.val;
    var (r0, _, e1) = Syscall(procLoadLibraryW.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡlibname)), 0, 0);
    handle = ((ΔHandle)r0);
    if (handle == 0) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

public static (ΔHandle handle, error err) LocalFree(ΔHandle hmem) {
    ΔHandle handle = default!;
    error err = default!;

    var (r0, _, e1) = Syscall(procLocalFree.Addr(), 1, ((uintptr)hmem), 0, 0);
    handle = ((ΔHandle)r0);
    if (handle != 0) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

public static (uintptr addr, error err) MapViewOfFile(ΔHandle handle, uint32 access, uint32 offsetHigh, uint32 offsetLow, uintptr length) {
    uintptr addr = default!;
    error err = default!;

    var (r0, _, e1) = Syscall6(procMapViewOfFile.Addr(), 5, ((uintptr)handle), ((uintptr)access), ((uintptr)offsetHigh), ((uintptr)offsetLow), ((uintptr)length), 0);
    addr = ((uintptr)r0);
    if (addr == 0) {
        err = errnoErr(e1);
    }
    return (addr, err);
}

public static error /*err*/ MoveFile(ж<uint16> Ꮡfrom, ж<uint16> Ꮡto) {
    error err = default!;

    ref var from = ref Ꮡfrom.val;
    ref var to = ref Ꮡto.val;
    var (r1, _, e1) = Syscall(procMoveFileW.Addr(), 2, ((uintptr)new @unsafe.Pointer(Ꮡfrom)), ((uintptr)new @unsafe.Pointer(Ꮡto)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (ΔHandle handle, error err) OpenProcess(uint32 da, bool inheritHandle, uint32 pid) {
    ΔHandle handle = default!;
    error err = default!;

    uint32 _p0 = default!;
    if (inheritHandle) {
        _p0 = 1;
    }
    var (r0, _, e1) = Syscall(procOpenProcess.Addr(), 3, ((uintptr)da), ((uintptr)_p0), ((uintptr)pid));
    handle = ((ΔHandle)r0);
    if (handle == 0) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

internal static error /*err*/ postQueuedCompletionStatus(ΔHandle cphandle, uint32 qty, uintptr key, ж<Overlapped> Ꮡoverlapped) {
    error err = default!;

    ref var overlapped = ref Ꮡoverlapped.val;
    var (r1, _, e1) = Syscall6(procPostQueuedCompletionStatus.Addr(), 4, ((uintptr)cphandle), ((uintptr)qty), ((uintptr)key), ((uintptr)new @unsafe.Pointer(Ꮡoverlapped)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ Process32First(ΔHandle snapshot, ж<ProcessEntry32> ᏑprocEntry) {
    error err = default!;

    ref var procEntry = ref ᏑprocEntry.val;
    var (r1, _, e1) = Syscall(procProcess32FirstW.Addr(), 2, ((uintptr)snapshot), ((uintptr)new @unsafe.Pointer(ᏑprocEntry)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ Process32Next(ΔHandle snapshot, ж<ProcessEntry32> ᏑprocEntry) {
    error err = default!;

    ref var procEntry = ref ᏑprocEntry.val;
    var (r1, _, e1) = Syscall(procProcess32NextW.Addr(), 2, ((uintptr)snapshot), ((uintptr)new @unsafe.Pointer(ᏑprocEntry)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ ReadConsole(ΔHandle console, ж<uint16> Ꮡbuf, uint32 toread, ж<uint32> Ꮡread, ж<byte> ᏑinputControl) {
    error err = default!;

    ref var buf = ref Ꮡbuf.val;
    ref var read = ref Ꮡread.val;
    ref var inputControl = ref ᏑinputControl.val;
    var (r1, _, e1) = Syscall6(procReadConsoleW.Addr(), 5, ((uintptr)console), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), ((uintptr)toread), ((uintptr)new @unsafe.Pointer(Ꮡread)), ((uintptr)new @unsafe.Pointer(ᏑinputControl)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ ReadDirectoryChanges(ΔHandle handle, ж<byte> Ꮡbuf, uint32 buflen, bool watchSubTree, uint32 mask, ж<uint32> Ꮡretlen, ж<Overlapped> Ꮡoverlapped, uintptr completionRoutine) {
    error err = default!;

    ref var buf = ref Ꮡbuf.val;
    ref var retlen = ref Ꮡretlen.val;
    ref var overlapped = ref Ꮡoverlapped.val;
    uint32 _p0 = default!;
    if (watchSubTree) {
        _p0 = 1;
    }
    var (r1, _, e1) = Syscall9(procReadDirectoryChangesW.Addr(), 8, ((uintptr)handle), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), ((uintptr)buflen), ((uintptr)_p0), ((uintptr)mask), ((uintptr)new @unsafe.Pointer(Ꮡretlen)), ((uintptr)new @unsafe.Pointer(Ꮡoverlapped)), ((uintptr)completionRoutine), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

internal static error /*err*/ readFile(ΔHandle handle, slice<byte> buf, ж<uint32> Ꮡdone, ж<Overlapped> Ꮡoverlapped) {
    error err = default!;

    ref var done = ref Ꮡdone.val;
    ref var overlapped = ref Ꮡoverlapped.val;
    ж<byte> _p0 = default!;
    if (len(buf) > 0) {
        _p0 = Ꮡ(buf, 0);
    }
    var (r1, _, e1) = Syscall6(procReadFile.Addr(), 5, ((uintptr)handle), ((uintptr)new @unsafe.Pointer(_p0)), ((uintptr)len(buf)), ((uintptr)new @unsafe.Pointer(Ꮡdone)), ((uintptr)new @unsafe.Pointer(Ꮡoverlapped)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ RemoveDirectory(ж<uint16> Ꮡpath) {
    error err = default!;

    ref var path = ref Ꮡpath.val;
    var (r1, _, e1) = Syscall(procRemoveDirectoryW.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡpath)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ SetCurrentDirectory(ж<uint16> Ꮡpath) {
    error err = default!;

    ref var path = ref Ꮡpath.val;
    var (r1, _, e1) = Syscall(procSetCurrentDirectoryW.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡpath)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ SetEndOfFile(ΔHandle handle) {
    error err = default!;

    var (r1, _, e1) = Syscall(procSetEndOfFile.Addr(), 1, ((uintptr)handle), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ SetEnvironmentVariable(ж<uint16> Ꮡname, ж<uint16> Ꮡvalue) {
    error err = default!;

    ref var name = ref Ꮡname.val;
    ref var value = ref Ꮡvalue.val;
    var (r1, _, e1) = Syscall(procSetEnvironmentVariableW.Addr(), 2, ((uintptr)new @unsafe.Pointer(Ꮡname)), ((uintptr)new @unsafe.Pointer(Ꮡvalue)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ SetFileAttributes(ж<uint16> Ꮡname, uint32 attrs) {
    error err = default!;

    ref var name = ref Ꮡname.val;
    var (r1, _, e1) = Syscall(procSetFileAttributesW.Addr(), 2, ((uintptr)new @unsafe.Pointer(Ꮡname)), ((uintptr)attrs), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ SetFileCompletionNotificationModes(ΔHandle handle, uint8 flags) {
    error err = default!;

    var (r1, _, e1) = Syscall(procSetFileCompletionNotificationModes.Addr(), 2, ((uintptr)handle), ((uintptr)flags), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (uint32 newlowoffset, error err) SetFilePointer(ΔHandle handle, int32 lowoffset, ж<int32> Ꮡhighoffsetptr, uint32 whence) {
    uint32 newlowoffset = default!;
    error err = default!;

    ref var highoffsetptr = ref Ꮡhighoffsetptr.val;
    var (r0, _, e1) = Syscall6(procSetFilePointer.Addr(), 4, ((uintptr)handle), ((uintptr)lowoffset), ((uintptr)new @unsafe.Pointer(Ꮡhighoffsetptr)), ((uintptr)whence), 0, 0);
    newlowoffset = ((uint32)r0);
    if (newlowoffset == (nint)4294967295L) {
        err = errnoErr(e1);
    }
    return (newlowoffset, err);
}

public static error /*err*/ SetFileTime(ΔHandle handle, ж<Filetime> Ꮡctime, ж<Filetime> Ꮡatime, ж<Filetime> Ꮡwtime) {
    error err = default!;

    ref var ctime = ref Ꮡctime.val;
    ref var atime = ref Ꮡatime.val;
    ref var wtime = ref Ꮡwtime.val;
    var (r1, _, e1) = Syscall6(procSetFileTime.Addr(), 4, ((uintptr)handle), ((uintptr)new @unsafe.Pointer(Ꮡctime)), ((uintptr)new @unsafe.Pointer(Ꮡatime)), ((uintptr)new @unsafe.Pointer(Ꮡwtime)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ SetHandleInformation(ΔHandle handle, uint32 mask, uint32 flags) {
    error err = default!;

    var (r1, _, e1) = Syscall(procSetHandleInformation.Addr(), 3, ((uintptr)handle), ((uintptr)mask), ((uintptr)flags));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ TerminateProcess(ΔHandle handle, uint32 exitcode) {
    error err = default!;

    var (r1, _, e1) = Syscall(procTerminateProcess.Addr(), 2, ((uintptr)handle), ((uintptr)exitcode), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ UnmapViewOfFile(uintptr addr) {
    error err = default!;

    var (r1, _, e1) = Syscall(procUnmapViewOfFile.Addr(), 1, ((uintptr)addr), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

internal static error /*err*/ updateProcThreadAttribute(ж<_PROC_THREAD_ATTRIBUTE_LIST> Ꮡattrlist, uint32 flags, uintptr attr, @unsafe.Pointer value, uintptr size, @unsafe.Pointer prevvalue, ж<uintptr> Ꮡreturnedsize) {
    error err = default!;

    ref var attrlist = ref Ꮡattrlist.val;
    ref var returnedsize = ref Ꮡreturnedsize.val;
    var (r1, _, e1) = Syscall9(procUpdateProcThreadAttribute.Addr(), 7, ((uintptr)new @unsafe.Pointer(Ꮡattrlist)), ((uintptr)flags), ((uintptr)attr), ((uintptr)value), ((uintptr)size), ((uintptr)prevvalue), ((uintptr)((@unsafe.Pointer)returnedsize)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ VirtualLock(uintptr addr, uintptr length) {
    error err = default!;

    var (r1, _, e1) = Syscall(procVirtualLock.Addr(), 2, ((uintptr)addr), ((uintptr)length), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ VirtualUnlock(uintptr addr, uintptr length) {
    error err = default!;

    var (r1, _, e1) = Syscall(procVirtualUnlock.Addr(), 2, ((uintptr)addr), ((uintptr)length), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (uint32 @event, error err) WaitForSingleObject(ΔHandle handle, uint32 waitMilliseconds) {
    uint32 @event = default!;
    error err = default!;

    var (r0, _, e1) = Syscall(procWaitForSingleObject.Addr(), 2, ((uintptr)handle), ((uintptr)waitMilliseconds), 0);
    @event = ((uint32)r0);
    if (@event == (nint)4294967295L) {
        err = errnoErr(e1);
    }
    return (@event, err);
}

public static error /*err*/ WriteConsole(ΔHandle console, ж<uint16> Ꮡbuf, uint32 towrite, ж<uint32> Ꮡwritten, ж<byte> Ꮡreserved) {
    error err = default!;

    ref var buf = ref Ꮡbuf.val;
    ref var written = ref Ꮡwritten.val;
    ref var reserved = ref Ꮡreserved.val;
    var (r1, _, e1) = Syscall6(procWriteConsoleW.Addr(), 5, ((uintptr)console), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), ((uintptr)towrite), ((uintptr)new @unsafe.Pointer(Ꮡwritten)), ((uintptr)new @unsafe.Pointer(Ꮡreserved)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

internal static error /*err*/ writeFile(ΔHandle handle, slice<byte> buf, ж<uint32> Ꮡdone, ж<Overlapped> Ꮡoverlapped) {
    error err = default!;

    ref var done = ref Ꮡdone.val;
    ref var overlapped = ref Ꮡoverlapped.val;
    ж<byte> _p0 = default!;
    if (len(buf) > 0) {
        _p0 = Ꮡ(buf, 0);
    }
    var (r1, _, e1) = Syscall6(procWriteFile.Addr(), 5, ((uintptr)handle), ((uintptr)new @unsafe.Pointer(_p0)), ((uintptr)len(buf)), ((uintptr)new @unsafe.Pointer(Ꮡdone)), ((uintptr)new @unsafe.Pointer(Ꮡoverlapped)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ AcceptEx(ΔHandle ls, ΔHandle @as, ж<byte> Ꮡbuf, uint32 rxdatalen, uint32 laddrlen, uint32 raddrlen, ж<uint32> Ꮡrecvd, ж<Overlapped> Ꮡoverlapped) {
    error err = default!;

    ref var buf = ref Ꮡbuf.val;
    ref var recvd = ref Ꮡrecvd.val;
    ref var overlapped = ref Ꮡoverlapped.val;
    var (r1, _, e1) = Syscall9(procAcceptEx.Addr(), 8, ((uintptr)ls), ((uintptr)@as), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), ((uintptr)rxdatalen), ((uintptr)laddrlen), ((uintptr)raddrlen), ((uintptr)new @unsafe.Pointer(Ꮡrecvd)), ((uintptr)new @unsafe.Pointer(Ꮡoverlapped)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static void GetAcceptExSockaddrs(ж<byte> Ꮡbuf, uint32 rxdatalen, uint32 laddrlen, uint32 raddrlen, ж<ж<RawSockaddrAny>> Ꮡlrsa, ж<int32> Ꮡlrsalen, ж<ж<RawSockaddrAny>> Ꮡrrsa, ж<int32> Ꮡrrsalen) {
    ref var buf = ref Ꮡbuf.val;
    ref var lrsa = ref Ꮡlrsa.val;
    ref var lrsalen = ref Ꮡlrsalen.val;
    ref var rrsa = ref Ꮡrrsa.val;
    ref var rrsalen = ref Ꮡrrsalen.val;

    Syscall9(procGetAcceptExSockaddrs.Addr(), 8, ((uintptr)new @unsafe.Pointer(Ꮡbuf)), ((uintptr)rxdatalen), ((uintptr)laddrlen), ((uintptr)raddrlen), ((uintptr)((@unsafe.Pointer)lrsa)), ((uintptr)new @unsafe.Pointer(Ꮡlrsalen)), ((uintptr)((@unsafe.Pointer)rrsa)), ((uintptr)new @unsafe.Pointer(Ꮡrrsalen)), 0);
    return;
}

public static error /*err*/ TransmitFile(ΔHandle s, ΔHandle handle, uint32 bytesToWrite, uint32 bytsPerSend, ж<Overlapped> Ꮡoverlapped, ж<TransmitFileBuffers> ᏑtransmitFileBuf, uint32 flags) {
    error err = default!;

    ref var overlapped = ref Ꮡoverlapped.val;
    ref var transmitFileBuf = ref ᏑtransmitFileBuf.val;
    var (r1, _, e1) = Syscall9(procTransmitFile.Addr(), 7, ((uintptr)s), ((uintptr)handle), ((uintptr)bytesToWrite), ((uintptr)bytsPerSend), ((uintptr)new @unsafe.Pointer(Ꮡoverlapped)), ((uintptr)new @unsafe.Pointer(ᏑtransmitFileBuf)), ((uintptr)flags), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*neterr*/ NetApiBufferFree(ж<byte> Ꮡbuf) {
    error neterr = default!;

    ref var buf = ref Ꮡbuf.val;
    var (r0, _, _) = Syscall(procNetApiBufferFree.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡbuf)), 0, 0);
    if (r0 != 0) {
        neterr = ((Errno)r0);
    }
    return neterr;
}

public static error /*neterr*/ NetGetJoinInformation(ж<uint16> Ꮡserver, ж<ж<uint16>> Ꮡname, ж<uint32> ᏑbufType) {
    error neterr = default!;

    ref var server = ref Ꮡserver.val;
    ref var name = ref Ꮡname.val;
    ref var bufType = ref ᏑbufType.val;
    var (r0, _, _) = Syscall(procNetGetJoinInformation.Addr(), 3, ((uintptr)new @unsafe.Pointer(Ꮡserver)), ((uintptr)((@unsafe.Pointer)name)), ((uintptr)new @unsafe.Pointer(ᏑbufType)));
    if (r0 != 0) {
        neterr = ((Errno)r0);
    }
    return neterr;
}

public static error /*neterr*/ NetUserGetInfo(ж<uint16> ᏑserverName, ж<uint16> ᏑuserName, uint32 level, ж<ж<byte>> Ꮡbuf) {
    error neterr = default!;

    ref var serverName = ref ᏑserverName.val;
    ref var userName = ref ᏑuserName.val;
    ref var buf = ref Ꮡbuf.val;
    var (r0, _, _) = Syscall6(procNetUserGetInfo.Addr(), 4, ((uintptr)new @unsafe.Pointer(ᏑserverName)), ((uintptr)new @unsafe.Pointer(ᏑuserName)), ((uintptr)level), ((uintptr)((@unsafe.Pointer)buf)), 0, 0);
    if (r0 != 0) {
        neterr = ((Errno)r0);
    }
    return neterr;
}

public static error /*err*/ GetUserNameEx(uint32 nameFormat, ж<uint16> ᏑnameBuffre, ж<uint32> ᏑnSize) {
    error err = default!;

    ref var nameBuffre = ref ᏑnameBuffre.val;
    ref var nSize = ref ᏑnSize.val;
    var (r1, _, e1) = Syscall(procGetUserNameExW.Addr(), 3, ((uintptr)nameFormat), ((uintptr)new @unsafe.Pointer(ᏑnameBuffre)), ((uintptr)new @unsafe.Pointer(ᏑnSize)));
    if ((uintptr)(r1 & 255) == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ TranslateName(ж<uint16> ᏑaccName, uint32 accNameFormat, uint32 desiredNameFormat, ж<uint16> ᏑtranslatedName, ж<uint32> ᏑnSize) {
    error err = default!;

    ref var accName = ref ᏑaccName.val;
    ref var translatedName = ref ᏑtranslatedName.val;
    ref var nSize = ref ᏑnSize.val;
    var (r1, _, e1) = Syscall6(procTranslateNameW.Addr(), 5, ((uintptr)new @unsafe.Pointer(ᏑaccName)), ((uintptr)accNameFormat), ((uintptr)desiredNameFormat), ((uintptr)new @unsafe.Pointer(ᏑtranslatedName)), ((uintptr)new @unsafe.Pointer(ᏑnSize)), 0);
    if ((uintptr)(r1 & 255) == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (ж<array<ж<array<uint16>>>> argv, error err) CommandLineToArgv(ж<uint16> Ꮡcmd, ж<int32> Ꮡargc) {
    ж<array<ж<array<uint16>>>> argv = default!;
    error err = default!;

    ref var cmd = ref Ꮡcmd.val;
    ref var argc = ref Ꮡargc.val;
    var (r0, _, e1) = Syscall(procCommandLineToArgvW.Addr(), 2, ((uintptr)new @unsafe.Pointer(Ꮡcmd)), ((uintptr)new @unsafe.Pointer(Ꮡargc)), 0);
    argv = (ж<array<ж<array<uint16>>>>)(uintptr)(((@unsafe.Pointer)r0));
    if (argv == nil) {
        err = errnoErr(e1);
    }
    return (argv, err);
}

public static error /*err*/ GetUserProfileDirectory(Token t, ж<uint16> Ꮡdir, ж<uint32> ᏑdirLen) {
    error err = default!;

    ref var dir = ref Ꮡdir.val;
    ref var dirLen = ref ᏑdirLen.val;
    var (r1, _, e1) = Syscall(procGetUserProfileDirectoryW.Addr(), 3, ((uintptr)t), ((uintptr)new @unsafe.Pointer(Ꮡdir)), ((uintptr)new @unsafe.Pointer(ᏑdirLen)));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static void FreeAddrInfoW(ж<AddrinfoW> Ꮡaddrinfo) {
    ref var addrinfo = ref Ꮡaddrinfo.val;

    Syscall(procFreeAddrInfoW.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡaddrinfo)), 0, 0);
    return;
}

public static error /*sockerr*/ GetAddrInfoW(ж<uint16> Ꮡnodename, ж<uint16> Ꮡservicename, ж<AddrinfoW> Ꮡhints, ж<ж<AddrinfoW>> Ꮡresult) {
    error sockerr = default!;

    ref var nodename = ref Ꮡnodename.val;
    ref var servicename = ref Ꮡservicename.val;
    ref var hints = ref Ꮡhints.val;
    ref var result = ref Ꮡresult.val;
    var (r0, _, _) = Syscall6(procGetAddrInfoW.Addr(), 4, ((uintptr)new @unsafe.Pointer(Ꮡnodename)), ((uintptr)new @unsafe.Pointer(Ꮡservicename)), ((uintptr)new @unsafe.Pointer(Ꮡhints)), ((uintptr)((@unsafe.Pointer)result)), 0, 0);
    if (r0 != 0) {
        sockerr = ((Errno)r0);
    }
    return sockerr;
}

public static error /*err*/ WSACleanup() {
    error err = default!;

    var (r1, _, e1) = Syscall(procWSACleanup.Addr(), 0, 0, 0, 0);
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

public static (int32 n, error err) WSAEnumProtocols(ж<int32> Ꮡprotocols, ж<WSAProtocolInfo> ᏑprotocolBuffer, ж<uint32> ᏑbufferLength) {
    int32 n = default!;
    error err = default!;

    ref var protocols = ref Ꮡprotocols.val;
    ref var protocolBuffer = ref ᏑprotocolBuffer.val;
    ref var bufferLength = ref ᏑbufferLength.val;
    var (r0, _, e1) = Syscall(procWSAEnumProtocolsW.Addr(), 3, ((uintptr)new @unsafe.Pointer(Ꮡprotocols)), ((uintptr)new @unsafe.Pointer(ᏑprotocolBuffer)), ((uintptr)new @unsafe.Pointer(ᏑbufferLength)));
    n = ((int32)r0);
    if (n == -1) {
        err = errnoErr(e1);
    }
    return (n, err);
}

public static error /*err*/ WSAIoctl(ΔHandle s, uint32 iocc, ж<byte> Ꮡinbuf, uint32 cbif, ж<byte> Ꮡoutbuf, uint32 cbob, ж<uint32> Ꮡcbbr, ж<Overlapped> Ꮡoverlapped, uintptr completionRoutine) {
    error err = default!;

    ref var inbuf = ref Ꮡinbuf.val;
    ref var outbuf = ref Ꮡoutbuf.val;
    ref var cbbr = ref Ꮡcbbr.val;
    ref var overlapped = ref Ꮡoverlapped.val;
    var (r1, _, e1) = Syscall9(procWSAIoctl.Addr(), 9, ((uintptr)s), ((uintptr)iocc), ((uintptr)new @unsafe.Pointer(Ꮡinbuf)), ((uintptr)cbif), ((uintptr)new @unsafe.Pointer(Ꮡoutbuf)), ((uintptr)cbob), ((uintptr)new @unsafe.Pointer(Ꮡcbbr)), ((uintptr)new @unsafe.Pointer(Ꮡoverlapped)), ((uintptr)completionRoutine));
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ WSARecv(ΔHandle s, ж<WSABuf> Ꮡbufs, uint32 bufcnt, ж<uint32> Ꮡrecvd, ж<uint32> Ꮡflags, ж<Overlapped> Ꮡoverlapped, ж<byte> Ꮡcroutine) {
    error err = default!;

    ref var bufs = ref Ꮡbufs.val;
    ref var recvd = ref Ꮡrecvd.val;
    ref var flags = ref Ꮡflags.val;
    ref var overlapped = ref Ꮡoverlapped.val;
    ref var croutine = ref Ꮡcroutine.val;
    var (r1, _, e1) = Syscall9(procWSARecv.Addr(), 7, ((uintptr)s), ((uintptr)new @unsafe.Pointer(Ꮡbufs)), ((uintptr)bufcnt), ((uintptr)new @unsafe.Pointer(Ꮡrecvd)), ((uintptr)new @unsafe.Pointer(Ꮡflags)), ((uintptr)new @unsafe.Pointer(Ꮡoverlapped)), ((uintptr)new @unsafe.Pointer(Ꮡcroutine)), 0, 0);
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ WSARecvFrom(ΔHandle s, ж<WSABuf> Ꮡbufs, uint32 bufcnt, ж<uint32> Ꮡrecvd, ж<uint32> Ꮡflags, ж<RawSockaddrAny> Ꮡfrom, ж<int32> Ꮡfromlen, ж<Overlapped> Ꮡoverlapped, ж<byte> Ꮡcroutine) {
    error err = default!;

    ref var bufs = ref Ꮡbufs.val;
    ref var recvd = ref Ꮡrecvd.val;
    ref var flags = ref Ꮡflags.val;
    ref var from = ref Ꮡfrom.val;
    ref var fromlen = ref Ꮡfromlen.val;
    ref var overlapped = ref Ꮡoverlapped.val;
    ref var croutine = ref Ꮡcroutine.val;
    var (r1, _, e1) = Syscall9(procWSARecvFrom.Addr(), 9, ((uintptr)s), ((uintptr)new @unsafe.Pointer(Ꮡbufs)), ((uintptr)bufcnt), ((uintptr)new @unsafe.Pointer(Ꮡrecvd)), ((uintptr)new @unsafe.Pointer(Ꮡflags)), ((uintptr)new @unsafe.Pointer(Ꮡfrom)), ((uintptr)new @unsafe.Pointer(Ꮡfromlen)), ((uintptr)new @unsafe.Pointer(Ꮡoverlapped)), ((uintptr)new @unsafe.Pointer(Ꮡcroutine)));
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ WSASend(ΔHandle s, ж<WSABuf> Ꮡbufs, uint32 bufcnt, ж<uint32> Ꮡsent, uint32 flags, ж<Overlapped> Ꮡoverlapped, ж<byte> Ꮡcroutine) {
    error err = default!;

    ref var bufs = ref Ꮡbufs.val;
    ref var sent = ref Ꮡsent.val;
    ref var overlapped = ref Ꮡoverlapped.val;
    ref var croutine = ref Ꮡcroutine.val;
    var (r1, _, e1) = Syscall9(procWSASend.Addr(), 7, ((uintptr)s), ((uintptr)new @unsafe.Pointer(Ꮡbufs)), ((uintptr)bufcnt), ((uintptr)new @unsafe.Pointer(Ꮡsent)), ((uintptr)flags), ((uintptr)new @unsafe.Pointer(Ꮡoverlapped)), ((uintptr)new @unsafe.Pointer(Ꮡcroutine)), 0, 0);
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ WSASendTo(ΔHandle s, ж<WSABuf> Ꮡbufs, uint32 bufcnt, ж<uint32> Ꮡsent, uint32 flags, ж<RawSockaddrAny> Ꮡto, int32 tolen, ж<Overlapped> Ꮡoverlapped, ж<byte> Ꮡcroutine) {
    error err = default!;

    ref var bufs = ref Ꮡbufs.val;
    ref var sent = ref Ꮡsent.val;
    ref var to = ref Ꮡto.val;
    ref var overlapped = ref Ꮡoverlapped.val;
    ref var croutine = ref Ꮡcroutine.val;
    var (r1, _, e1) = Syscall9(procWSASendTo.Addr(), 9, ((uintptr)s), ((uintptr)new @unsafe.Pointer(Ꮡbufs)), ((uintptr)bufcnt), ((uintptr)new @unsafe.Pointer(Ꮡsent)), ((uintptr)flags), ((uintptr)new @unsafe.Pointer(Ꮡto)), ((uintptr)tolen), ((uintptr)new @unsafe.Pointer(Ꮡoverlapped)), ((uintptr)new @unsafe.Pointer(Ꮡcroutine)));
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*sockerr*/ WSAStartup(uint32 verreq, ж<WSAData> Ꮡdata) {
    error sockerr = default!;

    ref var data = ref Ꮡdata.val;
    var (r0, _, _) = Syscall(procWSAStartup.Addr(), 2, ((uintptr)verreq), ((uintptr)new @unsafe.Pointer(Ꮡdata)), 0);
    if (r0 != 0) {
        sockerr = ((Errno)r0);
    }
    return sockerr;
}

internal static error /*err*/ bind(ΔHandle s, @unsafe.Pointer name, int32 namelen) {
    error err = default!;

    var (r1, _, e1) = Syscall(procbind.Addr(), 3, ((uintptr)s), ((uintptr)name), ((uintptr)namelen));
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ Closesocket(ΔHandle s) {
    error err = default!;

    var (r1, _, e1) = Syscall(procclosesocket.Addr(), 1, ((uintptr)s), 0, 0);
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

internal static error /*err*/ connect(ΔHandle s, @unsafe.Pointer name, int32 namelen) {
    error err = default!;

    var (r1, _, e1) = Syscall(procconnect.Addr(), 3, ((uintptr)s), ((uintptr)name), ((uintptr)namelen));
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

public static (ж<Hostent> h, error err) GetHostByName(@string name) {
    ж<Hostent> h = default!;
    error err = default!;

    ж<byte> _p0 = default!;
    (_p0, err) = BytePtrFromString(name);
    if (err != default!) {
        return (h, err);
    }
    return _GetHostByName(_p0);
}

internal static (ж<Hostent> h, error err) _GetHostByName(ж<byte> Ꮡname) {
    ж<Hostent> h = default!;
    error err = default!;

    ref var name = ref Ꮡname.val;
    var (r0, _, e1) = Syscall(procgethostbyname.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡname)), 0, 0);
    h = (ж<Hostent>)(uintptr)(((@unsafe.Pointer)r0));
    if (h == nil) {
        err = errnoErr(e1);
    }
    return (h, err);
}

internal static error /*err*/ getpeername(ΔHandle s, ж<RawSockaddrAny> Ꮡrsa, ж<int32> Ꮡaddrlen) {
    error err = default!;

    ref var rsa = ref Ꮡrsa.val;
    ref var addrlen = ref Ꮡaddrlen.val;
    var (r1, _, e1) = Syscall(procgetpeername.Addr(), 3, ((uintptr)s), ((uintptr)new @unsafe.Pointer(Ꮡrsa)), ((uintptr)new @unsafe.Pointer(Ꮡaddrlen)));
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

public static (ж<Protoent> p, error err) GetProtoByName(@string name) {
    ж<Protoent> p = default!;
    error err = default!;

    ж<byte> _p0 = default!;
    (_p0, err) = BytePtrFromString(name);
    if (err != default!) {
        return (p, err);
    }
    return _GetProtoByName(_p0);
}

internal static (ж<Protoent> p, error err) _GetProtoByName(ж<byte> Ꮡname) {
    ж<Protoent> p = default!;
    error err = default!;

    ref var name = ref Ꮡname.val;
    var (r0, _, e1) = Syscall(procgetprotobyname.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡname)), 0, 0);
    p = (ж<Protoent>)(uintptr)(((@unsafe.Pointer)r0));
    if (p == nil) {
        err = errnoErr(e1);
    }
    return (p, err);
}

public static (ж<Servent> s, error err) GetServByName(@string name, @string proto) {
    ж<Servent> s = default!;
    error err = default!;

    ж<byte> _p0 = default!;
    (_p0, err) = BytePtrFromString(name);
    if (err != default!) {
        return (s, err);
    }
    ж<byte> _p1 = default!;
    (_p1, err) = BytePtrFromString(proto);
    if (err != default!) {
        return (s, err);
    }
    return _GetServByName(_p0, _p1);
}

internal static (ж<Servent> s, error err) _GetServByName(ж<byte> Ꮡname, ж<byte> Ꮡproto) {
    ж<Servent> s = default!;
    error err = default!;

    ref var name = ref Ꮡname.val;
    ref var proto = ref Ꮡproto.val;
    var (r0, _, e1) = Syscall(procgetservbyname.Addr(), 2, ((uintptr)new @unsafe.Pointer(Ꮡname)), ((uintptr)new @unsafe.Pointer(Ꮡproto)), 0);
    s = (ж<Servent>)(uintptr)(((@unsafe.Pointer)r0));
    if (s == nil) {
        err = errnoErr(e1);
    }
    return (s, err);
}

internal static error /*err*/ getsockname(ΔHandle s, ж<RawSockaddrAny> Ꮡrsa, ж<int32> Ꮡaddrlen) {
    error err = default!;

    ref var rsa = ref Ꮡrsa.val;
    ref var addrlen = ref Ꮡaddrlen.val;
    var (r1, _, e1) = Syscall(procgetsockname.Addr(), 3, ((uintptr)s), ((uintptr)new @unsafe.Pointer(Ꮡrsa)), ((uintptr)new @unsafe.Pointer(Ꮡaddrlen)));
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ Getsockopt(ΔHandle s, int32 level, int32 optname, ж<byte> Ꮡoptval, ж<int32> Ꮡoptlen) {
    error err = default!;

    ref var optval = ref Ꮡoptval.val;
    ref var optlen = ref Ꮡoptlen.val;
    var (r1, _, e1) = Syscall6(procgetsockopt.Addr(), 5, ((uintptr)s), ((uintptr)level), ((uintptr)optname), ((uintptr)new @unsafe.Pointer(Ꮡoptval)), ((uintptr)new @unsafe.Pointer(Ꮡoptlen)), 0);
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

internal static error /*err*/ listen(ΔHandle s, int32 backlog) {
    error err = default!;

    var (r1, _, e1) = Syscall(proclisten.Addr(), 2, ((uintptr)s), ((uintptr)backlog), 0);
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

public static uint16 /*u*/ Ntohs(uint16 netshort) {
    uint16 u = default!;

    var (r0, _, _) = Syscall(procntohs.Addr(), 1, ((uintptr)netshort), 0, 0);
    u = ((uint16)r0);
    return u;
}

public static error /*err*/ Setsockopt(ΔHandle s, int32 level, int32 optname, ж<byte> Ꮡoptval, int32 optlen) {
    error err = default!;

    ref var optval = ref Ꮡoptval.val;
    var (r1, _, e1) = Syscall6(procsetsockopt.Addr(), 5, ((uintptr)s), ((uintptr)level), ((uintptr)optname), ((uintptr)new @unsafe.Pointer(Ꮡoptval)), ((uintptr)optlen), 0);
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

internal static error /*err*/ shutdown(ΔHandle s, int32 how) {
    error err = default!;

    var (r1, _, e1) = Syscall(procshutdown.Addr(), 2, ((uintptr)s), ((uintptr)how), 0);
    if (r1 == socket_error) {
        err = errnoErr(e1);
    }
    return err;
}

internal static (ΔHandle handle, error err) socket(int32 af, int32 typ, int32 protocol) {
    ΔHandle handle = default!;
    error err = default!;

    var (r0, _, e1) = Syscall(procsocket.Addr(), 3, ((uintptr)af), ((uintptr)typ), ((uintptr)protocol));
    handle = ((ΔHandle)r0);
    if (handle == InvalidHandle) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

} // end syscall_package
