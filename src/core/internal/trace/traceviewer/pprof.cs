// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// Serving of pprof-like profiles.
namespace go.@internal.trace;

using bufio = bufio_package;
using fmt = fmt_package;
using profile = @internal.profile_package;
using trace = @internal.trace_package;
using http = net.http_package;
using os = os_package;
using exec = os.exec_package;
using filepath = path.filepath_package;
using runtime = runtime_package;
using time = time_package;
using @internal;
using net;
using os;
using path;
using ꓸꓸꓸany = Span<any>;

partial class traceviewer_package {

public delegate (slice<ProfileRecord>, error) ProfileFunc(ж<http.Request> r);

// SVGProfileHandlerFunc serves pprof-like profile generated by prof as svg.
public static http.HandlerFunc SVGProfileHandlerFunc(ProfileFunc f) => func((defer, _) => {
    return (http.ResponseWriter w, ж<http.Request> r) => {
        if (r.FormValue("raw"u8) != ""u8) {
            w.Header().Set("Content-Type"u8, "application/octet-stream"u8);
            var failf = (@string s, params ꓸꓸꓸany argsʗp) => {
                w.Header().Set("Content-Type"u8, "text/plain; charset=utf-8"u8);
                w.Header().Set("X-Go-Pprof"u8, "1"u8);
                http.Error(w, fmt.Sprintf(s, args.ꓸꓸꓸ), http.StatusInternalServerError);
            };
            var records = f(r);
            var err = f(r);
            if (err != default!) {
                failf("failed to get records: %v"u8, err);
                return;
            }
            {
                var errΔ1 = BuildProfile(records).Write(w); if (errΔ1 != default!) {
                    failf("failed to write profile: %v"u8, errΔ1);
                    return;
                }
            }
            return;
        }
        (blockf, err) = os.CreateTemp(""u8, "block"u8);
        if (err != default!) {
            http.Error(w, fmt.Sprintf("failed to create temp file: %v"u8, err), http.StatusInternalServerError);
            return;
        }
        var blockfʗ1 = blockf;
        defer(() => {
            blockfʗ1.Close();
            os.Remove(blockfʗ1.Name());
        });
        var records = f(r);
        err = f(r);
        if (err != default!) {
            http.Error(w, fmt.Sprintf("failed to generate profile: %v"u8, err), http.StatusInternalServerError);
        }
        var blockb = bufio.NewWriter(~blockf);
        {
            var errΔ1 = BuildProfile(records).Write(~blockb); if (errΔ1 != default!) {
                http.Error(w, fmt.Sprintf("failed to write profile: %v"u8, errΔ1), http.StatusInternalServerError);
                return;
            }
        }
        {
            var errΔ2 = blockb.Flush(); if (errΔ2 != default!) {
                http.Error(w, fmt.Sprintf("failed to flush temp file: %v"u8, errΔ2), http.StatusInternalServerError);
                return;
            }
        }
        {
            var errΔ3 = blockf.Close(); if (errΔ3 != default!) {
                http.Error(w, fmt.Sprintf("failed to close temp file: %v"u8, errΔ3), http.StatusInternalServerError);
                return;
            }
        }
        @string svgFilename = blockf.Name() + ".svg"u8;
        {
            (output, errΔ4) = exec.Command(goCmd(), "tool"u8, "pprof", "-svg", "-output", svgFilename, blockf.Name()).CombinedOutput(); if (errΔ4 != default!) {
                http.Error(w, fmt.Sprintf("failed to execute go tool pprof: %v\n%s"u8, errΔ4, output), http.StatusInternalServerError);
                return;
            }
        }
        deferǃ(os.Remove, svgFilename, defer);
        w.Header().Set("Content-Type"u8, "image/svg+xml"u8);
        http.ServeFile(w, r, svgFilename);
    };
});

[GoType] partial struct ProfileRecord {
    public trace.Frame Stack;
    public uint64 Count;
    public time_package.Duration Time;
}

public static ж<profile.Profile> BuildProfile(slice<ProfileRecord> prof) {
    var p = Ꮡ(new profile.Profile(
        PeriodType: Ꮡ(new profile.ValueType(Type: "trace"u8, Unit: "count"u8)),
        Period: 1,
        SampleType: new profile.ValueType[]{
            new(Type: "contentions"u8, Unit: "count"u8),
            new(Type: "delay"u8, Unit: "nanoseconds"u8)
        }.slice()
    ));
    var locs = new profile.Location();
    var funcs = new profile.Function();
    ref var rec = ref heap(new ProfileRecord(), out var Ꮡrec);

    foreach (var (_, rec) in prof) {
        slice<profile.Location> sloc = default!;
        foreach (var (_, frame) in rec.Stack) {
            var loc = locs[(~frame).PC];
            if (loc == nil) {
                var fn = funcs[(~frame).File + (~frame).Fn];
                if (fn == nil) {
                    fn = Ꮡ(new profile.Function(
                        ID: ((uint64)(len((~p).Function) + 1)),
                        Name: (~frame).Fn,
                        SystemName: (~frame).Fn,
                        Filename: (~frame).File
                    ));
                    p.val.Function = append((~p).Function, fn);
                    funcs[(~frame).File + (~frame).Fn] = fn;
                }
                loc = Ꮡ(new profile.Location(
                    ID: ((uint64)(len((~p).Location) + 1)),
                    Address: (~frame).PC,
                    Line: new profile.Line[]{
                        new(
                            Function: fn,
                            Line: ((int64)(~frame).Line)
                        )
                    }.slice()
                ));
                p.val.Location = append((~p).Location, loc);
                locs[(~frame).PC] = loc;
            }
            sloc = append(sloc, loc);
        }
        p.val.Sample = append((~p).Sample, Ꮡ(new profile.Sample(
            Value: new int64[]{((int64)rec.Count), ((int64)rec.Time)}.slice(),
            Location: sloc
        )));
    }
    return p;
}

internal static @string goCmd() {
    @string exeSuffix = default!;
    if (runtime.GOOS == "windows"u8) {
        exeSuffix = ".exe"u8;
    }
    @string path = filepath.Join(runtime.GOROOT(), "bin", "go"u8 + exeSuffix);
    {
        (_, err) = os.Stat(path); if (err == default!) {
            return path;
        }
    }
    return "go"u8;
}

} // end traceviewer_package
