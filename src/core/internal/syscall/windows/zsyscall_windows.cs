// Code generated by 'go generate'; DO NOT EDIT.
namespace go.@internal.syscall;

using sysdll = @internal.syscall.windows.sysdll_package;
using syscall = syscall_package;
using @unsafe = unsafe_package;
using @internal.syscall.windows;

partial class windows_package {

internal static @unsafe.Pointer _;

// Do the interface allocations only once for common
// Errno values.
internal static readonly UntypedInt errnoERROR_IO_PENDING = 997;

internal static syscall.Errno errERROR_IO_PENDING = ((syscall.Errno)errnoERROR_IO_PENDING);
internal static syscall.Errno errERROR_EINVAL = syscall.EINVAL;

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
internal static error errnoErr(syscall.Errno e) {
    var exprᴛ1 = e;
    if (exprᴛ1 == 0) {
        return errERROR_EINVAL;
    }
    if (exprᴛ1 == errnoERROR_IO_PENDING) {
        return errERROR_IO_PENDING;
    }

    // TODO: add more here, after collecting data on the common
    // error values see on Windows. (perhaps when running
    // all.bat?)
    return e;
}

internal static ж<syscall.LazyDLL> modadvapi32 = syscall.NewLazyDLL(sysdll.Add("advapi32.dll"u8));
internal static ж<syscall.LazyDLL> modbcryptprimitives = syscall.NewLazyDLL(sysdll.Add("bcryptprimitives.dll"u8));
internal static ж<syscall.LazyDLL> modiphlpapi = syscall.NewLazyDLL(sysdll.Add("iphlpapi.dll"u8));
internal static ж<syscall.LazyDLL> modkernel32 = syscall.NewLazyDLL(sysdll.Add("kernel32.dll"u8));
internal static ж<syscall.LazyDLL> modnetapi32 = syscall.NewLazyDLL(sysdll.Add("netapi32.dll"u8));
internal static ж<syscall.LazyDLL> modntdll = syscall.NewLazyDLL(sysdll.Add("ntdll.dll"u8));
internal static ж<syscall.LazyDLL> modpsapi = syscall.NewLazyDLL(sysdll.Add("psapi.dll"u8));
internal static ж<syscall.LazyDLL> moduserenv = syscall.NewLazyDLL(sysdll.Add("userenv.dll"u8));
internal static ж<syscall.LazyDLL> modws2_32 = syscall.NewLazyDLL(sysdll.Add("ws2_32.dll"u8));
internal static ж<syscall.LazyProc> procAdjustTokenPrivileges = modadvapi32.NewProc("AdjustTokenPrivileges"u8);
internal static ж<syscall.LazyProc> procDuplicateTokenEx = modadvapi32.NewProc("DuplicateTokenEx"u8);
internal static ж<syscall.LazyProc> procImpersonateSelf = modadvapi32.NewProc("ImpersonateSelf"u8);
internal static ж<syscall.LazyProc> procLookupPrivilegeValueW = modadvapi32.NewProc("LookupPrivilegeValueW"u8);
internal static ж<syscall.LazyProc> procOpenSCManagerW = modadvapi32.NewProc("OpenSCManagerW"u8);
internal static ж<syscall.LazyProc> procOpenServiceW = modadvapi32.NewProc("OpenServiceW"u8);
internal static ж<syscall.LazyProc> procOpenThreadToken = modadvapi32.NewProc("OpenThreadToken"u8);
internal static ж<syscall.LazyProc> procQueryServiceStatus = modadvapi32.NewProc("QueryServiceStatus"u8);
internal static ж<syscall.LazyProc> procRevertToSelf = modadvapi32.NewProc("RevertToSelf"u8);
internal static ж<syscall.LazyProc> procSetTokenInformation = modadvapi32.NewProc("SetTokenInformation"u8);
internal static ж<syscall.LazyProc> procProcessPrng = modbcryptprimitives.NewProc("ProcessPrng"u8);
internal static ж<syscall.LazyProc> procGetAdaptersAddresses = modiphlpapi.NewProc("GetAdaptersAddresses"u8);
internal static ж<syscall.LazyProc> procCreateEventW = modkernel32.NewProc("CreateEventW"u8);
internal static ж<syscall.LazyProc> procGetACP = modkernel32.NewProc("GetACP"u8);
internal static ж<syscall.LazyProc> procGetComputerNameExW = modkernel32.NewProc("GetComputerNameExW"u8);
internal static ж<syscall.LazyProc> procGetConsoleCP = modkernel32.NewProc("GetConsoleCP"u8);
internal static ж<syscall.LazyProc> procGetCurrentThread = modkernel32.NewProc("GetCurrentThread"u8);
internal static ж<syscall.LazyProc> procGetFileInformationByHandleEx = modkernel32.NewProc("GetFileInformationByHandleEx"u8);
internal static ж<syscall.LazyProc> procGetFinalPathNameByHandleW = modkernel32.NewProc("GetFinalPathNameByHandleW"u8);
internal static ж<syscall.LazyProc> procGetModuleFileNameW = modkernel32.NewProc("GetModuleFileNameW"u8);
internal static ж<syscall.LazyProc> procGetTempPath2W = modkernel32.NewProc("GetTempPath2W"u8);
internal static ж<syscall.LazyProc> procGetVolumeInformationByHandleW = modkernel32.NewProc("GetVolumeInformationByHandleW"u8);
internal static ж<syscall.LazyProc> procGetVolumeNameForVolumeMountPointW = modkernel32.NewProc("GetVolumeNameForVolumeMountPointW"u8);
internal static ж<syscall.LazyProc> procLockFileEx = modkernel32.NewProc("LockFileEx"u8);
internal static ж<syscall.LazyProc> procModule32FirstW = modkernel32.NewProc("Module32FirstW"u8);
internal static ж<syscall.LazyProc> procModule32NextW = modkernel32.NewProc("Module32NextW"u8);
internal static ж<syscall.LazyProc> procMoveFileExW = modkernel32.NewProc("MoveFileExW"u8);
internal static ж<syscall.LazyProc> procMultiByteToWideChar = modkernel32.NewProc("MultiByteToWideChar"u8);
internal static ж<syscall.LazyProc> procRtlLookupFunctionEntry = modkernel32.NewProc("RtlLookupFunctionEntry"u8);
internal static ж<syscall.LazyProc> procRtlVirtualUnwind = modkernel32.NewProc("RtlVirtualUnwind"u8);
internal static ж<syscall.LazyProc> procSetFileInformationByHandle = modkernel32.NewProc("SetFileInformationByHandle"u8);
internal static ж<syscall.LazyProc> procUnlockFileEx = modkernel32.NewProc("UnlockFileEx"u8);
internal static ж<syscall.LazyProc> procVirtualQuery = modkernel32.NewProc("VirtualQuery"u8);
internal static ж<syscall.LazyProc> procNetShareAdd = modnetapi32.NewProc("NetShareAdd"u8);
internal static ж<syscall.LazyProc> procNetShareDel = modnetapi32.NewProc("NetShareDel"u8);
internal static ж<syscall.LazyProc> procNetUserGetLocalGroups = modnetapi32.NewProc("NetUserGetLocalGroups"u8);
internal static ж<syscall.LazyProc> procRtlGetVersion = modntdll.NewProc("RtlGetVersion"u8);
internal static ж<syscall.LazyProc> procGetProcessMemoryInfo = modpsapi.NewProc("GetProcessMemoryInfo"u8);
internal static ж<syscall.LazyProc> procCreateEnvironmentBlock = moduserenv.NewProc("CreateEnvironmentBlock"u8);
internal static ж<syscall.LazyProc> procDestroyEnvironmentBlock = moduserenv.NewProc("DestroyEnvironmentBlock"u8);
internal static ж<syscall.LazyProc> procGetProfilesDirectoryW = moduserenv.NewProc("GetProfilesDirectoryW"u8);
internal static ж<syscall.LazyProc> procWSAGetOverlappedResult = modws2_32.NewProc("WSAGetOverlappedResult"u8);
internal static ж<syscall.LazyProc> procWSASocketW = modws2_32.NewProc("WSASocketW"u8);

internal static (uint32 ret, error err) adjustTokenPrivileges(syscall.Token token, bool disableAllPrivileges, ж<TOKEN_PRIVILEGES> Ꮡnewstate, uint32 buflen, ж<TOKEN_PRIVILEGES> Ꮡprevstate, ж<uint32> Ꮡreturnlen) {
    uint32 ret = default!;
    error err = default!;

    ref var newstate = ref Ꮡnewstate.val;
    ref var prevstate = ref Ꮡprevstate.val;
    ref var returnlen = ref Ꮡreturnlen.val;
    uint32 _p0 = default!;
    if (disableAllPrivileges) {
        _p0 = 1;
    }
    var (r0, _, e1) = syscall.Syscall6(procAdjustTokenPrivileges.Addr(), 6, ((uintptr)token), ((uintptr)_p0), ((uintptr)new @unsafe.Pointer(Ꮡnewstate)), ((uintptr)buflen), ((uintptr)new @unsafe.Pointer(Ꮡprevstate)), ((uintptr)new @unsafe.Pointer(Ꮡreturnlen)));
    ret = ((uint32)r0);
    if (true) {
        err = errnoErr(e1);
    }
    return (ret, err);
}

public static error /*err*/ DuplicateTokenEx(syscall.Token hExistingToken, uint32 dwDesiredAccess, ж<syscall.SecurityAttributes> ᏑlpTokenAttributes, uint32 impersonationLevel, TokenType tokenType, ж<syscall.Token> ᏑphNewToken) {
    error err = default!;

    ref var lpTokenAttributes = ref ᏑlpTokenAttributes.val;
    ref var phNewToken = ref ᏑphNewToken.val;
    var (r1, _, e1) = syscall.Syscall6(procDuplicateTokenEx.Addr(), 6, ((uintptr)hExistingToken), ((uintptr)dwDesiredAccess), ((uintptr)new @unsafe.Pointer(ᏑlpTokenAttributes)), ((uintptr)impersonationLevel), ((uintptr)tokenType), ((uintptr)((@unsafe.Pointer)phNewToken)));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ ImpersonateSelf(uint32 impersonationlevel) {
    error err = default!;

    var (r1, _, e1) = syscall.Syscall(procImpersonateSelf.Addr(), 1, ((uintptr)impersonationlevel), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ LookupPrivilegeValue(ж<uint16> Ꮡsystemname, ж<uint16> Ꮡname, ж<LUID> Ꮡluid) {
    error err = default!;

    ref var systemname = ref Ꮡsystemname.val;
    ref var name = ref Ꮡname.val;
    ref var luid = ref Ꮡluid.val;
    var (r1, _, e1) = syscall.Syscall(procLookupPrivilegeValueW.Addr(), 3, ((uintptr)new @unsafe.Pointer(Ꮡsystemname)), ((uintptr)new @unsafe.Pointer(Ꮡname)), ((uintptr)new @unsafe.Pointer(Ꮡluid)));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (syscallꓸHandle handle, error err) OpenSCManager(ж<uint16> ᏑmachineName, ж<uint16> ᏑdatabaseName, uint32 access) {
    syscallꓸHandle handle = default!;
    error err = default!;

    ref var machineName = ref ᏑmachineName.val;
    ref var databaseName = ref ᏑdatabaseName.val;
    var (r0, _, e1) = syscall.Syscall(procOpenSCManagerW.Addr(), 3, ((uintptr)new @unsafe.Pointer(ᏑmachineName)), ((uintptr)new @unsafe.Pointer(ᏑdatabaseName)), ((uintptr)access));
    handle = ((syscallꓸHandle)r0);
    if (handle == 0) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

public static (syscallꓸHandle handle, error err) OpenService(syscallꓸHandle mgr, ж<uint16> ᏑserviceName, uint32 access) {
    syscallꓸHandle handle = default!;
    error err = default!;

    ref var serviceName = ref ᏑserviceName.val;
    var (r0, _, e1) = syscall.Syscall(procOpenServiceW.Addr(), 3, ((uintptr)mgr), ((uintptr)new @unsafe.Pointer(ᏑserviceName)), ((uintptr)access));
    handle = ((syscallꓸHandle)r0);
    if (handle == 0) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

public static error /*err*/ OpenThreadToken(syscallꓸHandle h, uint32 access, bool openasself, ж<syscall.Token> Ꮡtoken) {
    error err = default!;

    ref var token = ref Ꮡtoken.val;
    uint32 _p0 = default!;
    if (openasself) {
        _p0 = 1;
    }
    var (r1, _, e1) = syscall.Syscall6(procOpenThreadToken.Addr(), 4, ((uintptr)h), ((uintptr)access), ((uintptr)_p0), ((uintptr)((@unsafe.Pointer)token)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ QueryServiceStatus(syscallꓸHandle hService, ж<SERVICE_STATUS> ᏑlpServiceStatus) {
    error err = default!;

    ref var lpServiceStatus = ref ᏑlpServiceStatus.val;
    var (r1, _, e1) = syscall.Syscall(procQueryServiceStatus.Addr(), 2, ((uintptr)hService), ((uintptr)new @unsafe.Pointer(ᏑlpServiceStatus)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ RevertToSelf() {
    error err = default!;

    var (r1, _, e1) = syscall.Syscall(procRevertToSelf.Addr(), 0, 0, 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ SetTokenInformation(syscall.Token tokenHandle, uint32 tokenInformationClass, uintptr tokenInformation, uint32 tokenInformationLength) {
    error err = default!;

    var (r1, _, e1) = syscall.Syscall6(procSetTokenInformation.Addr(), 4, ((uintptr)tokenHandle), ((uintptr)tokenInformationClass), ((uintptr)tokenInformation), ((uintptr)tokenInformationLength), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ ProcessPrng(slice<byte> buf) {
    error err = default!;

    ж<byte> _p0 = default!;
    if (len(buf) > 0) {
        _p0 = Ꮡ(buf, 0);
    }
    var (r1, _, e1) = syscall.Syscall(procProcessPrng.Addr(), 2, ((uintptr)new @unsafe.Pointer(_p0)), ((uintptr)len(buf)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*errcode*/ GetAdaptersAddresses(uint32 family, uint32 flags, uintptr reserved, ж<IpAdapterAddresses> ᏑadapterAddresses, ж<uint32> ᏑsizePointer) {
    error errcode = default!;

    ref var adapterAddresses = ref ᏑadapterAddresses.val;
    ref var sizePointer = ref ᏑsizePointer.val;
    var (r0, _, _) = syscall.Syscall6(procGetAdaptersAddresses.Addr(), 5, ((uintptr)family), ((uintptr)flags), ((uintptr)reserved), ((uintptr)new @unsafe.Pointer(ᏑadapterAddresses)), ((uintptr)new @unsafe.Pointer(ᏑsizePointer)), 0);
    if (r0 != 0) {
        errcode = ((syscall.Errno)r0);
    }
    return errcode;
}

public static (syscallꓸHandle handle, error err) CreateEvent(ж<SecurityAttributes> ᏑeventAttrs, uint32 manualReset, uint32 initialState, ж<uint16> Ꮡname) {
    syscallꓸHandle handle = default!;
    error err = default!;

    ref var eventAttrs = ref ᏑeventAttrs.val;
    ref var name = ref Ꮡname.val;
    var (r0, _, e1) = syscall.Syscall6(procCreateEventW.Addr(), 4, ((uintptr)new @unsafe.Pointer(ᏑeventAttrs)), ((uintptr)manualReset), ((uintptr)initialState), ((uintptr)new @unsafe.Pointer(Ꮡname)), 0, 0);
    handle = ((syscallꓸHandle)r0);
    if (handle == 0) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

public static uint32 /*acp*/ GetACP() {
    uint32 acp = default!;

    var (r0, _, _) = syscall.Syscall(procGetACP.Addr(), 0, 0, 0, 0);
    acp = ((uint32)r0);
    return acp;
}

public static error /*err*/ GetComputerNameEx(uint32 nameformat, ж<uint16> Ꮡbuf, ж<uint32> Ꮡn) {
    error err = default!;

    ref var buf = ref Ꮡbuf.val;
    ref var n = ref Ꮡn.val;
    var (r1, _, e1) = syscall.Syscall(procGetComputerNameExW.Addr(), 3, ((uintptr)nameformat), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), ((uintptr)new @unsafe.Pointer(Ꮡn)));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static uint32 /*ccp*/ GetConsoleCP() {
    uint32 ccp = default!;

    var (r0, _, _) = syscall.Syscall(procGetConsoleCP.Addr(), 0, 0, 0, 0);
    ccp = ((uint32)r0);
    return ccp;
}

public static (syscallꓸHandle pseudoHandle, error err) GetCurrentThread() {
    syscallꓸHandle pseudoHandle = default!;
    error err = default!;

    var (r0, _, e1) = syscall.Syscall(procGetCurrentThread.Addr(), 0, 0, 0, 0);
    pseudoHandle = ((syscallꓸHandle)r0);
    if (pseudoHandle == 0) {
        err = errnoErr(e1);
    }
    return (pseudoHandle, err);
}

public static error /*err*/ GetFileInformationByHandleEx(syscallꓸHandle handle, uint32 @class, ж<byte> Ꮡinfo, uint32 bufsize) {
    error err = default!;

    ref var info = ref Ꮡinfo.val;
    var (r1, _, e1) = syscall.Syscall6(procGetFileInformationByHandleEx.Addr(), 4, ((uintptr)handle), ((uintptr)@class), ((uintptr)new @unsafe.Pointer(Ꮡinfo)), ((uintptr)bufsize), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (uint32 n, error err) GetFinalPathNameByHandle(syscallꓸHandle file, ж<uint16> ᏑfilePath, uint32 filePathSize, uint32 flags) {
    uint32 n = default!;
    error err = default!;

    ref var filePath = ref ᏑfilePath.val;
    var (r0, _, e1) = syscall.Syscall6(procGetFinalPathNameByHandleW.Addr(), 4, ((uintptr)file), ((uintptr)new @unsafe.Pointer(ᏑfilePath)), ((uintptr)filePathSize), ((uintptr)flags), 0, 0);
    n = ((uint32)r0);
    if (n == 0) {
        err = errnoErr(e1);
    }
    return (n, err);
}

public static (uint32 n, error err) GetModuleFileName(syscallꓸHandle module, ж<uint16> Ꮡfn, uint32 len) {
    uint32 n = default!;
    error err = default!;

    ref var fn = ref Ꮡfn.val;
    var (r0, _, e1) = syscall.Syscall(procGetModuleFileNameW.Addr(), 3, ((uintptr)module), ((uintptr)new @unsafe.Pointer(Ꮡfn)), ((uintptr)len));
    n = ((uint32)r0);
    if (n == 0) {
        err = errnoErr(e1);
    }
    return (n, err);
}

public static (uint32 n, error err) GetTempPath2(uint32 buflen, ж<uint16> Ꮡbuf) {
    uint32 n = default!;
    error err = default!;

    ref var buf = ref Ꮡbuf.val;
    var (r0, _, e1) = syscall.Syscall(procGetTempPath2W.Addr(), 2, ((uintptr)buflen), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), 0);
    n = ((uint32)r0);
    if (n == 0) {
        err = errnoErr(e1);
    }
    return (n, err);
}

public static error /*err*/ GetVolumeInformationByHandle(syscallꓸHandle file, ж<uint16> ᏑvolumeNameBuffer, uint32 volumeNameSize, ж<uint32> ᏑvolumeNameSerialNumber, ж<uint32> ᏑmaximumComponentLength, ж<uint32> ᏑfileSystemFlags, ж<uint16> ᏑfileSystemNameBuffer, uint32 fileSystemNameSize) {
    error err = default!;

    ref var volumeNameBuffer = ref ᏑvolumeNameBuffer.val;
    ref var volumeNameSerialNumber = ref ᏑvolumeNameSerialNumber.val;
    ref var maximumComponentLength = ref ᏑmaximumComponentLength.val;
    ref var fileSystemFlags = ref ᏑfileSystemFlags.val;
    ref var fileSystemNameBuffer = ref ᏑfileSystemNameBuffer.val;
    var (r1, _, e1) = syscall.Syscall9(procGetVolumeInformationByHandleW.Addr(), 8, ((uintptr)file), ((uintptr)new @unsafe.Pointer(ᏑvolumeNameBuffer)), ((uintptr)volumeNameSize), ((uintptr)new @unsafe.Pointer(ᏑvolumeNameSerialNumber)), ((uintptr)new @unsafe.Pointer(ᏑmaximumComponentLength)), ((uintptr)new @unsafe.Pointer(ᏑfileSystemFlags)), ((uintptr)new @unsafe.Pointer(ᏑfileSystemNameBuffer)), ((uintptr)fileSystemNameSize), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ GetVolumeNameForVolumeMountPoint(ж<uint16> ᏑvolumeMountPoint, ж<uint16> ᏑvolumeName, uint32 bufferlength) {
    error err = default!;

    ref var volumeMountPoint = ref ᏑvolumeMountPoint.val;
    ref var volumeName = ref ᏑvolumeName.val;
    var (r1, _, e1) = syscall.Syscall(procGetVolumeNameForVolumeMountPointW.Addr(), 3, ((uintptr)new @unsafe.Pointer(ᏑvolumeMountPoint)), ((uintptr)new @unsafe.Pointer(ᏑvolumeName)), ((uintptr)bufferlength));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ LockFileEx(syscallꓸHandle file, uint32 flags, uint32 reserved, uint32 bytesLow, uint32 bytesHigh, ж<syscall.Overlapped> Ꮡoverlapped) {
    error err = default!;

    ref var overlapped = ref Ꮡoverlapped.val;
    var (r1, _, e1) = syscall.Syscall6(procLockFileEx.Addr(), 6, ((uintptr)file), ((uintptr)flags), ((uintptr)reserved), ((uintptr)bytesLow), ((uintptr)bytesHigh), ((uintptr)new @unsafe.Pointer(Ꮡoverlapped)));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ Module32First(syscallꓸHandle snapshot, ж<ModuleEntry32> ᏑmoduleEntry) {
    error err = default!;

    ref var moduleEntry = ref ᏑmoduleEntry.val;
    var (r1, _, e1) = syscall.Syscall(procModule32FirstW.Addr(), 2, ((uintptr)snapshot), ((uintptr)new @unsafe.Pointer(ᏑmoduleEntry)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ Module32Next(syscallꓸHandle snapshot, ж<ModuleEntry32> ᏑmoduleEntry) {
    error err = default!;

    ref var moduleEntry = ref ᏑmoduleEntry.val;
    var (r1, _, e1) = syscall.Syscall(procModule32NextW.Addr(), 2, ((uintptr)snapshot), ((uintptr)new @unsafe.Pointer(ᏑmoduleEntry)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ MoveFileEx(ж<uint16> Ꮡfrom, ж<uint16> Ꮡto, uint32 flags) {
    error err = default!;

    ref var from = ref Ꮡfrom.val;
    ref var to = ref Ꮡto.val;
    var (r1, _, e1) = syscall.Syscall(procMoveFileExW.Addr(), 3, ((uintptr)new @unsafe.Pointer(Ꮡfrom)), ((uintptr)new @unsafe.Pointer(Ꮡto)), ((uintptr)flags));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (int32 nwrite, error err) MultiByteToWideChar(uint32 codePage, uint32 dwFlags, ж<byte> Ꮡstr, int32 nstr, ж<uint16> Ꮡwchar, int32 nwchar) {
    int32 nwrite = default!;
    error err = default!;

    ref var str = ref Ꮡstr.val;
    ref var wchar = ref Ꮡwchar.val;
    var (r0, _, e1) = syscall.Syscall6(procMultiByteToWideChar.Addr(), 6, ((uintptr)codePage), ((uintptr)dwFlags), ((uintptr)new @unsafe.Pointer(Ꮡstr)), ((uintptr)nstr), ((uintptr)new @unsafe.Pointer(Ꮡwchar)), ((uintptr)nwchar));
    nwrite = ((int32)r0);
    if (nwrite == 0) {
        err = errnoErr(e1);
    }
    return (nwrite, err);
}

public static uintptr /*ret*/ RtlLookupFunctionEntry(uintptr pc, ж<uintptr> ᏑbaseAddress, ж<byte> Ꮡtable) {
    uintptr ret = default!;

    ref var baseAddress = ref ᏑbaseAddress.val;
    ref var table = ref Ꮡtable.val;
    var (r0, _, _) = syscall.Syscall(procRtlLookupFunctionEntry.Addr(), 3, ((uintptr)pc), ((uintptr)((@unsafe.Pointer)baseAddress)), ((uintptr)new @unsafe.Pointer(Ꮡtable)));
    ret = ((uintptr)r0);
    return ret;
}

public static uintptr /*ret*/ RtlVirtualUnwind(uint32 handlerType, uintptr baseAddress, uintptr pc, uintptr entry, uintptr ctxt, ж<uintptr> Ꮡdata, ж<uintptr> Ꮡframe, ж<byte> Ꮡctxptrs) {
    uintptr ret = default!;

    ref var data = ref Ꮡdata.val;
    ref var frame = ref Ꮡframe.val;
    ref var ctxptrs = ref Ꮡctxptrs.val;
    var (r0, _, _) = syscall.Syscall9(procRtlVirtualUnwind.Addr(), 8, ((uintptr)handlerType), ((uintptr)baseAddress), ((uintptr)pc), ((uintptr)entry), ((uintptr)ctxt), ((uintptr)((@unsafe.Pointer)data)), ((uintptr)((@unsafe.Pointer)frame)), ((uintptr)new @unsafe.Pointer(Ꮡctxptrs)), 0);
    ret = ((uintptr)r0);
    return ret;
}

public static error /*err*/ SetFileInformationByHandle(syscallꓸHandle handle, uint32 fileInformationClass, @unsafe.Pointer buf, uint32 bufsize) {
    error err = default!;

    var (r1, _, e1) = syscall.Syscall6(procSetFileInformationByHandle.Addr(), 4, ((uintptr)handle), ((uintptr)fileInformationClass), ((uintptr)buf), ((uintptr)bufsize), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ UnlockFileEx(syscallꓸHandle file, uint32 reserved, uint32 bytesLow, uint32 bytesHigh, ж<syscall.Overlapped> Ꮡoverlapped) {
    error err = default!;

    ref var overlapped = ref Ꮡoverlapped.val;
    var (r1, _, e1) = syscall.Syscall6(procUnlockFileEx.Addr(), 5, ((uintptr)file), ((uintptr)reserved), ((uintptr)bytesLow), ((uintptr)bytesHigh), ((uintptr)new @unsafe.Pointer(Ꮡoverlapped)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ VirtualQuery(uintptr address, ж<MemoryBasicInformation> Ꮡbuffer, uintptr length) {
    error err = default!;

    ref var buffer = ref Ꮡbuffer.val;
    var (r1, _, e1) = syscall.Syscall(procVirtualQuery.Addr(), 3, ((uintptr)address), ((uintptr)new @unsafe.Pointer(Ꮡbuffer)), ((uintptr)length));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*neterr*/ NetShareAdd(ж<uint16> ᏑserverName, uint32 level, ж<byte> Ꮡbuf, ж<uint16> ᏑparmErr) {
    error neterr = default!;

    ref var serverName = ref ᏑserverName.val;
    ref var buf = ref Ꮡbuf.val;
    ref var parmErr = ref ᏑparmErr.val;
    var (r0, _, _) = syscall.Syscall6(procNetShareAdd.Addr(), 4, ((uintptr)new @unsafe.Pointer(ᏑserverName)), ((uintptr)level), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), ((uintptr)new @unsafe.Pointer(ᏑparmErr)), 0, 0);
    if (r0 != 0) {
        neterr = ((syscall.Errno)r0);
    }
    return neterr;
}

public static error /*neterr*/ NetShareDel(ж<uint16> ᏑserverName, ж<uint16> ᏑnetName, uint32 reserved) {
    error neterr = default!;

    ref var serverName = ref ᏑserverName.val;
    ref var netName = ref ᏑnetName.val;
    var (r0, _, _) = syscall.Syscall(procNetShareDel.Addr(), 3, ((uintptr)new @unsafe.Pointer(ᏑserverName)), ((uintptr)new @unsafe.Pointer(ᏑnetName)), ((uintptr)reserved));
    if (r0 != 0) {
        neterr = ((syscall.Errno)r0);
    }
    return neterr;
}

public static error /*neterr*/ NetUserGetLocalGroups(ж<uint16> ᏑserverName, ж<uint16> ᏑuserName, uint32 level, uint32 flags, ж<ж<byte>> Ꮡbuf, uint32 prefMaxLen, ж<uint32> ᏑentriesRead, ж<uint32> ᏑtotalEntries) {
    error neterr = default!;

    ref var serverName = ref ᏑserverName.val;
    ref var userName = ref ᏑuserName.val;
    ref var buf = ref Ꮡbuf.val;
    ref var entriesRead = ref ᏑentriesRead.val;
    ref var totalEntries = ref ᏑtotalEntries.val;
    var (r0, _, _) = syscall.Syscall9(procNetUserGetLocalGroups.Addr(), 8, ((uintptr)new @unsafe.Pointer(ᏑserverName)), ((uintptr)new @unsafe.Pointer(ᏑuserName)), ((uintptr)level), ((uintptr)flags), ((uintptr)((@unsafe.Pointer)buf)), ((uintptr)prefMaxLen), ((uintptr)new @unsafe.Pointer(ᏑentriesRead)), ((uintptr)new @unsafe.Pointer(ᏑtotalEntries)), 0);
    if (r0 != 0) {
        neterr = ((syscall.Errno)r0);
    }
    return neterr;
}

internal static void rtlGetVersion(ж<_OSVERSIONINFOW> Ꮡinfo) {
    ref var info = ref Ꮡinfo.val;

    syscall.Syscall(procRtlGetVersion.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡinfo)), 0, 0);
    return;
}

public static error /*err*/ GetProcessMemoryInfo(syscallꓸHandle handle, ж<PROCESS_MEMORY_COUNTERS> ᏑmemCounters, uint32 cb) {
    error err = default!;

    ref var memCounters = ref ᏑmemCounters.val;
    var (r1, _, e1) = syscall.Syscall(procGetProcessMemoryInfo.Addr(), 3, ((uintptr)handle), ((uintptr)new @unsafe.Pointer(ᏑmemCounters)), ((uintptr)cb));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ CreateEnvironmentBlock(ж<ж<uint16>> Ꮡblock, syscall.Token token, bool inheritExisting) {
    error err = default!;

    ref var block = ref Ꮡblock.val;
    uint32 _p0 = default!;
    if (inheritExisting) {
        _p0 = 1;
    }
    var (r1, _, e1) = syscall.Syscall(procCreateEnvironmentBlock.Addr(), 3, ((uintptr)((@unsafe.Pointer)block)), ((uintptr)token), ((uintptr)_p0));
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ DestroyEnvironmentBlock(ж<uint16> Ꮡblock) {
    error err = default!;

    ref var block = ref Ꮡblock.val;
    var (r1, _, e1) = syscall.Syscall(procDestroyEnvironmentBlock.Addr(), 1, ((uintptr)new @unsafe.Pointer(Ꮡblock)), 0, 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ GetProfilesDirectory(ж<uint16> Ꮡdir, ж<uint32> ᏑdirLen) {
    error err = default!;

    ref var dir = ref Ꮡdir.val;
    ref var dirLen = ref ᏑdirLen.val;
    var (r1, _, e1) = syscall.Syscall(procGetProfilesDirectoryW.Addr(), 2, ((uintptr)new @unsafe.Pointer(Ꮡdir)), ((uintptr)new @unsafe.Pointer(ᏑdirLen)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static error /*err*/ WSAGetOverlappedResult(syscallꓸHandle h, ж<syscall.Overlapped> Ꮡo, ж<uint32> Ꮡbytes, bool wait, ж<uint32> Ꮡflags) {
    error err = default!;

    ref var o = ref Ꮡo.val;
    ref var bytes = ref Ꮡbytes.val;
    ref var flags = ref Ꮡflags.val;
    uint32 _p0 = default!;
    if (wait) {
        _p0 = 1;
    }
    var (r1, _, e1) = syscall.Syscall6(procWSAGetOverlappedResult.Addr(), 5, ((uintptr)h), ((uintptr)new @unsafe.Pointer(Ꮡo)), ((uintptr)new @unsafe.Pointer(Ꮡbytes)), ((uintptr)_p0), ((uintptr)new @unsafe.Pointer(Ꮡflags)), 0);
    if (r1 == 0) {
        err = errnoErr(e1);
    }
    return err;
}

public static (syscallꓸHandle handle, error err) WSASocket(int32 af, int32 typ, int32 protocol, ж<syscall.WSAProtocolInfo> Ꮡprotinfo, uint32 group, uint32 flags) {
    syscallꓸHandle handle = default!;
    error err = default!;

    ref var protinfo = ref Ꮡprotinfo.val;
    var (r0, _, e1) = syscall.Syscall6(procWSASocketW.Addr(), 6, ((uintptr)af), ((uintptr)typ), ((uintptr)protocol), ((uintptr)new @unsafe.Pointer(Ꮡprotinfo)), ((uintptr)group), ((uintptr)flags));
    handle = ((syscallꓸHandle)r0);
    if (handle == syscall.InvalidHandle) {
        err = errnoErr(e1);
    }
    return (handle, err);
}

} // end windows_package
