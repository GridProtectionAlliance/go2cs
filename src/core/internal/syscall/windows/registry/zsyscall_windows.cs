// Code generated by 'go generate'; DO NOT EDIT.
namespace go.@internal.syscall.windows;

using sysdll = @internal.syscall.windows.sysdll_package;
using syscall = syscall_package;
using @unsafe = unsafe_package;

partial class registry_package {

internal static @unsafe.Pointer _;

// Do the interface allocations only once for common
// Errno values.
internal static readonly UntypedInt errnoERROR_IO_PENDING = 997;

internal static syscall.Errno errERROR_IO_PENDING = ((syscall.Errno)errnoERROR_IO_PENDING);
internal static syscall.Errno errERROR_EINVAL = syscall.EINVAL;

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
internal static error errnoErr(syscall.Errno e) {
    var exprᴛ1 = e;
    if (exprᴛ1 == 0) {
        return errERROR_EINVAL;
    }
    if (exprᴛ1 == errnoERROR_IO_PENDING) {
        return errERROR_IO_PENDING;
    }

    // TODO: add more here, after collecting data on the common
    // error values see on Windows. (perhaps when running
    // all.bat?)
    return e;
}

internal static ж<syscall.LazyDLL> modadvapi32 = syscall.NewLazyDLL(sysdll.Add("advapi32.dll"u8));
internal static ж<syscall.LazyDLL> modkernel32 = syscall.NewLazyDLL(sysdll.Add("kernel32.dll"u8));
internal static ж<syscall.LazyProc> procRegCreateKeyExW = modadvapi32.NewProc("RegCreateKeyExW"u8);
internal static ж<syscall.LazyProc> procRegDeleteKeyW = modadvapi32.NewProc("RegDeleteKeyW"u8);
internal static ж<syscall.LazyProc> procRegDeleteValueW = modadvapi32.NewProc("RegDeleteValueW"u8);
internal static ж<syscall.LazyProc> procRegEnumValueW = modadvapi32.NewProc("RegEnumValueW"u8);
internal static ж<syscall.LazyProc> procRegLoadMUIStringW = modadvapi32.NewProc("RegLoadMUIStringW"u8);
internal static ж<syscall.LazyProc> procRegSetValueExW = modadvapi32.NewProc("RegSetValueExW"u8);
internal static ж<syscall.LazyProc> procExpandEnvironmentStringsW = modkernel32.NewProc("ExpandEnvironmentStringsW"u8);

internal static error /*regerrno*/ regCreateKeyEx(syscallꓸHandle key, ж<uint16> Ꮡsubkey, uint32 reserved, ж<uint16> Ꮡclass, uint32 options, uint32 desired, ж<syscall.SecurityAttributes> Ꮡsa, ж<syscallꓸHandle> Ꮡresult, ж<uint32> Ꮡdisposition) {
    error regerrno = default!;

    ref var subkey = ref Ꮡsubkey.val;
    ref var @class = ref Ꮡclass.val;
    ref var sa = ref Ꮡsa.val;
    ref var result = ref Ꮡresult.val;
    ref var disposition = ref Ꮡdisposition.val;
    var (r0, _, _) = syscall.Syscall9(procRegCreateKeyExW.Addr(), 9, ((uintptr)key), ((uintptr)new @unsafe.Pointer(Ꮡsubkey)), ((uintptr)reserved), ((uintptr)new @unsafe.Pointer(Ꮡclass)), ((uintptr)options), ((uintptr)desired), ((uintptr)new @unsafe.Pointer(Ꮡsa)), ((uintptr)((@unsafe.Pointer)result)), ((uintptr)new @unsafe.Pointer(Ꮡdisposition)));
    if (r0 != 0) {
        regerrno = ((syscall.Errno)r0);
    }
    return regerrno;
}

internal static error /*regerrno*/ regDeleteKey(syscallꓸHandle key, ж<uint16> Ꮡsubkey) {
    error regerrno = default!;

    ref var subkey = ref Ꮡsubkey.val;
    var (r0, _, _) = syscall.Syscall(procRegDeleteKeyW.Addr(), 2, ((uintptr)key), ((uintptr)new @unsafe.Pointer(Ꮡsubkey)), 0);
    if (r0 != 0) {
        regerrno = ((syscall.Errno)r0);
    }
    return regerrno;
}

internal static error /*regerrno*/ regDeleteValue(syscallꓸHandle key, ж<uint16> Ꮡname) {
    error regerrno = default!;

    ref var name = ref Ꮡname.val;
    var (r0, _, _) = syscall.Syscall(procRegDeleteValueW.Addr(), 2, ((uintptr)key), ((uintptr)new @unsafe.Pointer(Ꮡname)), 0);
    if (r0 != 0) {
        regerrno = ((syscall.Errno)r0);
    }
    return regerrno;
}

internal static error /*regerrno*/ regEnumValue(syscallꓸHandle key, uint32 index, ж<uint16> Ꮡname, ж<uint32> ᏑnameLen, ж<uint32> Ꮡreserved, ж<uint32> Ꮡvaltype, ж<byte> Ꮡbuf, ж<uint32> Ꮡbuflen) {
    error regerrno = default!;

    ref var name = ref Ꮡname.val;
    ref var nameLen = ref ᏑnameLen.val;
    ref var reserved = ref Ꮡreserved.val;
    ref var valtype = ref Ꮡvaltype.val;
    ref var buf = ref Ꮡbuf.val;
    ref var buflen = ref Ꮡbuflen.val;
    var (r0, _, _) = syscall.Syscall9(procRegEnumValueW.Addr(), 8, ((uintptr)key), ((uintptr)index), ((uintptr)new @unsafe.Pointer(Ꮡname)), ((uintptr)new @unsafe.Pointer(ᏑnameLen)), ((uintptr)new @unsafe.Pointer(Ꮡreserved)), ((uintptr)new @unsafe.Pointer(Ꮡvaltype)), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), ((uintptr)new @unsafe.Pointer(Ꮡbuflen)), 0);
    if (r0 != 0) {
        regerrno = ((syscall.Errno)r0);
    }
    return regerrno;
}

internal static error /*regerrno*/ regLoadMUIString(syscallꓸHandle key, ж<uint16> Ꮡname, ж<uint16> Ꮡbuf, uint32 buflen, ж<uint32> ᏑbuflenCopied, uint32 flags, ж<uint16> Ꮡdir) {
    error regerrno = default!;

    ref var name = ref Ꮡname.val;
    ref var buf = ref Ꮡbuf.val;
    ref var buflenCopied = ref ᏑbuflenCopied.val;
    ref var dir = ref Ꮡdir.val;
    var (r0, _, _) = syscall.Syscall9(procRegLoadMUIStringW.Addr(), 7, ((uintptr)key), ((uintptr)new @unsafe.Pointer(Ꮡname)), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), ((uintptr)buflen), ((uintptr)new @unsafe.Pointer(ᏑbuflenCopied)), ((uintptr)flags), ((uintptr)new @unsafe.Pointer(Ꮡdir)), 0, 0);
    if (r0 != 0) {
        regerrno = ((syscall.Errno)r0);
    }
    return regerrno;
}

internal static error /*regerrno*/ regSetValueEx(syscallꓸHandle key, ж<uint16> ᏑvalueName, uint32 reserved, uint32 vtype, ж<byte> Ꮡbuf, uint32 bufsize) {
    error regerrno = default!;

    ref var valueName = ref ᏑvalueName.val;
    ref var buf = ref Ꮡbuf.val;
    var (r0, _, _) = syscall.Syscall6(procRegSetValueExW.Addr(), 6, ((uintptr)key), ((uintptr)new @unsafe.Pointer(ᏑvalueName)), ((uintptr)reserved), ((uintptr)vtype), ((uintptr)new @unsafe.Pointer(Ꮡbuf)), ((uintptr)bufsize));
    if (r0 != 0) {
        regerrno = ((syscall.Errno)r0);
    }
    return regerrno;
}

internal static (uint32 n, error err) expandEnvironmentStrings(ж<uint16> Ꮡsrc, ж<uint16> Ꮡdst, uint32 size) {
    uint32 n = default!;
    error err = default!;

    ref var src = ref Ꮡsrc.val;
    ref var dst = ref Ꮡdst.val;
    var (r0, _, e1) = syscall.Syscall(procExpandEnvironmentStringsW.Addr(), 3, ((uintptr)new @unsafe.Pointer(Ꮡsrc)), ((uintptr)new @unsafe.Pointer(Ꮡdst)), ((uintptr)size));
    n = ((uint32)r0);
    if (n == 0) {
        err = errnoErr(e1);
    }
    return (n, err);
}

} // end registry_package
