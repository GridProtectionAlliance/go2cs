// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/selection.go
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements Selections.
namespace go.go;

using bytes = bytes_package;
using fmt = fmt_package;

partial class types_package {

[GoType("num:nint")] partial struct SelectionKind;

public static readonly SelectionKind FieldVal = /* iota */ 0;    // x.f is a struct field selector
public static readonly SelectionKind MethodVal = 1;   // x.f is a method selector
public static readonly SelectionKind MethodExpr = 2;  // x.f is a method expression

// A Selection describes a selector expression x.f.
// For the declarations:
//
//	type T struct{ x int; E }
//	type E struct{}
//	func (e E) m() {}
//	var p *T
//
// the following relations exist:
//
//	Selector    Kind          Recv    Obj    Type       Index     Indirect
//
//	p.x         FieldVal      T       x      int        {0}       true
//	p.m         MethodVal     *T      m      func()     {1, 0}    true
//	T.m         MethodExpr    T       m      func(T)    {1, 0}    false
[GoType] partial struct Selection {
    internal SelectionKind kind;
    internal ΔType recv; // type of x
    internal Object obj; // object denoted by x.f
    internal slice<nint> index; // path from x to x.f
    internal bool indirect;   // set if there was any pointer indirection on the path
}

// Kind returns the selection kind.
[GoRecv] public static SelectionKind Kind(this ref Selection s) {
    return s.kind;
}

// Recv returns the type of x in x.f.
[GoRecv] public static ΔType Recv(this ref Selection s) {
    return s.recv;
}

// Obj returns the object denoted by x.f; a *Var for
// a field selection, and a *Func in all other cases.
[GoRecv] public static Object Obj(this ref Selection s) {
    return s.obj;
}

// Type returns the type of x.f, which may be different from the type of f.
// See Selection for more information.
[GoRecv] public static ΔType Type(this ref Selection s) {
    var exprᴛ1 = s.kind;
    if (exprᴛ1 == MethodVal) {
        ref var sig = ref heap<ΔSignature>(out var Ꮡsig);
        sig = s.obj._<Func.val>().typ._<ΔSignature.val>().val;
        ref var recv = ref heap<Var>(out var Ꮡrecv);
        recv = sig.recv.val;
        recv.typ = s.recv;
        sig.recv = Ꮡrecv;
        return ~Ꮡsig;
    }
    if (exprᴛ1 == MethodExpr) {
        ref var sig = ref heap<ΔSignature>(out var Ꮡsig);
        sig = s.obj._<Func.val>().typ._<ΔSignature.val>().val;
        ref var arg0 = ref heap<Var>(out var Ꮡarg0);
        arg0 = sig.recv.val;
        sig.recv = default!;
        arg0.typ = s.recv;
// The type of x.f is a method with its receiver type set
// to the type of x.
// The type of x.f is a function (without receiver)
// and an additional first argument with the same type as x.
// TODO(gri) Similar code is already in call.go - factor!
// TODO(gri) Compute this eagerly to avoid allocations.
        slice<ж<Var>> @params = default!;
        if (sig.@params != nil) {
            @params = sig.@params.val.vars;
        }
        sig.@params = NewTuple(append(new ж<Var>[]{Ꮡarg0}.slice(), Ꮡparams.ꓸꓸꓸ).ꓸꓸꓸ);
        return ~Ꮡsig;
    }

    // In all other cases, the type of x.f is the type of x.
    return s.obj.Type();
}

// Index describes the path from x to f in x.f.
// The last index entry is the field or method index of the type declaring f;
// either:
//
//  1. the list of declared methods of a named type; or
//  2. the list of methods of an interface type; or
//  3. the list of fields of a struct type.
//
// The earlier index entries are the indices of the embedded fields implicitly
// traversed to get from (the type of) x to f, starting at embedding depth 0.
[GoRecv] public static slice<nint> Index(this ref Selection s) {
    return s.index;
}

// Indirect reports whether any pointer indirection was required to get from
// x to f in x.f.
//
// Beware: Indirect spuriously returns true (Go issue #8353) for a
// MethodVal selection in which the receiver argument and parameter
// both have type *T so there is no indirection.
// Unfortunately, a fix is too risky.
[GoRecv] public static bool Indirect(this ref Selection s) {
    return s.indirect;
}

[GoRecv] public static @string String(this ref Selection s) {
    return SelectionString(s, default!);
}

// SelectionString returns the string form of s.
// The Qualifier controls the printing of
// package-level objects, and may be nil.
//
// Examples:
//
//	"field (T) f int"
//	"method (T) f(X) Y"
//	"method expr (T) f(X) Y"
public static @string SelectionString(ж<Selection> Ꮡs, Qualifier qf) {
    ref var s = ref Ꮡs.val;

    @string k = default!;
    var exprᴛ1 = s.kind;
    if (exprᴛ1 == FieldVal) {
        k = "field "u8;
    }
    else if (exprᴛ1 == MethodVal) {
        k = "method "u8;
    }
    else if (exprᴛ1 == MethodExpr) {
        k = "method expr "u8;
    }
    else { /* default: */
        throw panic("unreachable");
    }

    ref var buf = ref heap(new bytes_package.Buffer(), out var Ꮡbuf);
    buf.WriteString(k);
    buf.WriteByte((rune)'(');
    WriteType(Ꮡbuf, s.Recv(), qf);
    fmt.Fprintf(~Ꮡbuf, ") %s"u8, s.obj.Name());
    {
        var T = s.Type(); if (s.kind == FieldVal){
            buf.WriteByte((rune)' ');
            WriteType(Ꮡbuf, T, qf);
        } else {
            WriteSignature(Ꮡbuf, T._<ΔSignature.val>(), qf);
        }
    }
    return buf.String();
}

} // end types_package
