// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/lookup.go
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements various field and method lookup functions.
namespace go.go;

using bytes = bytes_package;
using token = go.token_package;

partial class types_package {

// Internal use of LookupFieldOrMethod: If the obj result is a method
// associated with a concrete (non-interface) type, the method's signature
// may not be fully set up. Call Checker.objDecl(obj, nil) before accessing
// the method's type.

// LookupFieldOrMethod looks up a field or method with given package and name
// in T and returns the corresponding *Var or *Func, an index sequence, and a
// bool indicating if there were any pointer indirections on the path to the
// field or method. If addressable is set, T is the type of an addressable
// variable (only matters for method lookups). T must not be nil.
//
// The last index entry is the field or method index in the (possibly embedded)
// type where the entry was found, either:
//
//  1. the list of declared methods of a named type; or
//  2. the list of all methods (method set) of an interface type; or
//  3. the list of fields of a struct type.
//
// The earlier index entries are the indices of the embedded struct fields
// traversed to get to the found entry, starting at depth 0.
//
// If no entry is found, a nil object is returned. In this case, the returned
// index and indirect values have the following meaning:
//
//   - If index != nil, the index sequence points to an ambiguous entry
//     (the same name appeared more than once at the same embedding level).
//
//   - If indirect is set, a method with a pointer receiver type was found
//     but there was no pointer on the path from the actual receiver type to
//     the method's formal receiver base type, nor was the receiver addressable.
public static (Object obj, slice<nint> index, bool indirect) LookupFieldOrMethod(ΔType T, bool addressable, ж<Package> Ꮡpkg, @string name) {
    Object obj = default!;
    slice<nint> index = default!;
    bool indirect = default!;

    ref var pkg = ref Ꮡpkg.val;
    if (T == default!) {
        throw panic("LookupFieldOrMethod on nil type");
    }
    return lookupFieldOrMethod(T, addressable, Ꮡpkg, name, false);
}

// lookupFieldOrMethod is like LookupFieldOrMethod but with the additional foldCase parameter
// (see Object.sameId for the meaning of foldCase).
internal static (Object obj, slice<nint> index, bool indirect) lookupFieldOrMethod(ΔType T, bool addressable, ж<Package> Ꮡpkg, @string name, bool foldCase) {
    Object obj = default!;
    slice<nint> index = default!;
    bool indirect = default!;

    ref var pkg = ref Ꮡpkg.val;
    // Methods cannot be associated to a named pointer type.
    // (spec: "The type denoted by T is called the receiver base type;
    // it must not be a pointer or interface type and it must be declared
    // in the same package as the method.").
    // Thus, if we have a named pointer type, proceed with the underlying
    // pointer type but discard the result if it is a method since we would
    // not have found it for T (see also go.dev/issue/8590).
    {
        var t = asNamed(T); if (t != nil) {
            {
                var (p, _) = t.Underlying()._<Pointer.val>(ᐧ); if (p != nil) {
                    (obj, index, indirect) = lookupFieldOrMethodImpl(~p, false, Ꮡpkg, name, foldCase);
                    {
                        var (_, ok) = obj._<Func.val>(ᐧ); if (ok) {
                            return (default!, default!, false);
                        }
                    }
                    return (obj, index, indirect);
                }
            }
        }
    }
    (obj, index, indirect) = lookupFieldOrMethodImpl(T, addressable, Ꮡpkg, name, foldCase);
    // If we didn't find anything and if we have a type parameter with a core type,
    // see if there is a matching field (but not a method, those need to be declared
    // explicitly in the constraint). If the constraint is a named pointer type (see
    // above), we are ok here because only fields are accepted as results.
    const bool enableTParamFieldLookup = false; // see go.dev/issue/51576
    if (enableTParamFieldLookup && obj == default! && isTypeParam(T)) {
        {
            var t = coreType(T); if (t != default!) {
                (obj, index, indirect) = lookupFieldOrMethodImpl(t, addressable, Ꮡpkg, name, foldCase);
                {
                    var (_, ok) = obj._<Var.val>(ᐧ); if (!ok) {
                        (obj, index, indirect) = (default!, default!, false);
                    }
                }
            }
        }
    }
    // accept fields (variables) only
    return (obj, index, indirect);
}

// lookupFieldOrMethodImpl is the implementation of lookupFieldOrMethod.
// Notably, in contrast to lookupFieldOrMethod, it won't find struct fields
// in base types of defined (*Named) pointer types T. For instance, given
// the declaration:
//
//	type T *struct{f int}
//
// lookupFieldOrMethodImpl won't find the field f in the defined (*Named) type T
// (methods on T are not permitted in the first place).
//
// Thus, lookupFieldOrMethodImpl should only be called by lookupFieldOrMethod
// and missingMethod (the latter doesn't care about struct fields).
//
// The resulting object may not be fully type-checked.
internal static (Object obj, slice<nint> index, bool indirect) lookupFieldOrMethodImpl(ΔType T, bool addressable, ж<Package> Ꮡpkg, @string name, bool foldCase) {
    Object obj = default!;
    slice<nint> index = default!;
    bool indirect = default!;

    ref var pkg = ref Ꮡpkg.val;
    // WARNING: The code in this function is extremely subtle - do not modify casually!
    if (name == "_"u8) {
        return (obj, index, indirect);
    }
    // blank fields/methods are never found
    // Importantly, we must not call under before the call to deref below (nor
    // does deref call under), as doing so could incorrectly result in finding
    // methods of the pointer base type when T is a (*Named) pointer type.
    var (typ, isPtr) = deref(T);
    // *typ where typ is an interface (incl. a type parameter) has no methods.
    if (isPtr) {
        {
            var (_, ok) = under(typ)._<Interface.val>(ᐧ); if (ok) {
                return (obj, index, indirect);
            }
        }
    }
    // Start with typ as single entry at shallowest depth.
    var current = new embeddedType[]{new(typ, default!, isPtr, false)}.slice();
    // seen tracks named types that we have seen already, allocated lazily.
    // Used to avoid endless searches in case of recursive types.
    //
    // We must use a lookup on identity rather than a simple map[*Named]bool as
    // instantiated types may be identical but not equal.
    instanceLookup seen = default!;
    // search current depth
    while (len(current) > 0) {
        slice<embeddedType> next = default!;                          // embedded types found at current depth
        // look for (pkg, name) in all types at current depth
        foreach (var (_, e) in current) {
            var typΔ1 = e.typ;
            // If we have a named type, we may have associated methods.
            // Look for those first.
            {
                var named = asNamed(typΔ1); if (named != nil) {
                    {
                        var alt = seen.lookup(named); if (alt != nil) {
                            // We have seen this type before, at a more shallow depth
                            // (note that multiples of this type at the current depth
                            // were consolidated before). The type at that depth shadows
                            // this same type at the current depth, so we can ignore
                            // this one.
                            continue;
                        }
                    }
                    seen.add(named);
                    // look for a matching attached method
                    {
                        var (i, m) = named.lookupMethod(Ꮡpkg, name, foldCase); if (m != nil) {
                            // potential match
                            // caution: method may not have a proper signature yet
                            index = concat(e.index, i);
                            if (obj != default! || e.multiples) {
                                return (default!, index, false);
                            }
                            // collision
                            obj = ~m;
                            indirect = e.indirect;
                            continue;
                        }
                    }
                }
            }
            // we can't have a matching field or interface method
            switch (under(typ).type()) {
            case Struct.val t: {
                foreach (var (i, f) in (~t).fields) {
                    // look for a matching field and collect embedded types
                    if (f.sameId(Ꮡpkg, name, foldCase)) {
                        assert(f.typ != default!);
                        index = concat(e.index, i);
                        if (obj != default! || e.multiples) {
                            return (default!, index, false);
                        }
                        // collision
                        obj = ~f;
                        indirect = e.indirect;
                        continue;
                    }
                    // we can't have a matching interface method
                    // Collect embedded struct fields for searching the next
                    // lower depth, but only if we have not seen a match yet
                    // (if we have a match it is either the desired field or
                    // we have a name collision on the same depth; in either
                    // case we don't need to look further).
                    // Embedded fields are always of the form T or *T where
                    // T is a type name. If e.typ appeared multiple times at
                    // this depth, f.typ appears multiple times at the next
                    // depth.
                    if (obj == default! && (~f).embedded) {
                        var (typΔ2, isPtrΔ1) = deref(f.typ);
                        // TODO(gri) optimization: ignore types that can't
                        // have fields or methods (only Named, Struct, and
                        // Interface types need to be considered).
                        next = append(next, new embeddedType(typΔ2, concat(e.index, i), e.indirect || isPtrΔ1, e.multiples));
                    }
                }
                break;
            }
            case Interface.val t: {
                {
                    var (i, m) = t.typeSet().LookupMethod(Ꮡpkg, // look for a matching method (interface may be a type parameter)
 name, foldCase); if (m != nil) {
                        assert(m.typ != default!);
                        index = concat(e.index, i);
                        if (obj != default! || e.multiples) {
                            return (default!, index, false);
                        }
                        // collision
                        obj = ~m;
                        indirect = e.indirect;
                    }
                }
                break;
            }}
        }
        if (obj != default!) {
            // found a potential match
            // spec: "A method call x.m() is valid if the method set of (the type of) x
            //        contains m and the argument list can be assigned to the parameter
            //        list of m. If x is addressable and &x's method set contains m, x.m()
            //        is shorthand for (&x).m()".
            {
                var (f, _) = obj._<Func.val>(ᐧ); if (f != nil) {
                    // determine if method has a pointer receiver
                    if (f.hasPtrRecv() && !indirect && !addressable) {
                        return (default!, default!, true);
                    }
                }
            }
            // pointer/addressable receiver required
            return (obj, index, indirect);
        }
        current = consolidateMultiples(next);
    }
    return (default!, default!, false);
}

// not found

// embeddedType represents an embedded type
[GoType] partial struct embeddedType {
    internal ΔType typ;
    internal slice<nint> index; // embedded field indices, starting with index at depth 0
    internal bool indirect;  // if set, there was a pointer indirection on the path to this field
    internal bool multiples;  // if set, typ appears multiple times at this depth
}

// consolidateMultiples collects multiple list entries with the same type
// into a single entry marked as containing multiples. The result is the
// consolidated list.
internal static slice<embeddedType> consolidateMultiples(slice<embeddedType> list) {
    if (len(list) <= 1) {
        return list;
    }
    // at most one entry - nothing to do
    nint n = 0;
    // number of entries w/ unique type
    var prev = new map<ΔType, nint>();
    // index at which type was previously seen
    foreach (var (_, e) in list) {
        {
            var (i, found) = lookupType(prev, e.typ); if (found){
                list[i].multiples = true;
            } else {
                // ignore this entry
                prev[e.typ] = n;
                list[n] = e;
                n++;
            }
        }
    }
    return list[..(int)(n)];
}

internal static (nint, bool) lookupType(map<ΔType, nint> m, ΔType typ) {
    // fast path: maybe the types are equal
    {
        nint i = m[typ];
        var found = m[typ]; if (found) {
            return (i, true);
        }
    }
    foreach (var (t, i) in m) {
        if (Identical(t, typ)) {
            return (i, true);
        }
    }
    return (0, false);
}

[GoType] partial struct instanceLookup {
    // buf is used to avoid allocating the map m in the common case of a small
    // number of instances.
    internal array<ж<Named>> buf = new(3);
    internal types.Named m;
}

[GoRecv] internal static ж<Named> lookup(this ref instanceLookup l, ж<Named> Ꮡinst) {
    ref var inst = ref Ꮡinst.val;

    foreach (var (_, t) in l.buf) {
        if (t != nil && Identical(~inst, ~t)) {
            return t;
        }
    }
    foreach (var (_, t) in l.m[inst.Origin()]) {
        if (Identical(~inst, ~t)) {
            return t;
        }
    }
    return default!;
}

[GoRecv] internal static void add(this ref instanceLookup l, ж<Named> Ꮡinst) {
    ref var inst = ref Ꮡinst.val;

    foreach (var (i, t) in l.buf) {
        if (t == nil) {
            l.buf[i] = inst;
            return;
        }
    }
    if (l.m == default!) {
        l.m = new types.Named();
    }
    var insts = l.m[inst.Origin()];
    l.m[inst.Origin()] = append(insts, Ꮡinst);
}

// MissingMethod returns (nil, false) if V implements T, otherwise it
// returns a missing method required by T and whether it is missing or
// just has the wrong type: either a pointer receiver or wrong signature.
//
// For non-interface types V, or if static is set, V implements T if all
// methods of T are present in V. Otherwise (V is an interface and static
// is not set), MissingMethod only checks that methods of T which are also
// present in V have matching types (e.g., for a type assertion x.(T) where
// x is of interface type V).
public static (ж<Func> method, bool wrongType) MissingMethod(ΔType V, ж<Interface> ᏑT, bool @static) {
    ж<Func> method = default!;
    bool wrongType = default!;

    ref var T = ref ᏑT.val;
    return ((ж<Checker>)(default!)).val.missingMethod(V, ~T, @static, Identical, nil);
}

// missingMethod is like MissingMethod but accepts a *Checker as receiver,
// a comparator equivalent for type comparison, and a *string for error causes.
// The receiver may be nil if missingMethod is invoked through an exported
// API call (such as MissingMethod), i.e., when all methods have been type-
// checked.
// The underlying type of T must be an interface; T (rather than its under-
// lying type) is used for better error messages (reported through *cause).
// The comparator is used to compare signatures.
// If a method is missing and cause is not nil, *cause describes the error.
[GoRecv] public static (ж<Func> method, bool wrongType) missingMethod(this ref Checker check, ΔType V, ΔType T, bool @static, types.Type) bool equivalent, ж<@string> Ꮡcause) {
    ж<Func> method = default!;
    bool wrongType = default!;

    ref var cause = ref Ꮡcause.val;
    var methods = under(T)._<Interface.val>().typeSet().methods;
    // T must be an interface
    if (len(methods) == 0) {
        return (default!, false);
    }
    static readonly UntypedInt ok = iota;
    static readonly UntypedInt notFound = 1;
    static readonly UntypedInt wrongName = 2;
    static readonly UntypedInt unexported = 3;
    static readonly UntypedInt wrongSig = 4;
    static readonly UntypedInt ambigSel = 5;
    static readonly UntypedInt ptrRecv = 6;
    static readonly UntypedInt field = 7;
    nint state = ok;
    ж<Func> m = default!;           // method on T we're trying to implement
    ж<Func> f = default!;           // method on V, if found (state is one of ok, wrongName, wrongSig)
    {
        var (u, _) = under(V)._<Interface.val>(ᐧ); if (u != nil){
            var tset = u.typeSet();
            foreach (var (_, vᴛ1) in methods) {
                m = vᴛ1;

                (_, f) = tset.LookupMethod(m.pkg, m.name, false);
                if (f == nil) {
                    if (!@static) {
                        continue;
                    }
                    state = notFound;
                    break;
                }
                if (!equivalent(f.typ, m.typ)) {
                    state = wrongSig;
                    break;
                }
            }
        } else {
            foreach (var (_, vᴛ2) in methods) {
                m = vᴛ2;

                var (obj, index, indirect) = lookupFieldOrMethodImpl(V, false, m.pkg, m.name, false);
                // check if m is ambiguous, on *V, or on V with case-folding
                if (obj == default!) {
                    switch (ᐧ) {
                    case {} when index is != default!: {
                        state = ambigSel;
                        break;
                    }
                    case {} when indirect: {
                        state = ptrRecv;
                        break;
                    }
                    default: {
                        state = notFound;
                        (obj, _, _) = lookupFieldOrMethodImpl(V, false, m.pkg, m.name, true);
                        (f, _) = obj._<Func.val>(ᐧ);
                        if (f != nil) {
                            /* fold case */
                            state = wrongName;
                            if (f.name == m.name) {
                                // If the names are equal, f must be unexported
                                // (otherwise the package wouldn't matter).
                                state = unexported;
                            }
                        }
                        break;
                    }}

                    break;
                }
                // we must have a method (not a struct field)
                (f, _) = obj._<Func.val>(ᐧ);
                if (f == nil) {
                    state = field;
                    break;
                }
                // methods may not have a fully set up signature yet
                if (check != nil) {
                    check.objDecl(~f, nil);
                }
                if (!equivalent(f.typ, m.typ)) {
                    state = wrongSig;
                    break;
                }
            }
        }
    }
    if (state == ok) {
        return (default!, false);
    }
    if (cause != nil) {
        if (f != nil) {
            // This method may be formatted in funcString below, so must have a fully
            // set up signature.
            if (check != nil) {
                check.objDecl(~f, nil);
            }
        }
        switch (state) {
        case notFound: {
            switch (ᐧ) {
            case {} when isInterfacePtr(V): {
                cause = "("u8 + check.interfacePtrError(V) + ")"u8;
                break;
            }
            case {} when isInterfacePtr(T): {
                cause = "("u8 + check.interfacePtrError(T) + ")"u8;
                break;
            }
            default: {
                cause = check.sprintf("(missing method %s)"u8, m.Name());
                break;
            }}

            break;
        }
        case wrongName: {
            @string fs = check.funcString(f, false);
            @string ms = check.funcString(m, false);
            cause = check.sprintf("(missing method %s)\n\t\thave %s\n\t\twant %s"u8, m.Name(), fs, ms);
            break;
        }
        case unexported: {
            cause = check.sprintf("(unexported method %s)"u8, m.Name());
            break;
        }
        case wrongSig: {
            @string fs = check.funcString(f, false);
            @string ms = check.funcString(m, false);
            if (fs == ms) {
                // Don't report "want Foo, have Foo".
                // Add package information to disambiguate (go.dev/issue/54258).
                (fs, ms) = (check.funcString(f, true), check.funcString(m, true));
            }
            if (fs == ms) {
                // We still have "want Foo, have Foo".
                // This is most likely due to different type parameters with
                // the same name appearing in the instantiated signatures
                // (go.dev/issue/61685).
                // Rather than reporting this misleading error cause, for now
                // just point out that the method signature is incorrect.
                // TODO(gri) should find a good way to report the root cause
                cause = check.sprintf("(wrong type for method %s)"u8, m.Name());
                break;
            }
            cause = check.sprintf("(wrong type for method %s)\n\t\thave %s\n\t\twant %s"u8, m.Name(), fs, ms);
            break;
        }
        case ambigSel: {
            cause = check.sprintf("(ambiguous selector %s.%s)"u8, V, m.Name());
            break;
        }
        case ptrRecv: {
            cause = check.sprintf("(method %s has pointer receiver)"u8, m.Name());
            break;
        }
        case field: {
            cause = check.sprintf("(%s.%s is a field, not a method)"u8, V, m.Name());
            break;
        }
        default: {
            throw panic("unreachable");
            break;
        }}

    }
    return (m, state == wrongSig || state == ptrRecv);
}

internal static bool isInterfacePtr(ΔType T) {
    var (p, _) = under(T)._<Pointer.val>(ᐧ);
    return p != nil && IsInterface((~p).@base);
}

// check may be nil.
[GoRecv] internal static @string interfacePtrError(this ref Checker check, ΔType T) {
    assert(isInterfacePtr(T));
    {
        var (p, _) = under(T)._<Pointer.val>(ᐧ); if (isTypeParam((~p).@base)) {
            return check.sprintf("type %s is pointer to type parameter, not type parameter"u8, T);
        }
    }
    return check.sprintf("type %s is pointer to interface, not interface"u8, T);
}

// funcString returns a string of the form name + signature for f.
// check may be nil.
[GoRecv] public static @string funcString(this ref Checker check, ж<Func> Ꮡf, bool pkgInfo) {
    ref var f = ref Ꮡf.val;

    var buf = bytes.NewBufferString(f.name);
    Qualifier qf = default!;
    if (check != nil && !pkgInfo) {
        qf = () => check.qualifier();
    }
    var w = newTypeWriter(buf, qf);
    w.val.pkgInfo = pkgInfo;
    w.val.paramNames = false;
    w.signature(f.typ._<ΔSignature.val>());
    return buf.String();
}

// assertableTo reports whether a value of type V can be asserted to have type T.
// The receiver may be nil if assertableTo is invoked through an exported API call
// (such as AssertableTo), i.e., when all methods have been type-checked.
// The underlying type of V must be an interface.
// If the result is false and cause is not nil, *cause describes the error.
// TODO(gri) replace calls to this function with calls to newAssertableTo.
[GoRecv] public static bool assertableTo(this ref Checker check, ΔType V, ΔType T, ж<@string> Ꮡcause) {
    ref var cause = ref Ꮡcause.val;

    // no static check is required if T is an interface
    // spec: "If T is an interface type, x.(T) asserts that the
    //        dynamic type of x implements the interface T."
    if (IsInterface(T)) {
        return true;
    }
    // TODO(gri) fix this for generalized interfaces
    var (m, _) = check.missingMethod(T, V, false, Identical, Ꮡcause);
    return m == nil;
}

// newAssertableTo reports whether a value of type V can be asserted to have type T.
// It also implements behavior for interfaces that currently are only permitted
// in constraint position (we have not yet defined that behavior in the spec).
// The underlying type of V must be an interface.
// If the result is false and cause is not nil, *cause is set to the error cause.
[GoRecv] public static bool newAssertableTo(this ref Checker check, tokenꓸPos pos, ΔType V, ΔType T, ж<@string> Ꮡcause) {
    ref var cause = ref Ꮡcause.val;

    // no static check is required if T is an interface
    // spec: "If T is an interface type, x.(T) asserts that the
    //        dynamic type of x implements the interface T."
    if (IsInterface(T)) {
        return true;
    }
    return check.implements(pos, T, V, false, Ꮡcause);
}

// deref dereferences typ if it is a *Pointer (but not a *Named type
// with an underlying pointer type!) and returns its base and true.
// Otherwise it returns (typ, false).
internal static (ΔType, bool) deref(ΔType typ) {
    {
        var (p, _) = Unalias(typ)._<Pointer.val>(ᐧ); if (p != nil) {
            // p.base should never be nil, but be conservative
            if ((~p).@base == default!) {
                if (debug) {
                    throw panic("pointer with nil base type (possibly due to an invalid cyclic declaration)");
                }
                return (~Typ[Invalid], true);
            }
            return ((~p).@base, true);
        }
    }
    return (typ, false);
}

// derefStructPtr dereferences typ if it is a (named or unnamed) pointer to a
// (named or unnamed) struct and returns its base. Otherwise it returns typ.
internal static ΔType derefStructPtr(ΔType typ) {
    {
        var (p, _) = under(typ)._<Pointer.val>(ᐧ); if (p != nil) {
            {
                var (_, ok) = under((~p).@base)._<Struct.val>(ᐧ); if (ok) {
                    return (~p).@base;
                }
            }
        }
    }
    return typ;
}

// concat returns the result of concatenating list and i.
// The result does not share its underlying array with list.
internal static slice<nint> concat(slice<nint> list, nint i) {
    slice<nint> t = default!;
    t = append(t, list.ꓸꓸꓸ);
    return append(t, i);
}

// fieldIndex returns the index for the field with matching package and name, or a value < 0.
// See Object.sameId for the meaning of foldCase.
internal static nint fieldIndex(slice<ж<Var>> fields, ж<Package> Ꮡpkg, @string name, bool foldCase) {
    ref var pkg = ref Ꮡpkg.val;

    if (name != "_"u8) {
        foreach (var (i, f) in fields) {
            if (f.sameId(Ꮡpkg, name, foldCase)) {
                return i;
            }
        }
    }
    return -1;
}

// methodIndex returns the index of and method with matching package and name, or (-1, nil).
// See Object.sameId for the meaning of foldCase.
internal static (nint, ж<Func>) methodIndex(slice<ж<Func>> methods, ж<Package> Ꮡpkg, @string name, bool foldCase) {
    ref var pkg = ref Ꮡpkg.val;

    if (name != "_"u8) {
        foreach (var (i, m) in methods) {
            if (m.sameId(Ꮡpkg, name, foldCase)) {
                return (i, m);
            }
        }
    }
    return (-1, default!);
}

} // end types_package
