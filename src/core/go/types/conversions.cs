// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/conversions.go
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements typechecking of conversions.
namespace go.go;

using constant = go.constant_package;
using static @internal.types.errors_package;
using unicode = unicode_package;
using ꓸꓸꓸany = Span<any>;

partial class types_package {

// conversion type-checks the conversion T(x).
// The result is in x.
[GoRecv] public static void conversion(this ref Checker check, ж<operand> Ꮡx, ΔType T) {
    ref var x = ref Ꮡx.val;

    var constArg = x.mode == constant_;
    var constConvertibleTo = (ΔType T, ж<constant.Value> val) => {
        {
            var (t, _) = under(T)._<Basic.val>(ᐧ);
            switch (ᐧ) {
            case {} when t == nil: {
                break;
            }
            case {} when representableConst(x.val, // nothing to do
 check, t, val): {
                return true;
            }
            case {} when isInteger(x.typ) && isString(~t): {
                var codepoint = unicode.ReplacementChar;
                {
                    var (i, okΔ2) = constant.Uint64Val(x.val); if (okΔ2 && i <= unicode.MaxRune) {
                        codepoint = ((rune)i);
                    }
                }
                if (val != nil) {
                    val.val = constant.MakeString(((@string)codepoint));
                }
                return true;
            }}
        }

        return false;
    };
    bool ok = default!;
    ref var cause = ref heap(new @string(), out var Ꮡcause);
    switch (ᐧ) {
    case {} when constArg && isConstType(T): {
        ok = constConvertibleTo(T, // constant conversion
 Ꮡ(x.val));
        if (!ok && isInteger(x.typ) && isInteger(T)) {
            // A conversion from an integer constant to an integer type
            // can only fail if there's overflow. Give a concise error.
            // (go.dev/issue/63563)
            check.errorf(~x, InvalidConversion, "constant %s overflows %s"u8, x.val, T);
            x.mode = invalid;
            return;
        }
        break;
    }
    case {} when constArg && isTypeParam(T): {
        ok = Unalias(T)._<TypeParam.val>().underIs(
        var causeʗ2 = cause;
        var constConvertibleToʗ2 = constConvertibleTo;
        (ΔType u) => {
            if (u == default!) {
                causeʗ2 = check.sprintf("%s does not contain specific types"u8, T);
                return false;
            }
            if (isString(x.typ) && isBytesOrRunes(u)) {
                return true;
            }
            if (!constConvertibleToʗ2(u, nil)) {
                if (isInteger(x.typ) && isInteger(u)){
                    causeʗ2 = check.sprintf("constant %s overflows %s (in %s)"u8, x.val, u, T);
                } else {
                    causeʗ2 = check.sprintf("cannot convert %s to type %s (in %s)"u8, x, u, T);
                }
                return false;
            }
            return true;
        });
        x.mode = value;
        break;
    }
    case {} when x.convertibleTo(check, // type parameters are not constants
 T, Ꮡcause): {
        ok = true;
        x.mode = value;
        break;
    }}

    // non-constant conversion
    if (!ok) {
        if (cause != ""u8){
            check.errorf(~x, InvalidConversion, "cannot convert %s to type %s: %s"u8, x, T, cause);
        } else {
            check.errorf(~x, InvalidConversion, "cannot convert %s to type %s"u8, x, T);
        }
        x.mode = invalid;
        return;
    }
    // The conversion argument types are final. For untyped values the
    // conversion provides the type, per the spec: "A constant may be
    // given a type explicitly by a constant declaration or conversion,...".
    if (isUntyped(x.typ)) {
        var final = T;
        // - For conversions to interfaces, except for untyped nil arguments
        //   and isTypes2, use the argument's default type.
        // - For conversions of untyped constants to non-constant types, also
        //   use the default type (e.g., []byte("foo") should report string
        //   not []byte as type for the constant "foo").
        // - If !isTypes2, keep untyped nil for untyped nil arguments.
        // - For constant integer to string conversions, keep the argument type.
        //   (See also the TODO below.)
        if (isTypes2 && x.typ == ~Typ[UntypedNil]){
        } else 
        if (isNonTypeParamInterface(T) || constArg && !isConstType(T) || !isTypes2 && x.isNil()){
            // ok
            final = Default(x.typ);
        } else 
        if (x.mode == constant_ && isInteger(x.typ) && allString(T)) {
            // default type of untyped nil is untyped nil
            final = x.typ;
        }
        check.updateExprType(x.expr, final, true);
    }
    x.typ = T;
}

// TODO(gri) convertibleTo checks if T(x) is valid. It assumes that the type
// of x is fully known, but that's not the case for say string(1<<s + 1.0):
// Here, the type of 1<<s + 1.0 will be UntypedFloat which will lead to the
// (correct!) refusal of the conversion. But the reported error is essentially
// "cannot convert untyped float value to string", yet the correct error (per
// the spec) is that we cannot shift a floating-point value: 1 in 1<<s should
// be converted to UntypedFloat because of the addition of 1.0. Fixing this
// is tricky because we'd have to run updateExprType on the argument first.
// (go.dev/issue/21982.)

// convertibleTo reports whether T(x) is valid. In the failure case, *cause
// may be set to the cause for the failure.
// The check parameter may be nil if convertibleTo is invoked through an
// exported API call, i.e., when all methods have been type-checked.
[GoRecv] internal static bool convertibleTo(this ref operand x, ж<Checker> Ꮡcheck, ΔType T, ж<@string> Ꮡcause) {
    ref var check = ref Ꮡcheck.val;
    ref var cause = ref Ꮡcause.val;

    // "x is assignable to T"
    {
        var (ok, _) = x.assignableTo(Ꮡcheck, T, Ꮡcause); if (ok) {
            return true;
        }
    }
    var origT = T;
    var V = Unalias(x.typ);
    T = Unalias(T);
    var Vu = under(V);
    var Tu = under(T);
    var (Vp, _) = V._<TypeParam.val>(ᐧ);
    var (Tp, _) = T._<TypeParam.val>(ᐧ);
    // "V and T have identical underlying types if tags are ignored
    // and V and T are not type parameters"
    if (IdenticalIgnoreTags(Vu, Tu) && Vp == nil && Tp == nil) {
        return true;
    }
    // "V and T are unnamed pointer types and their pointer base types
    // have identical underlying types if tags are ignored
    // and their pointer base types are not type parameters"
    {
        var (VΔ1, ok) = V._<Pointer.val>(ᐧ); if (ok) {
            {
                var (TΔ1, okΔ1) = T._<Pointer.val>(ᐧ); if (okΔ1) {
                    if (IdenticalIgnoreTags(under((~VΔ1).@base), under((~TΔ1).@base)) && !isTypeParam((~VΔ1).@base) && !isTypeParam((~TΔ1).@base)) {
                        return true;
                    }
                }
            }
        }
    }
    // "V and T are both integer or floating point types"
    if (isIntegerOrFloat(Vu) && isIntegerOrFloat(Tu)) {
        return true;
    }
    // "V and T are both complex types"
    if (isComplex(Vu) && isComplex(Tu)) {
        return true;
    }
    // "V is an integer or a slice of bytes or runes and T is a string type"
    if ((isInteger(Vu) || isBytesOrRunes(Vu)) && isString(Tu)) {
        return true;
    }
    // "V is a string and T is a slice of bytes or runes"
    if (isString(Vu) && isBytesOrRunes(Tu)) {
        return true;
    }
    // package unsafe:
    // "any pointer or value of underlying type uintptr can be converted into a unsafe.Pointer"
    if ((isPointer(Vu) || isUintptr(Vu)) && isUnsafePointer(Tu)) {
        return true;
    }
    // "and vice versa"
    if (isUnsafePointer(Vu) && (isPointer(Tu) || isUintptr(Tu))) {
        return true;
    }
    // "V is a slice, T is an array or pointer-to-array type,
    // and the slice and array types have identical element types."
    {
        var (s, _) = Vu._<Slice.val>(ᐧ); if (s != nil) {
            switch (Tu.type()) {
            case Array.val a: {
                if (Identical(s.Elem(), a.Elem())) {
                    if (check == nil || check.allowVersion(~x, go1_20)) {
                        return true;
                    }
                    // check != nil
                    if (cause != nil) {
                        // TODO(gri) consider restructuring versionErrorf so we can use it here and below
                        cause = "conversion of slice to array requires go1.20 or later"u8;
                    }
                    return false;
                }
                break;
            }
            case Pointer.val a: {
                {
                    var (a, _) = under(a.Elem())._<Array.val>(ᐧ); if (a != nil) {
                        if (Identical(s.Elem(), a.Elem())) {
                            if (check == nil || check.allowVersion(~x, go1_17)) {
                                return true;
                            }
                            // check != nil
                            if (cause != nil) {
                                cause = "conversion of slice to array pointer requires go1.17 or later"u8;
                            }
                            return false;
                        }
                    }
                }
                break;
            }}
        }
    }
    // optimization: if we don't have type parameters, we're done
    if (Vp == nil && Tp == nil) {
        return false;
    }
    var errorf = (@string format, params ꓸꓸꓸany argsʗp) => {
        if (check != nil && cause != nil) {
            @string msg = check.sprintf(format, args.ꓸꓸꓸ);
            if (cause != ""u8) {
                msg += "\n\t"u8 + cause;
            }
            cause = msg;
        }
    };
    // generic cases with specific type terms
    // (generic operands cannot be constants, so we can ignore x.val)
    switch (ᐧ) {
    case {} when Vp != nil && Tp != nil: {
        ref var xΔ2 = ref heap<operand>(out var ᏑxΔ2);
        xΔ2 = x;
        return Vp.@is(
        var Tpʗ5 = Tp;
        var Vpʗ5 = Vp;
        var errorfʗ5 = errorf;
        var xʗ5 = xΔ2;
        (ж<term> V) => {
            if (VΔ4 == nil) {
                return false;
            }
            xʗ5.typ = VΔ4.val.typ;
            return Tpʗ5.@is(
            var Tpʗ7 = Tp;
            var Vpʗ7 = Vp;
            var errorfʗ7 = errorf;
            var xʗ7 = xΔ2;
            (ж<term> T) => {
                if (TΔ4 == nil) {
                    return false;
                }
                if (!xʗ7.convertibleTo(Ꮡcheck, (~TΔ4).typ, Ꮡcause)) {
                    errorfʗ7("cannot convert %s (in %s) to type %s (in %s)"u8, (~VΔ4).typ, Vpʗ7, (~TΔ4).typ, Tpʗ7);
                    return false;
                }
                return true;
            });
        });
    }
    case {} when Vp != nil: {
        ref var xΔ3 = ref heap<operand>(out var ᏑxΔ3);
        xΔ3 = x;
        return Vp.@is(
        var Vpʗ14 = Vp;
        var errorfʗ14 = errorf;
        var origTʗ2 = origT;
        var xʗ14 = xΔ3;
        (ж<term> V) => {
            if (VΔ5 == nil) {
                return false;
            }
            xʗ14.typ = VΔ5.val.typ;
            if (!xʗ14.convertibleTo(Ꮡcheck, T, Ꮡcause)) {
                errorfʗ14("cannot convert %s (in %s) to type %s"u8, (~VΔ5).typ, Vpʗ14, origTʗ2);
                return false;
            }
            return true;
        });
    }
    case {} when Tp != nil: {
        return Tp.@is(
        var Tpʗ14 = Tp;
        var errorfʗ17 = errorf;
        (ж<term> T) => {
            if (TΔ5 == nil) {
                return false;
            }
            if (!x.convertibleTo(Ꮡcheck, (~TΔ5).typ, Ꮡcause)) {
                errorfʗ17("cannot convert %s to type %s (in %s)"u8, x.typ, (~TΔ5).typ, Tpʗ14);
                return false;
            }
            return true;
        });
    }}

    return false;
}

internal static bool isUintptr(ΔType typ) {
    var (t, _) = under(typ)._<Basic.val>(ᐧ);
    return t != nil && (~t).kind == Uintptr;
}

internal static bool isUnsafePointer(ΔType typ) {
    var (t, _) = under(typ)._<Basic.val>(ᐧ);
    return t != nil && (~t).kind == UnsafePointer;
}

internal static bool isPointer(ΔType typ) {
    var (_, ok) = under(typ)._<Pointer.val>(ᐧ);
    return ok;
}

internal static bool isBytesOrRunes(ΔType typ) {
    {
        var (s, _) = under(typ)._<Slice.val>(ᐧ); if (s != nil) {
            var (t, _) = under((~s).elem)._<Basic.val>(ᐧ);
            return t != nil && ((~t).kind == Byte || (~t).kind == Rune);
        }
    }
    return false;
}

} // end types_package
