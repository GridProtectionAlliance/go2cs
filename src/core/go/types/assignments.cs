// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/assignments.go
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements initialization and assignment checks.
namespace go.go;

using fmt = fmt_package;
using ast = go.ast_package;
using static @internal.types.errors_package;
using strings = strings_package;

partial class types_package {

// assignment reports whether x can be assigned to a variable of type T,
// if necessary by attempting to convert untyped values to the appropriate
// type. context describes the context in which the assignment takes place.
// Use T == nil to indicate assignment to an untyped blank identifier.
// If the assignment check fails, x.mode is set to invalid.
[GoRecv] public static void assignment(this ref Checker check, ж<operand> Ꮡx, ΔType T, @string context) {
    ref var x = ref Ꮡx.val;

    check.singleValue(Ꮡx);
    var exprᴛ1 = x.mode;
    if (exprᴛ1 == invalid) {
        return;
    }
    if (exprᴛ1 == nilvalue) {
        assert(isTypes2);
    }
    else if (exprᴛ1 == constant_ || exprᴛ1 == variable || exprᴛ1 == mapindex || exprᴛ1 == value || exprᴛ1 == commaok || exprᴛ1 == commaerr) {
    }
    else { /* default: */
        check.errorf(~x, // error reported before
 // ok
 // ok
 // we may get here because of other problems (go.dev/issue/39634, crash 12)
 // TODO(gri) do we need a new "generic" error code here?
 IncompatibleAssign, "cannot assign %s to %s in %s"u8, x, T, context);
        x.mode = invalid;
        return;
    }

    if (isUntyped(x.typ)) {
        var target = T;
        // spec: "If an untyped constant is assigned to a variable of interface
        // type or the blank identifier, the constant is first converted to type
        // bool, rune, int, float64, complex128 or string respectively, depending
        // on whether the value is a boolean, rune, integer, floating-point,
        // complex, or string constant."
        if (isTypes2){
            if (x.isNil()){
                if (T == default!) {
                    check.errorf(~x, UntypedNilUse, "use of untyped nil in %s"u8, context);
                    x.mode = invalid;
                    return;
                }
            } else 
            if (T == default! || isNonTypeParamInterface(T)) {
                target = Default(x.typ);
            }
        } else {
            // go/types
            if (T == default! || isNonTypeParamInterface(T)) {
                if (T == default! && x.typ == ~Typ[UntypedNil]) {
                    check.errorf(~x, UntypedNilUse, "use of untyped nil in %s"u8, context);
                    x.mode = invalid;
                    return;
                }
                target = Default(x.typ);
            }
        }
        var (newType, val, code) = check.implicitTypeAndValue(Ꮡx, target);
        if (code != 0) {
            @string msg = check.sprintf("cannot use %s as %s value in %s"u8, x, target, context);
            var exprᴛ2 = code;
            if (exprᴛ2 == TruncatedFloat) {
                msg += " (truncated)"u8;
            }
            else if (exprᴛ2 == NumericOverflow) {
                msg += " (overflows)"u8;
            }
            else { /* default: */
                code = IncompatibleAssign;
            }

            check.error(~x, code, msg);
            x.mode = invalid;
            return;
        }
        if (val != default!) {
            x.val = val;
            check.updateExprVal(x.expr, val);
        }
        if (!AreEqual(newType, x.typ)) {
            x.typ = newType;
            check.updateExprType(x.expr, newType, false);
        }
    }
    // x.typ is typed
    // A generic (non-instantiated) function value cannot be assigned to a variable.
    {
        var (sig, _) = under(x.typ)._<ΔSignature.val>(ᐧ); if (sig != nil && sig.TypeParams().Len() > 0) {
            check.errorf(~x, WrongTypeArgCount, "cannot use generic function %s without instantiation in %s"u8, x, context);
            x.mode = invalid;
            return;
        }
    }
    // spec: "If a left-hand side is the blank identifier, any typed or
    // non-constant value except for the predeclared identifier nil may
    // be assigned to it."
    if (T == default!) {
        return;
    }
    @string cause = ""u8;
    {
        var (ok, code) = x.assignableTo(check, T, Ꮡcause); if (!ok) {
            if (cause != ""u8){
                check.errorf(~x, code, "cannot use %s as %s value in %s: %s"u8, x, T, context, cause);
            } else {
                check.errorf(~x, code, "cannot use %s as %s value in %s"u8, x, T, context);
            }
            x.mode = invalid;
        }
    }
}

[GoRecv] public static void initConst(this ref Checker check, ж<Const> Ꮡlhs, ж<operand> Ꮡx) {
    ref var lhs = ref Ꮡlhs.val;
    ref var x = ref Ꮡx.val;

    if (x.mode == invalid || !isValid(x.typ) || !isValid(lhs.typ)) {
        if (lhs.typ == default!) {
            lhs.typ = Typ[Invalid];
        }
        return;
    }
    // rhs must be a constant
    if (x.mode != constant_) {
        check.errorf(~x, InvalidConstInit, "%s is not constant"u8, x);
        if (lhs.typ == default!) {
            lhs.typ = Typ[Invalid];
        }
        return;
    }
    assert(isConstType(x.typ));
    // If the lhs doesn't have a type yet, use the type of x.
    if (lhs.typ == default!) {
        lhs.typ = x.typ;
    }
    check.assignment(Ꮡx, lhs.typ, "constant declaration"u8);
    if (x.mode == invalid) {
        return;
    }
    lhs.val = x.val;
}

// initVar checks the initialization lhs = x in a variable declaration.
// If lhs doesn't have a type yet, it is given the type of x,
// or Typ[Invalid] in case of an error.
// If the initialization check fails, x.mode is set to invalid.
[GoRecv] public static void initVar(this ref Checker check, ж<Var> Ꮡlhs, ж<operand> Ꮡx, @string context) {
    ref var lhs = ref Ꮡlhs.val;
    ref var x = ref Ꮡx.val;

    if (x.mode == invalid || !isValid(x.typ) || !isValid(lhs.typ)) {
        if (lhs.typ == default!) {
            lhs.typ = Typ[Invalid];
        }
        x.mode = invalid;
        return;
    }
    // If lhs doesn't have a type yet, use the type of x.
    if (lhs.typ == default!) {
        var typ = x.typ;
        if (isUntyped(typ)) {
            // convert untyped types to default types
            if (Ꮡtyp == ~Typ[UntypedNil]) {
                check.errorf(~x, UntypedNilUse, "use of untyped nil in %s"u8, context);
                lhs.typ = Typ[Invalid];
                x.mode = invalid;
                return;
            }
            typ = Default(typ);
        }
        lhs.typ = typ;
    }
    check.assignment(Ꮡx, lhs.typ, context);
}

// lhsVar checks a lhs variable in an assignment and returns its type.
// lhsVar takes care of not counting a lhs identifier as a "use" of
// that identifier. The result is nil if it is the blank identifier,
// and Typ[Invalid] if it is an invalid lhs expression.
[GoRecv] internal static ΔType lhsVar(this ref Checker check, ast.Expr lhs) {
    // Determine if the lhs is a (possibly parenthesized) identifier.
    var (ident, _) = ast.Unparen(lhs)._<ж<ast.Ident>>(ᐧ);
    // Don't evaluate lhs if it is the blank identifier.
    if (ident != nil && (~ident).Name == "_"u8) {
        check.recordDef(ident, default!);
        return default!;
    }
    // If the lhs is an identifier denoting a variable v, this reference
    // is not a 'use' of v. Remember current value of v.used and restore
    // after evaluating the lhs via check.expr.
    ж<Var> v = default!;
    bool v_used = default!;
    if (ident != nil) {
        {
            var obj = check.lookup((~ident).Name); if (obj != default!) {
                // It's ok to mark non-local variables, but ignore variables
                // from other packages to avoid potential race conditions with
                // dot-imported variables.
                {
                    var (w, _) = obj._<Var.val>(ᐧ); if (w != nil && w.pkg == check.pkg) {
                        v = w;
                        v_used = v.val.used;
                    }
                }
            }
        }
    }
    ref var x = ref heap(new operand(), out var Ꮡx);
    check.expr(nil, Ꮡx, lhs);
    if (v != nil) {
        v.val.used = v_used;
    }
    // restore v.used
    if (x.mode == invalid || !isValid(x.typ)) {
        return ~Typ[Invalid];
    }
    // spec: "Each left-hand side operand must be addressable, a map index
    // expression, or the blank identifier. Operands may be parenthesized."
    var exprᴛ1 = x.mode;
    if (exprᴛ1 == invalid) {
        return ~Typ[Invalid];
    }
    if (exprᴛ1 == variable || exprᴛ1 == mapindex) {
    }
    { /* default: */
        {
            var (sel, ok) = x.expr._<ж<ast.SelectorExpr>>(ᐧ); if (ok) {
                // ok
                ref var op = ref heap(new operand(), out var Ꮡop);
                check.expr(nil, Ꮡop, (~sel).X);
                if (op.mode == mapindex) {
                    check.errorf(~Ꮡx, UnaddressableFieldAssign, "cannot assign to struct field %s in map"u8, ExprString(x.expr));
                    return ~Typ[Invalid];
                }
            }
        }
        check.errorf(~Ꮡx, UnassignableOperand, "cannot assign to %s (neither addressable nor a map index expression)"u8, x.expr);
        return ~Typ[Invalid];
    }

    return x.typ;
}

// assignVar checks the assignment lhs = rhs (if x == nil), or lhs = x (if x != nil).
// If x != nil, it must be the evaluation of rhs (and rhs will be ignored).
// If the assignment check fails and x != nil, x.mode is set to invalid.
[GoRecv] public static void assignVar(this ref Checker check, ast.Expr lhs, ast.Expr rhs, ж<operand> Ꮡx, @string context) {
    ref var x = ref Ꮡx.val;

    var T = check.lhsVar(lhs);
    // nil if lhs is _
    if (!isValid(T)) {
        if (x != nil){
            x.mode = invalid;
        } else {
            check.use(rhs);
        }
        return;
    }
    if (x == nil) {
        ж<target> target = default!;
        // avoid calling ExprString if not needed
        if (T != default!) {
            {
                var (_, ok) = under(T)._<ΔSignature.val>(ᐧ); if (ok) {
                    target = newTarget(T, ExprString(lhs));
                }
            }
        }
        x = @new<operand>();
        check.expr(target, Ꮡx, rhs);
    }
    if (T == default! && context == "assignment"u8) {
        context = "assignment to _ identifier"u8;
    }
    check.assignment(Ꮡx, T, context);
}

// operandTypes returns the list of types for the given operands.
internal static slice<ΔType> /*res*/ operandTypes(slice<ж<operand>> list) {
    slice<ΔType> res = default!;

    foreach (var (_, x) in list) {
        res = append(res, (~x).typ);
    }
    return res;
}

// varTypes returns the list of types for the given variables.
internal static slice<ΔType> /*res*/ varTypes(slice<ж<Var>> list) {
    slice<ΔType> res = default!;

    foreach (var (_, x) in list) {
        res = append(res, x.typ);
    }
    return res;
}

// typesSummary returns a string of the form "(t1, t2, ...)" where the
// ti's are user-friendly string representations for the given types.
// If variadic is set and the last type is a slice, its string is of
// the form "...E" where E is the slice's element type.
[GoRecv] internal static @string typesSummary(this ref Checker check, slice<ΔType> list, bool variadic) {
    slice<@string> res = default!;
    foreach (var (i, t) in list) {
        @string s = default!;
        var matchᴛ1 = false;
        if (t is default!) { matchᴛ1 = true;
            fallthrough = true;
        }
        if (fallthrough || !matchᴛ1 && (!isValid(t))) { matchᴛ1 = true;
            s = "unknown type"u8;
        }
        else if (isUntyped(t))) {
            if (isNumeric(t)){
                // should not happen but be cautious
                // Do not imply a specific type requirement:
                // "have number, want float64" is better than
                // "have untyped int, want float64" or
                // "have int, want float64".
                s = "number"u8;
            } else {
                // If we don't have a number, omit the "untyped" qualifier
                // for compactness.
                s = strings.Replace(t._<Basic.val>().name, "untyped "u8, ""u8, -1);
            }
        }
        else if (variadic && i == len(list) - 1)) { matchᴛ1 = true;
            s = check.sprintf("...%s"u8, t._<Slice.val>().elem);
        }

        if (s == ""u8) {
            s = check.sprintf("%s"u8, t);
        }
        res = append(res, s);
    }
    return "("u8 + strings.Join(res, ", "u8) + ")"u8;
}

internal static @string measure(nint x, @string unit) {
    if (x != 1) {
        unit += "s"u8;
    }
    return fmt.Sprintf("%d %s"u8, x, unit);
}

[GoRecv] internal static void assignError(this ref Checker check, slice<ast.Expr> rhs, nint l, nint r) {
    @string vars = measure(l, "variable"u8);
    @string vals = measure(r, "value"u8);
    var rhs0 = rhs[0];
    if (len(rhs) == 1) {
        {
            var (call, _) = ast.Unparen(rhs0)._<ж<ast.CallExpr>>(ᐧ); if (call != nil) {
                check.errorf(rhs0, WrongAssignCount, "assignment mismatch: %s but %s returns %s"u8, vars, (~call).Fun, vals);
                return;
            }
        }
    }
    check.errorf(rhs0, WrongAssignCount, "assignment mismatch: %s but %s"u8, vars, vals);
}

[GoRecv] internal static void returnError(this ref Checker check, positioner at, slice<ж<Var>> lhs, slice<ж<operand>> rhs) {
    nint l = len(lhs);
    nint r = len(rhs);
    @string qualifier = "not enough"u8;
    if (r > l){
        at = ~rhs[l];
        // report at first extra value
        qualifier = "too many"u8;
    } else 
    if (r > 0) {
        at = ~rhs[r - 1];
    }
    // report at last value
    var err = check.newError(WrongResultCount);
    err.addf(at, "%s return values"u8, qualifier);
    err.addf(noposn, "have %s"u8, check.typesSummary(operandTypes(rhs), false));
    err.addf(noposn, "want %s"u8, check.typesSummary(varTypes(lhs), false));
    err.report();
}

// initVars type-checks assignments of initialization expressions orig_rhs
// to variables lhs.
// If returnStmt is non-nil, initVars type-checks the implicit assignment
// of result expressions orig_rhs to function result parameters lhs.
[GoRecv] internal static void initVars(this ref Checker check, slice<ж<Var>> lhs, slice<ast.Expr> orig_rhs, ast.Stmt returnStmt) {
    @string context = "assignment"u8;
    if (returnStmt != default!) {
        context = "return statement"u8;
    }
    nint l = len(lhs);
    nint r = len(orig_rhs);
    // If l == 1 and the rhs is a single call, for a better
    // error message don't handle it as n:n mapping below.
    var isCall = false;
    if (r == 1) {
        (_, isCall) = ast.Unparen(orig_rhs[0])._<ж<ast.CallExpr>>(ᐧ);
    }
    // If we have a n:n mapping from lhs variable to rhs expression,
    // each value can be assigned to its corresponding variable.
    if (l == r && !isCall) {
        ref var x = ref heap(new operand(), out var Ꮡx);
        foreach (var (i, lhsΔ1) in lhs) {
            @string desc = lhsΔ1.name;
            if (returnStmt != default! && desc == ""u8) {
                desc = "result variable"u8;
            }
            check.expr(newTarget(lhsΔ1.typ, desc), Ꮡx, orig_rhs[i]);
            check.initVar(ᏑlhsΔ1, Ꮡx, context);
        }
        return;
    }
    // If we don't have an n:n mapping, the rhs must be a single expression
    // resulting in 2 or more values; otherwise we have an assignment mismatch.
    if (r != 1) {
        // Only report a mismatch error if there are no other errors on the rhs.
        if (check.use(orig_rhs.ꓸꓸꓸ)) {
            if (returnStmt != default!){
                var rhsΔ1 = check.exprList(orig_rhs);
                check.returnError(returnStmt, lhs, rhsΔ1);
            } else {
                check.assignError(orig_rhs, l, r);
            }
        }
        // ensure that LHS variables have a type
        foreach (var (_, v) in lhs) {
            if (v.typ == default!) {
                v.typ = Typ[Invalid];
            }
        }
        return;
    }
    var (rhs, commaOk) = check.multiExpr(orig_rhs[0], l == 2 && returnStmt == default!);
    r = len(rhs);
    if (l == r) {
        ref var i = ref heap(new nint(), out var Ꮡi);

        foreach (var (i, lhsΔ2) in lhs) {
            check.initVar(ᏑlhsΔ2, rhs[i], context);
        }
        // Only record comma-ok expression if both initializations succeeded
        // (go.dev/issue/59371).
        if (commaOk && (~rhs[0]).mode != invalid && (~rhs[1]).mode != invalid) {
            check.recordCommaOkTypes(orig_rhs[0], rhs);
        }
        return;
    }
    // In all other cases we have an assignment mismatch.
    // Only report a mismatch error if there are no other errors on the rhs.
    if ((~rhs[0]).mode != invalid) {
        if (returnStmt != default!){
            check.returnError(returnStmt, lhs, rhs);
        } else {
            check.assignError(orig_rhs, l, r);
        }
    }
    // ensure that LHS variables have a type
    foreach (var (_, v) in lhs) {
        if (v.typ == default!) {
            v.typ = Typ[Invalid];
        }
    }
}

// orig_rhs[0] was already evaluated

// assignVars type-checks assignments of expressions orig_rhs to variables lhs.
[GoRecv] internal static void assignVars(this ref Checker check, slice<ast.Expr> lhs, slice<ast.Expr> orig_rhs) {
    nint l = len(lhs);
    nint r = len(orig_rhs);
    // If l == 1 and the rhs is a single call, for a better
    // error message don't handle it as n:n mapping below.
    var isCall = false;
    if (r == 1) {
        (_, isCall) = ast.Unparen(orig_rhs[0])._<ж<ast.CallExpr>>(ᐧ);
    }
    // If we have a n:n mapping from lhs variable to rhs expression,
    // each value can be assigned to its corresponding variable.
    if (l == r && !isCall) {
        foreach (var (i, lhsΔ1) in lhs) {
            check.assignVar(lhsΔ1, orig_rhs[i], nil, "assignment"u8);
        }
        return;
    }
    // If we don't have an n:n mapping, the rhs must be a single expression
    // resulting in 2 or more values; otherwise we have an assignment mismatch.
    if (r != 1) {
        // Only report a mismatch error if there are no other errors on the lhs or rhs.
        var okLHS = check.useLHS(lhs.ꓸꓸꓸ);
        var okRHS = check.use(orig_rhs.ꓸꓸꓸ);
        if (okLHS && okRHS) {
            check.assignError(orig_rhs, l, r);
        }
        return;
    }
    var (rhs, commaOk) = check.multiExpr(orig_rhs[0], l == 2);
    r = len(rhs);
    if (l == r) {
        ref var i = ref heap(new nint(), out var Ꮡi);

        foreach (var (i, lhsΔ2) in lhs) {
            check.assignVar(lhsΔ2, default!, rhs[i], "assignment"u8);
        }
        // Only record comma-ok expression if both assignments succeeded
        // (go.dev/issue/59371).
        if (commaOk && (~rhs[0]).mode != invalid && (~rhs[1]).mode != invalid) {
            check.recordCommaOkTypes(orig_rhs[0], rhs);
        }
        return;
    }
    // In all other cases we have an assignment mismatch.
    // Only report a mismatch error if there are no other errors on the rhs.
    if ((~rhs[0]).mode != invalid) {
        check.assignError(orig_rhs, l, r);
    }
    check.useLHS(lhs.ꓸꓸꓸ);
}

// orig_rhs[0] was already evaluated
[GoRecv] internal static void shortVarDecl(this ref Checker check, positioner pos, slice<ast.Expr> lhs, slice<ast.Expr> rhs) {
    nint top = len(check.delayed);
    var scope = check.scope;
    // collect lhs variables
    var seen = new map<@string, bool>(len(lhs));
    var lhsVars = new slice<ж<Var>>(len(lhs));
    var newVars = new slice<ж<Var>>(0, len(lhs));
    var hasErr = false;
    foreach (var (i, lhsΔ1) in lhs) {
        var (ident, _) = lhsΔ1._<ж<ast.Ident>>(ᐧ);
        if (ident == nil) {
            check.useLHS(lhsΔ1);
            // TODO(gri) This is redundant with a go/parser error. Consider omitting in go/types?
            check.errorf(lhsΔ1, BadDecl, "non-name %s on left side of :="u8, lhsΔ1);
            hasErr = true;
            continue;
        }
        @string name = ident.val.Name;
        if (name != "_"u8) {
            if (seen[name]) {
                check.errorf(lhsΔ1, RepeatedDecl, "%s repeated on left side of :="u8, lhsΔ1);
                hasErr = true;
                continue;
            }
            seen[name] = true;
        }
        // Use the correct obj if the ident is redeclared. The
        // variable's scope starts after the declaration; so we
        // must use Scope.Lookup here and call Scope.Insert
        // (via check.declare) later.
        {
            var alt = scope.Lookup(name); if (alt != default!) {
                check.recordUse(ident, alt);
                // redeclared object must be a variable
                {
                    var (obj, _) = alt._<Var.val>(ᐧ); if (obj != nil){
                        lhsVars[i] = obj;
                    } else {
                        check.errorf(lhsΔ1, UnassignableOperand, "cannot assign to %s"u8, lhsΔ1);
                        hasErr = true;
                    }
                }
                continue;
            }
        }
        // declare new variable
        var obj = NewVar(ident.Pos(), check.pkg, name, default!);
        lhsVars[i] = obj;
        if (name != "_"u8) {
            newVars = append(newVars, obj);
        }
        check.recordDef(ident, ~obj);
    }
    // create dummy variables where the lhs is invalid
    foreach (var (i, obj) in lhsVars) {
        if (obj == nil) {
            lhsVars[i] = NewVar(lhs[i].Pos(), check.pkg, "_"u8, default!);
        }
    }
    check.initVars(lhsVars, rhs, default!);
    // process function literals in rhs expressions before scope changes
    check.processDelayed(top);
    if (len(newVars) == 0 && !hasErr) {
        check.softErrorf(pos, NoNewVar, "no new variables on left side of :="u8);
        return;
    }
    // declare new variables
    // spec: "The scope of a constant or variable identifier declared inside
    // a function begins at the end of the ConstSpec or VarSpec (ShortVarDecl
    // for short variable declarations) and ends at the end of the innermost
    // containing block."
    tokenꓸPos scopePos = endPos(rhs[len(rhs) - 1]);
    foreach (var (_, obj) in newVars) {
        check.declare(scope, nil, ~obj, scopePos);
    }
}

// id = nil: recordDef already called

} // end types_package
