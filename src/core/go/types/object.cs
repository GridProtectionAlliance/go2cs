// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/object.go
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go.go;

using bytes = bytes_package;
using fmt = fmt_package;
using constant = go.constant_package;
using token = go.token_package;
using strings = strings_package;
using unicode = unicode_package;
using utf8 = unicode.utf8_package;
using unicode;

partial class types_package {

// An Object describes a named language entity such as a package,
// constant, type, variable, function (incl. methods), or label.
// All objects implement the Object interface.
[GoType] partial interface Object {
    ж<ΔScope> Parent(); // scope in which this object is declared; nil for methods and struct fields
    tokenꓸPos Pos(); // position of object identifier in declaration
    ж<Package> Pkg(); // package to which this object belongs; nil for labels and objects in the Universe scope
    @string Name();  // package local object name
    ΔType Type();   // object type
    bool Exported(); // reports whether the name starts with a capital letter
    @string Id();    // object name if exported, qualified name if not exported (see func Id)
    // String returns a human-readable string of the object.
    @string String();
    // order reflects a package-level object's source order: if object
    // a is before object b in the source, then a.order() < b.order().
    // order returns a value > 0 for package-level objects; it returns
    // 0 for all other objects (including objects in file scopes).
    uint32 order();
    // color returns the object's color.
    Δcolor color();
    // setType sets the type of the object.
    void setType(ΔType _);
    // setOrder sets the order number of the object. It must be > 0.
    void setOrder(uint32 _);
    // setColor sets the object's color. It must not be white.
    void setColor(Δcolor Δcolor);
    // setParent sets the parent scope of the object.
    void setParent(ж<ΔScope> _);
    // sameId reports whether obj.Id() and Id(pkg, name) are the same.
    // If foldCase is true, names are considered equal if they are equal with case folding
    // and their packages are ignored (e.g., pkg1.m, pkg1.M, pkg2.m, and pkg2.M are all equal).
    bool sameId(ж<Package> pkg, @string name, bool foldCase);
    // scopePos returns the start position of the scope of this Object
    tokenꓸPos scopePos();
    // setScopePos sets the start position of the scope for this Object.
    void setScopePos(tokenꓸPos pos);
}

internal static bool isExported(@string name) {
    var (ch, _) = utf8.DecodeRuneInString(name);
    return unicode.IsUpper(ch);
}

// Id returns name if it is exported, otherwise it
// returns the name qualified with the package path.
public static @string Id(ж<Package> Ꮡpkg, @string name) {
    ref var pkg = ref Ꮡpkg.val;

    if (isExported(name)) {
        return name;
    }
    // unexported names need the package path for differentiation
    // (if there's no package, make sure we don't start with '.'
    // as that may change the order of methods between a setup
    // inside a package and outside a package - which breaks some
    // tests)
    @string path = "_"u8;
    // pkg is nil for objects in Universe scope and possibly types
    // introduced via Eval (see also comment in object.sameId)
    if (pkg != nil && pkg.path != ""u8) {
        path = pkg.path;
    }
    return path + "."u8 + name;
}

// An object implements the common parts of an Object.
[GoType] partial struct @object {
    internal ж<ΔScope> parent;
    internal go.token_package.ΔPos pos;
    internal ж<Package> pkg;
    internal @string name;
    internal ΔType typ;
    internal uint32 order_;
    internal Δcolor color_;
    internal go.token_package.ΔPos scopePos_;
}

[GoType("num:uint32")] partial struct Δcolor;

// An object may be painted in one of three colors.
// Color values other than white or black are considered grey.
internal static readonly Δcolor white = /* iota */ 0;

internal static readonly Δcolor black = 1;

internal static readonly Δcolor grey = 2; // must be > white and black

public static @string String(this Δcolor c) {
    var exprᴛ1 = c;
    if (exprᴛ1 == white) {
        return "white"u8;
    }
    if (exprᴛ1 == black) {
        return "black"u8;
    }
    { /* default: */
        return "grey"u8;
    }

}

// colorFor returns the (initial) color for an object depending on
// whether its type t is known or not.
internal static Δcolor colorFor(ΔType t) {
    if (t != default!) {
        return black;
    }
    return white;
}

// Parent returns the scope in which the object is declared.
// The result is nil for methods and struct fields.
[GoRecv] public static ж<ΔScope> Parent(this ref @object obj) {
    return obj.parent;
}

// Pos returns the declaration position of the object's identifier.
[GoRecv] public static tokenꓸPos Pos(this ref @object obj) {
    return obj.pos;
}

// Pkg returns the package to which the object belongs.
// The result is nil for labels and objects in the Universe scope.
[GoRecv] public static ж<Package> Pkg(this ref @object obj) {
    return obj.pkg;
}

// Name returns the object's (package-local, unqualified) name.
[GoRecv] public static @string Name(this ref @object obj) {
    return obj.name;
}

// Type returns the object's type.
[GoRecv] public static ΔType Type(this ref @object obj) {
    return obj.typ;
}

// Exported reports whether the object is exported (starts with a capital letter).
// It doesn't take into account whether the object is in a local (function) scope
// or not.
[GoRecv] public static bool Exported(this ref @object obj) {
    return isExported(obj.name);
}

// Id is a wrapper for Id(obj.Pkg(), obj.Name()).
[GoRecv] public static @string Id(this ref @object obj) {
    return Id(obj.pkg, obj.name);
}

[GoRecv] public static @string String(this ref @object obj) {
    throw panic("abstract");
}

[GoRecv] internal static uint32 order(this ref @object obj) {
    return obj.order_;
}

[GoRecv] internal static Δcolor color(this ref @object obj) {
    return obj.color_;
}

[GoRecv] internal static tokenꓸPos scopePos(this ref @object obj) {
    return obj.scopePos_;
}

[GoRecv] public static void setParent(this ref @object obj, ж<ΔScope> Ꮡparent) {
    ref var parent = ref Ꮡparent.val;

    obj.parent = parent;
}

[GoRecv] internal static void setType(this ref @object obj, ΔType typ) {
    obj.typ = typ;
}

[GoRecv] internal static void setOrder(this ref @object obj, uint32 order) {
    assert(order > 0);
    obj.order_ = order;
}

[GoRecv] internal static void setColor(this ref @object obj, Δcolor Δcolor) {
    assert(Δcolor != white);
    obj.color_ = Δcolor;
}

[GoRecv] internal static void setScopePos(this ref @object obj, tokenꓸPos pos) {
    obj.scopePos_ = pos;
}

[GoRecv] public static bool sameId(this ref @object obj, ж<Package> Ꮡpkg, @string name, bool foldCase) {
    ref var pkg = ref Ꮡpkg.val;

    // If we don't care about capitalization, we also ignore packages.
    if (foldCase && strings.EqualFold(obj.name, name)) {
        return true;
    }
    // spec:
    // "Two identifiers are different if they are spelled differently,
    // or if they appear in different packages and are not exported.
    // Otherwise, they are the same."
    if (obj.name != name) {
        return false;
    }
    // obj.Name == name
    if (obj.Exported()) {
        return true;
    }
    // not exported, so packages must be the same
    return samePkg(obj.pkg, Ꮡpkg);
}

// less reports whether object a is ordered before object b.
//
// Objects are ordered nil before non-nil, exported before
// non-exported, then by name, and finally (for non-exported
// functions) by package path.
[GoRecv] public static bool less(this ref @object a, ж<@object> Ꮡb) {
    ref var b = ref Ꮡb.val;

    if (a == Ꮡb) {
        return false;
    }
    // Nil before non-nil.
    if (a == nil) {
        return true;
    }
    if (b == nil) {
        return false;
    }
    // Exported functions before non-exported.
    var ea = isExported(a.name);
    var eb = isExported(b.name);
    if (ea != eb) {
        return ea;
    }
    // Order by name and then (for non-exported names) by package.
    if (a.name != b.name) {
        return a.name < b.name;
    }
    if (!ea) {
        return a.pkg.path < b.pkg.path;
    }
    return false;
}

// A PkgName represents an imported Go package.
// PkgNames don't have a type.
[GoType] partial struct PkgName {
    internal partial ref @object @object { get; }
    internal ж<Package> imported;
    internal bool used; // set if the package was used
}

// NewPkgName returns a new PkgName object representing an imported package.
// The remaining arguments set the attributes found with all Objects.
public static ж<PkgName> NewPkgName(tokenꓸPos pos, ж<Package> Ꮡpkg, @string name, ж<Package> Ꮡimported) {
    ref var pkg = ref Ꮡpkg.val;
    ref var imported = ref Ꮡimported.val;

    return Ꮡ(new PkgName(new @object(nil, pos, Ꮡpkg, name, Typ[Invalid], 0, black, nopos), Ꮡimported, false));
}

// Imported returns the package that was imported.
// It is distinct from Pkg(), which is the package containing the import statement.
[GoRecv] public static ж<Package> Imported(this ref PkgName obj) {
    return obj.imported;
}

// A Const represents a declared constant.
[GoType] partial struct Const {
    internal partial ref @object @object { get; }
    internal go.constant_package.Value val;
}

// NewConst returns a new constant with value val.
// The remaining arguments set the attributes found with all Objects.
public static ж<Const> NewConst(tokenꓸPos pos, ж<Package> Ꮡpkg, @string name, ΔType typ, constant.Value val) {
    ref var pkg = ref Ꮡpkg.val;

    return Ꮡ(new Const(new @object(nil, pos, Ꮡpkg, name, typ, 0, colorFor(typ), nopos), val));
}

// Val returns the constant's value.
[GoRecv] public static constant.Value Val(this ref Const obj) {
    return obj.val;
}

[GoRecv] internal static void isDependency(this ref Const _) {
}

// a constant may be a dependency of an initialization expression

// A TypeName represents a name for a (defined or alias) type.
[GoType] partial struct TypeName {
    internal partial ref @object @object { get; }
}

// NewTypeName returns a new type name denoting the given typ.
// The remaining arguments set the attributes found with all Objects.
//
// The typ argument may be a defined (Named) type or an alias type.
// It may also be nil such that the returned TypeName can be used as
// argument for NewNamed, which will set the TypeName's type as a side-
// effect.
public static ж<TypeName> NewTypeName(tokenꓸPos pos, ж<Package> Ꮡpkg, @string name, ΔType typ) {
    ref var pkg = ref Ꮡpkg.val;

    return Ꮡ(new TypeName(new @object(nil, pos, Ꮡpkg, name, typ, 0, colorFor(typ), nopos)));
}

// NewTypeNameLazy returns a new defined type like NewTypeName, but it
// lazily calls resolve to finish constructing the Named object.
internal static ж<TypeName> _NewTypeNameLazy(tokenꓸPos pos, ж<Package> Ꮡpkg, @string name, types.Func) load) {
    ref var pkg = ref Ꮡpkg.val;

    var obj = NewTypeName(pos, Ꮡpkg, name, default!);
    NewNamed(obj, default!, default!).val.loader = load;
    return obj;
}

// IsAlias reports whether obj is an alias name for a type.
[GoRecv] public static bool IsAlias(this ref TypeName obj) {
    switch (obj.typ.type()) {
    case default! t: {
        return false;
    }
    case Basic.val t: {
        if (obj.pkg == Unsafe) {
            // case *Alias:
            //	handled by default case
            // unsafe.Pointer is not an alias.
            return false;
        }
        return obj.pkg != nil || (~t).name != obj.name || ~t == ᏑuniverseByte || ~t == ᏑuniverseRune;
    }
    case Named.val t: {
        return obj != (~t).obj;
    }
    case TypeParam.val t: {
        return obj != (~t).obj;
    }
    default: {
        var t = obj.typ.type();
        return true;
    }}
}

// Any user-defined type name for a basic type is an alias for a
// basic type (because basic types are pre-declared in the Universe
// scope, outside any package scope), and so is any type name with
// a different name than the name of the basic type it refers to.
// Additionally, we need to look for "byte" and "rune" because they
// are aliases but have the same names (for better error messages).

// A Variable represents a declared variable (including function parameters and results, and struct fields).
[GoType] partial struct Var {
    internal partial ref @object @object { get; }
    internal bool embedded; // if set, the variable is an embedded struct field, and name is the type name
    internal bool isField; // var is struct field
    internal bool used; // set if the variable was used
    internal ж<Var> origin; // if non-nil, the Var from which this one was instantiated
}

// NewVar returns a new variable.
// The arguments set the attributes found with all Objects.
public static ж<Var> NewVar(tokenꓸPos pos, ж<Package> Ꮡpkg, @string name, ΔType typ) {
    ref var pkg = ref Ꮡpkg.val;

    return Ꮡ(new Var(@object: new @object(nil, pos, Ꮡpkg, name, typ, 0, colorFor(typ), nopos)));
}

// NewParam returns a new variable representing a function parameter.
public static ж<Var> NewParam(tokenꓸPos pos, ж<Package> Ꮡpkg, @string name, ΔType typ) {
    ref var pkg = ref Ꮡpkg.val;

    return Ꮡ(new Var(@object: new @object(nil, pos, Ꮡpkg, name, typ, 0, colorFor(typ), nopos), used: true));
}

// parameters are always 'used'

// NewField returns a new variable representing a struct field.
// For embedded fields, the name is the unqualified type name
// under which the field is accessible.
public static ж<Var> NewField(tokenꓸPos pos, ж<Package> Ꮡpkg, @string name, ΔType typ, bool embedded) {
    ref var pkg = ref Ꮡpkg.val;

    return Ꮡ(new Var(@object: new @object(nil, pos, Ꮡpkg, name, typ, 0, colorFor(typ), nopos), embedded: embedded, isField: true));
}

// Anonymous reports whether the variable is an embedded field.
// Same as Embedded; only present for backward-compatibility.
[GoRecv] public static bool Anonymous(this ref Var obj) {
    return obj.embedded;
}

// Embedded reports whether the variable is an embedded field.
[GoRecv] public static bool Embedded(this ref Var obj) {
    return obj.embedded;
}

// IsField reports whether the variable is a struct field.
[GoRecv] public static bool IsField(this ref Var obj) {
    return obj.isField;
}

// Origin returns the canonical Var for its receiver, i.e. the Var object
// recorded in Info.Defs.
//
// For synthetic Vars created during instantiation (such as struct fields or
// function parameters that depend on type arguments), this will be the
// corresponding Var on the generic (uninstantiated) type. For all other Vars
// Origin returns the receiver.
[GoRecv("capture")] public static ж<Var> Origin(this ref Var obj) {
    if (obj.origin != nil) {
        return obj.origin;
    }
    return OriginꓸᏑobj;
}

[GoRecv] internal static void isDependency(this ref Var _) {
}

// a variable may be a dependency of an initialization expression

// A Func represents a declared function, concrete method, or abstract
// (interface) method. Its Type() is always a *Signature.
// An abstract method may belong to many interfaces due to embedding.
[GoType] partial struct Func {
    internal partial ref @object @object { get; }
    internal bool hasPtrRecv_;  // only valid for methods that don't have a type yet; use hasPtrRecv() to read
    internal ж<Func> origin; // if non-nil, the Func from which this one was instantiated
}

// NewFunc returns a new function with the given signature, representing
// the function's type.
public static ж<Func> NewFunc(tokenꓸPos pos, ж<Package> Ꮡpkg, @string name, ж<ΔSignature> Ꮡsig) {
    ref var pkg = ref Ꮡpkg.val;
    ref var sig = ref Ꮡsig.val;

    ΔType typ = default!;
    if (sig != nil){
        typ = ~sig;
    } else {
    }
    // Don't store a (typed) nil *Signature.
    // We can't simply replace it with new(Signature) either,
    // as this would violate object.{Type,color} invariants.
    // TODO(adonovan): propose to disallow NewFunc with nil *Signature.
    return Ꮡ(new Func(new @object(nil, pos, Ꮡpkg, name, typ, 0, colorFor(typ), nopos), false, nil));
}

// Signature returns the signature (type) of the function or method.
[GoRecv] public static ж<ΔSignature> Signature(this ref Func obj) {
    if (obj.typ != default!) {
        return obj.typ._<ΔSignature.val>();
    }
    // normal case
    // No signature: Signature was called either:
    // - within go/types, before a FuncDecl's initially
    //   nil Func.Type was lazily populated, indicating
    //   a types bug; or
    // - by a client after NewFunc(..., nil),
    //   which is arguably a client bug, but we need a
    //   proposal to tighten NewFunc's precondition.
    // For now, return a trivial signature.
    return @new<ΔSignature>();
}

// FullName returns the package- or receiver-type-qualified name of
// function or method obj.
[GoRecv] public static @string FullName(this ref Func obj) {
    ref var buf = ref heap(new bytes_package.Buffer(), out var Ꮡbuf);
    writeFuncName(Ꮡbuf, obj, default!);
    return buf.String();
}

// Scope returns the scope of the function's body block.
// The result is nil for imported or instantiated functions and methods
// (but there is also no mechanism to get to an instantiated function).
[GoRecv] public static ж<ΔScope> Scope(this ref Func obj) {
    return obj.typ._<ΔSignature.val>().scope;
}

// Origin returns the canonical Func for its receiver, i.e. the Func object
// recorded in Info.Defs.
//
// For synthetic functions created during instantiation (such as methods on an
// instantiated Named type or interface methods that depend on type arguments),
// this will be the corresponding Func on the generic (uninstantiated) type.
// For all other Funcs Origin returns the receiver.
[GoRecv("capture")] public static ж<Func> Origin(this ref Func obj) {
    if (obj.origin != nil) {
        return obj.origin;
    }
    return OriginꓸᏑobj;
}

// Pkg returns the package to which the function belongs.
//
// The result is nil for methods of types in the Universe scope,
// like method Error of the error built-in interface type.
[GoRecv] public static ж<Package> Pkg(this ref Func obj) {
    return obj.@object.Pkg();
}

// hasPtrRecv reports whether the receiver is of the form *T for the given method obj.
[GoRecv] internal static bool hasPtrRecv(this ref Func obj) {
    // If a method's receiver type is set, use that as the source of truth for the receiver.
    // Caution: Checker.funcDecl (decl.go) marks a function by setting its type to an empty
    // signature. We may reach here before the signature is fully set up: we must explicitly
    // check if the receiver is set (we cannot just look for non-nil obj.typ).
    {
        var (sig, _) = obj.typ._<ΔSignature.val>(ᐧ); if (sig != nil && (~sig).recv != nil) {
            var (_, isPtr) = deref((~sig).recv.typ);
            return isPtr;
        }
    }
    // If a method's type is not set it may be a method/function that is:
    // 1) client-supplied (via NewFunc with no signature), or
    // 2) internally created but not yet type-checked.
    // For case 1) we can't do anything; the client must know what they are doing.
    // For case 2) we can use the information gathered by the resolver.
    return obj.hasPtrRecv_;
}

[GoRecv] internal static void isDependency(this ref Func _) {
}

// a function may be a dependency of an initialization expression

// A Label represents a declared label.
// Labels don't have a type.
[GoType] partial struct Label {
    internal partial ref @object @object { get; }
    internal bool used; // set if the label was used
}

// NewLabel returns a new label.
public static ж<Label> NewLabel(tokenꓸPos pos, ж<Package> Ꮡpkg, @string name) {
    ref var pkg = ref Ꮡpkg.val;

    return Ꮡ(new Label(new @object(pos: pos, pkg: pkg, name: name, typ: Typ[Invalid], color_: black), false));
}

// A Builtin represents a built-in function.
// Builtins don't have a valid type.
[GoType] partial struct Builtin {
    internal partial ref @object @object { get; }
    internal builtinId id;
}

internal static ж<Builtin> newBuiltin(builtinId id) {
    return Ꮡ(new Builtin(new @object(name: predeclaredFuncs[id].name, typ: Typ[Invalid], color_: black), id));
}

// Nil represents the predeclared value nil.
[GoType] partial struct Nil {
    internal partial ref @object @object { get; }
}

internal static void writeObject(ж<bytes.Buffer> Ꮡbuf, Object obj, Qualifier qf) {
    ref var buf = ref Ꮡbuf.val;

    ж<TypeName> tname = default!;
    var typ = obj.Type();
    switch (obj.type()) {
    case PkgName.val obj: {
        fmt.Fprintf(~buf, "package %s"u8, obj.Name());
        {
            @string path = (~obj).imported.val.path; if (path != ""u8 && path != obj.name) {
                fmt.Fprintf(~buf, " (%q)"u8, path);
            }
        }
        return;
    }
    case Const.val obj: {
        buf.WriteString("const"u8);
        break;
    }
    case TypeName.val obj: {
        tname = obj;
        buf.WriteString("type"u8);
        if (isTypeParam(typ)) {
            buf.WriteString(" parameter"u8);
        }
        break;
    }
    case Var.val obj: {
        if ((~obj).isField){
            buf.WriteString("field"u8);
        } else {
            buf.WriteString("var"u8);
        }
        break;
    }
    case Func.val obj: {
        buf.WriteString("func "u8);
        writeFuncName(Ꮡbuf, Ꮡobj, qf);
        if (typ != default!) {
            WriteSignature(Ꮡbuf, typ._<ΔSignature.val>(), qf);
        }
        return;
    }
    case Label.val obj: {
        buf.WriteString("label"u8);
        typ = default!;
        break;
    }
    case Builtin.val obj: {
        buf.WriteString("builtin"u8);
        typ = default!;
        break;
    }
    case Nil.val obj: {
        buf.WriteString("nil"u8);
        return;
    }
    default: {
        var obj = obj.type();
        throw panic(fmt.Sprintf("writeObject(%T)"u8, obj));
        break;
    }}
    buf.WriteByte((rune)' ');
    // For package-level objects, qualify the name.
    if (obj.Pkg() != nil && AreEqual((~obj.Pkg()).scope.Lookup(obj.Name()), obj)) {
        buf.WriteString(packagePrefix(obj.Pkg(), qf));
    }
    buf.WriteString(obj.Name());
    if (typ == default!) {
        return;
    }
    if (tname != nil) {
        switch (typ.type()) {
        case Basic.val t: {
            return;
        }
        case Named.val t: {
            if (t.TypeParams().Len() > 0) {
                // Don't print anything more for basic types since there's
                // no more information.
                newTypeWriter(Ꮡbuf, qf).tParamList(t.TypeParams().list());
            }
            break;
        }}
        if (tname.IsAlias()){
            buf.WriteString(" ="u8);
            {
                var (alias, ok) = typ._<Alias.val>(ᐧ); if (ok) {
                    // materialized? (gotypesalias=1)
                    typ = alias.val.fromRHS;
                }
            }
        } else 
        {
            var (t, _) = typ._<TypeParam.val>(ᐧ); if (t != nil){
                typ = t.val.bound;
            } else {
                // TODO(gri) should this be fromRHS for *Named?
                // (See discussion in #66559.)
                typ = under(typ);
            }
        }
    }
    // Special handling for any: because WriteType will format 'any' as 'any',
    // resulting in the object string `type any = any` rather than `type any =
    // interface{}`. To avoid this, swap in a different empty interface.
    if (obj.Name() == "any"u8 && obj.Parent() == Universe) {
        assert(Identical(typ, emptyInterface));
        Ꮡtyp = emptyInterface; typ = ref Ꮡtyp.val;
    }
    buf.WriteByte((rune)' ');
    WriteType(Ꮡbuf, typ, qf);
}

internal static @string packagePrefix(ж<Package> Ꮡpkg, Qualifier qf) {
    ref var pkg = ref Ꮡpkg.val;

    if (pkg == nil) {
        return ""u8;
    }
    @string s = default!;
    if (qf != default!){
        s = qf(Ꮡpkg);
    } else {
        s = pkg.Path();
    }
    if (s != ""u8) {
        s += "."u8;
    }
    return s;
}

// ObjectString returns the string form of obj.
// The Qualifier controls the printing of
// package-level objects, and may be nil.
public static @string ObjectString(Object obj, Qualifier qf) {
    ref var buf = ref heap(new bytes_package.Buffer(), out var Ꮡbuf);
    writeObject(Ꮡbuf, obj, qf);
    return buf.String();
}

[GoRecv] public static @string String(this ref PkgName obj) {
    return ObjectString(~obj, default!);
}

[GoRecv] public static @string String(this ref Const obj) {
    return ObjectString(~obj, default!);
}

[GoRecv] public static @string String(this ref TypeName obj) {
    return ObjectString(~obj, default!);
}

[GoRecv] public static @string String(this ref Var obj) {
    return ObjectString(~obj, default!);
}

[GoRecv] public static @string String(this ref Func obj) {
    return ObjectString(~obj, default!);
}

[GoRecv] public static @string String(this ref Label obj) {
    return ObjectString(~obj, default!);
}

[GoRecv] public static @string String(this ref Builtin obj) {
    return ObjectString(~obj, default!);
}

[GoRecv] public static @string String(this ref Nil obj) {
    return ObjectString(~obj, default!);
}

internal static void writeFuncName(ж<bytes.Buffer> Ꮡbuf, ж<Func> Ꮡf, Qualifier qf) {
    ref var buf = ref Ꮡbuf.val;
    ref var f = ref Ꮡf.val;

    if (f.typ != default!) {
        var sig = f.typ._<ΔSignature.val>();
        {
            var recv = sig.Recv(); if (recv != nil){
                buf.WriteByte((rune)'(');
                {
                    var (_, ok) = recv.Type()._<Interface.val>(ᐧ); if (ok){
                        // gcimporter creates abstract methods of
                        // named interfaces using the interface type
                        // (not the named type) as the receiver.
                        // Don't print it in full.
                        buf.WriteString("interface"u8);
                    } else {
                        WriteType(Ꮡbuf, recv.Type(), qf);
                    }
                }
                buf.WriteByte((rune)')');
                buf.WriteByte((rune)'.');
            } else 
            if (f.pkg != nil) {
                buf.WriteString(packagePrefix(f.pkg, qf));
            }
        }
    }
    buf.WriteString(f.name);
}

} // end types_package
