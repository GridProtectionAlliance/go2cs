// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/under.go
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go.go;

partial class types_package {

// under returns the true expanded underlying type.
// If it doesn't exist, the result is Typ[Invalid].
// under must only be called when a type is known
// to be fully set up.
internal static ΔType under(ΔType t) {
    {
        var tΔ1 = asNamed(t); if (tΔ1 != nil) {
            return tΔ1.under();
        }
    }
    return t.Underlying();
}

// If t is not a type parameter, coreType returns the underlying type.
// If t is a type parameter, coreType returns the single underlying
// type of all types in its type set if it exists, or nil otherwise. If the
// type set contains only unrestricted and restricted channel types (with
// identical element types), the single underlying type is the restricted
// channel type if the restrictions are always the same, or nil otherwise.
internal static ΔType coreType(ΔType t) {
    t = Unalias(t);
    var (tpar, _) = t._<TypeParam.val>(ᐧ);
    if (tpar == nil) {
        return under(t);
    }
    ΔType su = default!;
    if (tpar.underIs(
    var suʗ2 = su;
    (ΔType u) => {
        if (u == default!) {
            return false;
        }
        if (suʗ2 != default!) {
            u = match(suʗ2, u);
            if (u == default!) {
                return false;
            }
        }
        suʗ2 = u;
        return true;
    })) {
        return su;
    }
    return default!;
}

// coreString is like coreType but also considers []byte
// and strings as identical. In this case, if successful and we saw
// a string, the result is of type (possibly untyped) string.
internal static ΔType coreString(ΔType t) {
    t = Unalias(t);
    var (tpar, _) = t._<TypeParam.val>(ᐧ);
    if (tpar == nil) {
        return under(t);
    }
    // string or untyped string
    ΔType su = default!;
    var hasString = false;
    if (tpar.underIs(
    var suʗ2 = su;
    (ΔType u) => {
        if (u == default!) {
            return false;
        }
        if (isString(u)) {
            u = ~NewSlice(universeByte);
            hasString = true;
        }
        if (suʗ2 != default!) {
            u = match(suʗ2, u);
            if (u == default!) {
                return false;
            }
        }
        suʗ2 = u;
        return true;
    })) {
        if (hasString) {
            return ~Typ[ΔString];
        }
        return su;
    }
    return default!;
}

// If x and y are identical, match returns x.
// If x and y are identical channels but for their direction
// and one of them is unrestricted, match returns the channel
// with the restricted direction.
// In all other cases, match returns nil.
internal static ΔType match(ΔType x, ΔType y) {
    // Common case: we don't have channels.
    if (Identical(x, y)) {
        return x;
    }
    // We may have channels that differ in direction only.
    {
        var (xΔ1, _) = x._<Chan.val>(ᐧ); if (xΔ1 != nil) {
            {
                var (yΔ1, _) = y._<Chan.val>(ᐧ); if (yΔ1 != nil && Identical((~xΔ1).elem, (~yΔ1).elem)) {
                    // We have channels that differ in direction only.
                    // If there's an unrestricted channel, select the restricted one.
                    switch (ᐧ) {
                    case {} when (~xΔ1).dir is SendRecv: {
                        return ~yΔ1;
                    }
                    case {} when (~yΔ1).dir is SendRecv: {
                        return ~xΔ1;
                    }}

                }
            }
        }
    }
    // types are different
    return default!;
}

} // end types_package
