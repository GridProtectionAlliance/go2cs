// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/operand.go
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file defines operands and associated operations.
namespace go.go;

using bytes = bytes_package;
using fmt = fmt_package;
using ast = go.ast_package;
using constant = go.constant_package;
using token = go.token_package;
using static @internal.types.errors_package;
using ꓸꓸꓸany = Span<any>;

partial class types_package {

[GoType("num:byte")] partial struct operandMode;

internal static readonly operandMode invalid = /* iota */ 0;  // operand is invalid
internal static readonly operandMode novalue = 1;  // operand represents no value (result of a function call w/o result)
internal static readonly operandMode Δbuiltin = 2; // operand is a built-in function
internal static readonly operandMode typexpr = 3;  // operand is a type
internal static readonly operandMode constant_ = 4; // operand is a constant; the operand's typ is a Basic type
internal static readonly operandMode variable = 5; // operand is an addressable variable
internal static readonly operandMode mapindex = 6; // operand is a map index expression (acts like a variable on lhs, commaok on rhs of an assignment)
internal static readonly operandMode value = 7;    // operand is a computed value
internal static readonly operandMode nilvalue = 8; // operand is the nil value - only used by types2
internal static readonly operandMode commaok = 9;  // like value, but operand may be used in a comma,ok expression
internal static readonly operandMode commaerr = 10; // like commaok, but second value is error, not boolean
internal static readonly operandMode cgofunc = 11;  // operand is a cgo function

// only used by types2
internal static array<@string> operandModeString = new runtime.SparseArray<@string>{
    [invalid] = "invalid operand"u8,
    [novalue] = "no value"u8,
    [Δbuiltin] = "built-in"u8,
    [typexpr] = "type"u8,
    [constant_] = "constant"u8,
    [variable] = "variable"u8,
    [mapindex] = "map index expression"u8,
    [value] = "value"u8,
    [nilvalue] = "nil"u8,
    [commaok] = "comma, ok expression"u8,
    [commaerr] = "comma, error expression"u8,
    [cgofunc] = "cgo function"u8
}.array();

// An operand represents an intermediate value during type checking.
// Operands have an (addressing) mode, the expression evaluating to
// the operand, the operand's type, a value for constants, and an id
// for built-in functions.
// The zero value of operand is a ready to use invalid operand.
[GoType] partial struct operand {
    internal operandMode mode;
    internal go.ast_package.Expr expr;
    internal ΔType typ;
    internal go.constant_package.Value val;
    internal builtinId id;
}

// Pos returns the position of the expression corresponding to x.
// If x is invalid the position is nopos.
[GoRecv] internal static tokenꓸPos Pos(this ref operand x) {
    // x.expr may not be set if x is invalid
    if (x.expr == default!) {
        return nopos;
    }
    return x.expr.Pos();
}

// Operand string formats
// (not all "untyped" cases can appear due to the type system,
// but they fall out naturally here)
//
// mode       format
//
// invalid    <expr> (               <mode>                    )
// novalue    <expr> (               <mode>                    )
// builtin    <expr> (               <mode>                    )
// typexpr    <expr> (               <mode>                    )
//
// constant   <expr> (<untyped kind> <mode>                    )
// constant   <expr> (               <mode>       of type <typ>)
// constant   <expr> (<untyped kind> <mode> <val>              )
// constant   <expr> (               <mode> <val> of type <typ>)
//
// variable   <expr> (<untyped kind> <mode>                    )
// variable   <expr> (               <mode>       of type <typ>)
//
// mapindex   <expr> (<untyped kind> <mode>                    )
// mapindex   <expr> (               <mode>       of type <typ>)
//
// value      <expr> (<untyped kind> <mode>                    )
// value      <expr> (               <mode>       of type <typ>)
//
// nilvalue   untyped nil
// nilvalue   nil    (                            of type <typ>)
//
// commaok    <expr> (<untyped kind> <mode>                    )
// commaok    <expr> (               <mode>       of type <typ>)
//
// commaerr   <expr> (<untyped kind> <mode>                    )
// commaerr   <expr> (               <mode>       of type <typ>)
//
// cgofunc    <expr> (<untyped kind> <mode>                    )
// cgofunc    <expr> (               <mode>       of type <typ>)
internal static @string operandString(ж<operand> Ꮡx, Qualifier qf) {
    ref var x = ref Ꮡx.val;

    // special-case nil
    if (isTypes2){
        if (x.mode == nilvalue) {
            var exprᴛ1 = x.typ;
            if (exprᴛ1 == default! || exprᴛ1 == Typ[Invalid]) {
                return "nil (with invalid type)"u8;
            }
            if (exprᴛ1 is Typ[UntypedNil]) {
                return "nil"u8;
            }
            { /* default: */
                return fmt.Sprintf("nil (of type %s)"u8, TypeString(x.typ, qf));
            }

        }
    } else {
        // go/types
        if (x.mode == value && x.typ == ~Typ[UntypedNil]) {
            return "nil"u8;
        }
    }
    ref var buf = ref heap(new bytes_package.Buffer(), out var Ꮡbuf);
    @string expr = default!;
    if (x.expr != default!){
        expr = ExprString(x.expr);
    } else {
        var exprᴛ2 = x.mode;
        if (exprᴛ2 == Δbuiltin) {
            expr = predeclaredFuncs[x.id].name;
        }
        else if (exprᴛ2 == typexpr) {
            expr = TypeString(x.typ, qf);
        }
        else if (exprᴛ2 == constant_) {
            expr = x.val.String();
        }

    }
    // <expr> (
    if (expr != ""u8) {
        buf.WriteString(expr);
        buf.WriteString(" ("u8);
    }
    // <untyped kind>
    var hasType = false;
    var exprᴛ3 = x.mode;
    if (exprᴛ3 == invalid || exprᴛ3 == novalue || exprᴛ3 == Δbuiltin || exprᴛ3 == typexpr) {
    }
    else { /* default: */
        if (x.typ != default!) {
            // no type
            // should have a type, but be cautious (don't crash during printing)
            if (isUntyped(x.typ)) {
                buf.WriteString(x.typ._<Basic.val>().name);
                buf.WriteByte((rune)' ');
                break;
            }
            hasType = true;
        }
    }

    // <mode>
    buf.WriteString(operandModeString[x.mode]);
    // <val>
    if (x.mode == constant_) {
        {
            @string s = x.val.String(); if (s != expr) {
                buf.WriteByte((rune)' ');
                buf.WriteString(s);
            }
        }
    }
    // <typ>
    if (hasType) {
        if (isValid(x.typ)){
            @string intro = default!;
            if (isGeneric(x.typ)){
                intro = " of generic type "u8;
            } else {
                intro = " of type "u8;
            }
            buf.WriteString(intro);
            WriteType(Ꮡbuf, x.typ, qf);
            {
                var (tpar, _) = Unalias(x.typ)._<TypeParam.val>(ᐧ); if (tpar != nil) {
                    buf.WriteString(" constrained by "u8);
                    WriteType(Ꮡbuf, (~tpar).bound, qf);
                    // do not compute interface type sets here
                    // If we have the type set and it's empty, say so for better error messages.
                    if (hasEmptyTypeset(~tpar)) {
                        buf.WriteString(" with empty type set"u8);
                    }
                }
            }
        } else {
            buf.WriteString(" with invalid type"u8);
        }
    }
    // )
    if (expr != ""u8) {
        buf.WriteByte((rune)')');
    }
    return buf.String();
}

[GoRecv] internal static @string String(this ref operand x) {
    return operandString(x, default!);
}

// setConst sets x to the untyped constant for literal lit.
[GoRecv] internal static void setConst(this ref operand x, token.Token k, @string lit) {
    BasicKind kind = default!;
    var exprᴛ1 = k;
    if (exprᴛ1 == token.INT) {
        kind = ΔUntypedInt;
    }
    else if (exprᴛ1 == token.FLOAT) {
        kind = ΔUntypedFloat;
    }
    else if (exprᴛ1 == token.IMAG) {
        kind = ΔUntypedComplex;
    }
    else if (exprᴛ1 == token.CHAR) {
        kind = UntypedRune;
    }
    else if (exprᴛ1 == token.STRING) {
        kind = UntypedString;
    }
    else { /* default: */
        throw panic("unreachable");
    }

    var val = makeFromLiteral(lit, k);
    if (val.Kind() == constant.Unknown) {
        x.mode = invalid;
        x.typ = Typ[Invalid];
        return;
    }
    x.mode = constant_;
    x.typ = Typ[kind];
    x.val = val;
}

// isNil reports whether x is the (untyped) nil value.
[GoRecv] internal static bool isNil(this ref operand x) {
    if (isTypes2){
        return x.mode == nilvalue;
    } else {
        // go/types
        return x.mode == value && x.typ == ~Typ[UntypedNil];
    }
}

// assignableTo reports whether x is assignable to a variable of type T. If the
// result is false and a non-nil cause is provided, it may be set to a more
// detailed explanation of the failure (result != ""). The returned error code
// is only valid if the (first) result is false. The check parameter may be nil
// if assignableTo is invoked through an exported API call, i.e., when all
// methods have been type-checked.
[GoRecv] internal static (bool, errors.Code) assignableTo(this ref operand x, ж<Checker> Ꮡcheck, ΔType T, ж<@string> Ꮡcause) {
    ref var check = ref Ꮡcheck.val;
    ref var cause = ref Ꮡcause.val;

    if (x.mode == invalid || !isValid(T)) {
        return (true, 0);
    }
    // avoid spurious errors
    var origT = T;
    var V = Unalias(x.typ);
    T = Unalias(T);
    // x's type is identical to T
    if (Identical(V, T)) {
        return (true, 0);
    }
    var Vu = under(V);
    var Tu = under(T);
    var (Vp, _) = V._<TypeParam.val>(ᐧ);
    var (Tp, _) = T._<TypeParam.val>(ᐧ);
    // x is an untyped value representable by a value of type T.
    if (isUntyped(Vu)) {
        assert(Vp == nil);
        if (Tp != nil) {
            // T is a type parameter: x is assignable to T if it is
            // representable by each specific type in the type set of T.
            return (Tp.@is((ж<term> t) => {
                if (t == nil) {
                    return false;
                }
                var (newType, _, _) = check.implicitTypeAndValue(x, (~t).typ);
                return newType != default!;
            }), IncompatibleAssign);
        }
        var (newType, _, _) = check.implicitTypeAndValue(x, T);
        return (newType != default!, IncompatibleAssign);
    }
    // Vu is typed
    // x's type V and T have identical underlying types
    // and at least one of V or T is not a named type
    // and neither V nor T is a type parameter.
    if (Identical(Vu, Tu) && (!hasName(V) || !hasName(T)) && Vp == nil && Tp == nil) {
        return (true, 0);
    }
    // T is an interface type, but not a type parameter, and V implements T.
    // Also handle the case where T is a pointer to an interface so that we get
    // the Checker.implements error cause.
    {
        var (_, ok) = Tu._<Interface.val>(ᐧ); if (ok && Tp == nil || isInterfacePtr(Tu)) {
            if (check.implements(x.Pos(), V, T, false, Ꮡcause)) {
                return (true, 0);
            }
            // V doesn't implement T but V may still be assignable to T if V
            // is a type parameter; do not report an error in that case yet.
            if (Vp == nil) {
                return (false, InvalidIfaceAssign);
            }
            if (cause != nil) {
                cause = ""u8;
            }
        }
    }
    // If V is an interface, check if a missing type assertion is the problem.
    {
        var (Vi, _) = Vu._<Interface.val>(ᐧ); if (Vi != nil && Vp == nil) {
            if (check.implements(x.Pos(), T, V, false, nil)) {
                // T implements V, so give hint about type assertion.
                if (cause != nil) {
                    cause = "need type assertion"u8;
                }
                return (false, IncompatibleAssign);
            }
        }
    }
    // x is a bidirectional channel value, T is a channel
    // type, x's type V and T have identical element types,
    // and at least one of V or T is not a named type.
    {
        var (Vc, ok) = Vu._<Chan.val>(ᐧ); if (ok && (~Vc).dir == SendRecv) {
            {
                var (Tc, okΔ1) = Tu._<Chan.val>(ᐧ); if (okΔ1 && Identical((~Vc).elem, (~Tc).elem)) {
                    return (!hasName(V) || !hasName(T), InvalidChanAssign);
                }
            }
        }
    }
    // optimization: if we don't have type parameters, we're done
    if (Vp == nil && Tp == nil) {
        return (false, IncompatibleAssign);
    }
    var errorf = (@string format, params ꓸꓸꓸany argsʗp) => {
        if (check != nil && cause != nil) {
            @string msg = check.sprintf(format, args.ꓸꓸꓸ);
            if (cause != ""u8) {
                msg += "\n\t"u8 + cause;
            }
            cause = msg;
        }
    };
    // x's type V is not a named type and T is a type parameter, and
    // x is assignable to each specific type in T's type set.
    if (!hasName(V) && Tp != nil) {
        var ok = false;
        errors.Code code = IncompatibleAssign;
        Tp.@is(
        var Tpʗ2 = Tp;
        var errorfʗ2 = errorf;
        (ж<term> T) => {
            if (TΔ1 == nil) {
                return false;
            }
            (ok, code) = x.assignableTo(Ꮡcheck, (~TΔ1).typ, Ꮡcause);
            if (!ok) {
                errorfʗ2("cannot assign %s to %s (in %s)"u8, x.typ, (~TΔ1).typ, Tpʗ2);
                return false;
            }
            return true;
        });
        return (ok, code);
    }
    // x's type V is a type parameter and T is not a named type,
    // and values x' of each specific type in V's type set are
    // assignable to T.
    if (Vp != nil && !hasName(T)) {
        ref var xΔ1 = ref heap<operand>(out var ᏑxΔ1);
        xΔ1 = x;
        // don't clobber outer x
        var ok = false;
        errors.Code code = IncompatibleAssign;
        Vp.@is(
        var Vpʗ2 = Vp;
        var errorfʗ5 = errorf;
        var origTʗ2 = origT;
        var xʗ2 = xΔ1;
        (ж<term> V) => {
            if (VΔ1 == nil) {
                return false;
            }
            xʗ2.typ = VΔ1.val.typ;
            (ok, code) = xʗ2.assignableTo(Ꮡcheck, T, Ꮡcause);
            if (!ok) {
                errorfʗ5("cannot assign %s (in %s) to %s"u8, (~VΔ1).typ, Vpʗ2, origTʗ2);
                return false;
            }
            return true;
        });
        return (ok, code);
    }
    return (false, IncompatibleAssign);
}

} // end types_package
