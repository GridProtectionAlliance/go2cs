// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/universe.go
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file sets up the universe scope and the unsafe package.
namespace go.go;

using constant = go.constant_package;
using strings = strings_package;

partial class types_package {

// The Universe scope contains all predeclared objects of Go.
// It is the outermost scope of any chain of nested scopes.
public static ж<ΔScope> Universe;

// The Unsafe package is the package returned by an importer
// for the import path "unsafe".
public static ж<Package> Unsafe;

internal static Object universeIota;
internal static ΔType universeByte; // uint8 alias, but has name "byte"
internal static ΔType universeRune; // int32 alias, but has name "rune"
internal static ж<TypeName> universeAnyNoAlias;
internal static ж<TypeName> universeAnyAlias;
internal static ΔType universeError;
internal static Object universeComparable;

// Typ contains the predeclared *Basic types indexed by their
// corresponding BasicKind.
//
// The *Basic type for Typ[Byte] will have the name "uint8".
// Use Universe.Lookup("byte").Type() to obtain the specific
// alias basic type named "byte" (and analogous for "rune").
public static slice<ж<Basic>> Typ = new runtime.SparseArray<ж<Basic>>{
    [Invalid] = new(Invalid, 0, "invalid type"u8),
    [Bool] = new(Bool, IsBoolean, "bool"u8),
    [Int] = new(Int, IsInteger, "int"u8),
    [Int8] = new(Int8, IsInteger, "int8"u8),
    [Int16] = new(Int16, IsInteger, "int16"u8),
    [Int32] = new(Int32, IsInteger, "int32"u8),
    [Int64] = new(Int64, IsInteger, "int64"u8),
    [Uint] = new(Uint, (BasicInfo)(IsInteger | IsUnsigned), "uint"u8),
    [Uint8] = new(Uint8, (BasicInfo)(IsInteger | IsUnsigned), "uint8"u8),
    [Uint16] = new(Uint16, (BasicInfo)(IsInteger | IsUnsigned), "uint16"u8),
    [Uint32] = new(Uint32, (BasicInfo)(IsInteger | IsUnsigned), "uint32"u8),
    [Uint64] = new(Uint64, (BasicInfo)(IsInteger | IsUnsigned), "uint64"u8),
    [Uintptr] = new(Uintptr, (BasicInfo)(IsInteger | IsUnsigned), "uintptr"u8),
    [Float32] = new(Float32, IsFloat, "float32"u8),
    [Float64] = new(Float64, IsFloat, "float64"u8),
    [Complex64] = new(Complex64, IsComplex, "complex64"u8),
    [Complex128] = new(Complex128, IsComplex, "complex128"u8),
    [ΔString] = new(ΔString, IsString, "string"u8),
    [UnsafePointer] = new(UnsafePointer, 0, "Pointer"u8),
    [UntypedBool] = new(UntypedBool, (BasicInfo)(IsBoolean | IsUntyped), "untyped bool"u8),
    [ΔUntypedInt] = new(ΔUntypedInt, (BasicInfo)(IsInteger | IsUntyped), "untyped int"u8),
    [UntypedRune] = new(UntypedRune, (BasicInfo)(IsInteger | IsUntyped), "untyped rune"u8),
    [ΔUntypedFloat] = new(ΔUntypedFloat, (BasicInfo)(IsFloat | IsUntyped), "untyped float"u8),
    [ΔUntypedComplex] = new(ΔUntypedComplex, (BasicInfo)(IsComplex | IsUntyped), "untyped complex"u8),
    [UntypedString] = new(UntypedString, (BasicInfo)(IsString | IsUntyped), "untyped string"u8),
    [UntypedNil] = new(UntypedNil, IsUntyped, "untyped nil"u8)
}.slice();

internal static array<ж<Basic>> basicAliases = new ж<Basic>[]{
    new(Byte, (BasicInfo)(IsInteger | IsUnsigned), "byte"u8),
    new(Rune, IsInteger, "rune"u8)
}.array();

internal static void defPredeclaredTypes() {
    foreach (var (_, t) in Typ) {
        def(~NewTypeName(nopos, nil, (~t).name, ~t));
    }
    foreach (var (_, t) in basicAliases) {
        def(~NewTypeName(nopos, nil, (~t).name, ~t));
    }
    // type any = interface{}
    //
    // Implement two representations of any: one for the legacy gotypesalias=0,
    // and one for gotypesalias=1. This is necessary for consistent
    // representation of interface aliases during type checking, and is
    // implemented via hijacking [Scope.Lookup] for the [Universe] scope.
    //
    // Both representations use the same distinguished pointer for their RHS
    // interface type, allowing us to detect any (even with the legacy
    // representation), and format it as "any" rather than interface{}, which
    // clarifies user-facing error messages significantly.
    //
    // TODO(rfindley): once the gotypesalias GODEBUG variable is obsolete (and we
    // consistently use the Alias node), we should be able to clarify user facing
    // error messages without using a distinguished pointer for the any
    // interface.
    {
        universeAnyNoAlias = NewTypeName(nopos, nil, "any"u8, new Interface(complete: true, tset: Ꮡ(topTypeSet)));
        universeAnyNoAlias.setColor(black);
        // ensure that the any TypeName reports a consistent Parent, after
        // hijacking Universe.Lookup with gotypesalias=0.
        universeAnyNoAlias.setParent(Universe);
        // It shouldn't matter which representation of any is actually inserted
        // into the Universe, but we lean toward the future and insert the Alias
        // representation.
        universeAnyAlias = NewTypeName(nopos, nil, "any"u8, default!);
        universeAnyAlias.setColor(black);
        _ = NewAlias(universeAnyAlias, universeAnyNoAlias.Type().Underlying());
        // Link TypeName and Alias
        def(~universeAnyAlias);
    }
    // type error interface{ Error() string }
    {
        var obj = NewTypeName(nopos, nil, "error"u8, default!);
        obj.setColor(black);
        var typ = NewNamed(obj, default!, default!);
        // error.Error() string
        var recv = NewVar(nopos, nil, ""u8, ~typ);
        var res = NewVar(nopos, nil, ""u8, ~Typ[ΔString]);
        var sig = NewSignatureType(recv, default!, default!, nil, NewTuple(res), false);
        var err = NewFunc(nopos, nil, "Error"u8, sig);
        // interface{ Error() string }
        var ityp = Ꮡ(new Interface(methods: new ж<Func>[]{err}.slice(), complete: true));
        computeInterfaceTypeSet(nil, nopos, ityp);
        // prevent races due to lazy computation of tset
        typ.SetUnderlying(~ityp);
        def(~obj);
    }
    // type comparable interface{} // marked as comparable
    {
        var obj = NewTypeName(nopos, nil, "comparable"u8, default!);
        obj.setColor(black);
        var typ = NewNamed(obj, default!, default!);
        // interface{} // marked as comparable
        var ityp = Ꮡ(new Interface(complete: true, tset: Ꮡ(new _TypeSet(default!, allTermlist, true))));
        typ.SetUnderlying(~ityp);
        def(~obj);
    }
}


[GoType("dyn")] partial struct Δtype {
    internal @string name;
    internal BasicKind kind;
    internal go.constant_package.Value val;
}
internal static array<constant.Value}> predeclaredConsts = new constant.Value}[]{
    new("true"u8, UntypedBool, constant.MakeBool(true)),
    new("false"u8, UntypedBool, constant.MakeBool(false)),
    new("iota"u8, ΔUntypedInt, constant.MakeInt64(0))
}.array();

internal static void defPredeclaredConsts() {
    foreach (var (_, c) in predeclaredConsts) {
        def(~NewConst(nopos, nil, c.name, ~Typ[c.kind], c.val));
    }
}

internal static void defPredeclaredNil() {
    def(new Nil(new @object(name: "nil"u8, typ: Typ[UntypedNil], color_: black)));
}

[GoType("num:nint")] partial struct builtinId;

internal static readonly builtinId _Append = /* iota */ 0;
internal static readonly builtinId _Cap = 1;
internal static readonly builtinId _Clear = 2;
internal static readonly builtinId _Close = 3;
internal static readonly builtinId _Complex = 4;
internal static readonly builtinId _Copy = 5;
internal static readonly builtinId _Delete = 6;
internal static readonly builtinId _Imag = 7;
internal static readonly builtinId _Len = 8;
internal static readonly builtinId _Make = 9;
internal static readonly builtinId _Max = 10;
internal static readonly builtinId _Min = 11;
internal static readonly builtinId _New = 12;
internal static readonly builtinId _Panic = 13;
internal static readonly builtinId _Print = 14;
internal static readonly builtinId _Println = 15;
internal static readonly builtinId _Real = 16;
internal static readonly builtinId _Recover = 17;
internal static readonly builtinId _Add = 18;
internal static readonly builtinId _Alignof = 19;
internal static readonly builtinId _Offsetof = 20;
internal static readonly builtinId _Sizeof = 21;
internal static readonly builtinId _Slice = 22;
internal static readonly builtinId _SliceData = 23;
internal static readonly builtinId _String = 24;
internal static readonly builtinId _StringData = 25;
internal static readonly builtinId _Assert = 26;
internal static readonly builtinId _Trace = 27;

// To disable max/min, remove the next two lines.

[GoType("dyn")] partial struct Δtypeᴛ1 {
    internal @string name;
    internal nint nargs;
    internal bool variadic;
    internal exprKind kind;
}
internal static array<struct{name string; nargs int; variadic bool; kind exprKind}> predeclaredFuncs = new runtime.SparseArray<struct{name string; nargs int; variadic bool; kind exprKind}>{
    [_Append] = new("append"u8, 1, true, expression),
    [_Cap] = new("cap"u8, 1, false, expression),
    [_Clear] = new("clear"u8, 1, false, statement),
    [_Close] = new("close"u8, 1, false, statement),
    [_Complex] = new("complex"u8, 2, false, expression),
    [_Copy] = new("copy"u8, 2, false, statement),
    [_Delete] = new("delete"u8, 2, false, statement),
    [_Imag] = new("imag"u8, 1, false, expression),
    [_Len] = new("len"u8, 1, false, expression),
    [_Make] = new("make"u8, 1, true, expression),
    [_Max] = new("max"u8, 1, true, expression),
    [_Min] = new("min"u8, 1, true, expression),
    [_New] = new("new"u8, 1, false, expression),
    [_Panic] = new("panic"u8, 1, false, statement),
    [_Print] = new("print"u8, 0, true, statement),
    [_Println] = new("println"u8, 0, true, statement),
    [_Real] = new("real"u8, 1, false, expression),
    [_Recover] = new("recover"u8, 0, false, statement),
    [_Add] = new("Add"u8, 2, false, expression),
    [_Alignof] = new("Alignof"u8, 1, false, expression),
    [_Offsetof] = new("Offsetof"u8, 1, false, expression),
    [_Sizeof] = new("Sizeof"u8, 1, false, expression),
    [_Slice] = new("Slice"u8, 2, false, expression),
    [_SliceData] = new("SliceData"u8, 1, false, expression),
    [_String] = new("String"u8, 2, false, expression),
    [_StringData] = new("StringData"u8, 1, false, expression),
    [_Assert] = new("assert"u8, 1, false, statement),
    [_Trace] = new("trace"u8, 0, true, statement)
}.array();

internal static void defPredeclaredFuncs() {
    foreach (var (i, _) in predeclaredFuncs) {
        builtinId id = ((builtinId)i);
        if (id == _Assert || id == _Trace) {
            continue;
        }
        // only define these in testing environment
        def(~newBuiltin(id));
    }
}

// DefPredeclaredTestFuncs defines the assert and trace built-ins.
// These built-ins are intended for debugging and testing of this
// package only.
public static void DefPredeclaredTestFuncs() {
    if (Universe.Lookup("assert"u8) != default!) {
        return;
    }
    // already defined
    def(~newBuiltin(_Assert));
    def(~newBuiltin(_Trace));
}

[GoInit] internal static void initΔ1() {
    Universe = NewScope(nil, nopos, nopos, "universe"u8);
    Unsafe = NewPackage("unsafe"u8, "unsafe"u8);
    Unsafe.val.complete = true;
    defPredeclaredTypes();
    defPredeclaredConsts();
    defPredeclaredNil();
    defPredeclaredFuncs();
    universeIota = Universe.Lookup("iota"u8);
    universeByte = Universe.Lookup("byte"u8).Type();
    universeRune = Universe.Lookup("rune"u8).Type();
    universeError = Universe.Lookup("error"u8).Type();
    universeComparable = Universe.Lookup("comparable"u8);
}

// Objects with names containing blanks are internal and not entered into
// a scope. Objects with exported names are inserted in the unsafe package
// scope; other objects are inserted in the universe scope.
internal static void def(Object obj) {
    assert(obj.color() == black);
    @string name = obj.Name();
    if (strings.Contains(name, " "u8)) {
        return;
    }
    // nothing to do
    // fix Obj link for named types
    {
        var typ = asNamed(obj.Type()); if (typ != nil) {
            typ.val.obj = obj._<TypeName.val>();
        }
    }
    // exported identifiers go into package unsafe
    var scope = Universe;
    if (obj.Exported()) {
        scope = Unsafe.val.scope;
        // set Pkg field
        switch (obj.type()) {
        case TypeName.val obj: {
            obj.pkg = Unsafe;
            break;
        }
        case Builtin.val obj: {
            obj.pkg = Unsafe;
            break;
        }
        default: {
            var obj = obj.type();
            throw panic("unreachable");
            break;
        }}
    }
    if (scope.Insert(obj) != default!) {
        throw panic("double declaration of predeclared identifier");
    }
}

} // end types_package
