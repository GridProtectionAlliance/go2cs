// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/predicates.go
// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements commonly used type predicates.
namespace go.go;

partial class types_package {

// isValid reports whether t is a valid type.
internal static bool isValid(ΔType t) {
    return Unalias(t) != ~Typ[Invalid];
}

// The isX predicates below report whether t is an X.
// If t is a type parameter the result is false; i.e.,
// these predicates don't look inside a type parameter.
internal static bool isBoolean(ΔType t) {
    return isBasic(t, IsBoolean);
}

internal static bool isInteger(ΔType t) {
    return isBasic(t, IsInteger);
}

internal static bool isUnsigned(ΔType t) {
    return isBasic(t, IsUnsigned);
}

internal static bool isFloat(ΔType t) {
    return isBasic(t, IsFloat);
}

internal static bool isComplex(ΔType t) {
    return isBasic(t, IsComplex);
}

internal static bool isNumeric(ΔType t) {
    return isBasic(t, IsNumeric);
}

internal static bool isString(ΔType t) {
    return isBasic(t, IsString);
}

internal static bool isIntegerOrFloat(ΔType t) {
    return isBasic(t, (BasicInfo)(IsInteger | IsFloat));
}

internal static bool isConstType(ΔType t) {
    return isBasic(t, IsConstType);
}

// isBasic reports whether under(t) is a basic type with the specified info.
// If t is a type parameter the result is false; i.e.,
// isBasic does not look inside a type parameter.
internal static bool isBasic(ΔType t, BasicInfo info) {
    var (u, _) = under(t)._<Basic.val>(ᐧ);
    return u != nil && (BasicInfo)((~u).info & info) != 0;
}

// The allX predicates below report whether t is an X.
// If t is a type parameter the result is true if isX is true
// for all specified types of the type parameter's type set.
// allX is an optimized version of isX(coreType(t)) (which
// is the same as underIs(t, isX)).
internal static bool allBoolean(ΔType t) {
    return allBasic(t, IsBoolean);
}

internal static bool allInteger(ΔType t) {
    return allBasic(t, IsInteger);
}

internal static bool allUnsigned(ΔType t) {
    return allBasic(t, IsUnsigned);
}

internal static bool allNumeric(ΔType t) {
    return allBasic(t, IsNumeric);
}

internal static bool allString(ΔType t) {
    return allBasic(t, IsString);
}

internal static bool allOrdered(ΔType t) {
    return allBasic(t, IsOrdered);
}

internal static bool allNumericOrString(ΔType t) {
    return allBasic(t, (BasicInfo)(IsNumeric | IsString));
}

// allBasic reports whether under(t) is a basic type with the specified info.
// If t is a type parameter, the result is true if isBasic(t, info) is true
// for all specific types of the type parameter's type set.
// allBasic(t, info) is an optimized version of isBasic(coreType(t), info).
internal static bool allBasic(ΔType t, BasicInfo info) {
    {
        var (tpar, _) = Unalias(t)._<TypeParam.val>(ᐧ); if (tpar != nil) {
            return tpar.@is((ж<term> t) => tΔ1 != nil && isBasic((~tΔ1).typ, info));
        }
    }
    return isBasic(t, info);
}

// hasName reports whether t has a name. This includes
// predeclared types, defined types, and type parameters.
// hasName may be called with types that are not fully set up.
internal static bool hasName(ΔType t) {
    switch (Unalias(t).type()) {
    case Basic.val : {
        return true;
    }
    case Named.val : {
        return true;
    }
    case TypeParam.val : {
        return true;
    }}

    return false;
}

// isTypeLit reports whether t is a type literal.
// This includes all non-defined types, but also basic types.
// isTypeLit may be called with types that are not fully set up.
internal static bool isTypeLit(ΔType t) {
    switch (Unalias(t).type()) {
    case Named.val : {
        return false;
    }
    case TypeParam.val : {
        return false;
    }}

    return true;
}

// isTyped reports whether t is typed; i.e., not an untyped
// constant or boolean.
// Safe to call from types that are not fully set up.
internal static bool isTyped(ΔType t) {
    // Alias and named types cannot denote untyped types
    // so there's no need to call Unalias or under, below.
    var (b, _) = t._<Basic.val>(ᐧ);
    return b == nil || (BasicInfo)((~b).info & IsUntyped) == 0;
}

// isUntyped(t) is the same as !isTyped(t).
// Safe to call from types that are not fully set up.
internal static bool isUntyped(ΔType t) {
    return !isTyped(t);
}

// isUntypedNumeric reports whether t is an untyped numeric type.
// Safe to call from types that are not fully set up.
internal static bool isUntypedNumeric(ΔType t) {
    // Alias and named types cannot denote untyped types
    // so there's no need to call Unalias or under, below.
    var (b, _) = t._<Basic.val>(ᐧ);
    return b != nil && (BasicInfo)((~b).info & IsUntyped) != 0 && (BasicInfo)((~b).info & IsNumeric) != 0;
}

// IsInterface reports whether t is an interface type.
public static bool IsInterface(ΔType t) {
    var (_, ok) = under(t)._<Interface.val>(ᐧ);
    return ok;
}

// isNonTypeParamInterface reports whether t is an interface type but not a type parameter.
internal static bool isNonTypeParamInterface(ΔType t) {
    return !isTypeParam(t) && IsInterface(t);
}

// isTypeParam reports whether t is a type parameter.
internal static bool isTypeParam(ΔType t) {
    var (_, ok) = Unalias(t)._<TypeParam.val>(ᐧ);
    return ok;
}

// hasEmptyTypeset reports whether t is a type parameter with an empty type set.
// The function does not force the computation of the type set and so is safe to
// use anywhere, but it may report a false negative if the type set has not been
// computed yet.
internal static bool hasEmptyTypeset(ΔType t) {
    {
        var (tpar, _) = Unalias(t)._<TypeParam.val>(ᐧ); if (tpar != nil && (~tpar).bound != default!) {
            var (iface, _) = safeUnderlying((~tpar).bound)._<Interface.val>(ᐧ);
            return iface != nil && (~iface).tset != nil && (~iface).tset.IsEmpty();
        }
    }
    return false;
}

// isGeneric reports whether a type is a generic, uninstantiated type
// (generic signatures are not included).
// TODO(gri) should we include signatures or assert that they are not present?
internal static bool isGeneric(ΔType t) {
    // A parameterized type is only generic if it doesn't have an instantiation already.
    {
        var (alias, _) = t._<Alias.val>(ᐧ); if (alias != nil && (~alias).tparams != nil && (~alias).targs == nil) {
            return true;
        }
    }
    var named = asNamed(t);
    return named != nil && (~named).obj != nil && (~named).inst == nil && named.TypeParams().Len() > 0;
}

// Comparable reports whether values of type T are comparable.
public static bool Comparable(ΔType T) {
    return comparable(T, true, default!, default!);
}

// If dynamic is set, non-type parameter interfaces are always comparable.
// If reportf != nil, it may be used to report why T is not comparable.
internal static bool comparable(ΔType T, bool dynamic, map<ΔType, bool> seen, Action<@string, .interface{}> reportf) {
    if (seen[T]) {
        return true;
    }
    if (seen == default!) {
        seen = new map<ΔType, bool>();
    }
    seen[T] = true;
    switch (under(T).type()) {
    case Basic.val t: {
        return (~t).kind != UntypedNil;
    }
    case Pointer.val t: {
        return true;
    }
    case Chan.val t: {
        return true;
    }
    case Struct.val t: {
        foreach (var (_, f) in (~t).fields) {
            // assume invalid types to be comparable
            // to avoid follow-up errors
            if (!comparable(f.typ, dynamic, seen, default!)) {
                if (reportf != default!) {
                    reportf("struct containing %s cannot be compared"u8, f.typ);
                }
                return false;
            }
        }
        return true;
    }
    case Array.val t: {
        if (!comparable((~t).elem, dynamic, seen, default!)) {
            if (reportf != default!) {
                reportf("%s cannot be compared"u8, t);
            }
            return false;
        }
        return true;
    }
    case Interface.val t: {
        if (dynamic && !isTypeParam(T) || t.typeSet().IsComparable(seen)) {
            return true;
        }
        if (reportf != default!) {
            if (t.typeSet().IsEmpty()){
                reportf("empty type set"u8);
            } else {
                reportf("incomparable types in type set"u8);
            }
        }
        break;
    }}
    // fallthrough
    return false;
}

// hasNil reports whether type t includes the nil value.
internal static bool hasNil(ΔType t) {
    switch (under(t).type()) {
    case Basic.val u: {
        return (~u).kind == UnsafePointer;
    }
    case Slice.val u: {
        return true;
    }
    case Pointer.val u: {
        return true;
    }
    case ΔSignature.val u: {
        return true;
    }
    case Map.val u: {
        return true;
    }
    case Chan.val u: {
        return true;
    }
    case Interface.val u: {
        return !isTypeParam(t) || u.typeSet().underIs((ΔType u) => u != default! && hasNil(u));
    }}
    return false;
}

// samePkg reports whether packages a and b are the same.
internal static bool samePkg(ж<Package> Ꮡa, ж<Package> Ꮡb) {
    ref var a = ref Ꮡa.val;
    ref var b = ref Ꮡb.val;

    // package is nil for objects in universe scope
    if (a == nil || b == nil) {
        return Ꮡa == Ꮡb;
    }
    // a != nil && b != nil
    return a.path == b.path;
}

// An ifacePair is a node in a stack of interface type pairs compared for identity.
[GoType] partial struct ifacePair {
    internal ж<Interface> x;
    internal ж<Interface> y;
    internal ж<ifacePair> prev;
}

[GoRecv] internal static bool identical(this ref ifacePair p, ж<ifacePair> Ꮡq) {
    ref var q = ref Ꮡq.val;

    return p.x == q.x && p.y == q.y || p.x == q.y && p.y == q.x;
}

// A comparer is used to compare types.
[GoType] partial struct comparer {
    internal bool ignoreTags; // if set, identical ignores struct tags
    internal bool ignoreInvalids; // if set, identical treats an invalid type as identical to any type
}

// For changes to this code the corresponding changes should be made to unifier.nify.
[GoRecv] internal static bool identical(this ref comparer c, ΔType x, ΔType y, ж<ifacePair> Ꮡp) {
    ref var p = ref Ꮡp.val;

    x = Unalias(x);
    y = Unalias(y);
    if (AreEqual(x, y)) {
        return true;
    }
    if (c.ignoreInvalids && (!isValid(x) || !isValid(y))) {
        return true;
    }
    switch (x.type()) {
    case Basic.val x: {
        {
            var (yΔ1, ok) = y._<Basic.val>(ᐧ); if (ok) {
                // Basic types are singletons except for the rune and byte
                // aliases, thus we cannot solely rely on the x == y check
                // above. See also comment in TypeName.IsAlias.
                return (~x).kind == (~yΔ1).kind;
            }
        }
        break;
    }
    case Array.val x: {
        {
            var (yΔ2, ok) = y._<Array.val>(ᐧ); if (ok) {
                // Two array types are identical if they have identical element types
                // and the same array length.
                // If one or both array lengths are unknown (< 0) due to some error,
                // assume they are the same to avoid spurious follow-on errors.
                return ((~x).len < 0 || (~yΔ2).len < 0 || (~x).len == (~yΔ2).len) && c.identical((~x).elem, (~yΔ2).elem, Ꮡp);
            }
        }
        break;
    }
    case Slice.val x: {
        {
            var (yΔ3, ok) = y._<Slice.val>(ᐧ); if (ok) {
                // Two slice types are identical if they have identical element types.
                return c.identical((~x).elem, (~yΔ3).elem, Ꮡp);
            }
        }
        break;
    }
    case Struct.val x: {
        {
            var (yΔ4, ok) = y._<Struct.val>(ᐧ); if (ok) {
                // Two struct types are identical if they have the same sequence of fields,
                // and if corresponding fields have the same names, and identical types,
                // and identical tags. Two embedded fields are considered to have the same
                // name. Lower-case field names from different packages are always different.
                if (x.NumFields() == yΔ4.NumFields()) {
                    foreach (var (i, f) in (~x).fields) {
                        var g = (~yΔ4).fields[i];
                        if ((~f).embedded != (~g).embedded || !c.ignoreTags && x.Tag(i) != yΔ4.Tag(i) || !f.sameId(g.pkg, g.name, false) || !c.identical(f.typ, g.typ, Ꮡp)) {
                            return false;
                        }
                    }
                    return true;
                }
            }
        }
        break;
    }
    case Pointer.val x: {
        {
            var (yΔ5, ok) = y._<Pointer.val>(ᐧ); if (ok) {
                // Two pointer types are identical if they have identical base types.
                return c.identical((~x).@base, (~yΔ5).@base, Ꮡp);
            }
        }
        break;
    }
    case Tuple.val x: {
        {
            var (yΔ6, ok) = y._<Tuple.val>(ᐧ); if (ok) {
                // Two tuples types are identical if they have the same number of elements
                // and corresponding elements have identical types.
                if (x.Len() == yΔ6.Len()) {
                    if (x != nil) {
                        foreach (var (i, v) in (~x).vars) {
                            var w = (~yΔ6).vars[i];
                            if (!c.identical(v.typ, w.typ, Ꮡp)) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
            }
        }
        break;
    }
    case ΔSignature.val x: {
        var (yΔ7, _) = y._<ΔSignature.val>(ᐧ);
        if (yΔ7 == nil) {
            return false;
        }
        if (x.TypeParams().Len() != yΔ7.TypeParams().Len()) {
            // Two function types are identical if they have the same number of
            // parameters and result values, corresponding parameter and result types
            // are identical, and either both functions are variadic or neither is.
            // Parameter and result names are not required to match, and type
            // parameters are considered identical modulo renaming.
            return false;
        }
        var yparams = yΔ7.val.@params;
        var yresults = yΔ7.val.results;
        if (x.TypeParams().Len() > 0) {
            // In the case of generic signatures, we will substitute in yparams and
            // yresults.
            // We must ignore type parameter names when comparing x and y. The
            // easiest way to do this is to substitute x's type parameters for y's.
            var xtparams = x.TypeParams().list();
            var ytparams = yΔ7.TypeParams().list();
            slice<ΔType> targs = default!;
            foreach (var (i, _) in xtparams) {
                targs = append(targs, ~x.TypeParams().At(i));
            }
            var smap = makeSubstMap(ytparams, targs);
            ж<Checker> check = default!;               // ok to call subst on a nil *Checker
            var ctxt = NewContext();
            // need a non-nil Context for the substitution below
            // Constraints must be pair-wise identical, after substitution.
            foreach (var (i, xtparam) in xtparams) {
                var ybound = check.subst(nopos, (~ytparams[i]).bound, smap, nil, ctxt);
                if (!c.identical((~xtparam).bound, ybound, Ꮡp)) {
                    return false;
                }
            }
            yparams = check.subst(nopos, ~(~yΔ7).@params, smap, nil, ctxt)._<Tuple.val>();
            yresults = check.subst(nopos, ~(~yΔ7).results, smap, nil, ctxt)._<Tuple.val>();
        }
        return (~x).variadic == (~yΔ7).variadic && c.identical(~(~x).@params, ~yparams, Ꮡp) && c.identical(~(~x).results, ~yresults, Ꮡp);
    }
    case Union.val x: {
        {
            var (yΔ8, _) = y._<Union.val>(ᐧ); if (yΔ8 != nil) {
                // TODO(rfindley): can this be reached during type checking? If so,
                // consider passing a type set map.
                var unionSets = new types._TypeSet();
                var xset = computeUnionTypeSet(nil, unionSets, nopos, Ꮡx);
                var yset = computeUnionTypeSet(nil, unionSets, nopos, ᏑyΔ8);
                return (~xset).terms.equal((~yset).terms);
            }
        }
        break;
    }
    case Interface.val x: {
        {
            var (yΔ9, ok) = y._<Interface.val>(ᐧ); if (ok) {
                // Two interface types are identical if they describe the same type sets.
                // With the existing implementation restriction, this simplifies to:
                //
                // Two interface types are identical if they have the same set of methods with
                // the same names and identical function types, and if any type restrictions
                // are the same. Lower-case method names from different packages are always
                // different. The order of the methods is irrelevant.
                var xset = x.typeSet();
                var yset = yΔ9.typeSet();
                if ((~xset).comparable != (~yset).comparable) {
                    return false;
                }
                if (!(~xset).terms.equal((~yset).terms)) {
                    return false;
                }
                var a = xset.val.methods;
                var b = yset.val.methods;
                if (len(a) == len(b)) {
                    // Interface types are the only types where cycles can occur
                    // that are not "terminated" via named types; and such cycles
                    // can only be created via method parameter types that are
                    // anonymous interfaces (directly or indirectly) embedding
                    // the current interface. Example:
                    //
                    //    type T interface {
                    //        m() interface{T}
                    //    }
                    //
                    // If two such (differently named) interfaces are compared,
                    // endless recursion occurs if the cycle is not detected.
                    //
                    // If x and y were compared before, they must be equal
                    // (if they were not, the recursion would have stopped);
                    // search the ifacePair stack for the same pair.
                    //
                    // This is a quadratic algorithm, but in practice these stacks
                    // are extremely short (bounded by the nesting depth of interface
                    // type declarations that recur via parameter types, an extremely
                    // rare occurrence). An alternative implementation might use a
                    // "visited" map, but that is probably less efficient overall.
                    var q = Ꮡ(new ifacePair(Ꮡx, ᏑyΔ9, Ꮡp));
                    while (p != nil) {
                        if (p.identical(q)) {
                            return true;
                        }
                        // same pair was compared before
                        p = p.prev;
                    }
                    if (debug) {
                        assertSortedMethods(a);
                        assertSortedMethods(b);
                    }
                    foreach (var (i, f) in a) {
                        var g = b[i];
                        if (f.Id() != g.Id() || !c.identical(f.typ, g.typ, q)) {
                            return false;
                        }
                    }
                    return true;
                }
            }
        }
        break;
    }
    case Map.val x: {
        {
            var (yΔ10, ok) = y._<Map.val>(ᐧ); if (ok) {
                // Two map types are identical if they have identical key and value types.
                return c.identical((~x).key, (~yΔ10).key, Ꮡp) && c.identical((~x).elem, (~yΔ10).elem, Ꮡp);
            }
        }
        break;
    }
    case Chan.val x: {
        {
            var (yΔ11, ok) = y._<Chan.val>(ᐧ); if (ok) {
                // Two channel types are identical if they have identical value types
                // and the same direction.
                return (~x).dir == (~yΔ11).dir && c.identical((~x).elem, (~yΔ11).elem, Ꮡp);
            }
        }
        break;
    }
    case Named.val x: {
        {
            var yΔ12 = asNamed(y); if (yΔ12 != nil) {
                // Two named types are identical if their type names originate
                // in the same type declaration; if they are instantiated they
                // must have identical type argument lists.
                // check type arguments before origins to match unifier
                // (for correct source code we need to do all checks so
                // order doesn't matter)
                var xargs = x.TypeArgs().list();
                var yargs = yΔ12.TypeArgs().list();
                if (len(xargs) != len(yargs)) {
                    return false;
                }
                foreach (var (i, xarg) in xargs) {
                    if (!Identical(xarg, yargs[i])) {
                        return false;
                    }
                }
                return identicalOrigin(Ꮡx, ᏑyΔ12);
            }
        }
        break;
    }
    case TypeParam.val x: {
        break;
    }
    case default! x: {
        break;
    }
    default: {
        var x = x.type();
        throw panic("unreachable");
        break;
    }}
    // nothing to do (x and y being equal is caught in the very beginning of this function)
    // avoid a crash in case of nil type
    return false;
}

// identicalOrigin reports whether x and y originated in the same declaration.
internal static bool identicalOrigin(ж<Named> Ꮡx, ж<Named> Ꮡy) {
    ref var x = ref Ꮡx.val;
    ref var y = ref Ꮡy.val;

    // TODO(gri) is this correct?
    return (~x.Origin()).obj == (~y.Origin()).obj;
}

// identicalInstance reports if two type instantiations are identical.
// Instantiations are identical if their origin and type arguments are
// identical.
internal static bool identicalInstance(ΔType xorig, slice<ΔType> xargs, ΔType yorig, slice<ΔType> yargs) {
    if (len(xargs) != len(yargs)) {
        return false;
    }
    foreach (var (i, xa) in xargs) {
        if (!Identical(xa, yargs[i])) {
            return false;
        }
    }
    return Identical(xorig, yorig);
}

// Default returns the default "typed" type for an "untyped" type;
// it returns the incoming type for all other types. The default type
// for untyped nil is untyped nil.
public static ΔType Default(ΔType t) {
    // Alias and named types cannot denote untyped types
    // so there's no need to call Unalias or under, below.
    {
        var (tΔ1, _) = t._<Basic.val>(ᐧ); if (tΔ1 != nil) {
            var exprᴛ1 = (~tΔ1).kind;
            if (exprᴛ1 == UntypedBool) {
                return ~Typ[Bool];
            }
            if (exprᴛ1 == ΔUntypedInt) {
                return ~Typ[Int];
            }
            if (exprᴛ1 == UntypedRune) {
                return universeRune;
            }
            if (exprᴛ1 == ΔUntypedFloat) {
                return ~Typ[Float64];
            }
            if (exprᴛ1 == ΔUntypedComplex) {
                return ~Typ[Complex128];
            }
            if (exprᴛ1 == UntypedString) {
                return ~Typ[ΔString];
            }

        }
    }
    // use 'rune' name
    return t;
}

// maxType returns the "largest" type that encompasses both x and y.
// If x and y are different untyped numeric types, the result is the type of x or y
// that appears later in this list: integer, rune, floating-point, complex.
// Otherwise, if x != y, the result is nil.
internal static ΔType maxType(ΔType x, ΔType y) {
    // We only care about untyped types (for now), so == is good enough.
    // TODO(gri) investigate generalizing this function to simplify code elsewhere
    if (AreEqual(x, y)) {
        return x;
    }
    if (isUntypedNumeric(x) && isUntypedNumeric(y)) {
        // untyped types are basic types
        if (x._<Basic.val>().kind > y._<Basic.val>().kind) {
            return x;
        }
        return y;
    }
    return default!;
}

// clone makes a "flat copy" of *p and returns a pointer to the copy.
internal static P clone<P, T>(P p)
    where P : /* *T */ IEqualityOperators<P, P, bool>, new()
    where T : new()
{
    var c = p;
    return Ꮡ(c);
}

} // end types_package
