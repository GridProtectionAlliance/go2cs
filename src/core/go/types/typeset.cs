// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/typeset.go
// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go.go;

using token = go.token_package;
using static @internal.types.errors_package;
using sort = sort_package;
using strings = strings_package;

partial class types_package {

// ----------------------------------------------------------------------------
// API

// A _TypeSet represents the type set of an interface.
// Because of existing language restrictions, methods can be "factored out"
// from the terms. The actual type set is the intersection of the type set
// implied by the methods and the type set described by the terms and the
// comparable bit. To test whether a type is included in a type set
// ("implements" relation), the type must implement all methods _and_ be
// an element of the type set described by the terms and the comparable bit.
// If the term list describes the set of all types and comparable is true,
// only comparable types are meant; in all other cases comparable is false.
[GoType] partial struct _TypeSet {
    internal slice<–∂<Func>> methods; // all methods of the interface; sorted by unique ID
    internal Œîtermlist terms; // type terms of the type set
    internal bool comparable;     // invariant: !comparable || terms.isAll()
}

// IsEmpty reports whether type set s is the empty set.
[GoRecv] internal static bool IsEmpty(this ref _TypeSet s) {
    return s.terms.isEmpty();
}

// IsAll reports whether type set s is the set of all types (corresponding to the empty interface).
[GoRecv] internal static bool IsAll(this ref _TypeSet s) {
    return s.IsMethodSet() && len(s.methods) == 0;
}

// IsMethodSet reports whether the interface t is fully described by its method set.
[GoRecv] internal static bool IsMethodSet(this ref _TypeSet s) {
    return !s.comparable && s.terms.isAll();
}

// IsComparable reports whether each type in the set is comparable.
[GoRecv] internal static bool IsComparable(this ref _TypeSet s, map<ŒîType, bool> seen) {
    if (s.terms.isAll()) {
        return s.comparable;
    }
    return s.@is(
    var seen ó2 = seen;
    (–∂<term> t) => t != nil && comparable((~t).typ, false, seen ó2, default!));
}

// NumMethods returns the number of methods available.
[GoRecv] internal static nint NumMethods(this ref _TypeSet s) {
    return len(s.methods);
}

// Method returns the i'th method of type set s for 0 <= i < s.NumMethods().
// The methods are ordered by their unique ID.
[GoRecv] internal static –∂<Func> Method(this ref _TypeSet s, nint i) {
    return s.methods[i];
}

// LookupMethod returns the index of and method with matching package and name, or (-1, nil).
[GoRecv] internal static (nint, –∂<Func>) LookupMethod(this ref _TypeSet s, –∂<Package> ·èëpkg, @string name, bool foldCase) {
    ref var pkg = ref ·èëpkg.val;

    return methodIndex(s.methods, ·èëpkg, name, foldCase);
}

[GoRecv] internal static @string String(this ref _TypeSet s) {
    switch (·êß) {
    case {} when s.IsEmpty(): {
        return "‚àÖ"u8;
    }
    case {} when s.IsAll(): {
        return "ùì§"u8;
    }}

    var hasMethods = len(s.methods) > 0;
    var hasTerms = s.hasTerms();
    strings.Builder buf = default!;
    buf.WriteByte((rune)'{');
    if (s.comparable) {
        buf.WriteString("comparable"u8);
        if (hasMethods || hasTerms) {
            buf.WriteString("; "u8);
        }
    }
    foreach (var (i, m) in s.methods) {
        if (i > 0) {
            buf.WriteString("; "u8);
        }
        buf.WriteString(m.String());
    }
    if (hasMethods && hasTerms) {
        buf.WriteString("; "u8);
    }
    if (hasTerms) {
        buf.WriteString(s.terms.String());
    }
    buf.WriteString("}"u8);
    return buf.String();
}

// ----------------------------------------------------------------------------
// Implementation

// hasTerms reports whether the type set has specific type terms.
[GoRecv] internal static bool hasTerms(this ref _TypeSet s) {
    return !s.terms.isEmpty() && !s.terms.isAll();
}

// subsetOf reports whether s1 ‚äÜ s2.
[GoRecv] internal static bool subsetOf(this ref _TypeSet s1, –∂<_TypeSet> ·èës2) {
    ref var s2 = ref ·èës2.val;

    return s1.terms.subsetOf(s2.terms);
}

// TODO(gri) TypeSet.is and TypeSet.underIs should probably also go into termlist.go

// is calls f with the specific type terms of s and reports whether
// all calls to f returned true. If there are no specific terms, is
// returns the result of f(nil).
[GoRecv] internal static bool @is(this ref _TypeSet s, Func<–∂<term>, bool> f) {
    if (!s.hasTerms()) {
        return f(nil);
    }
    foreach (var (_, t) in s.terms) {
        assert((~t).typ != default!);
        if (!f(t)) {
            return false;
        }
    }
    return true;
}

// underIs calls f with the underlying types of the specific type terms
// of s and reports whether all calls to f returned true. If there are
// no specific terms, underIs returns the result of f(nil).
[GoRecv] internal static bool underIs(this ref _TypeSet s, Func<ŒîType, bool> f) {
    if (!s.hasTerms()) {
        return f(default!);
    }
    foreach (var (_, t) in s.terms) {
        assert((~t).typ != default!);
        // Unalias(x) == under(x) for ~x terms
        var u = Unalias((~t).typ);
        if (!(~t).tilde) {
            u = under(u);
        }
        if (debug) {
            assert(Identical(u, under(u)));
        }
        if (!f(u)) {
            return false;
        }
    }
    return true;
}

// topTypeSet may be used as type set for the empty interface.
internal static _TypeSet topTypeSet = new _TypeSet(terms: allTermlist);

// computeInterfaceTypeSet may be called with check == nil.
internal static –∂<_TypeSet> computeInterfaceTypeSet(–∂<Checker> ·èëcheck, tokenÍì∏Pos pos, –∂<Interface> ·èëityp) => func((defer, _) => {
    ref var check = ref ·èëcheck.val;
    ref var ityp = ref ·èëityp.val;

    if (ityp.tset != nil) {
        return ·èëityp.tset;
    }
    // If the interface is not fully set up yet, the type set will
    // not be complete, which may lead to errors when using the
    // type set (e.g. missing method). Don't compute a partial type
    // set (and don't store it!), so that we still compute the full
    // type set eventually. Instead, return the top type set and
    // let any follow-on errors play out.
    //
    // TODO(gri) Consider recording when this happens and reporting
    // it as an error (but only if there were no other errors so to
    // to not have unnecessary follow-on errors).
    if (!ityp.complete) {
        return ·èë(topTypeSet);
    }
    if (check != nil && check.conf._Trace) {
        // Types don't generally have position information.
        // If we don't have a valid pos provided, try to use
        // one close enough.
        if (!posŒî1.IsValid() && len(ityp.methods) > 0) {
             = ityp.methods[0].pos;
        }
        check.trace(posŒî1, "-- type set for %s"u8, ityp);
        check.indent++;
        defer(() => {
            check.indent--;
            check.trace(posŒî1, "=> %s "u8, ityp.typeSet());
        });
    }
    // An infinitely expanding interface (due to a cycle) is detected
    // elsewhere (Checker.validType), so here we simply assume we only
    // have valid interfaces. Mark the interface as complete to avoid
    // infinite recursion if the validType check occurs later for some
    // reason.
    ityp.tset = ·èë(new _TypeSet(terms: allTermlist));
    // TODO(gri) is this sufficient?
    types._TypeSet unionSets = default!;
    if (check != nil){
        if (check.unionTypeSets == default!) {
            check.unionTypeSets = new types._TypeSet();
        }
        unionSets = check.unionTypeSets;
    } else {
        unionSets = new types._TypeSet();
    }
    // Methods of embedded interfaces are collected unchanged; i.e., the identity
    // of a method I.m's Func Object of an interface I is the same as that of
    // the method m in an interface that embeds interface I. On the other hand,
    // if a method is embedded via multiple overlapping embedded interfaces, we
    // don't provide a guarantee which "original m" got chosen for the embedding
    // interface. See also go.dev/issue/34421.
    //
    // If we don't care to provide this identity guarantee anymore, instead of
    // reusing the original method in embeddings, we can clone the method's Func
    // Object and give it the position of a corresponding embedded interface. Then
    // we can get rid of the mpos map below and simply use the cloned method's
    // position.
    objset seen = default!;
    slice<–∂<Func>> allMethods = default!;
    var mpos = new tokenÍì∏Pos();
    // method specification or method embedding position, for good error messages
    var addMethod = 
    var allMethods ó1 = allMethods;
    var mpos ó1 = mpos;
    var seen ó1 = seen;
    (tokenÍì∏Pos pos, –∂<Func> m, bool @explicit) => {
        {
            var other = seen ó1.insert(~m);
            switch (·êß) {
            case {} when other == default!: {
                allMethods ó1 = append(allMethods ó1, m);
                mpos ó1[m] = posŒî2;
                break;
            }
            case {} when @explicit: {
                if (check != nil) {
                    var err = check.newError(DuplicateDecl);
                    err.addf(((atPos)posŒî2), "duplicate method %s"u8, m.name);
                    err.addf(((atPos)mpos ó1[other._<Func.val>()]), "other declaration of method %s"u8, m.name);
                    err.report();
                }
                break;
            }
            default: {
                if (check != nil) {
                    // We have a duplicate method name in an embedded (not explicitly declared) method.
                    // Check method signatures after all types are computed (go.dev/issue/33656).
                    // If we're pre-go1.14 (overlapping embeddings are not permitted), report that
                    // error here as well (even though we could do it eagerly) because it's the same
                    // error message.
                    check.later(
                    var mpos ó12 = mpos;
                    var other ó11 = other;
                    () => {
                        if (posŒî2.IsValid() && !check.allowVersion(((atPos)posŒî2), go1_14) || !Identical(m.typ, other ó11.Type())) {
                            var err = check.newError(DuplicateDecl);
                            err.addf(((atPos)posŒî2), "duplicate method %s"u8, m.name);
                            err.addf(((atPos)mpos ó12[other ó11._<Func.val>()]), "other declaration of method %s"u8, m.name);
                            err.report();
                        }
                    }).describef(((atPos)posŒî2), "duplicate method check for %s"u8, m.name);
                }
                break;
            }}
        }

    };
    foreach (var (_, m) in ityp.methods) {
        addMethod(m.pos, m, true);
    }
    // collect embedded elements
    var allTerms = allTermlist;
    var allComparable = false;
    foreach (var (i, typ) in ityp.embeddeds) {
        // The embedding position is nil for imported interfaces.
        // We don't need to do version checks in those cases.
        tokenÍì∏Pos posŒî3 = default!;              // embedding position
        if (ityp.embedPos != nil) {
            posŒî3 = (ityp.embedPos)[i];
        }
        bool comparable = default!;
        Œîtermlist terms = default!;
        switch (under(typ).type()) {
        case Interface.val u: {
            assert(!isTypeParam(typ));
            var tset = computeInterfaceTypeSet(·èëcheck, // For now we don't permit type parameters as constraints.
 posŒî3, u);
            if (posŒî3.IsValid() && check != nil && check.isImportedConstraint(typ) && !check.verifyVersionf(((atPos)posŒî3), // If typ is local, an error was already reported where typ is specified/defined.
 go1_18, "embedding constraint interface %s"u8, typ)) {
                continue;
            }
            comparable = tset.val.comparable;
            foreach (var (_, m) in (~tset).methods) {
                addMethod(posŒî3, m, false);
            }
            terms = tset.val.terms;
            break;
        }
        case Union.val u: {
            if (posŒî3.IsValid() && check != nil && !check.verifyVersionf(((atPos)posŒî3), // use embedding position pos rather than m.pos
 go1_18, "embedding interface element %s"u8, u)) {
                continue;
            }
            tset = computeUnionTypeSet(·èëcheck, unionSets, posŒî3, u);
            if (tset == ·èë(invalidTypeSet)) {
                continue;
            }
            assert(!(~tset).comparable);
            assert(len((~tset).methods) == 0);
            terms = tset.val.terms;
            break;
        }
        default: {
            var u = under(typ).type();
            if (!isValid(u)) {
                // ignore invalid unions
                continue;
            }
            if (posŒî3.IsValid() && check != nil && !check.verifyVersionf(((atPos)posŒî3), go1_18, "embedding non-interface type %s"u8, typ)) {
                continue;
            }
            terms = new Œîtermlist{new(false, typ)};
            break;
        }}
        // The type set of an interface is the intersection of the type sets of all its elements.
        // Due to language restrictions, only embedded interfaces can add methods, they are handled
        // separately. Here we only need to intersect the term lists and comparable bits.
        (allTerms, allComparable) = intersectTermLists(allTerms, allComparable, terms, comparable);
    }
    ityp.tset.comparable = allComparable;
    if (len(allMethods) != 0) {
        sortMethods(allMethods);
        ityp.tset.methods = allMethods;
    }
    ityp.tset.terms = allTerms;
    return ·èëityp.tset;
});

// TODO(gri) The intersectTermLists function belongs to the termlist implementation.
//           The comparable type set may also be best represented as a term (using
//           a special type).

// intersectTermLists computes the intersection of two term lists and respective comparable bits.
// xcomp, ycomp are valid only if xterms.isAll() and yterms.isAll() respectively.
internal static (Œîtermlist, bool) intersectTermLists(Œîtermlist xterms, bool xcomp, Œîtermlist yterms, bool ycomp) {
    var terms = xterms.intersect(yterms);
    // If one of xterms or yterms is marked as comparable,
    // the result must only include comparable types.
    var comp = xcomp || ycomp;
    if (comp && !terms.isAll()) {
        // only keep comparable terms
        nint i = 0;
        foreach (var (_, t) in terms) {
            assert((~t).typ != default!);
            if (comparable((~t).typ, false, /* strictly comparable */
 default!, default!)) {
                terms[i] = t;
                i++;
            }
        }
        terms = terms[..(int)(i)];
        if (!terms.isAll()) {
            comp = false;
        }
    }
    assert(!comp || terms.isAll());
    // comparable invariant
    return (terms, comp);
}

internal static void sortMethods(slice<–∂<Func>> list) {
    sort.Sort(((byUniqueMethodName)list));
}

internal static void assertSortedMethods(slice<–∂<Func>> list) {
    if (!debug) {
        throw panic("assertSortedMethods called outside debug mode");
    }
    if (!sort.IsSorted(((byUniqueMethodName)list))) {
        throw panic("methods not sorted");
    }
}

[GoType("[]Func")] partial struct byUniqueMethodName;

internal static nint Len(this byUniqueMethodName a) {
    return len(a);
}

internal static bool Less(this byUniqueMethodName a, nint i, nint j) {
    return a[i].less(·èë(a[j].@object));
}

internal static void Swap(this byUniqueMethodName a, nint i, nint j) {
    (a[i], a[j]) = (a[j], a[i]);
}

// invalidTypeSet is a singleton type set to signal an invalid type set
// due to an error. It's also a valid empty type set, so consumers of
// type sets may choose to ignore it.
internal static _TypeSet invalidTypeSet;

// computeUnionTypeSet may be called with check == nil.
// The result is &invalidTypeSet if the union overflows.
internal static –∂<_TypeSet> computeUnionTypeSet(–∂<Checker> ·èëcheck, types._TypeSet unionSets, tokenÍì∏Pos pos, –∂<Union> ·èëutyp) {
    ref var check = ref ·èëcheck.val;
    ref var utyp = ref ·èëutyp.val;

    {
        var tset = unionSets[utyp];
        var _ = unionSets[utyp]; if (tset != nil) {
            return tset;
        }
    }
    // avoid infinite recursion (see also computeInterfaceTypeSet)
    unionSets[utyp] = @new<_TypeSet>();
    Œîtermlist allTerms = default!;
    foreach (var (_, t) in utyp.terms) {
        Œîtermlist terms = default!;
        var u = under((~t).typ);
        {
            var (ui, _) = u._<Interface.val>(·êß); if (ui != nil){
                // For now we don't permit type parameters as constraints.
                assert(!isTypeParam((~t).typ));
                terms = computeInterfaceTypeSet(·èëcheck, pos, ui).val.terms;
            } else 
            if (!isValid(u)){
                continue;
            } else {
                if ((~t).tilde && !Identical((~t).typ, u)) {
                    // There is no underlying type which is t.typ.
                    // The corresponding type set is empty.
                    t = default!;
                }
                // ‚àÖ term
                terms = new Œîtermlist{((–∂<term>)(t?.val ?? default!))};
            }
        }
        // The type set of a union expression is the union
        // of the type sets of each term.
        allTerms = allTerms.union(terms);
        if (len(allTerms) > maxTermCount) {
            if (check != nil) {
                check.errorf(((atPos)pos), InvalidUnion, "cannot handle more than %d union terms (implementation limitation)"u8, maxTermCount);
            }
            unionSets[utyp] = ·èë(invalidTypeSet);
            return ·èëunionSets[utyp];
        }
    }
    unionSets[utyp].terms = allTerms;
    return ·èëunionSets[utyp];
}

} // end types_package
