// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/package.go
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go.go;

using fmt = fmt_package;

partial class types_package {

// A Package describes a Go package.
[GoType] partial struct Package {
    internal @string path;
    internal @string name;
    internal ж<ΔScope> scope;
    internal slice<ж<Package>> imports;
    internal bool complete;
    internal bool fake;   // scope lookup errors are silently dropped if package is fake (internal use only)
    internal bool cgo;   // uses of this package will be rewritten into uses of declarations from _cgo_gotypes.go
    internal @string goVersion; // minimum Go version required for package (by Config.GoVersion, typically from go.mod)
}

// NewPackage returns a new Package for the given package path and name.
// The package is not complete and contains no explicit imports.
public static ж<Package> NewPackage(@string path, @string name) {
    var scope = NewScope(Universe, nopos, nopos, fmt.Sprintf("package %q"u8, path));
    return Ꮡ(new Package(path: path, name: name, scope: scope));
}

// Path returns the package path.
[GoRecv] public static @string Path(this ref Package pkg) {
    return pkg.path;
}

// Name returns the package name.
[GoRecv] public static @string Name(this ref Package pkg) {
    return pkg.name;
}

// SetName sets the package name.
[GoRecv] public static void SetName(this ref Package pkg, @string name) {
    pkg.name = name;
}

// GoVersion returns the minimum Go version required by this package.
// If the minimum version is unknown, GoVersion returns the empty string.
// Individual source files may specify a different minimum Go version,
// as reported in the [go/ast.File.GoVersion] field.
[GoRecv] public static @string GoVersion(this ref Package pkg) {
    return pkg.goVersion;
}

// Scope returns the (complete or incomplete) package scope
// holding the objects declared at package level (TypeNames,
// Consts, Vars, and Funcs).
// For a nil pkg receiver, Scope returns the Universe scope.
[GoRecv] public static ж<ΔScope> Scope(this ref Package pkg) {
    if (pkg != nil) {
        return pkg.scope;
    }
    return Universe;
}

// A package is complete if its scope contains (at least) all
// exported objects; otherwise it is incomplete.
[GoRecv] public static bool Complete(this ref Package pkg) {
    return pkg.complete;
}

// MarkComplete marks a package as complete.
[GoRecv] public static void MarkComplete(this ref Package pkg) {
    pkg.complete = true;
}

// Imports returns the list of packages directly imported by
// pkg; the list is in source order.
//
// If pkg was loaded from export data, Imports includes packages that
// provide package-level objects referenced by pkg. This may be more or
// less than the set of packages directly imported by pkg's source code.
//
// If pkg uses cgo and the FakeImportC configuration option
// was enabled, the imports list may contain a fake "C" package.
[GoRecv] public static slice<ж<Package>> Imports(this ref Package pkg) {
    return pkg.imports;
}

// SetImports sets the list of explicitly imported packages to list.
// It is the caller's responsibility to make sure list elements are unique.
[GoRecv] public static void SetImports(this ref Package pkg, slice<ж<Package>> list) {
    pkg.imports = list;
}

[GoRecv] public static @string String(this ref Package pkg) {
    return fmt.Sprintf("package %s (%q)"u8, pkg.name, pkg.path);
}

} // end types_package
