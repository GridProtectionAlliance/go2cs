// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/subst.go
// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements type parameter substitution.
namespace go.go;

using token = go.token_package;

partial class types_package {
/* visitMapType: map[*TypeParam]Type */

// makeSubstMap creates a new substitution map mapping tpars[i] to targs[i].
// If targs[i] is nil, tpars[i] is not substituted.
internal static substMap makeSubstMap(slice<ж<TypeParam>> tpars, slice<ΔType> targs) {
    assert(len(tpars) == len(targs));
    var proj = new substMap(len(tpars));
    foreach (var (i, tpar) in tpars) {
        proj[tpar] = targs[i];
    }
    return proj;
}

// makeRenameMap is like makeSubstMap, but creates a map used to rename type
// parameters in from with the type parameters in to.
internal static substMap makeRenameMap(slice<ж<TypeParam>> from, slice<ж<TypeParam>> to) {
    assert(len(from) == len(to));
    var proj = new substMap(len(from));
    foreach (var (i, tpar) in from) {
        proj[tpar] = to[i];
    }
    return proj;
}

internal static bool empty(this substMap m) {
    return len(m) == 0;
}

internal static ΔType lookup(this substMap m, ж<TypeParam> Ꮡtpar) {
    ref var tpar = ref Ꮡtpar.val;

    {
        var t = m[tpar]; if (t != default!) {
            return t;
        }
    }
    return ~tpar;
}

// subst returns the type typ with its type parameters tpars replaced by the
// corresponding type arguments targs, recursively. subst doesn't modify the
// incoming type. If a substitution took place, the result type is different
// from the incoming type.
//
// If expanding is non-nil, it is the instance type currently being expanded.
// One of expanding or ctxt must be non-nil.
[GoRecv] public static ΔType subst(this ref Checker check, tokenꓸPos pos, ΔType typ, substMap smap, ж<Named> Ꮡexpanding, ж<Context> Ꮡctxt) {
    ref var expanding = ref Ꮡexpanding.val;
    ref var ctxt = ref Ꮡctxt.val;

    assert(expanding != nil || ctxt != nil);
    if (smap.empty()) {
        return typ;
    }
    // common cases
    switch (typ.type()) {
    case Basic.val t: {
        return typ;
    }
    case TypeParam.val t: {
        return smap.lookup(t);
    }}
    // nothing to do
    // general case
    var subst = new subster(
        pos: pos,
        smap: smap,
        check: check,
        expanding: expanding,
        ctxt: ctxt
    );
    return subst.typ(typ);
}

[GoType] partial struct subster {
    internal go.token_package.ΔPos pos;
    internal substMap smap;
    internal ж<Checker> check; // nil if called via Instantiate
    internal ж<Named> expanding; // if non-nil, the instance that is being expanded
    internal ж<Context> ctxt;
}

[GoRecv] internal static ΔType typ(this ref subster subst, ΔType typ) {
    switch (typ.type()) {
    case default! t: {
        throw panic("nil typ");
        break;
    }
    case Basic.val t: {
        break;
    }
    case Alias.val t: {
        var orig = t.Origin();
        nint n = orig.TypeParams().Len();
        if (n == 0) {
            // Call typOrNil if it's possible that typ is nil.
            // nothing to do
            // This code follows the code for *Named types closely.
            // TODO(gri) try to factor better
            return ~t;
        }
        if (t.TypeArgs().Len() != n) {
            // type is not parameterized
            // TODO(gri) do we need this for Alias types?
            return ~Typ[Invalid];
        }
        var (targs, updated) = subst.typeList(t.TypeArgs().list());
        if (updated) {
            // error reported elsewhere
            // already instantiated
            // For each (existing) type argument determine if it needs
            // to be substituted; i.e., if it is or contains a type parameter
            // that has a type argument for it.
            return ~subst.check.newAliasInstance(subst.pos, (~t).orig, targs, subst.expanding, subst.ctxt);
        }
        break;
    }
    case Array.val t: {
        var elem = subst.typOrNil((~t).elem);
        if (!AreEqual(elem, (~t).elem)) {
            return new Array(len: (~t).len, elem: elem);
        }
        break;
    }
    case Slice.val t: {
        elem = subst.typOrNil((~t).elem);
        if (!AreEqual(elem, (~t).elem)) {
            return new Slice(elem: elem);
        }
        break;
    }
    case Struct.val t: {
        {
            var (fields, copied) = subst.varList((~t).fields); if (copied) {
                var s = Ꮡ(new Struct(fields: fields, tags: (~t).tags));
                s.markComplete();
                return ~s;
            }
        }
        break;
    }
    case Pointer.val t: {
        var @base = subst.typ((~t).@base);
        if (!AreEqual(@base, (~t).@base)) {
            return new Pointer(@base: @base);
        }
        break;
    }
    case Tuple.val t: {
        return ~subst.tuple(t);
    }
    case ΔSignature.val t: {
        var recv = t.val.recv;
        var @params = subst.tuple((~t).@params);
        var results = subst.tuple((~t).results);
        if (@params != (~t).@params || results != (~t).results) {
            // Preserve the receiver: it is handled during *Interface and *Named type
            // substitution.
            //
            // Naively doing the substitution here can lead to an infinite recursion in
            // the case where the receiver is an interface. For example, consider the
            // following declaration:
            //
            //  type T[A any] struct { f interface{ m() } }
            //
            // In this case, the type of f is an interface that is itself the receiver
            // type of all of its methods. Because we have no type name to break
            // cycles, substituting in the recv results in an infinite loop of
            // recv->interface->recv->interface->...
            return new ΔSignature(
                rparams: (~t).rparams, // TODO(gri) why can't we nil out tparams here, rather than in instantiate?

                tparams: (~t).tparams, // instantiated signatures have a nil scope

                recv: recv,
                @params: @params,
                results: results,
                variadic: (~t).variadic
            );
        }
        break;
    }
    case Union.val t: {
        var (terms, copied) = subst.termlist((~t).terms);
        if (copied) {
            // term list substitution may introduce duplicate terms (unlikely but possible).
            // This is ok; lazy type set computation will determine the actual type set
            // in normal form.
            return new Union(terms);
        }
        break;
    }
    case Interface.val t: {
        var (methods, mcopied) = subst.funcList((~t).methods);
        var (embeddeds, ecopied) = subst.typeList((~t).embeddeds);
        if (mcopied || ecopied) {
            var iface = subst.check.newInterface();
            iface.val.embeddeds = embeddeds;
            iface.val.embedPos = t.val.embedPos;
            iface.val.@implicit = t.val.@implicit;
            assert((~t).complete);
            // otherwise we are copying incomplete data
            iface.val.complete = t.val.complete;
            // If we've changed the interface type, we may need to replace its
            // receiver if the receiver type is the original interface. Receivers of
            // *Named type are replaced during named type expansion.
            //
            // Notably, it's possible to reach here and not create a new *Interface,
            // even though the receiver type may be parameterized. For example:
            //
            //  type T[P any] interface{ m() }
            //
            // In this case the interface will not be substituted here, because its
            // method signatures do not depend on the type parameter P, but we still
            // need to create new interface methods to hold the instantiated
            // receiver. This is handled by Named.expandUnderlying.
            (iface.val.methods, _) = replaceRecvType(methods, ~t, ~iface);
            // If check != nil, check.newInterface will have saved the interface for later completion.
            if (subst.check == nil) {
                // golang/go#61561: all newly created interfaces must be completed
                iface.typeSet();
            }
            return ~iface;
        }
        break;
    }
    case Map.val t: {
        var key = subst.typ((~t).key);
        elem = subst.typ((~t).elem);
        if (!AreEqual(key, (~t).key) || !AreEqual(elem, (~t).elem)) {
            return new Map(key: key, elem: elem);
        }
        break;
    }
    case Chan.val t: {
        elem = subst.typ((~t).elem);
        if (!AreEqual(elem, (~t).elem)) {
            return new Chan(dir: (~t).dir, elem: elem);
        }
        break;
    }
    case Named.val t: {
        orig = t.Origin();
        n = orig.TypeParams().Len();
        if (n == 0) {
            // subst is called during expansion, so in this function we need to be
            // careful not to call any methods that would cause t to be expanded: doing
            // so would result in deadlock.
            //
            // So we call t.Origin().TypeParams() rather than t.TypeParams().
            return ~t;
        }
        if (t.TypeArgs().Len() != n) {
            // type is not parameterized
            return ~Typ[Invalid];
        }
        (targs, updated) = subst.typeList(t.TypeArgs().list());
        if (updated) {
            // error reported elsewhere
            // already instantiated
            // For each (existing) type argument determine if it needs
            // to be substituted; i.e., if it is or contains a type parameter
            // that has a type argument for it.
            // Create a new instance and populate the context to avoid endless
            // recursion. The position used here is irrelevant because validation only
            // occurs on t (we don't call validType on named), but we use subst.pos to
            // help with debugging.
            return subst.check.instance(subst.pos, ~orig, targs, subst.expanding, subst.ctxt);
        }
        break;
    }
    case TypeParam.val t: {
        return subst.smap.lookup(t);
    }
    default: {
        var t = typ.type();
        throw panic("unreachable");
        break;
    }}
    return typ;
}

// typOrNil is like typ but if the argument is nil it is replaced with Typ[Invalid].
// A nil type may appear in pathological cases such as type T[P any] []func(_ T([]_))
// where an array/slice element is accessed before it is set up.
[GoRecv] internal static ΔType typOrNil(this ref subster subst, ΔType typ) {
    if (typ == default!) {
        return ~Typ[Invalid];
    }
    return subst.typ(typ);
}

[GoRecv] internal static ж<Var> var_(this ref subster subst, ж<Var> Ꮡv) {
    ref var v = ref Ꮡv.val;

    if (v != nil) {
        {
            var typ = subst.typ(v.typ); if (!AreEqual(typ, v.typ)) {
                return substVar(Ꮡv, typ);
            }
        }
    }
    return Ꮡv;
}

internal static ж<Var> substVar(ж<Var> Ꮡv, ΔType typ) {
    ref var v = ref Ꮡv.val;

    ref var copy = ref heap<Var>(out var Ꮡcopy);
    copy = v;
    copy.typ = typ;
    copy.origin = v.Origin();
    return Ꮡcopy;
}

[GoRecv] internal static ж<Tuple> tuple(this ref subster subst, ж<Tuple> Ꮡt) {
    ref var t = ref Ꮡt.val;

    if (t != nil) {
        {
            var (vars, copied) = subst.varList(t.vars); if (copied) {
                return Ꮡ(new Tuple(vars: vars));
            }
        }
    }
    return Ꮡt;
}

[GoRecv] internal static (slice<ж<Var>> @out, bool copied) varList(this ref subster subst, slice<ж<Var>> @in) {
    slice<ж<Var>> @out = default!;
    bool copied = default!;

    @out = @in;
    foreach (var (i, v) in @in) {
        {
            var w = subst.var_(v); if (w != v) {
                if (!copied) {
                    // first variable that got substituted => allocate new out slice
                    // and copy all variables
                    var @new = new slice<ж<Var>>(len(@in));
                    copy(@new, @out);
                    @out = @new;
                    copied = true;
                }
                @out[i] = w;
            }
        }
    }
    return (@out, copied);
}

[GoRecv] internal static ж<Func> func_(this ref subster subst, ж<Func> Ꮡf) {
    ref var f = ref Ꮡf.val;

    if (f != nil) {
        {
            var typ = subst.typ(f.typ); if (!AreEqual(typ, f.typ)) {
                return substFunc(Ꮡf, typ);
            }
        }
    }
    return Ꮡf;
}

internal static ж<Func> substFunc(ж<Func> Ꮡf, ΔType typ) {
    ref var f = ref Ꮡf.val;

    ref var copy = ref heap<Func>(out var Ꮡcopy);
    copy = f;
    copy.typ = typ;
    copy.origin = f.Origin();
    return Ꮡcopy;
}

[GoRecv] internal static (slice<ж<Func>> @out, bool copied) funcList(this ref subster subst, slice<ж<Func>> @in) {
    slice<ж<Func>> @out = default!;
    bool copied = default!;

    @out = @in;
    foreach (var (i, f) in @in) {
        {
            var g = subst.func_(f); if (g != f) {
                if (!copied) {
                    // first function that got substituted => allocate new out slice
                    // and copy all functions
                    var @new = new slice<ж<Func>>(len(@in));
                    copy(@new, @out);
                    @out = @new;
                    copied = true;
                }
                @out[i] = g;
            }
        }
    }
    return (@out, copied);
}

[GoRecv] internal static (slice<ΔType> @out, bool copied) typeList(this ref subster subst, slice<ΔType> @in) {
    slice<ΔType> @out = default!;
    bool copied = default!;

    @out = @in;
    foreach (var (i, t) in @in) {
        {
            var u = subst.typ(t); if (!AreEqual(u, t)) {
                if (!copied) {
                    // first function that got substituted => allocate new out slice
                    // and copy all functions
                    var @new = new slice<ΔType>(len(@in));
                    copy(@new, @out);
                    @out = @new;
                    copied = true;
                }
                @out[i] = u;
            }
        }
    }
    return (@out, copied);
}

[GoRecv] internal static (slice<ж<ΔTerm>> @out, bool copied) termlist(this ref subster subst, slice<ж<ΔTerm>> @in) {
    slice<ж<ΔTerm>> @out = default!;
    bool copied = default!;

    @out = @in;
    foreach (var (i, t) in @in) {
        {
            var u = subst.typ((~t).typ); if (!AreEqual(u, (~t).typ)) {
                if (!copied) {
                    // first function that got substituted => allocate new out slice
                    // and copy all functions
                    var @new = new slice<ж<ΔTerm>>(len(@in));
                    copy(@new, @out);
                    @out = @new;
                    copied = true;
                }
                @out[i] = NewTerm((~t).tilde, u);
            }
        }
    }
    return (@out, copied);
}

// replaceRecvType updates any function receivers that have type old to have
// type new. It does not modify the input slice; if modifications are required,
// the input slice and any affected signatures will be copied before mutating.
//
// The resulting out slice contains the updated functions, and copied reports
// if anything was modified.
internal static (slice<ж<Func>> @out, bool copied) replaceRecvType(slice<ж<Func>> @in, ΔType old, ΔType @new) {
    slice<ж<Func>> @out = default!;
    bool copied = default!;

    @out = @in;
    foreach (var (i, method) in @in) {
        var sig = method.Signature();
        if ((~sig).recv != nil && AreEqual((~sig).recv.Type(), old)) {
            if (!copied) {
                // Allocate a new methods slice before mutating for the first time.
                // This is defensive, as we may share methods across instantiations of
                // a given interface type if they do not get substituted.
                @out = new slice<ж<Func>>(len(@in));
                copy(@out, @in);
                copied = true;
            }
            ref var newsig = ref heap<ΔSignature>(out var Ꮡnewsig);
            newsig = sig.val;
            newsig.recv = substVar((~sig).recv, @new);
            @out[i] = substFunc(method, ~Ꮡnewsig);
        }
    }
    return (@out, copied);
}

} // end types_package
