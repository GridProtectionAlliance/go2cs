// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/mono.go
// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go.go;

using ast = go.ast_package;
using token = go.token_package;
using static @internal.types.errors_package;

partial class types_package {

// This file implements a check to validate that a Go package doesn't
// have unbounded recursive instantiation, which is not compatible
// with compilers using static instantiation (such as
// monomorphization).
//
// It implements a sort of "type flow" analysis by detecting which
// type parameters are instantiated with other type parameters (or
// types derived thereof). A package cannot be statically instantiated
// if the graph has any cycles involving at least one derived type.
//
// Concretely, we construct a directed, weighted graph. Vertices are
// used to represent type parameters as well as some defined
// types. Edges are used to represent how types depend on each other:
//
// * Everywhere a type-parameterized function or type is instantiated,
//   we add edges to each type parameter from the vertices (if any)
//   representing each type parameter or defined type referenced by
//   the type argument. If the type argument is just the referenced
//   type itself, then the edge has weight 0, otherwise 1.
//
// * For every defined type declared within a type-parameterized
//   function or method, we add an edge of weight 1 to the defined
//   type from each ambient type parameter.
//
// For example, given:
//
//	func f[A, B any]() {
//		type T int
//		f[T, map[A]B]()
//	}
//
// we construct vertices representing types A, B, and T. Because of
// declaration "type T int", we construct edges T<-A and T<-B with
// weight 1; and because of instantiation "f[T, map[A]B]" we construct
// edges A<-T with weight 0, and B<-A and B<-B with weight 1.
//
// Finally, we look for any positive-weight cycles. Zero-weight cycles
// are allowed because static instantiation will reach a fixed point.
[GoType] partial struct monoGraph {
    internal slice<monoVertex> vertices;
    internal slice<monoEdge> edges;
    // canon maps method receiver type parameters to their respective
    // receiver type's type parameters.
    internal types.TypeParam canon;
    // nameIdx maps a defined type or (canonical) type parameter to its
    // vertex index.
    internal map<ж<TypeName>, nint> nameIdx;
}

[GoType] partial struct monoVertex {
    internal nint weight; // weight of heaviest known path to this vertex
    internal nint pre; // previous edge (if any) in the above path
    internal nint len; // length of the above path
    // obj is the defined type or type parameter represented by this
    // vertex.
    internal ж<TypeName> obj;
}

[GoType] partial struct monoEdge {
    internal nint dst;
    internal nint src;
    internal nint weight;
    internal go.token_package.ΔPos pos;
    internal ΔType typ;
}

[GoRecv] internal static void monomorph(this ref Checker check) {
    // We detect unbounded instantiation cycles using a variant of
    // Bellman-Ford's algorithm. Namely, instead of always running |V|
    // iterations, we run until we either reach a fixed point or we've
    // found a path of length |V|. This allows us to terminate earlier
    // when there are no cycles, which should be the common case.
    var again = true;
    while (again) {
        again = false;
        foreach (var (i, edge) in check.mono.edges) {
            var src = Ꮡ(check.mono.vertices[edge.src]);
            var dst = Ꮡ(check.mono.vertices[edge.dst]);
            // N.B., we're looking for the greatest weight paths, unlike
            // typical Bellman-Ford.
            nint w = (~src).weight + edge.weight;
            if (w <= (~dst).weight) {
                continue;
            }
            dst.val.pre = i;
            dst.val.len = (~src).len + 1;
            if ((~dst).len == len(check.mono.vertices)) {
                check.reportInstanceLoop(edge.dst);
                return;
            }
            dst.val.weight = w;
            again = true;
        }
    }
}

[GoRecv] internal static void reportInstanceLoop(this ref Checker check, nint v) {
    slice<nint> stack = default!;
    var seen = new slice<bool>(len(check.mono.vertices));
    // We have a path that contains a cycle and ends at v, but v may
    // only be reachable from the cycle, not on the cycle itself. We
    // start by walking backwards along the path until we find a vertex
    // that appears twice.
    while (!seen[v]) {
        stack = append(stack, v);
        seen[v] = true;
        v = check.mono.edges[check.mono.vertices[v].pre].src;
    }
    // Trim any vertices we visited before visiting v the first
    // time. Since v is the first vertex we found within the cycle, any
    // vertices we visited earlier cannot be part of the cycle.
    while (stack[0] != v) {
        stack = stack[1..];
    }
    // TODO(mdempsky): Pivot stack so we report the cycle from the top?
    var err = check.newError(InvalidInstanceCycle);
    var obj0 = check.mono.vertices[v].obj;
    err.addf(~obj0, "instantiation cycle:"u8);
    var qf = RelativeTo(check.pkg);
    foreach (var (_, vΔ1) in stack) {
        var edge = check.mono.edges[check.mono.vertices[vΔ1].pre];
        var obj = check.mono.vertices[edge.dst].obj;
        switch (obj.Type().type()) {
        default: {

            throw panic("unexpected type");
            break;
        }
        case Named.val : {
            err.addf(((atPos)edge.pos), "%s implicitly parameterized by %s"u8, obj.Name(), TypeString(edge.typ, qf));
            break;
        }
        case TypeParam.val : {
            err.addf(((atPos)edge.pos), // secondary error, \t indented
 "%s instantiated as %s"u8, obj.Name(), TypeString(edge.typ, qf));
            break;
        }}

    }
    // secondary error, \t indented
    err.report();
}

// recordCanon records that tpar is the canonical type parameter
// corresponding to method type parameter mpar.
[GoRecv] internal static void recordCanon(this ref monoGraph w, ж<TypeParam> Ꮡmpar, ж<TypeParam> Ꮡtpar) {
    ref var mpar = ref Ꮡmpar.val;
    ref var tpar = ref Ꮡtpar.val;

    if (w.canon == default!) {
        w.canon = new types.TypeParam();
    }
    w.canon[mpar] = tpar;
}

// recordInstance records that the given type parameters were
// instantiated with the corresponding type arguments.
[GoRecv] internal static void recordInstance(this ref monoGraph w, ж<Package> Ꮡpkg, tokenꓸPos pos, slice<ж<TypeParam>> tparams, slice<ΔType> targs, slice<ast.Expr> xlist) {
    ref var pkg = ref Ꮡpkg.val;

    foreach (var (i, tpar) in tparams) {
        tokenꓸPos posΔ1 = pos;
        if (i < len(xlist)) {
            posΔ1 = startPos(xlist[i]);
        }
        w.assign(Ꮡpkg, posΔ1, tpar, targs[i]);
    }
}

// assign records that tpar was instantiated as targ at pos.
[GoRecv] internal static void assign(this ref monoGraph w, ж<Package> Ꮡpkg, tokenꓸPos pos, ж<TypeParam> Ꮡtpar, ΔType targ) {
    ref var pkg = ref Ꮡpkg.val;
    ref var tpar = ref Ꮡtpar.val;

    // Go generics do not have an analog to C++`s template-templates,
    // where a template parameter can itself be an instantiable
    // template. So any instantiation cycles must occur within a single
    // package. Accordingly, we can ignore instantiations of imported
    // type parameters.
    //
    // TODO(mdempsky): Push this check up into recordInstance? All type
    // parameters in a list will appear in the same package.
    if (tpar.Obj().Pkg() != Ꮡpkg) {
        return;
    }
    // flow adds an edge from vertex src representing that typ flows to tpar.
    var flow = (nint src, ΔType typ) => {
        nint weight = 1;
        if (AreEqual(typ, targ)) {
            weight = 0;
        }
        w.addEdge(w.typeParamVertex(Ꮡtpar), src, weight, pos, targ);
    };
    // Recursively walk the type argument to find any defined types or
    // type parameters.
    Action<ΔType> @do = default!;
    @do = 
    var doʗ1 = @do;
    var flowʗ1 = flow;
    (ΔType typ) => {
        switch (Unalias(typ).type()) {
        default: {
            var typ = Unalias(typ).type();
            throw panic("unexpected type");
            break;
        }
        case TypeParam.val typ: {
            assert(typ.Obj().Pkg() == Ꮡpkg);
            flowʗ1(w.typeParamVertex(typ), ~typ);
            break;
        }
        case Named.val typ: {
            {
                nint src = w.localNamedVertex(Ꮡpkg, typ.Origin()); if (src >= 0) {
                    flowʗ1(src, ~typ);
                }
            }
            var targs = typ.TypeArgs();
            for (nint i = 0; i < targs.Len(); i++) {
                doʗ1(targs.At(i));
            }
            break;
        }
        case Array.val typ: {
            doʗ1(typ.Elem());
            break;
        }
        case Basic.val typ: {
            break;
        }
        case Chan.val typ: {
            doʗ1(typ.Elem());
            break;
        }
        case Map.val typ: {
            doʗ1(typ.Key());
            doʗ1(typ.Elem());
            break;
        }
        case Pointer.val typ: {
            doʗ1(typ.Elem());
            break;
        }
        case Slice.val typ: {
            doʗ1(typ.Elem());
            break;
        }
        case Interface.val typ: {
            for (nint i = 0; i < typ.NumMethods(); i++) {
                // ok
                doʗ1(typ.Method(i).Type());
            }
            break;
        }
        case ΔSignature.val typ: {
            var tuple = 
            var doʗ2 = @do;
            (ж<Tuple> tup) => {
                for (nint i = 0; i < tup.Len(); i++) {
                    doʗ2(tup.At(i).Type());
                }
            };
            tuple(typ.Params());
            tuple(typ.Results());
            break;
        }
        case Struct.val typ: {
            for (nint i = 0; i < typ.NumFields(); i++) {
                @do(typ.Field(i).Type());
            }
            break;
        }}
    };
    @do(targ);
}

// localNamedVertex returns the index of the vertex representing
// named, or -1 if named doesn't need representation.
[GoRecv] internal static nint localNamedVertex(this ref monoGraph w, ж<Package> Ꮡpkg, ж<Named> Ꮡnamed) {
    ref var pkg = ref Ꮡpkg.val;
    ref var named = ref Ꮡnamed.val;

    var obj = named.Obj();
    if (obj.Pkg() != Ꮡpkg) {
        return -1;
    }
    // imported type
    var root = pkg.Scope();
    if (obj.Parent() == root) {
        return -1;
    }
    // package scope, no ambient type parameters
    {
        nint idxΔ1 = w.nameIdx[obj];
        var ok = w.nameIdx[obj]; if (ok) {
            return idxΔ1;
        }
    }
    nint idx = -1;
    // Walk the type definition's scope to find any ambient type
    // parameters that it's implicitly parameterized by.
    for (var scope = obj.Parent(); scope != root; scope = scope.Parent()) {
        foreach (var (_, elem) in (~scope).elems) {
            {
                var (elemΔ1, ok) = elem._<TypeName.val>(ᐧ); if (ok && !elemΔ1.IsAlias() && cmpPos(elemΔ1.Pos(), obj.Pos()) < 0) {
                    {
                        var (tpar, okΔ1) = elem.Type()._<TypeParam.val>(ᐧ); if (okΔ1) {
                            if (idx < 0) {
                                idx = len(w.vertices);
                                w.vertices = append(w.vertices, new monoVertex(obj: obj));
                            }
                            w.addEdge(idx, w.typeParamVertex(tpar), 1, obj.Pos(), ~tpar);
                        }
                    }
                }
            }
        }
    }
    if (w.nameIdx == default!) {
        w.nameIdx = new map<ж<TypeName>, nint>();
    }
    w.nameIdx[obj] = idx;
    return idx;
}

// typeParamVertex returns the index of the vertex representing tpar.
[GoRecv] internal static nint typeParamVertex(this ref monoGraph w, ж<TypeParam> Ꮡtpar) {
    ref var tpar = ref Ꮡtpar.val;

    {
        var x = w.canon[tpar];
        var ok = w.canon[tpar]; if (ok) {
            tpar = x;
        }
    }
    var obj = tpar.Obj();
    {
        nint idxΔ1 = w.nameIdx[obj];
        var ok = w.nameIdx[obj]; if (ok) {
            return idxΔ1;
        }
    }
    if (w.nameIdx == default!) {
        w.nameIdx = new map<ж<TypeName>, nint>();
    }
    nint idx = len(w.vertices);
    w.vertices = append(w.vertices, new monoVertex(obj: obj));
    w.nameIdx[obj] = idx;
    return idx;
}

[GoRecv] internal static void addEdge(this ref monoGraph w, nint dst, nint src, nint weight, tokenꓸPos pos, ΔType typ) {
    // TODO(mdempsky): Deduplicate redundant edges?
    w.edges = append(w.edges, new monoEdge(
        dst: dst,
        src: src,
        weight: weight,
        pos: pos,
        typ: typ
    ));
}

} // end types_package
