// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/alias.go
// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go.go;

using fmt = fmt_package;
using token = go.token_package;

partial class types_package {

// An Alias represents an alias type.
// Whether or not Alias types are created is controlled by the
// gotypesalias setting with the GODEBUG environment variable.
// For gotypesalias=1, alias declarations produce an Alias type.
// Otherwise, the alias information is only in the type name,
// which points directly to the actual (aliased) type.
[GoType] partial struct Alias {
    internal ж<TypeName> obj;   // corresponding declared alias object
    internal ж<Alias> orig;      // original, uninstantiated alias
    internal ж<TypeParamList> tparams; // type parameters, or nil
    internal ж<TypeList> targs;   // type arguments, or nil
    internal ΔType fromRHS;         // RHS of type alias declaration; may be an alias
    internal ΔType actual;         // actual (aliased) type; never an alias
}

// NewAlias creates a new Alias type with the given type name and rhs.
// rhs must not be nil.
public static ж<Alias> NewAlias(ж<TypeName> Ꮡobj, ΔType rhs) {
    ref var obj = ref Ꮡobj.val;

    var alias = ((ж<Checker>)(default!)).val.newAlias(Ꮡobj, rhs);
    // Ensure that alias.actual is set (#65455).
    alias.cleanup();
    return alias;
}

// Obj returns the type name for the declaration defining the alias type a.
// For instantiated types, this is same as the type name of the origin type.
[GoRecv] public static ж<TypeName> Obj(this ref Alias a) {
    return a.orig.obj;
}

[GoRecv] public static @string String(this ref Alias a) {
    return TypeString(~a, default!);
}

// Underlying returns the [underlying type] of the alias type a, which is the
// underlying type of the aliased type. Underlying types are never Named,
// TypeParam, or Alias types.
//
// [underlying type]: https://go.dev/ref/spec#Underlying_types.
[GoRecv] public static ΔType Underlying(this ref Alias a) {
    return unalias(a).Underlying();
}

// Origin returns the generic Alias type of which a is an instance.
// If a is not an instance of a generic alias, Origin returns a.
[GoRecv] public static ж<Alias> Origin(this ref Alias a) {
    return a.orig;
}

// TypeParams returns the type parameters of the alias type a, or nil.
// A generic Alias and its instances have the same type parameters.
[GoRecv] public static ж<TypeParamList> TypeParams(this ref Alias a) {
    return a.tparams;
}

// SetTypeParams sets the type parameters of the alias type a.
// The alias a must not have type arguments.
[GoRecv] public static void SetTypeParams(this ref Alias a, slice<ж<TypeParam>> tparams) {
    assert(a.targs == nil);
    a.tparams = bindTParams(tparams);
}

// TypeArgs returns the type arguments used to instantiate the Alias type.
// If a is not an instance of a generic alias, the result is nil.
[GoRecv] public static ж<TypeList> TypeArgs(this ref Alias a) {
    return a.targs;
}

// Rhs returns the type R on the right-hand side of an alias
// declaration "type A = R", which may be another alias.
[GoRecv] public static ΔType Rhs(this ref Alias a) {
    return a.fromRHS;
}

// Unalias returns t if it is not an alias type;
// otherwise it follows t's alias chain until it
// reaches a non-alias type which is then returned.
// Consequently, the result is never an alias type.
public static ΔType Unalias(ΔType t) {
    {
        var (a0, _) = t._<Alias.val>(ᐧ); if (a0 != nil) {
            return unalias(a0);
        }
    }
    return t;
}

internal static ΔType unalias(ж<Alias> Ꮡa0) {
    ref var a0 = ref Ꮡa0.val;

    if (a0.actual != default!) {
        return a0.actual;
    }
    ΔType t = default!;
    for (var a = a0; a != nil; (a, _) = t._<Alias.val>(ᐧ)) {
        t = a.val.fromRHS;
    }
    if (t == default!) {
        throw panic(fmt.Sprintf("non-terminated alias %s"u8, a0.obj.name));
    }
    // Memoize the type only if valid.
    // In the presence of unfinished cyclic declarations, Unalias
    // would otherwise latch the invalid value (#66704).
    // TODO(adonovan): rethink, along with checker.typeDecl's use
    // of Invalid to mark unfinished aliases.
    if (Ꮡt != ~Typ[Invalid]) {
        a0.actual = t;
    }
    return t;
}

// asNamed returns t as *Named if that is t's
// actual type. It returns nil otherwise.
internal static ж<Named> asNamed(ΔType t) {
    var (n, _) = Unalias(t)._<Named.val>(ᐧ);
    return n;
}

// newAlias creates a new Alias type with the given type name and rhs.
// rhs must not be nil.
[GoRecv] public static ж<Alias> newAlias(this ref Checker check, ж<TypeName> Ꮡobj, ΔType rhs) {
    ref var obj = ref Ꮡobj.val;

    assert(rhs != default!);
    var a = @new<Alias>();
    a.val.obj = obj;
    a.val.orig = a;
    a.val.fromRHS = rhs;
    if (obj.typ == default!) {
        obj.typ = a;
    }
    // Ensure that a.actual is set at the end of type checking.
    if (check != nil) {
        check.needsCleanup(~a);
    }
    return a;
}

// newAliasInstance creates a new alias instance for the given origin and type
// arguments, recording pos as the position of its synthetic object (for error
// reporting).
[GoRecv] public static ж<Alias> newAliasInstance(this ref Checker check, tokenꓸPos pos, ж<Alias> Ꮡorig, slice<ΔType> targs, ж<Named> Ꮡexpanding, ж<Context> Ꮡctxt) {
    ref var orig = ref Ꮡorig.val;
    ref var expanding = ref Ꮡexpanding.val;
    ref var ctxt = ref Ꮡctxt.val;

    assert(len(targs) > 0);
    var obj = NewTypeName(pos, orig.obj.pkg, orig.obj.name, default!);
    var rhs = check.subst(pos, orig.fromRHS, makeSubstMap(orig.TypeParams().list(), targs), Ꮡexpanding, Ꮡctxt);
    var res = check.newAlias(obj, rhs);
    res.val.orig = orig;
    res.val.tparams = orig.tparams;
    res.val.targs = newTypeList(targs);
    return res;
}

[GoRecv] internal static void cleanup(this ref Alias a) {
    // Ensure a.actual is set before types are published,
    // so Unalias is a pure "getter", not a "setter".
    var actual = Unalias(~a);
    if (Ꮡactual == ~Typ[Invalid]) {
        // We don't set a.actual to Typ[Invalid] during type checking,
        // as it may indicate that the RHS is not fully set up.
        a.actual = actual;
    }
}

} // end types_package
