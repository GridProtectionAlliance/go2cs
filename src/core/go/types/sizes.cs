// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/sizes.go
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements Sizes.
namespace go.go;

partial class types_package {

// Sizes defines the sizing functions for package unsafe.
[GoType] partial interface Sizes {
    // Alignof returns the alignment of a variable of type T.
    // Alignof must implement the alignment guarantees required by the spec.
    // The result must be >= 1.
    int64 Alignof(ΔType T);
    // Offsetsof returns the offsets of the given struct fields, in bytes.
    // Offsetsof must implement the offset guarantees required by the spec.
    // A negative entry in the result indicates that the struct is too large.
    slice<int64> Offsetsof(slice<ж<Var>> fields);
    // Sizeof returns the size of a variable of type T.
    // Sizeof must implement the size guarantees required by the spec.
    // A negative result indicates that T is too large.
    int64 Sizeof(ΔType T);
}

// StdSizes is a convenience type for creating commonly used Sizes.
// It makes the following simplifying assumptions:
//
//   - The size of explicitly sized basic types (int16, etc.) is the
//     specified size.
//   - The size of strings and interfaces is 2*WordSize.
//   - The size of slices is 3*WordSize.
//   - The size of an array of n elements corresponds to the size of
//     a struct of n consecutive fields of the array's element type.
//   - The size of a struct is the offset of the last field plus that
//     field's size. As with all element types, if the struct is used
//     in an array its size must first be aligned to a multiple of the
//     struct's alignment.
//   - All other types have size WordSize.
//   - Arrays and structs are aligned per spec definition; all other
//     types are naturally aligned with a maximum alignment MaxAlign.
//
// *StdSizes implements Sizes.
[GoType] partial struct StdSizes {
    public int64 WordSize; // word size in bytes - must be >= 4 (32bits)
    public int64 MaxAlign; // maximum alignment in bytes - must be >= 1
}

[GoRecv] public static int64 /*result*/ Alignof(this ref StdSizes s, ΔType T) => func((defer, _) => {
    int64 result = default!;

    defer(() => {
        assert(result >= 1);
    });
    // For arrays and structs, alignment is defined in terms
    // of alignment of the elements and fields, respectively.
    switch (under(T).type()) {
    case Array.val t: {
        return s.Alignof((~t).elem);
    }
    case Struct.val t: {
        if (len((~t).fields) == 0 && _IsSyncAtomicAlign64(T)) {
            // spec: "For a variable x of array type: unsafe.Alignof(x)
            // is the same as unsafe.Alignof(x[0]), but at least 1."
            // Special case: sync/atomic.align64 is an
            // empty struct we recognize as a signal that
            // the struct it contains must be
            // 64-bit-aligned.
            //
            // This logic is equivalent to the logic in
            // cmd/compile/internal/types/size.go:calcStructOffset
            return 8;
        }
        var max = ((int64)1);
        foreach (var (_, f) in (~t).fields) {
            // spec: "For a variable x of struct type: unsafe.Alignof(x)
            // is the largest of the values unsafe.Alignof(x.f) for each
            // field f of x, but at least 1."
            {
                var aΔ1 = s.Alignof(f.typ); if (aΔ1 > max) {
                    max = aΔ1;
                }
            }
        }
        return max;
    }
    case Slice.val t: {
        assert(!isTypeParam(T));
        return s.WordSize;
    }
    case Interface.val t: {
        assert(!isTypeParam(T));
        return s.WordSize;
    }
    case Basic.val t: {
        if ((BasicInfo)(t.Info() & IsString) != 0) {
            // Multiword data structures are effectively structs
            // in which each element has size WordSize.
            // Type parameters lead to variable sizes/alignments;
            // StdSizes.Alignof won't be called for them.
            // Strings are like slices and interfaces.
            return s.WordSize;
        }
        break;
    }
    case TypeParam.val t: {
        throw panic("unreachable");
        break;
    }
    case Union.val t: {
        throw panic("unreachable");
        break;
    }}
    var a = s.Sizeof(T);
    // may be 0 or negative
    // spec: "For a variable x of any type: unsafe.Alignof(x) is at least 1."
    if (a < 1) {
        return 1;
    }
    // complex{64,128} are aligned like [2]float{32,64}.
    if (isComplex(T)) {
        a /= 2;
    }
    if (a > s.MaxAlign) {
        return s.MaxAlign;
    }
    return a;
});

internal static bool _IsSyncAtomicAlign64(ΔType T) {
    var named = asNamed(T);
    if (named == nil) {
        return false;
    }
    var obj = named.Obj();
    return obj.Name() == "align64"u8 && obj.Pkg() != nil && (obj.Pkg().Path() == "sync/atomic"u8 || obj.Pkg().Path() == "internal/runtime/atomic"u8);
}

[GoRecv] public static slice<int64> Offsetsof(this ref StdSizes s, slice<ж<Var>> fields) {
    var offsets = new slice<int64>(len(fields));
    int64 offs = default!;
    foreach (var (i, f) in fields) {
        if (offs < 0) {
            // all remaining offsets are too large
            offsets[i] = -1;
            continue;
        }
        // offs >= 0
        var a = s.Alignof(f.typ);
        offs = align(offs, a);
        // possibly < 0 if align overflows
        offsets[i] = offs;
        {
            var d = s.Sizeof(f.typ); if (d >= 0 && offs >= 0){
                offs += d;
            } else {
                // ok to overflow to < 0
                offs = -1;
            }
        }
    }
    // f.typ or offs is too large
    return offsets;
}

internal static array<byte> basicSizes = new runtime.SparseArray<byte>{
    [Bool] = 1,
    [Int8] = 1,
    [Int16] = 2,
    [Int32] = 4,
    [Int64] = 8,
    [Uint8] = 1,
    [Uint16] = 2,
    [Uint32] = 4,
    [Uint64] = 8,
    [Float32] = 4,
    [Float64] = 8,
    [Complex64] = 8,
    [Complex128] = 16
}.array();

[GoRecv] public static int64 Sizeof(this ref StdSizes s, ΔType T) {
    switch (under(T).type()) {
    case Basic.val t: {
        assert(isTyped(T));
        BasicKind k = t.val.kind;
        if (((nint)k) < len(basicSizes)) {
            {
                var sΔ1 = basicSizes[k]; if (sΔ1 > 0) {
                    return ((int64)sΔ1);
                }
            }
        }
        if (k == ΔString) {
            return s.WordSize * 2;
        }
        break;
    }
    case Array.val t: {
        var n = t.val.len;
        if (n <= 0) {
            return 0;
        }
        var esize = s.Sizeof((~t).elem);
        if (esize < 0) {
            // n > 0
            return -1;
        }
        if (esize == 0) {
            // element too large
            return 0;
        }
        var a = s.Alignof((~t).elem);
        var ea = align(esize, // 0-size element
 // esize > 0
 a);
        if (ea < 0) {
            // possibly < 0 if align overflows
            return -1;
        }
        var n1 = n - 1;
// ea >= 1
// n1 >= 0
        // Final size is ea*n1 + esize; and size must be <= maxInt64.
        static readonly UntypedInt maxInt64 = /* 1<<63 - 1 */ 9223372036854775807;
        if (n1 > 0 && ea > maxInt64 / n1) {
            return -1;
        }
        return ea * n1 + esize;
    }
    case Slice.val t: {
        return s.WordSize * 3;
    }
    case Struct.val t: {
        n = t.NumFields();
        if (n == 0) {
            // ea*n1 overflows
            // may still overflow to < 0 which is ok
            return 0;
        }
        var offsets = s.Offsetsof((~t).fields);
        var offs = offsets[n - 1];
        var size = s.Sizeof((~t).fields[n - 1].typ);
        if (offs < 0 || size < 0) {
            return -1;
        }
        return offs + size;
    }
    case Interface.val t: {
        assert(!isTypeParam(T));
        return s.WordSize * 2;
    }
    case TypeParam.val t: {
        throw panic("unreachable");
        break;
    }
    case Union.val t: {
        throw panic("unreachable");
        break;
    }}
    // type too large
    // may overflow to < 0 which is ok
    // Type parameters lead to variable sizes/alignments;
    // StdSizes.Sizeof won't be called for them.
    return s.WordSize;
}

// catch-all
// When adding more architectures here,
// update the doc string of SizesFor below.
// common architecture word sizes and alignments
internal static map<@string, ж<gcSizes>> gcArchSizes = new map<@string, ж<gcSizes>>{
    ["386"u8] = new(4, 4),
    ["amd64"u8] = new(8, 8),
    ["amd64p32"u8] = new(4, 8),
    ["arm"u8] = new(4, 4),
    ["arm64"u8] = new(8, 8),
    ["loong64"u8] = new(8, 8),
    ["mips"u8] = new(4, 4),
    ["mipsle"u8] = new(4, 4),
    ["mips64"u8] = new(8, 8),
    ["mips64le"u8] = new(8, 8),
    ["ppc64"u8] = new(8, 8),
    ["ppc64le"u8] = new(8, 8),
    ["riscv64"u8] = new(8, 8),
    ["s390x"u8] = new(8, 8),
    ["sparc64"u8] = new(8, 8),
    ["wasm"u8] = new(8, 8)
};

// SizesFor returns the Sizes used by a compiler for an architecture.
// The result is nil if a compiler/architecture pair is not known.
//
// Supported architectures for compiler "gc":
// "386", "amd64", "amd64p32", "arm", "arm64", "loong64", "mips", "mipsle",
// "mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x", "sparc64", "wasm".
public static Sizes SizesFor(@string compiler, @string arch) {
    var exprᴛ1 = compiler;
    if (exprᴛ1 == "gc"u8) {
        {
            var s = gcSizesFor(compiler, arch); if (s != nil) {
                return new Sizes(s);
            }
        }
    }
    if (exprᴛ1 == "gccgo"u8) {
        {
            var s = gccgoArchSizes[arch];
            var ok = gccgoArchSizes[arch]; if (ok) {
                return new Sizes(s);
            }
        }
    }

    return default!;
}

// stdSizes is used if Config.Sizes == nil.
internal static Sizes stdSizes = SizesFor("gc"u8, "amd64"u8);

[GoRecv] internal static int64 alignof(this ref Config conf, ΔType T) {
    var f = () => stdSizes.Alignof();
    if (conf.Sizes != default!) {
        f = () => conf.Sizes.Alignof();
    }
    {
        var a = f(T); if (a >= 1) {
            return a;
        }
    }
    throw panic("implementation of alignof returned an alignment < 1");
}

[GoRecv] public static slice<int64> offsetsof(this ref Config conf, ж<Struct> ᏑT) {
    ref var T = ref ᏑT.val;

    slice<int64> offsets = default!;
    if (T.NumFields() > 0) {
        // compute offsets on demand
        var f = () => stdSizes.Offsetsof();
        if (conf.Sizes != default!) {
            f = () => conf.Sizes.Offsetsof();
        }
        offsets = f(T.fields);
        // sanity checks
        if (len(offsets) != T.NumFields()) {
            throw panic("implementation of offsetsof returned the wrong number of offsets");
        }
    }
    return offsets;
}

// offsetof returns the offset of the field specified via
// the index sequence relative to T. All embedded fields
// must be structs (rather than pointers to structs).
// If the offset is too large (because T is too large),
// the result is negative.
[GoRecv] internal static int64 offsetof(this ref Config conf, ΔType T, slice<nint> index) {
    int64 offs = default!;
    foreach (var (_, i) in index) {
        var s = under(T)._<Struct.val>();
        var d = conf.offsetsof(s)[i];
        if (d < 0) {
            return -1;
        }
        offs += d;
        if (offs < 0) {
            return -1;
        }
        T = (~s).fields[i].typ;
    }
    return offs;
}

// sizeof returns the size of T.
// If T is too large, the result is negative.
[GoRecv] internal static int64 @sizeof(this ref Config conf, ΔType T) {
    var f = () => stdSizes.Sizeof();
    if (conf.Sizes != default!) {
        f = () => conf.Sizes.Sizeof();
    }
    return f(T);
}

// align returns the smallest y >= x such that y % a == 0.
// a must be within 1 and 8 and it must be a power of 2.
// The result may be negative due to overflow.
internal static int64 align(int64 x, int64 a) {
    assert(x >= 0 && 1 <= a && a <= 8 && (int64)(a & (a - 1)) == 0);
    return (int64)((x + a - 1) & ~(a - 1));
}

} // end types_package
