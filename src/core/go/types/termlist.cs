// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/termlist.go
// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go.go;

using strings = strings_package;

partial class types_package {

[GoType("[]term")] partial struct Δtermlist;

// allTermlist represents the set of all types.
// It is in normal form.
internal static Δtermlist allTermlist = new Δtermlist{@new<term>()};

// termSep is the separator used between individual terms.
internal static readonly @string termSep = " | "u8;

// String prints the termlist exactly (without normalization).
public static @string String(this Δtermlist xl) {
    if (len(xl) == 0) {
        return "∅"u8;
    }
    strings.Builder buf = default!;
    foreach (var (i, x) in xl) {
        if (i > 0) {
            buf.WriteString(termSep);
        }
        buf.WriteString(x.String());
    }
    return buf.String();
}

// isEmpty reports whether the termlist xl represents the empty set of types.
internal static bool isEmpty(this Δtermlist xl) {
    // If there's a non-nil term, the entire list is not empty.
    // If the termlist is in normal form, this requires at most
    // one iteration.
    foreach (var (_, x) in xl) {
        if (x != nil) {
            return false;
        }
    }
    return true;
}

// isAll reports whether the termlist xl represents the set of all types.
internal static bool isAll(this Δtermlist xl) {
    // If there's a 𝓤 term, the entire list is 𝓤.
    // If the termlist is in normal form, this requires at most
    // one iteration.
    foreach (var (_, x) in xl) {
        if (x != nil && (~x).typ == default!) {
            return true;
        }
    }
    return false;
}

// norm returns the normal form of xl.
internal static Δtermlist norm(this Δtermlist xl) {
    // Quadratic algorithm, but good enough for now.
    // TODO(gri) fix asymptotic performance
    var used = new slice<bool>(len(xl));
    Δtermlist rl = default!;
    foreach (var (i, xi) in xl) {
        if (xi == nil || used[i]) {
            continue;
        }
        for (nint j = i + 1; j < len(xl); j++) {
            var xj = xl[j];
            if (xj == nil || used[j]) {
                continue;
            }
            {
                (u1, u2) = xi.union(xj); if (u2 == nil) {
                    // If we encounter a 𝓤 term, the entire list is 𝓤.
                    // Exit early.
                    // (Note that this is not just an optimization;
                    // if we continue, we may end up with a 𝓤 term
                    // and other terms and the result would not be
                    // in normal form.)
                    if ((~u1).typ == default!) {
                        return allTermlist;
                    }
                    xi = u1;
                    used[j] = true;
                }
            }
        }
        // xj is now unioned into xi - ignore it in future iterations
        rl = append(rl, xi);
    }
    return rl;
}

// union returns the union xl ∪ yl.
internal static Δtermlist union(this Δtermlist xl, Δtermlist yl) {
    return append(xl, Ꮡyl.ꓸꓸꓸ).norm();
}

// intersect returns the intersection xl ∩ yl.
internal static Δtermlist intersect(this Δtermlist xl, Δtermlist yl) {
    if (xl.isEmpty() || yl.isEmpty()) {
        return default!;
    }
    // Quadratic algorithm, but good enough for now.
    // TODO(gri) fix asymptotic performance
    Δtermlist rl = default!;
    foreach (var (_, x) in xl) {
        foreach (var (_, y) in yl) {
            {
                var r = x.intersect(y); if (r != nil) {
                    rl = append(rl, r);
                }
            }
        }
    }
    return rl.norm();
}

// equal reports whether xl and yl represent the same type set.
internal static bool equal(this Δtermlist xl, Δtermlist yl) {
    // TODO(gri) this should be more efficient
    return xl.subsetOf(yl) && yl.subsetOf(xl);
}

// includes reports whether t ∈ xl.
internal static bool includes(this Δtermlist xl, ΔType t) {
    foreach (var (_, x) in xl) {
        if (x.includes(t)) {
            return true;
        }
    }
    return false;
}

// supersetOf reports whether y ⊆ xl.
public static bool supersetOf(this Δtermlist xl, ж<term> Ꮡy) {
    ref var y = ref Ꮡy.val;

    foreach (var (_, x) in xl) {
        if (y.subsetOf(x)) {
            return true;
        }
    }
    return false;
}

// subsetOf reports whether xl ⊆ yl.
internal static bool subsetOf(this Δtermlist xl, Δtermlist yl) {
    if (yl.isEmpty()) {
        return xl.isEmpty();
    }
    // each term x of xl must be a subset of yl
    foreach (var (_, x) in xl) {
        if (!yl.supersetOf(x)) {
            return false;
        }
    }
    // x is not a subset yl
    return true;
}

} // end types_package
