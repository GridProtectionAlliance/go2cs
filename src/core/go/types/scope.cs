// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/scope.go
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements Scopes.
namespace go.go;

using fmt = fmt_package;
using token = go.token_package;
using io = io_package;
using sort = sort_package;
using strings = strings_package;
using sync = sync_package;

partial class types_package {

// A Scope maintains a set of objects and links to its containing
// (parent) and contained (children) scopes. Objects may be inserted
// and looked up by name. The zero value for Scope is a ready-to-use
// empty scope.
[GoType] partial struct ΔScope {
    internal ж<ΔScope> parent;
    internal slice<ж<ΔScope>> children;
    internal nint number;              // parent.children[number-1] is this scope; 0 if there is no parent
    internal map<@string, Object> elems; // lazily allocated
    internal go.token_package.ΔPos pos;       // scope extent; may be invalid
    internal go.token_package.ΔPos end;
    internal @string comment;           // for debugging only
    internal bool isFunc;              // set if this is a function scope (internal use only)
}

// NewScope returns a new, empty scope contained in the given parent
// scope, if any. The comment is for debugging only.
public static ж<ΔScope> NewScope(ж<ΔScope> Ꮡparent, tokenꓸPos pos, tokenꓸPos end, @string comment) {
    ref var parent = ref Ꮡparent.val;

    var s = Ꮡ(new ΔScope(Ꮡparent, default!, 0, default!, pos, end, comment, false));
    // don't add children to Universe scope!
    if (parent != nil && Ꮡparent != Universe) {
        parent.children = append(parent.children, s);
        s.val.number = len(parent.children);
    }
    return s;
}

// Parent returns the scope's containing (parent) scope.
[GoRecv] public static ж<ΔScope> Parent(this ref ΔScope s) {
    return s.parent;
}

// Len returns the number of scope elements.
[GoRecv] public static nint Len(this ref ΔScope s) {
    return len(s.elems);
}

// Names returns the scope's element names in sorted order.
[GoRecv] public static slice<@string> Names(this ref ΔScope s) {
    var names = new slice<@string>(len(s.elems));
    nint i = 0;
    foreach (var (name, _) in s.elems) {
        names[i] = name;
        i++;
    }
    sort.Strings(names);
    return names;
}

// NumChildren returns the number of scopes nested in s.
[GoRecv] public static nint NumChildren(this ref ΔScope s) {
    return len(s.children);
}

// Child returns the i'th child scope for 0 <= i < NumChildren().
[GoRecv] public static ж<ΔScope> Child(this ref ΔScope s, nint i) {
    return s.children[i];
}

// Lookup returns the object in scope s with the given name if such an
// object exists; otherwise the result is nil.
[GoRecv] public static Object Lookup(this ref ΔScope s, @string name) {
    var obj = resolve(name, s.elems[name]);
    // Hijack Lookup for "any": with gotypesalias=1, we want the Universe to
    // return an Alias for "any", and with gotypesalias=0 we want to return
    // the legacy representation of aliases.
    //
    // This is rather tricky, but works out after auditing of the usage of
    // s.elems. The only external API to access scope elements is Lookup.
    //
    // TODO: remove this once gotypesalias=0 is no longer supported.
    if (Ꮡobj == ~universeAnyAlias && !aliasAny()) {
        return ~universeAnyNoAlias;
    }
    return obj;
}

// LookupParent follows the parent chain of scopes starting with s until
// it finds a scope where Lookup(name) returns a non-nil object, and then
// returns that scope and object. If a valid position pos is provided,
// only objects that were declared at or before pos are considered.
// If no such scope and object exists, the result is (nil, nil).
//
// Note that obj.Parent() may be different from the returned scope if the
// object was inserted into the scope and already had a parent at that
// time (see Insert). This can only happen for dot-imported objects
// whose scope is the scope of the package that exported them.
[GoRecv("capture")] public static (ж<ΔScope>, Object) LookupParent(this ref ΔScope s, @string name, tokenꓸPos pos) {
    for (; s != nil; s = s.parent) {
        {
            var obj = s.Lookup(name); if (obj != default! && (!pos.IsValid() || cmpPos(obj.scopePos(), pos) <= 0)) {
                return (LookupParentꓸᏑs, obj);
            }
        }
    }
    return (default!, default!);
}

// Insert attempts to insert an object obj into scope s.
// If s already contains an alternative object alt with
// the same name, Insert leaves s unchanged and returns alt.
// Otherwise it inserts obj, sets the object's parent scope
// if not already set, and returns nil.
[GoRecv] public static Object Insert(this ref ΔScope s, Object obj) {
    @string name = obj.Name();
    {
        var alt = s.Lookup(name); if (alt != default!) {
            return alt;
        }
    }
    s.insert(name, obj);
    if (obj.Parent() == nil) {
        obj.setParent(s);
    }
    return default!;
}

// InsertLazy is like Insert, but allows deferring construction of the
// inserted object until it's accessed with Lookup. The Object
// returned by resolve must have the same name as given to InsertLazy.
// If s already contains an alternative object with the same name,
// InsertLazy leaves s unchanged and returns false. Otherwise it
// records the binding and returns true. The object's parent scope
// will be set to s after resolve is called.
[GoRecv] internal static bool _InsertLazy(this ref ΔScope s, @string name, Func<Object> resolve) {
    if (s.elems[name] != default!) {
        return false;
    }
    s.insert(name, new lazyObject(parent: s, resolve: resolve));
    return true;
}

[GoRecv] internal static void insert(this ref ΔScope s, @string name, Object obj) {
    if (s.elems == default!) {
        s.elems = new map<@string, Object>();
    }
    s.elems[name] = obj;
}

// Squash merges s with its parent scope p by adding all
// objects of s to p, adding all children of s to the
// children of p, and removing s from p's children.
// The function f is called for each object obj in s which
// has an object alt in p. s should be discarded after
// having been squashed.
[GoRecv] internal static void squash(this ref ΔScope s, types.Object) err) {
    var p = s.parent;
    assert(p != nil);
    foreach (var (name, obj) in s.elems) {
        obj = resolve(name, obj);
        obj.setParent(nil);
        {
            var alt = p.Insert(obj); if (alt != default!) {
                err(obj, alt);
            }
        }
    }
    nint j = -1;
    // index of s in p.children
    foreach (var (i, ch) in (~p).children) {
        if (ch == s) {
            j = i;
            break;
        }
    }
    assert(j >= 0);
    nint k = len((~p).children) - 1;
    (~p).children[j] = (~p).children[k];
    p.val.children = (~p).children[..(int)(k)];
    p.val.children = append((~p).children, s.children.ꓸꓸꓸ);
    s.children = default!;
    s.elems = default!;
}

// Pos and End describe the scope's source code extent [pos, end).
// The results are guaranteed to be valid only if the type-checked
// AST has complete position information. The extent is undefined
// for Universe and package scopes.
[GoRecv] public static tokenꓸPos Pos(this ref ΔScope s) {
    return s.pos;
}

[GoRecv] public static tokenꓸPos End(this ref ΔScope s) {
    return s.end;
}

// Contains reports whether pos is within the scope's extent.
// The result is guaranteed to be valid only if the type-checked
// AST has complete position information.
[GoRecv] public static bool Contains(this ref ΔScope s, tokenꓸPos pos) {
    return cmpPos(s.pos, pos) <= 0 && cmpPos(pos, s.end) < 0;
}

// Innermost returns the innermost (child) scope containing
// pos. If pos is not within any scope, the result is nil.
// The result is also nil for the Universe scope.
// The result is guaranteed to be valid only if the type-checked
// AST has complete position information.
[GoRecv("capture")] public static ж<ΔScope> Innermost(this ref ΔScope s, tokenꓸPos pos) {
    // Package scopes do not have extents since they may be
    // discontiguous, so iterate over the package's files.
    if (s.parent == Universe) {
        foreach (var (_, sΔ1) in s.children) {
            {
                var inner = sΔ1.Innermost(pos); if (inner != nil) {
                    return inner;
                }
            }
        }
    }
    if (s.Contains(pos)) {
        foreach (var (_, sΔ2) in s.children) {
            if (sΔ2.Contains(pos)) {
                return sΔ2.Innermost(pos);
            }
        }
        return InnermostꓸᏑs;
    }
    return default!;
}

// WriteTo writes a string representation of the scope to w,
// with the scope elements sorted by name.
// The level of indentation is controlled by n >= 0, with
// n == 0 for no indentation.
// If recurse is set, it also writes nested (children) scopes.
[GoRecv] public static void WriteTo(this ref ΔScope s, io.Writer w, nint n, bool recurse) {
    @string ind = ".  "u8;
    @string indn = strings.Repeat(ind, n);
    fmt.Fprintf(w, "%s%s scope %p {\n"u8, indn, s.comment, s);
    @string indn1 = indn + ind;
    foreach (var (_, name) in s.Names()) {
        fmt.Fprintf(w, "%s%s\n"u8, indn1, s.Lookup(name));
    }
    if (recurse) {
        foreach (var (_, sΔ1) in s.children) {
            sΔ1.WriteTo(w, n + 1, recurse);
        }
    }
    fmt.Fprintf(w, "%s}\n"u8, indn);
}

// String returns a string representation of the scope, for debugging.
[GoRecv] public static @string String(this ref ΔScope s) {
    ref var buf = ref heap(new strings_package.Builder(), out var Ꮡbuf);
    s.WriteTo(~Ꮡbuf, 0, false);
    return buf.String();
}

// A lazyObject represents an imported Object that has not been fully
// resolved yet by its importer.
[GoType] partial struct lazyObject {
    internal ж<ΔScope> parent;
    internal Func<Object> resolve;
    internal Object obj;
    internal sync_package.Once once;
}

// resolve returns the Object represented by obj, resolving lazy
// objects as appropriate.
internal static Object resolve(@string name, Object obj) {
    {
        var (lazy, ok) = obj._<lazyObject.val>(ᐧ); if (ok) {
            (~lazy).once.Do(
            var lazyʗ2 = lazy;
            () => {
                var objΔ1 = (~lazyʗ2).resolve();
                {
                    var (_, okΔ1) = obj._<lazyObject.val>(ᐧ); if (okΔ1) {
                        throw panic("recursive lazy object");
                    }
                }
                if (objΔ1.Name() != name) {
                    throw panic("lazy object has unexpected name");
                }
                if (objΔ1.Parent() == nil) {
                    objΔ1.setParent((~lazyʗ2).parent);
                }
                lazyʗ2.val.obj = objΔ1;
            });
            obj = lazy.val.obj;
        }
    }
    return obj;
}

// stub implementations so *lazyObject implements Object and we can
// store them directly into Scope.elems.
[GoRecv] internal static ж<ΔScope> Parent(this ref lazyObject _) {
    throw panic("unreachable");
}

[GoRecv] internal static tokenꓸPos Pos(this ref lazyObject _) {
    throw panic("unreachable");
}

[GoRecv] internal static ж<Package> Pkg(this ref lazyObject _) {
    throw panic("unreachable");
}

[GoRecv] internal static @string Name(this ref lazyObject _) {
    throw panic("unreachable");
}

[GoRecv] internal static ΔType Type(this ref lazyObject _) {
    throw panic("unreachable");
}

[GoRecv] internal static bool Exported(this ref lazyObject _) {
    throw panic("unreachable");
}

[GoRecv] internal static @string Id(this ref lazyObject _) {
    throw panic("unreachable");
}

[GoRecv] internal static @string String(this ref lazyObject _) {
    throw panic("unreachable");
}

[GoRecv] internal static uint32 order(this ref lazyObject _) {
    throw panic("unreachable");
}

[GoRecv] internal static Δcolor color(this ref lazyObject _) {
    throw panic("unreachable");
}

[GoRecv] internal static void setType(this ref lazyObject _, ΔType _) {
    throw panic("unreachable");
}

[GoRecv] internal static void setOrder(this ref lazyObject _, uint32 _) {
    throw panic("unreachable");
}

[GoRecv] internal static void setColor(this ref lazyObject _, Δcolor Δcolor) {
    throw panic("unreachable");
}

[GoRecv] internal static void setParent(this ref lazyObject , ж<ΔScope> Ꮡ) {
    ref var  = ref Ꮡ.val;

    throw panic("unreachable");
}

[GoRecv] internal static bool sameId(this ref lazyObject , ж<Package> Ꮡ, @string , bool ) {
    ref var  = ref Ꮡ.val;

    throw panic("unreachable");
}

[GoRecv] internal static tokenꓸPos scopePos(this ref lazyObject _) {
    throw panic("unreachable");
}

[GoRecv] internal static void setScopePos(this ref lazyObject _, tokenꓸPos _) {
    throw panic("unreachable");
}

} // end types_package
