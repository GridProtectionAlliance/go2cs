// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/typestring.go
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements printing of types.
namespace go.go;

using bytes = bytes_package;
using fmt = fmt_package;
using sort = sort_package;
using strconv = strconv_package;
using strings = strings_package;
using utf8 = unicode.utf8_package;
using unicode;

partial class types_package {

public delegate @string Qualifier(ж<Package> _);

// RelativeTo returns a [Qualifier] that fully qualifies members of
// all packages other than pkg.
public static Qualifier RelativeTo(ж<Package> Ꮡpkg) {
    ref var pkg = ref Ꮡpkg.val;

    if (pkg == nil) {
        return default!;
    }
    return (ж<Package> other) => {
        if (Ꮡpkg == other) {
            return ""u8;
        }
        // same package; unqualified
        return other.Path();
    };
}

// TypeString returns the string representation of typ.
// The [Qualifier] controls the printing of
// package-level objects, and may be nil.
public static @string TypeString(ΔType typ, Qualifier qf) {
    ref var buf = ref heap(new bytes_package.Buffer(), out var Ꮡbuf);
    WriteType(Ꮡbuf, typ, qf);
    return buf.String();
}

// WriteType writes the string representation of typ to buf.
// The [Qualifier] controls the printing of
// package-level objects, and may be nil.
public static void WriteType(ж<bytes.Buffer> Ꮡbuf, ΔType typ, Qualifier qf) {
    ref var buf = ref Ꮡbuf.val;

    newTypeWriter(Ꮡbuf, qf).typ(typ);
}

// WriteSignature writes the representation of the signature sig to buf,
// without a leading "func" keyword. The [Qualifier] controls the printing
// of package-level objects, and may be nil.
public static void WriteSignature(ж<bytes.Buffer> Ꮡbuf, ж<ΔSignature> Ꮡsig, Qualifier qf) {
    ref var buf = ref Ꮡbuf.val;
    ref var sig = ref Ꮡsig.val;

    newTypeWriter(Ꮡbuf, qf).signature(Ꮡsig);
}

[GoType] partial struct typeWriter {
    internal ж<bytes_package.Buffer> buf;
    internal map<ΔType, bool> seen;
    internal Qualifier qf;
    internal ж<Context> ctxt;    // if non-nil, we are type hashing
    internal ж<TypeParamList> tparams; // local type parameters
    internal bool paramNames;           // if set, write function parameter names, otherwise, write types only
    internal bool tpSubscripts;           // if set, write type parameter indices as subscripts
    internal bool pkgInfo;           // package-annotate first unexported-type field to avoid confusing type description
}

internal static ж<typeWriter> newTypeWriter(ж<bytes.Buffer> Ꮡbuf, Qualifier qf) {
    ref var buf = ref Ꮡbuf.val;

    return Ꮡ(new typeWriter(Ꮡbuf, new map<ΔType, bool>(), qf, nil, nil, true, false, false));
}

internal static ж<typeWriter> newTypeHasher(ж<bytes.Buffer> Ꮡbuf, ж<Context> Ꮡctxt) {
    ref var buf = ref Ꮡbuf.val;
    ref var ctxt = ref Ꮡctxt.val;

    assert(ctxt != nil);
    return Ꮡ(new typeWriter(Ꮡbuf, new map<ΔType, bool>(), default!, Ꮡctxt, nil, false, false, false));
}

[GoRecv] internal static void @byte(this ref typeWriter w, byte b) {
    if (w.ctxt != nil) {
        if (b == (rune)' ') {
            b = (rune)'#';
        }
        w.buf.WriteByte(b);
        return;
    }
    w.buf.WriteByte(b);
    if (b == (rune)',' || b == (rune)';') {
        w.buf.WriteByte((rune)' ');
    }
}

[GoRecv] internal static void @string(this ref typeWriter w, @string s) {
    w.buf.WriteString(s);
}

[GoRecv] internal static void error(this ref typeWriter w, @string msg) {
    if (w.ctxt != nil) {
        throw panic(msg);
    }
    w.buf.WriteString("<"u8 + msg + ">"u8);
}

[GoRecv] internal static void typ(this ref typeWriter w, ΔType typ) => func((defer, _) => {
    if (w.seen[typ]) {
        w.error("cycle to "u8 + goTypeName(typ));
        return;
    }
    w.seen[typ] = true;
    deferǃ(delete, w.seen, typ, defer);
    switch (typ.type()) {
    case default! t: {
        w.error("nil"u8);
        break;
    }
    case Basic.val t: {
        if (isExported((~t).name)) {
            // exported basic types go into package unsafe
            // (currently this is just unsafe.Pointer)
            {
                var (obj, _) = (~Unsafe).scope.Lookup((~t).name)._<TypeName.val>(ᐧ); if (obj != nil) {
                    w.typeName(obj);
                    break;
                }
            }
        }
        w.@string((~t).name);
        break;
    }
    case Array.val t: {
        w.@byte((rune)'[');
        w.@string(strconv.FormatInt((~t).len, 10));
        w.@byte((rune)']');
        w.typ((~t).elem);
        break;
    }
    case Slice.val t: {
        w.@string("[]"u8);
        w.typ((~t).elem);
        break;
    }
    case Struct.val t: {
        w.@string("struct{"u8);
        foreach (var (i, f) in (~t).fields) {
            if (i > 0) {
                w.@byte((rune)';');
            }
            // If disambiguating one struct for another, look for the first unexported field.
            // Do this first in case of nested structs; tag the first-outermost field.
            var pkgAnnotate = false;
            if (w.qf == default! && w.pkgInfo && !isExported(f.name)) {
                // note for embedded types, type name is field name, and "string" etc are lower case hence unexported.
                pkgAnnotate = true;
                w.pkgInfo = false;
            }
            // only tag once
            // This doesn't do the right thing for embedded type
            // aliases where we should print the alias name, not
            // the aliased type (see go.dev/issue/44410).
            if (!(~f).embedded) {
                w.@string(f.name);
                w.@byte((rune)' ');
            }
            w.typ(f.typ);
            if (pkgAnnotate) {
                w.@string(" /* package "u8);
                w.@string(f.pkg.Path());
                w.@string(" */ "u8);
            }
            {
                @string tag = t.Tag(i); if (tag != ""u8) {
                    w.@byte((rune)' ');
                    // TODO(gri) If tag contains blanks, replacing them with '#'
                    //           in Context.TypeHash may produce another tag
                    //           accidentally.
                    w.@string(strconv.Quote(tag));
                }
            }
        }
        w.@byte((rune)'}');
        break;
    }
    case Pointer.val t: {
        w.@byte((rune)'*');
        w.typ((~t).@base);
        break;
    }
    case Tuple.val t: {
        w.tuple(t, false);
        break;
    }
    case ΔSignature.val t: {
        w.@string("func"u8);
        w.signature(t);
        break;
    }
    case Union.val t: {
        if (t.Len() == 0) {
            // Unions only appear as (syntactic) embedded elements
            // in interfaces and syntactically cannot be empty.
            w.error("empty union"u8);
            break;
        }
        foreach (var (i, t) in (~t).terms) {
            if (i > 0) {
                w.@string(termSep);
            }
            if ((~t).tilde) {
                w.@byte((rune)'~');
            }
            w.typ((~t).typ);
        }
        break;
    }
    case Interface.val t: {
        if (w.ctxt == nil) {
            if (~t == universeAnyAlias.Type().Underlying()) {
                // When not hashing, we can try to improve type strings by writing "any"
                // for a type that is pointer-identical to universeAny.
                // TODO(rfindley): this logic should not be necessary with
                // gotypesalias=1. Remove once that is always the case.
                w.@string("any"u8);
                break;
            }
            if (~t == (~asNamed(universeComparable.Type())).underlying) {
                w.@string("interface{comparable}"u8);
                break;
            }
        }
        if ((~t).@implicit) {
            if (len((~t).methods) == 0 && len((~t).embeddeds) == 1) {
                w.typ((~t).embeddeds[0]);
                break;
            }
            // Something's wrong with the implicit interface.
            // Print it as such and continue.
            w.@string("/* implicit */ "u8);
        }
        w.@string("interface{"u8);
        var first = true;
        if (w.ctxt != nil){
            w.typeSet(t.typeSet());
        } else {
            foreach (var (_, m) in (~t).methods) {
                if (!first) {
                    w.@byte((rune)';');
                }
                first = false;
                w.@string(m.name);
                w.signature(m.typ._<ΔSignature.val>());
            }
            foreach (var (_, typΔ1) in (~t).embeddeds) {
                if (!first) {
                    w.@byte((rune)';');
                }
                first = false;
                w.typΔ1(typΔ1);
            }
        }
        w.@byte((rune)'}');
        break;
    }
    case Map.val t: {
        w.@string("map["u8);
        w.typ((~t).key);
        w.@byte((rune)']');
        w.typ((~t).elem);
        break;
    }
    case Chan.val t: {
        @string s = default!;
        bool parens = default!;
        var exprᴛ1 = (~t).dir;
        if (exprᴛ1 == SendRecv) {
            s = "chan "u8;
            {
                var (c, _) = (~t).elem._<Chan.val>(ᐧ); if (c != nil && (~c).dir == RecvOnly) {
                    // chan (<-chan T) requires parentheses
                    parens = true;
                }
            }
        }
        else if (exprᴛ1 == SendOnly) {
            s = "chan<- "u8;
        }
        else if (exprᴛ1 == RecvOnly) {
            s = "<-chan "u8;
        }
        else { /* default: */
            w.error("unknown channel direction"u8);
        }

        w.@string(s);
        if (parens) {
            w.@byte((rune)'(');
        }
        w.typ((~t).elem);
        if (parens) {
            w.@byte((rune)')');
        }
        break;
    }
    case Named.val t: {
        if (w.ctxt != nil) {
            // If hashing, write a unique prefix for t to represent its identity, since
            // named type identity is pointer identity.
            w.@string(strconv.Itoa(w.ctxt.getID(~t)));
        }
        w.typeName((~t).obj);
        if ((~t).inst != nil){
            // when hashing written for readability of the hash only
            // instantiated type
            w.typeList((~(~t).inst).targs.list());
        } else 
        if (w.ctxt == nil && t.TypeParams().Len() != 0) {
            // For type hashing, don't need to format the TypeParams
            // parameterized type
            w.tParamList(t.TypeParams().list());
        }
        break;
    }
    case TypeParam.val t: {
        if ((~t).obj == nil) {
            w.error("unnamed type parameter"u8);
            break;
        }
        {
            nint i = tparamIndex(w.tparams.list(), t); if (i >= 0){
                // The names of type parameters that are declared by the type being
                // hashed are not part of the type identity. Replace them with a
                // placeholder indicating their index.
                w.@string(fmt.Sprintf("$%d"u8, i));
            } else {
                w.@string((~t).obj.name);
                if (w.tpSubscripts || w.ctxt != nil) {
                    w.@string(subscript((~t).id));
                }
                // If the type parameter name is the same as a predeclared object
                // (say int), point out where it is declared to avoid confusing
                // error messages. This doesn't need to be super-elegant; we just
                // need a clear indication that this is not a predeclared name.
                if (w.ctxt == nil && Universe.Lookup((~t).obj.name) != default!) {
                    if (isTypes2){
                        w.@string(fmt.Sprintf(" /* with %s declared at %v */"u8, (~t).obj.name, (~t).obj.Pos()));
                    } else {
                        // Can't print position information because
                        // we don't have a token.FileSet accessible.
                        w.@string("/* type parameter */"u8);
                    }
                }
            }
        }
        break;
    }
    case Alias.val t: {
        w.typeName((~t).obj);
        {
            var list = (~t).targs.list(); if (len(list) != 0) {
                // instantiated type
                w.typeList(list);
            }
        }
        if (w.ctxt != nil) {
            // TODO(gri) do we need to print the alias type name, too?
            w.typ(Unalias((~t).obj.typ));
        }
        break;
    }
    default: {
        var t = typ.type();
        w.@string(t.String());
        break;
    }}
});

// For externally defined implementations of Type.
// Note: In this case cycles won't be caught.

// typeSet writes a canonical hash for an interface type set.
[GoRecv] internal static void typeSet(this ref typeWriter w, ж<_TypeSet> Ꮡs) {
    ref var s = ref Ꮡs.val;

    assert(w.ctxt != nil);
    var first = true;
    foreach (var (_, m) in s.methods) {
        if (!first) {
            w.@byte((rune)';');
        }
        first = false;
        w.@string(m.name);
        w.signature(m.typ._<ΔSignature.val>());
    }
    switch (ᐧ) {
    case {} when s.terms.isAll(): {
        break;
    }
    case {} when s.terms.isEmpty(): {
        w.@string(s.terms.String());
        break;
    }
    default: {
// nothing to do
        slice<@string> termHashes = default!;
        foreach (var (_, term) in s.terms) {
            // terms are not canonically sorted, so we sort their hashes instead.
            ref var buf = ref heap(new bytes_package.Buffer(), out var Ꮡbuf);
            if ((~term).tilde) {
                buf.WriteByte((rune)'~');
            }
            newTypeHasher(Ꮡbuf, w.ctxt).typ((~term).typ);
            termHashes = append(termHashes, buf.String());
        }
        sort.Strings(termHashes);
        if (!first) {
            w.@byte((rune)';');
        }
        w.@string(strings.Join(termHashes, "|"u8));
        break;
    }}

}

[GoRecv] internal static void typeList(this ref typeWriter w, slice<ΔType> list) {
    w.@byte((rune)'[');
    foreach (var (i, typ) in list) {
        if (i > 0) {
            w.@byte((rune)',');
        }
        w.typ(typ);
    }
    w.@byte((rune)']');
}

[GoRecv] internal static void tParamList(this ref typeWriter w, slice<ж<TypeParam>> list) {
    w.@byte((rune)'[');
    ΔType prev = default!;
    foreach (var (i, tpar) in list) {
        // Determine the type parameter and its constraint.
        // list is expected to hold type parameter names,
        // but don't crash if that's not the case.
        if (tpar == nil) {
            w.error("nil type parameter"u8);
            continue;
        }
        if (i > 0) {
            if (!AreEqual((~tpar).bound, prev)) {
                // bound changed - write previous one before advancing
                w.@byte((rune)' ');
                w.typ(prev);
            }
            w.@byte((rune)',');
        }
        prev = tpar.val.bound;
        w.typ(~tpar);
    }
    if (prev != default!) {
        w.@byte((rune)' ');
        w.typ(prev);
    }
    w.@byte((rune)']');
}

[GoRecv] internal static void typeName(this ref typeWriter w, ж<TypeName> Ꮡobj) {
    ref var obj = ref Ꮡobj.val;

    w.@string(packagePrefix(obj.pkg, w.qf));
    w.@string(obj.name);
}

[GoRecv] internal static void tuple(this ref typeWriter w, ж<Tuple> Ꮡtup, bool variadic) {
    ref var tup = ref Ꮡtup.val;

    w.@byte((rune)'(');
    if (tup != nil) {
        foreach (var (i, v) in tup.vars) {
            if (i > 0) {
                w.@byte((rune)',');
            }
            // parameter names are ignored for type identity and thus type hashes
            if (w.ctxt == nil && v.name != ""u8 && w.paramNames) {
                w.@string(v.name);
                w.@byte((rune)' ');
            }
            var typ = v.typ;
            if (variadic && i == len(tup.vars) - 1) {
                {
                    var (s, ok) = typ._<Slice.val>(ᐧ); if (ok){
                        w.@string("..."u8);
                        typ = s.val.elem;
                    } else {
                        // special case:
                        // append(s, "foo"...) leads to signature func([]byte, string...)
                        {
                            var (t, _) = under(typ)._<Basic.val>(ᐧ); if (t == nil || (~t).kind != ΔString) {
                                w.error("expected string type"u8);
                                continue;
                            }
                        }
                        w.typ(typ);
                        w.@string("..."u8);
                        continue;
                    }
                }
            }
            w.typ(typ);
        }
    }
    w.@byte((rune)')');
}

[GoRecv] internal static void signature(this ref typeWriter w, ж<ΔSignature> Ꮡsig) => func((defer, _) => {
    ref var sig = ref Ꮡsig.val;

    if (sig.TypeParams().Len() != 0) {
        if (w.ctxt != nil) {
            assert(w.tparams == nil);
            w.tparams = sig.TypeParams();
            defer(() => {
                w.tparams = default!;
            });
        }
        w.tParamList(sig.TypeParams().list());
    }
    w.tuple(sig.@params, sig.variadic);
    nint n = sig.results.Len();
    if (n == 0) {
        // no result
        return;
    }
    w.@byte((rune)' ');
    if (n == 1 && (w.ctxt != nil || sig.results.vars[0].name == ""u8)) {
        // single unnamed result (if type hashing, name must be ignored)
        w.typ(sig.results.vars[0].typ);
        return;
    }
    // multiple or named result(s)
    w.tuple(sig.results, false);
});

// subscript returns the decimal (utf8) representation of x using subscript digits.
internal static @string subscript(uint64 x) {
    const nint w = /* len("₀") */ 3; // all digits 0...9 have the same utf8 width
    array<byte> buf = new(96); /* 32 * w */
    nint i = len(buf);
    while (ᐧ) {
        i -= w;
        utf8.EncodeRune(buf[(int)(i)..], (rune)'₀' + ((rune)(x % 10)));
        // '₀' == U+2080
        x /= 10;
        if (x == 0) {
            break;
        }
    }
    return ((@string)(buf[(int)(i)..]));
}

} // end types_package
