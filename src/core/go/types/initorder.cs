// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/initorder.go
// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go.go;

using heap = container.heap_package;
using fmt = fmt_package;
using static @internal.types.errors_package;
using sort = sort_package;
using container;

partial class types_package {

// initOrder computes the Info.InitOrder for package variables.
[GoRecv] internal static void initOrder(this ref Checker check) {
    // An InitOrder may already have been computed if a package is
    // built from several calls to (*Checker).Files. Clear it.
    check.Info.InitOrder = check.Info.InitOrder[..0];
    // Compute the object dependency graph and initialize
    // a priority queue with the list of graph nodes.
    var pq = ((nodeQueue)dependencyGraph(check.objMap));
    heap.Init(pq);
    const bool debug = false;
    if (debug) {
        fmt.Printf("Computing initialization order for %s\n\n"u8, check.pkg);
        fmt.Println("Object dependency graph:");
        foreach (var (obj, d) in check.objMap) {
            // only print objects that may appear in the dependency graph
            {
                var (objΔ1, _) = obj._<dependency>(ᐧ); if (objΔ1 != default!) {
                    if (len((~d).deps) > 0){
                        fmt.Printf("\t%s depends on\n"u8, objΔ1.Name());
                        foreach (var (dep, _) in (~d).deps) {
                            fmt.Printf("\t\t%s\n"u8, dep.Name());
                        }
                    } else {
                        fmt.Printf("\t%s has no dependencies\n"u8, objΔ1.Name());
                    }
                }
            }
        }
        fmt.Println();
        fmt.Println("Transposed object dependency graph (functions eliminated):");
        foreach (var (_, n) in pq) {
            fmt.Printf("\t%s depends on %d nodes\n"u8, (~n).obj.Name(), (~n).ndeps);
            foreach (var (p, _) in (~n).pred) {
                fmt.Printf("\t\t%s is dependent\n"u8, (~p).obj.Name());
            }
        }
        fmt.Println();
        fmt.Println("Processing nodes:");
    }
    // Determine initialization order by removing the highest priority node
    // (the one with the fewest dependencies) and its edges from the graph,
    // repeatedly, until there are no nodes left.
    // In a valid Go program, those nodes always have zero dependencies (after
    // removing all incoming dependencies), otherwise there are initialization
    // cycles.
    var emitted = new map<ж<declInfo>, bool>();
    while (len(pq) > 0) {
        // get the next node
        var n = heap.Pop(pq)._<graphNode.val>();
        if (debug) {
            fmt.Printf("\t%s (src pos %d) depends on %d nodes now\n"u8,
                (~n).obj.Name(), (~n).obj.order(), (~n).ndeps);
        }
        // if n still depends on other nodes, we have a cycle
        if ((~n).ndeps > 0) {
            var cycle = findPath(check.objMap, (~n).obj, (~n).obj, new map<Object, bool>());
            // If n.obj is not part of the cycle (e.g., n.obj->b->c->d->c),
            // cycle will be nil. Don't report anything in that case since
            // the cycle is reported when the algorithm gets to an object
            // in the cycle.
            // Furthermore, once an object in the cycle is encountered,
            // the cycle will be broken (dependency count will be reduced
            // below), and so the remaining nodes in the cycle don't trigger
            // another error (unless they are part of multiple cycles).
            if (cycle != default!) {
                check.reportCycle(cycle);
            }
        }
        // Ok to continue, but the variable initialization order
        // will be incorrect at this point since it assumes no
        // cycle errors.
        // reduce dependency count of all dependent nodes
        // and update priority queue
        foreach (var (p, _) in (~n).pred) {
            (~p).ndeps--;
            heap.Fix(pq, (~p).index);
        }
        // record the init order for variables with initializers only
        var (v, _) = (~n).obj._<Var.val>(ᐧ);
        var info = check.objMap[v];
        if (v == nil || !info.hasInitializer()) {
            continue;
        }
        // n:1 variable declarations such as: a, b = f()
        // introduce a node for each lhs variable (here: a, b);
        // but they all have the same initializer - emit only
        // one, for the first variable seen
        if (emitted[info]) {
            continue;
        }
        // initializer already emitted, if any
        emitted[info] = true;
        var infoLhs = info.val.lhs;
        // possibly nil (see declInfo.lhs field comment)
        if (infoLhs == default!) {
            infoLhs = new ж<Var>[]{v}.slice();
        }
        var init = Ꮡ(new Initializer(infoLhs, (~info).init));
        check.Info.InitOrder = append(check.Info.InitOrder, init);
    }
    if (debug) {
        fmt.Println();
        fmt.Println("Initialization order:");
        foreach (var (_, init) in check.Info.InitOrder) {
            fmt.Printf("\t%s\n"u8, init);
        }
        fmt.Println();
    }
}

// findPath returns the (reversed) list of objects []Object{to, ... from}
// such that there is a path of object dependencies from 'from' to 'to'.
// If there is no such path, the result is nil.
internal static slice<Object> findPath(types.declInfo objMap, Object from, Object to, map<Object, bool> seen) {
    if (seen[from]) {
        return default!;
    }
    seen[from] = true;
    foreach (var (d, _) in objMap[from].deps) {
        if (AreEqual(d, to)) {
            return new Object[]{d}.slice();
        }
        {
            var P = findPath(objMap, d, to, seen); if (P != default!) {
                return append(P, d);
            }
        }
    }
    return default!;
}

// reportCycle reports an error for the given cycle.
[GoRecv] internal static void reportCycle(this ref Checker check, slice<Object> cycle) {
    var obj = cycle[0];
    // report a more concise error for self references
    if (len(cycle) == 1) {
        check.errorf(obj, InvalidInitCycle, "initialization cycle: %s refers to itself"u8, obj.Name());
        return;
    }
    var err = check.newError(InvalidInitCycle);
    err.addf(obj, "initialization cycle for %s"u8, obj.Name());
    // subtle loop: print cycle[i] for i = 0, n-1, n-2, ... 1 for len(cycle) = n
    for (nint i = len(cycle) - 1; i >= 0; i--) {
        err.addf(obj, "%s refers to"u8, obj.Name());
        obj = cycle[i];
    }
    // print cycle[0] again to close the cycle
    err.addf(obj, "%s"u8, obj.Name());
    err.report();
}

// ----------------------------------------------------------------------------
// Object dependency graph

// A dependency is an object that may be a dependency in an initialization
// expression. Only constants, variables, and functions can be dependencies.
// Constants are here because constant expression cycles are reported during
// initialization order computation.
[GoType] partial interface dependency :
    Object
{
    void isDependency();
}

// A graphNode represents a node in the object dependency graph.
// Each node p in n.pred represents an edge p->n, and each node
// s in n.succ represents an edge n->s; with a->b indicating that
// a depends on b.
[GoType] partial struct graphNode {
    internal dependency obj; // object represented by this node
    internal nodeSet pred;    // consumers and dependencies of this node (lazily initialized)
    internal nodeSet succ;
    internal nint index;       // node index in graph slice/priority queue
    internal nint ndeps;       // number of outstanding dependencies before this object can be initialized
}

// cost returns the cost of removing this node, which involves copying each
// predecessor to each successor (and vice-versa).
[GoRecv] internal static nint cost(this ref graphNode n) {
    return len(n.pred) * len(n.succ);
}
/* visitMapType: map[*graphNode]bool */

[GoRecv] internal static void add(this ref nodeSet s, ж<graphNode> Ꮡp) {
    ref var p = ref Ꮡp.val;

    if (s == default!) {
        s = new nodeSet();
    }
    (ж<ж<nodeSet>>)[p] = true;
}

// dependencyGraph computes the object dependency graph from the given objMap,
// with any function nodes removed. The resulting graph contains only constants
// and variables.
internal static slice<ж<graphNode>> dependencyGraph(types.declInfo objMap) {
    // M is the dependency (Object) -> graphNode mapping
    var M = new types.graphNode();
    foreach (var (obj, _) in objMap) {
        // only consider nodes that may be an initialization dependency
        {
            var (objΔ1, _) = obj._<dependency>(ᐧ); if (objΔ1 != default!) {
                M[obj] = Ꮡ(new graphNode(obj: objΔ1));
            }
        }
    }
    // compute edges for graph M
    // (We need to include all nodes, even isolated ones, because they still need
    // to be scheduled for initialization in correct order relative to other nodes.)
    foreach (var (obj, n) in M) {
        // for each dependency obj -> d (= deps[i]), create graph edges n->s and s->n
        foreach (var (d, _) in objMap[obj].deps) {
            // only consider nodes that may be an initialization dependency
            {
                var (dΔ1, _) = d._<dependency>(ᐧ); if (dΔ1 != default!) {
                    var dΔ2 = M[dΔ1];
                    (~n).succ.add(dΔ2);
                    (~dΔ2).pred.add(n);
                }
            }
        }
    }
    slice<ж<graphNode>> G = default!;                                // separate non-functions and functions
    slice<ж<graphNode>> funcG = default!;
    foreach (var (_, n) in M) {
        {
            var (_, ok) = (~n).obj._<Func.val>(ᐧ); if (ok){
                funcG = append(funcG, n);
            } else {
                G = append(G, n);
            }
        }
    }
    // remove function nodes and collect remaining graph nodes in G
    // (Mutually recursive functions may introduce cycles among themselves
    // which are permitted. Yet such cycles may incorrectly inflate the dependency
    // count for variables which in turn may not get scheduled for initialization
    // in correct order.)
    //
    // Note that because we recursively copy predecessors and successors
    // throughout the function graph, the cost of removing a function at
    // position X is proportional to cost * (len(funcG)-X). Therefore, we should
    // remove high-cost functions last.
    sort.Slice(funcG, 
    var funcGʗ1 = funcG;
    (nint i, nint j) => funcGʗ1[i].cost() < funcGʗ1[j].cost());
    foreach (var (_, n) in funcG) {
        // connect each predecessor p of n with each successor s
        // and drop the function node (don't collect it in G)
        foreach (var (p, _) in (~n).pred) {
            // ignore self-cycles
            if (p != n) {
                // Each successor s of n becomes a successor of p, and
                // each predecessor p of n becomes a predecessor of s.
                foreach (var (s, _) in (~n).succ) {
                    // ignore self-cycles
                    if (s != n) {
                        (~p).succ.add(s);
                        (~s).pred.add(p);
                    }
                }
                delete((~p).succ, n);
            }
        }
        // remove edge to n
        foreach (var (s, _) in (~n).succ) {
            delete((~s).pred, n);
        }
    }
    // remove edge to n
    // fill in index and ndeps fields
    foreach (var (i, n) in G) {
        n.val.index = i;
        n.val.ndeps = len((~n).succ);
    }
    return G;
}

[GoType("[]graphNode")] partial struct nodeQueue;

// ----------------------------------------------------------------------------
// Priority queue
internal static nint Len(this nodeQueue a) {
    return len(a);
}

internal static void Swap(this nodeQueue a, nint i, nint j) {
    var x = a[i];
    var y = a[j];
    (a[i], a[j]) = (y, x);
    (x.val.index, y.val.index) = (j, i);
}

internal static bool Less(this nodeQueue a, nint i, nint j) {
    var x = a[i];
    var y = a[j];
    // Prioritize all constants before non-constants. See go.dev/issue/66575/.
    var (_, xConst) = (~x).obj._<Const.val>(ᐧ);
    var (_, yConst) = (~y).obj._<Const.val>(ᐧ);
    if (xConst != yConst) {
        return xConst;
    }
    // nodes are prioritized by number of incoming dependencies (1st key)
    // and source order (2nd key)
    return (~x).ndeps < (~y).ndeps || (~x).ndeps == (~y).ndeps && (~x).obj.order() < (~y).obj.order();
}

[GoRecv] internal static void Push(this ref nodeQueue a, any x) {
    throw panic("unreachable");
}

[GoRecv] internal static unsafe any Pop(this ref nodeQueue a) {
    nint n = len(a);
    var x = (ж<ж<nodeQueue>>)[n - 1];
    x.val.index = -1;
    // for safety
    a = new Span<ж<nodeQueue>>((nodeQueue**), n - 1);
    return x;
}

} // end types_package
