// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/errsupport.go
// Copyright 2024 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements support functions for error messages.
namespace go.go;

partial class types_package {

// lookupError returns a case-specific error when a lookup of selector sel in the
// given type fails but an object with alternative spelling (case folding) is found.
// If structLit is set, the error message is specifically for struct literal fields.
[GoRecv] internal static @string lookupError(this ref Checker check, ΔType typ, @string sel, Object obj, bool structLit) {
    // Provide more detail if there is an unexported object, or one with different capitalization.
    // If selector and object are in the same package (==), export doesn't matter, otherwise (!=) it does.
    // Messages depend on whether it's a general lookup or a field lookup in a struct literal.
    //
    // case           sel     pkg   have   message (examples for general lookup)
    // ---------------------------------------------------------------------------------------------------------
    // ok             x.Foo   ==    Foo
    // misspelled     x.Foo   ==    FoO    type X has no field or method Foo, but does have field FoO
    // misspelled     x.Foo   ==    foo    type X has no field or method Foo, but does have field foo
    // misspelled     x.Foo   ==    foO    type X has no field or method Foo, but does have field foO
    //
    // misspelled     x.foo   ==    Foo    type X has no field or method foo, but does have field Foo
    // misspelled     x.foo   ==    FoO    type X has no field or method foo, but does have field FoO
    // ok             x.foo   ==    foo
    // misspelled     x.foo   ==    foO    type X has no field or method foo, but does have field foO
    //
    // ok             x.Foo   !=    Foo
    // misspelled     x.Foo   !=    FoO    type X has no field or method Foo, but does have field FoO
    // unexported     x.Foo   !=    foo    type X has no field or method Foo, but does have unexported field foo
    // missing        x.Foo   !=    foO    type X has no field or method Foo
    //
    // misspelled     x.foo   !=    Foo    type X has no field or method foo, but does have field Foo
    // missing        x.foo   !=    FoO    type X has no field or method foo
    // inaccessible   x.foo   !=    foo    cannot refer to unexported field foo
    // missing        x.foo   !=    foO    type X has no field or method foo
    static readonly UntypedInt ok = iota;
    static readonly UntypedInt missing = 1; // no object found
    static readonly UntypedInt misspelled = 2; // found object with different spelling
    static readonly UntypedInt unexported = 3; // found object with name differing only in first letter
    static readonly UntypedInt inaccessible = 4; // found object with matching name but inaccessible from the current package
    // determine case
    nint e = missing;
    @string alt = default!;           // alternative spelling of selector; if any
    if (obj != default!) {
        alt = obj.Name();
        if (obj.Pkg() == check.pkg){
            assert(alt != sel);
            // otherwise there is no lookup error
            e = misspelled;
        } else 
        if (isExported(sel)){
            if (isExported(alt)){
                e = misspelled;
            } else 
            if (tail(sel) == tail(alt)) {
                e = unexported;
            }
        } else 
        if (isExported(alt)){
            if (tail(sel) == tail(alt)) {
                e = misspelled;
            }
        } else 
        if (sel == alt) {
            e = inaccessible;
        }
    }
    if (structLit){
        var exprᴛ1 = e;
        if (exprᴛ1 == missing) {
            return check.sprintf("unknown field %s in struct literal of type %s"u8, sel, typ);
        }
        if (exprᴛ1 == misspelled) {
            return check.sprintf("unknown field %s in struct literal of type %s, but does have %s"u8, sel, typ, alt);
        }
        if (exprᴛ1 == unexported) {
            return check.sprintf("unknown field %s in struct literal of type %s, but does have unexported %s"u8, sel, typ, alt);
        }
        if (exprᴛ1 == inaccessible) {
            return check.sprintf("cannot refer to unexported field %s in struct literal of type %s"u8, alt, typ);
        }

    } else {
        @string what = "object"u8;
        switch (obj.type()) {
        case Var.val : {
            what = "field"u8;
            break;
        }
        case Func.val : {
            what = "method"u8;
            break;
        }}

        var exprᴛ2 = e;
        if (exprᴛ2 == missing) {
            return check.sprintf("type %s has no field or method %s"u8, typ, sel);
        }
        if (exprᴛ2 == misspelled) {
            return check.sprintf("type %s has no field or method %s, but does have %s %s"u8, typ, sel, what, alt);
        }
        if (exprᴛ2 == unexported) {
            return check.sprintf("type %s has no field or method %s, but does have unexported %s %s"u8, typ, sel, what, alt);
        }
        if (exprᴛ2 == inaccessible) {
            return check.sprintf("cannot refer to unexported %s %s"u8, what, alt);
        }

    }
    throw panic("unreachable");
}

// tail returns the string s without its first (UTF-8) character.
// If len(s) == 0, the result is s.
internal static @string tail(@string s) {
    foreach (var (i, _) in s) {
        if (i > 0) {
            return s[(int)(i)..];
        }
    }
    return s;
}

} // end types_package
