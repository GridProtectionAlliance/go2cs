// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements printing of expressions.
namespace go.go;

using bytes = bytes_package;
using fmt = fmt_package;
using ast = go.ast_package;
using typeparams = go.@internal.typeparams_package;
using go.@internal;

partial class types_package {

// ExprString returns the (possibly shortened) string representation for x.
// Shortened representations are suitable for user interfaces but may not
// necessarily follow Go syntax.
public static @string ExprString(ast.Expr x) {
    ref var buf = ref heap(new bytes_package.Buffer(), out var Ꮡbuf);
    WriteExpr(Ꮡbuf, x);
    return buf.String();
}

// WriteExpr writes the (possibly shortened) string representation for x to buf.
// Shortened representations are suitable for user interfaces but may not
// necessarily follow Go syntax.
public static void WriteExpr(ж<bytes.Buffer> Ꮡbuf, ast.Expr x) {
    ref var buf = ref Ꮡbuf.val;

    // The AST preserves source-level parentheses so there is
    // no need to introduce them here to correct for different
    // operator precedences. (This assumes that the AST was
    // generated by a Go parser.)
    switch (x.type()) {
    default: {
        var x = x.type();
        fmt.Fprintf(~buf, "(ast: %T)"u8, x);
        break;
    }
    case ж<ast.Ident> x: {
        buf.WriteString((~x).Name);
        break;
    }
    case ж<ast.Ellipsis> x: {
        buf.WriteString("..."u8);
        if ((~x).Elt != default!) {
            // nil, ast.BadExpr, ast.KeyValueExpr
            WriteExpr(Ꮡbuf, (~x).Elt);
        }
        break;
    }
    case ж<ast.BasicLit> x: {
        buf.WriteString((~x).Value);
        break;
    }
    case ж<ast.FuncLit> x: {
        buf.WriteByte((rune)'(');
        WriteExpr(Ꮡbuf, ~(~x).Type);
        buf.WriteString(" literal)"u8);
        break;
    }
    case ж<ast.CompositeLit> x: {
        WriteExpr(Ꮡbuf, // shortened
 (~x).Type);
        buf.WriteByte((rune)'{');
        if (len((~x).Elts) > 0) {
            buf.WriteString("…"u8);
        }
        buf.WriteByte((rune)'}');
        break;
    }
    case ж<ast.ParenExpr> x: {
        buf.WriteByte((rune)'(');
        WriteExpr(Ꮡbuf, (~x).X);
        buf.WriteByte((rune)')');
        break;
    }
    case ж<ast.SelectorExpr> x: {
        WriteExpr(Ꮡbuf, (~x).X);
        buf.WriteByte((rune)'.');
        buf.WriteString((~(~x).Sel).Name);
        break;
    }
    case ж<ast.IndexExpr> x: {
        var ix = typeparams.UnpackIndexExpr(x);
        WriteExpr(Ꮡbuf, (~ix).X);
        buf.WriteByte((rune)'[');
        writeExprList(Ꮡbuf, (~ix).Indices);
        buf.WriteByte((rune)']');
        break;
    }
    case ж<ast.IndexListExpr> x: {
        var ix = typeparams.UnpackIndexExpr(x);
        WriteExpr(Ꮡbuf, (~ix).X);
        buf.WriteByte((rune)'[');
        writeExprList(Ꮡbuf, (~ix).Indices);
        buf.WriteByte((rune)']');
        break;
    }
    case ж<ast.SliceExpr> x: {
        WriteExpr(Ꮡbuf, (~x).X);
        buf.WriteByte((rune)'[');
        if ((~x).Low != default!) {
            WriteExpr(Ꮡbuf, (~x).Low);
        }
        buf.WriteByte((rune)':');
        if ((~x).High != default!) {
            WriteExpr(Ꮡbuf, (~x).High);
        }
        if ((~x).Slice3) {
            buf.WriteByte((rune)':');
            if ((~x).Max != default!) {
                WriteExpr(Ꮡbuf, (~x).Max);
            }
        }
        buf.WriteByte((rune)']');
        break;
    }
    case ж<ast.TypeAssertExpr> x: {
        WriteExpr(Ꮡbuf, (~x).X);
        buf.WriteString(".("u8);
        WriteExpr(Ꮡbuf, (~x).Type);
        buf.WriteByte((rune)')');
        break;
    }
    case ж<ast.CallExpr> x: {
        WriteExpr(Ꮡbuf, (~x).Fun);
        buf.WriteByte((rune)'(');
        writeExprList(Ꮡbuf, (~x).Args);
        if (hasDots(Ꮡx)) {
            buf.WriteString("..."u8);
        }
        buf.WriteByte((rune)')');
        break;
    }
    case ж<ast.StarExpr> x: {
        buf.WriteByte((rune)'*');
        WriteExpr(Ꮡbuf, (~x).X);
        break;
    }
    case ж<ast.UnaryExpr> x: {
        buf.WriteString((~x).Op.String());
        WriteExpr(Ꮡbuf, (~x).X);
        break;
    }
    case ж<ast.BinaryExpr> x: {
        WriteExpr(Ꮡbuf, (~x).X);
        buf.WriteByte((rune)' ');
        buf.WriteString((~x).Op.String());
        buf.WriteByte((rune)' ');
        WriteExpr(Ꮡbuf, (~x).Y);
        break;
    }
    case ж<ast.ArrayType> x: {
        buf.WriteByte((rune)'[');
        if ((~x).Len != default!) {
            WriteExpr(Ꮡbuf, (~x).Len);
        }
        buf.WriteByte((rune)']');
        WriteExpr(Ꮡbuf, (~x).Elt);
        break;
    }
    case ж<ast.StructType> x: {
        buf.WriteString("struct{"u8);
        writeFieldList(Ꮡbuf, (~(~x).Fields).List, "; "u8, false);
        buf.WriteByte((rune)'}');
        break;
    }
    case ж<ast.FuncType> x: {
        buf.WriteString("func"u8);
        writeSigExpr(Ꮡbuf, Ꮡx);
        break;
    }
    case ж<ast.InterfaceType> x: {
        buf.WriteString("interface{"u8);
        writeFieldList(Ꮡbuf, (~(~x).Methods).List, "; "u8, true);
        buf.WriteByte((rune)'}');
        break;
    }
    case ж<ast.MapType> x: {
        buf.WriteString("map["u8);
        WriteExpr(Ꮡbuf, (~x).Key);
        buf.WriteByte((rune)']');
        WriteExpr(Ꮡbuf, (~x).Value);
        break;
    }
    case ж<ast.ChanType> x: {
        @string s = default!;
        var exprᴛ1 = (~x).Dir;
        if (exprᴛ1 == ast.SEND) {
            s = "chan<- "u8;
        }
        else if (exprᴛ1 == ast.RECV) {
            s = "<-chan "u8;
        }
        else { /* default: */
            s = "chan "u8;
        }

        buf.WriteString(s);
        WriteExpr(Ꮡbuf, (~x).Value);
        break;
    }}
}

internal static void writeSigExpr(ж<bytes.Buffer> Ꮡbuf, ж<ast.FuncType> Ꮡsig) {
    ref var buf = ref Ꮡbuf.val;
    ref var sig = ref Ꮡsig.val;

    buf.WriteByte((rune)'(');
    writeFieldList(Ꮡbuf, sig.Params.List, ", "u8, false);
    buf.WriteByte((rune)')');
    var res = sig.Results;
    nint n = res.NumFields();
    if (n == 0) {
        // no result
        return;
    }
    buf.WriteByte((rune)' ');
    if (n == 1 && len((~(~res).List[0]).Names) == 0) {
        // single unnamed result
        WriteExpr(Ꮡbuf, (~(~res).List[0]).Type);
        return;
    }
    // multiple or named result(s)
    buf.WriteByte((rune)'(');
    writeFieldList(Ꮡbuf, (~res).List, ", "u8, false);
    buf.WriteByte((rune)')');
}

internal static void writeFieldList(ж<bytes.Buffer> Ꮡbuf, slice<ast.Field> list, @string sep, bool iface) {
    ref var buf = ref Ꮡbuf.val;

    foreach (var (i, f) in list) {
        if (i > 0) {
            buf.WriteString(sep);
        }
        // field list names
        writeIdentList(Ꮡbuf, (~f).Names);
        // types of interface methods consist of signatures only
        {
            var (sig, _) = (~f).Type._<ж<ast.FuncType>>(ᐧ); if (sig != nil && iface) {
                writeSigExpr(Ꮡbuf, sig);
                continue;
            }
        }
        // named fields are separated with a blank from the field type
        if (len((~f).Names) > 0) {
            buf.WriteByte((rune)' ');
        }
        WriteExpr(Ꮡbuf, (~f).Type);
    }
}

// ignore tag
internal static void writeIdentList(ж<bytes.Buffer> Ꮡbuf, slice<ast.Ident> list) {
    ref var buf = ref Ꮡbuf.val;

    foreach (var (i, x) in list) {
        if (i > 0) {
            buf.WriteString(", "u8);
        }
        buf.WriteString((~x).Name);
    }
}

internal static void writeExprList(ж<bytes.Buffer> Ꮡbuf, slice<ast.Expr> list) {
    ref var buf = ref Ꮡbuf.val;

    foreach (var (i, x) in list) {
        if (i > 0) {
            buf.WriteString(", "u8);
        }
        WriteExpr(Ꮡbuf, x);
    }
}

} // end types_package
