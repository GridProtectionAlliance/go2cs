// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/instantiate.go
// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements instantiation of generic types
// through substitution of type parameters by type arguments.
namespace go.go;

using errors = errors_package;
using fmt = fmt_package;
using token = go.token_package;
using buildcfg = @internal.buildcfg_package;
using static @internal.types.errors_package;
using @internal;

partial class types_package {

// A genericType implements access to its type parameters.
[GoType] partial interface ΔgenericType :
    ΔType
{
    ж<TypeParamList> TypeParams();
}

// Instantiate instantiates the type orig with the given type arguments targs.
// orig must be an *Alias, *Named, or *Signature type. If there is no error,
// the resulting Type is an instantiated type of the same kind (*Alias, *Named
// or *Signature, respectively).
//
// Methods attached to a *Named type are also instantiated, and associated with
// a new *Func that has the same position as the original method, but nil function
// scope.
//
// If ctxt is non-nil, it may be used to de-duplicate the instance against
// previous instances with the same identity. As a special case, generic
// *Signature origin types are only considered identical if they are pointer
// equivalent, so that instantiating distinct (but possibly identical)
// signatures will yield different instances. The use of a shared context does
// not guarantee that identical instances are deduplicated in all cases.
//
// If validate is set, Instantiate verifies that the number of type arguments
// and parameters match, and that the type arguments satisfy their respective
// type constraints. If verification fails, the resulting error may wrap an
// *ArgumentError indicating which type argument did not satisfy its type parameter
// constraint, and why.
//
// If validate is not set, Instantiate does not verify the type argument count
// or whether the type arguments satisfy their constraints. Instantiate is
// guaranteed to not return an error, but may panic. Specifically, for
// *Signature types, Instantiate will panic immediately if the type argument
// count is incorrect; for *Named types, a panic may occur later inside the
// *Named API.
public static (ΔType, error) Instantiate(ж<Context> Ꮡctxt, ΔType orig, slice<ΔType> targs, bool validate) {
    ref var ctxt = ref Ꮡctxt.val;

    assert(len(targs) > 0);
    if (ctxt == nil) {
        ctxt = NewContext();
    }
    var orig_ = orig._<ΔgenericType>();
    // signature of Instantiate must not change for backward-compatibility
    if (validate) {
        var tparams = orig_.TypeParams().list();
        assert(len(tparams) > 0);
        if (len(targs) != len(tparams)) {
            return (default!, fmt.Errorf("got %d type arguments but %s has %d type parameters"u8, len(targs), orig, len(tparams)));
        }
        {
            (i, err) = ((ж<Checker>)(default!)).val.verify(nopos, tparams, targs, Ꮡctxt); if (err != default!) {
                return (default!, new ArgumentError(i, err));
            }
        }
    }
    var inst = ((ж<Checker>)(default!)).val.instance(nopos, orig_, targs, nil, Ꮡctxt);
    return (inst, default!);
}

// instance instantiates the given original (generic) function or type with the
// provided type arguments and returns the resulting instance. If an identical
// instance exists already in the given contexts, it returns that instance,
// otherwise it creates a new one.
//
// If expanding is non-nil, it is the Named instance type currently being
// expanded. If ctxt is non-nil, it is the context associated with the current
// type-checking pass or call to Instantiate. At least one of expanding or ctxt
// must be non-nil.
//
// For Named types the resulting instance may be unexpanded.
[GoRecv] public static ΔType /*res*/ instance(this ref Checker check, tokenꓸPos pos, ΔgenericType orig, slice<ΔType> targs, ж<Named> Ꮡexpanding, ж<Context> Ꮡctxt) {
    ΔType res = default!;

    ref var expanding = ref Ꮡexpanding.val;
    ref var ctxt = ref Ꮡctxt.val;
    // The order of the contexts below matters: we always prefer instances in the
    // expanding instance context in order to preserve reference cycles.
    //
    // Invariant: if expanding != nil, the returned instance will be the instance
    // recorded in expanding.inst.ctxt.
    slice<ж<Context>> ctxts = default!;
    if (expanding != nil) {
        ctxts = append(ctxts, expanding.inst.ctxt);
    }
    if (ctxt != nil) {
        ctxts = append(ctxts, Ꮡctxt);
    }
    assert(len(ctxts) > 0);
    // Compute all hashes; hashes may differ across contexts due to different
    // unique IDs for Named types within the hasher.
    var hashes = new slice<@string>(len(ctxts));
    foreach (var (i, ctxtΔ1) in ctxts) {
        hashes[i] = ctxtΔ1.instanceHash(orig, targs);
    }
    // Record the result in all contexts.
    // Prefer to re-use existing types from expanding context, if it exists, to reduce
    // the memory pinned by the Named type.
    var updateContexts = 
    var ctxtsʗ1 = ctxts;
    var hashesʗ1 = hashes;
    var targsʗ1 = targs;
    (ΔType res) => {
        for (nint i = len(ctxtsʗ1) - 1; i >= 0; i--) {
            resΔ1 = ctxtsʗ1[i].update(hashesʗ1[i], orig, targsʗ1, resΔ1);
        }
        return resΔ1;
    };
    // typ may already have been instantiated with identical type arguments. In
    // that case, re-use the existing instance.
    foreach (var (i, ctxtΔ2) in ctxts) {
        {
            var inst = ctxtΔ2.lookup(hashes[i], orig, targs); if (inst != default!) {
                return updateContexts(inst);
            }
        }
    }
    switch (orig.type()) {
    case Named.val orig: {
        res = ~check.newNamedInstance(pos, Ꮡorig, targs, Ꮡexpanding);
        break;
    }
    case Alias.val orig: {
        if (!buildcfg.Experiment.AliasTypeParams) {
            // substituted lazily
            assert(expanding == nil);
        }
        var tparams = orig.TypeParams();
        if (!check.validateTArgLen(pos, // Alias instances cannot be reached from Named types
 // TODO(gri) investigate if this is needed (type argument and parameter count seem to be correct here)
 orig.String(), tparams.Len(), len(targs))) {
            return ~Typ[Invalid];
        }
        if (tparams.Len() == 0) {
            return ~orig;
        }
        return ~check.newAliasInstance(pos, // nothing to do (minor optimization)
 Ꮡorig, targs, Ꮡexpanding, Ꮡctxt);
    }
    case ΔSignature.val orig: {
        assert(expanding == nil);
        tparams = orig.TypeParams();
        if (!check.validateTArgLen(pos, // function instances cannot be reached from Named types
 // TODO(gri) investigate if this is needed (type argument and parameter count seem to be correct here)
 orig.String(), tparams.Len(), len(targs))) {
            return ~Typ[Invalid];
        }
        if (tparams.Len() == 0) {
            return ~orig;
        }
        var sig = check.subst(pos, // nothing to do (minor optimization)
 ~orig, makeSubstMap(tparams.list(), targs), nil, Ꮡctxt)._<ΔSignature.val>();
        if (sig == Ꮡorig) {
            // If the signature doesn't use its type parameters, subst
            // will not make a copy. In that case, make a copy now (so
            // we can set tparams to nil w/o causing side-effects).
            ref var copy = ref heap<ΔSignature>(out var Ꮡcopy);
            copy = sig.val;
            sig = Ꮡcopy;
        }
        sig.val.tparams = default!;
        res = ~sig;
        break;
    }
    default: {
        var orig = orig.type();
        throw panic(fmt.Sprintf("%v: cannot instantiate %v"u8, // After instantiating a generic signature, it is not generic
 // anymore; we need to set tparams to nil.
 // only types and functions can be generic
 pos, orig));
        break;
    }}
    // Update all contexts; it's possible that we've lost a race.
    return updateContexts(res);
}

// validateTArgLen checks that the number of type arguments (got) matches the
// number of type parameters (want); if they don't match an error is reported.
// If validation fails and check is nil, validateTArgLen panics.
[GoRecv] internal static bool validateTArgLen(this ref Checker check, tokenꓸPos pos, @string name, nint want, nint got) {
    @string qual = default!;
    switch (ᐧ) {
    case {} when got is < want: {
        qual = "not enough"u8;
        break;
    }
    case {} when got is > want: {
        qual = "too many"u8;
        break;
    }
    default: {
        return true;
    }}

    @string msg = check.sprintf("%s type arguments for type %s: have %d, want %d"u8, qual, name, got, want);
    if (check != nil) {
        check.error(((atPos)pos), WrongTypeArgCount, msg);
        return false;
    }
    throw panic(fmt.Sprintf("%v: %s"u8, pos, msg));
}

[GoRecv] public static (nint, error) verify(this ref Checker check, tokenꓸPos pos, slice<ж<TypeParam>> tparams, slice<ΔType> targs, ж<Context> Ꮡctxt) {
    ref var ctxt = ref Ꮡctxt.val;

    var smap = makeSubstMap(tparams, targs);
    foreach (var (i, tpar) in tparams) {
        // Ensure that we have a (possibly implicit) interface as type bound (go.dev/issue/51048).
        tpar.iface();
        // The type parameter bound is parameterized with the same type parameters
        // as the instantiated type; before we can use it for bounds checking we
        // need to instantiate it with the type arguments with which we instantiated
        // the parameterized type.
        var bound = check.subst(pos, (~tpar).bound, smap, nil, Ꮡctxt);
        ref var cause = ref heap(new @string(), out var Ꮡcause);
        if (!check.implements(pos, targs[i], bound, true, Ꮡcause)) {
            return (i, errors.New(cause));
        }
    }
    return (-1, default!);
}

// implements checks if V implements T. The receiver may be nil if implements
// is called through an exported API call such as AssignableTo. If constraint
// is set, T is a type constraint.
//
// If the provided cause is non-nil, it may be set to an error string
// explaining why V does not implement (or satisfy, for constraints) T.
[GoRecv] public static bool implements(this ref Checker check, tokenꓸPos pos, ΔType V, ΔType T, bool constraint, ж<@string> Ꮡcause) {
    ref var cause = ref Ꮡcause.val;

    var Vu = under(V);
    var Tu = under(T);
    if (!isValid(Vu) || !isValid(Tu)) {
        return true;
    }
    // avoid follow-on errors
    {
        var (p, _) = Vu._<Pointer.val>(ᐧ); if (p != nil && !isValid(under((~p).@base))) {
            return true;
        }
    }
    // avoid follow-on errors (see go.dev/issue/49541 for an example)
    @string verb = "implement"u8;
    if (constraint) {
        verb = "satisfy"u8;
    }
    var (Ti, _) = Tu._<Interface.val>(ᐧ);
    if (Ti == nil) {
        if (cause != nil) {
            @string detailΔ1 = default!;
            if (isInterfacePtr(Tu)){
                 = check.sprintf("type %s is pointer to interface, not interface"u8, T);
            } else {
                 = check.sprintf("%s is not an interface"u8, T);
            }
            cause = check.sprintf("%s does not %s %s (%s)"u8, V, verb, T, detailΔ1);
        }
        return false;
    }
    // Every type satisfies the empty interface.
    if (Ti.Empty()) {
        return true;
    }
    // T is not the empty interface (i.e., the type set of T is restricted)
    // An interface V with an empty type set satisfies any interface.
    // (The empty set is a subset of any set.)
    var (Vi, _) = Vu._<Interface.val>(ᐧ);
    if (Vi != nil && Vi.typeSet().IsEmpty()) {
        return true;
    }
    // type set of V is not empty
    // No type with non-empty type set satisfies the empty type set.
    if (Ti.typeSet().IsEmpty()) {
        if (cause != nil) {
            cause = check.sprintf("cannot %s %s (empty type set)"u8, verb, T);
        }
        return false;
    }
    // V must implement T's methods, if any.
    {
        var (m, _) = check.missingMethod(V, T, true, Identical, Ꮡcause); if (m != nil) {
            /* !Implements(V, T) */
            if (cause != nil) {
                cause = check.sprintf("%s does not %s %s %s"u8, V, verb, T, cause);
            }
            return false;
        }
    }
    // Only check comparability if we don't have a more specific error.
    var checkComparability = 
    var Tiʗ1 = Ti;
    () => {
        if (!Tiʗ1.IsComparable()) {
            return true;
        }
        // If T is comparable, V must be comparable.
        // If V is strictly comparable, we're done.
        if (comparable(V, false, /* strict comparability */
 default!, default!)) {
            return true;
        }
        // For constraint satisfaction, use dynamic (spec) comparability
        // so that ordinary, non-type parameter interfaces implement comparable.
        if (constraint && comparable(V, true, /* spec comparability */
 default!, default!)) {
            // V is comparable if we are at Go 1.20 or higher.
            if (check == nil || check.allowVersion(((atPos)pos), go1_20)) {
                // atPos needed so that go/types generate passes
                return true;
            }
            if (cause != nil) {
                cause = check.sprintf("%s to %s comparable requires go1.20 or later"u8, V, verb);
            }
            return false;
        }
        if (cause != nil) {
            cause = check.sprintf("%s does not %s comparable"u8, V, verb);
        }
        return false;
    };
    // V must also be in the set of types of T, if any.
    // Constraints with empty type sets were already excluded above.
    if (!Ti.typeSet().hasTerms()) {
        return checkComparability();
    }
    // nothing to do
    // If V is itself an interface, each of its possible types must be in the set
    // of T types (i.e., the V type set must be a subset of the T type set).
    // Interfaces V with empty type sets were already excluded above.
    if (Vi != nil) {
        if (!Vi.typeSet().subsetOf(Ti.typeSet())) {
            // TODO(gri) report which type is missing
            if (cause != nil) {
                cause = check.sprintf("%s does not %s %s"u8, V, verb, T);
            }
            return false;
        }
        return checkComparability();
    }
    // Otherwise, V's type must be included in the iface type set.
    ΔType alt = default!;
    if (Ti.typeSet().@is(
    var altʗ2 = alt;
    (ж<term> t) => {
        if (!t.includes(V)) {
            if (altʗ2 == default! && !(~t).tilde && Identical((~t).typ, under((~t).typ))) {
                ref var tt = ref heap<term>(out var Ꮡtt);
                tt = t.val;
                tt.tilde = true;
                if (tt.includes(V)) {
                    altʗ2 = t.val.typ;
                }
            }
            return true;
        }
        return false;
    })) {
        if (cause != nil) {
            @string detail = default!;
            switch (ᐧ) {
            case {} when alt != default!: {
                detail = check.sprintf("possibly missing ~ for %s in %s"u8, alt, T);
                break;
            }
            case {} when mentions(~Ti, V): {
                detail = check.sprintf("%s mentions %s, but %s is not in the type set of %s"u8, T, V, V, T);
                break;
            }
            default: {
                detail = check.sprintf("%s missing in %s"u8, V, (~Ti.typeSet()).terms);
                break;
            }}

            cause = check.sprintf("%s does not %s %s (%s)"u8, V, verb, T, detail);
        }
        return false;
    }
    return checkComparability();
}

// mentions reports whether type T "mentions" typ in an (embedded) element or term
// of T (whether typ is in the type set of T or not). For better error messages.
internal static bool mentions(ΔType T, ΔType typ) {
    switch (T.type()) {
    case Interface.val T: {
        foreach (var (_, e) in (~T).embeddeds) {
            if (mentions(e, typ)) {
                return true;
            }
        }
        break;
    }
    case Union.val T: {
        foreach (var (_, t) in (~T).terms) {
            if (mentions((~t).typ, typ)) {
                return true;
            }
        }
        break;
    }
    default: {
        var T = T.type();
        if (Identical(T, typ)) {
            return true;
        }
        break;
    }}
    return false;
}

} // end types_package
