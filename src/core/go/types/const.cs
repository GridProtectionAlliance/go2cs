// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/const.go
// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
// This file implements functions for untyped constant operands.
namespace go.go;

using constant = go.constant_package;
using token = go.token_package;
using static @internal.types.errors_package;
using math = math_package;

partial class types_package {

// overflow checks that the constant x is representable by its type.
// For untyped constants, it checks that the value doesn't become
// arbitrarily large.
[GoRecv] public static void overflow(this ref Checker check, ж<operand> Ꮡx, tokenꓸPos opPos) {
    ref var x = ref Ꮡx.val;

    assert(x.mode == constant_);
    if (x.val.Kind() == constant.Unknown) {
        // TODO(gri) We should report exactly what went wrong. At the
        //           moment we don't have the (go/constant) API for that.
        //           See also TODO in go/constant/value.go.
        check.error(((atPos)opPos), InvalidConstVal, "constant result is not representable"u8);
        return;
    }
    // Typed constants must be representable in
    // their type after each constant operation.
    // x.typ cannot be a type parameter (type
    // parameters cannot be constant types).
    if (isTyped(x.typ)) {
        check.representable(Ꮡx, under(x.typ)._<Basic.val>());
        return;
    }
    // Untyped integer values must not grow arbitrarily.
    static readonly UntypedInt prec = 512; // 512 is the constant precision
    if (x.val.Kind() == constant.Int && constant.BitLen(x.val) > prec) {
        @string op = opName(x.expr);
        if (op != ""u8) {
            op += " "u8;
        }
        check.errorf(((atPos)opPos), InvalidConstVal, "constant %soverflow"u8, op);
        x.val = constant.MakeUnknown();
    }
}

// representableConst reports whether x can be represented as
// value of the given basic type and for the configuration
// provided (only needed for int/uint sizes).
//
// If rounded != nil, *rounded is set to the rounded value of x for
// representable floating-point and complex values, and to an Int
// value for integer values; it is left alone otherwise.
// It is ok to provide the addressof the first argument for rounded.
//
// The check parameter may be nil if representableConst is invoked
// (indirectly) through an exported API call (AssignableTo, ConvertibleTo)
// because we don't need the Checker's config for those calls.
internal static bool representableConst(constant.Value x, ж<Checker> Ꮡcheck, ж<Basic> Ꮡtyp, ж<constant.Value> Ꮡrounded) {
    ref var check = ref Ꮡcheck.val;
    ref var typ = ref Ꮡtyp.val;
    ref var rounded = ref Ꮡrounded.val;

    if (x.Kind() == constant.Unknown) {
        return true;
    }
    // avoid follow-up errors
    ж<Config> conf = default!;
    if (check != nil) {
        conf = check.conf;
    }
    var @sizeof = 
    var confʗ1 = conf;
    (ΔType T) => {
        var sΔ1 = confʗ1.@sizeof(T);
        return sΔ1;
    };
    switch (ᐧ) {
    case {} when isInteger(~typ): {
        var xΔ3 = constant.ToInt(x);
        if (xΔ3.Kind() != constant.Int) {
            return false;
        }
        if (rounded != nil) {
            rounded = xΔ3;
        }
        {
            var (xΔ4, ok) = constant.Int64Val(xΔ3); if (ok) {
                var exprᴛ1 = typ.kind;
                if (exprᴛ1 == Int) {
                    nuint sΔ8 = ((nuint)@sizeof(~typ)) * 8;
                    return ((int64)(-1)) << (int)((sΔ8 - 1)) <= xΔ4 && xΔ4 <= ((int64)1) << (int)((sΔ8 - 1)) - 1;
                }
                if (exprᴛ1 == Int8) {
                    static readonly UntypedInt s = 8;
                    return -1 << (int)((s - 1)) <= xΔ4 && xΔ4 <= 1 << (int)((s - 1)) - 1;
                }
                if (exprᴛ1 == Int16) {
                    static readonly UntypedInt s = 16;
                    return -1 << (int)((s - 1)) <= xΔ4 && xΔ4 <= 1 << (int)((s - 1)) - 1;
                }
                if (exprᴛ1 == Int32) {
                    static readonly UntypedInt s = 32;
                    return -1 << (int)((s - 1)) <= xΔ4 && xΔ4 <= 1 << (int)((s - 1)) - 1;
                }
                if (exprᴛ1 == Int64 || exprᴛ1 == ΔUntypedInt) {
                    return true;
                }
                if (exprᴛ1 == Uint || exprᴛ1 == Uintptr) {
                    {
                        nuint sΔ9 = ((nuint)@sizeof(~typ)) * 8; if (sΔ9 < 64) {
                            return 0 <= xΔ4 && xΔ4 <= ((int64)1) << (int)(sΔ9) - 1;
                        }
                    }
                    return 0 <= xΔ4;
                }
                if (exprᴛ1 == Uint8) {
                    static readonly UntypedInt s = 8;
                    return 0 <= xΔ4 && xΔ4 <= 1 << (int)(s) - 1;
                }
                if (exprᴛ1 == Uint16) {
                    static readonly UntypedInt s = 16;
                    return 0 <= xΔ4 && xΔ4 <= 1 << (int)(s) - 1;
                }
                if (exprᴛ1 == Uint32) {
                    static readonly UntypedInt s = 32;
                    return 0 <= xΔ4 && xΔ4 <= 1 << (int)(s) - 1;
                }
                if (exprᴛ1 == Uint64) {
                    return 0 <= xΔ4;
                }
                { /* default: */
                    throw panic("unreachable");
                }

            }
        }
        {
            nint n = constant.BitLen(x);
            var exprᴛ2 = typ.kind;
            if (exprᴛ2 == Uint || exprᴛ2 == Uintptr) {
// x does not fit into int64
                nuint s = ((nuint)@sizeof(~typ)) * 8;
                return constant.Sign(xΔ3) >= 0 && n <= ((nint)s);
            }
            if (exprᴛ2 == Uint64) {
                return constant.Sign(xΔ3) >= 0 && n <= 64;
            }
            if (exprᴛ2 == ΔUntypedInt) {
                return true;
            }
        }

        break;
    }
    case {} when isFloat(~typ): {
        var xΔ5 = constant.ToFloat(x);
        if (xΔ5.Kind() != constant.Float) {
            return false;
        }
        var exprᴛ3 = typ.kind;
        if (exprᴛ3 == Float32) {
            if (rounded == nil) {
                return fitsFloat32(xΔ5);
            }
            var r = roundFloat32(xΔ5);
            if (r != default!) {
                rounded = r;
                return true;
            }
        }
        if (exprᴛ3 == Float64) {
            if (rounded == nil) {
                return fitsFloat64(xΔ5);
            }
            var r = roundFloat64(xΔ5);
            if (r != default!) {
                rounded = r;
                return true;
            }
        }
        if (exprᴛ3 == ΔUntypedFloat) {
            return true;
        }
        { /* default: */
            throw panic("unreachable");
        }

        break;
    }
    case {} when isComplex(~typ): {
        var xΔ6 = constant.ToComplex(x);
        if (xΔ6.Kind() != constant.Complex) {
            return false;
        }
        var exprᴛ4 = typ.kind;
        if (exprᴛ4 == Complex64) {
            if (rounded == nil) {
                return fitsFloat32(constant.Real(xΔ6)) && fitsFloat32(constant.Imag(xΔ6));
            }
            var re = roundFloat32(constant.Real(xΔ6));
            var im = roundFloat32(constant.Imag(xΔ6));
            if (re != default! && im != default!) {
                rounded = constant.BinaryOp(re, token.ADD, constant.MakeImag(im));
                return true;
            }
        }
        if (exprᴛ4 == Complex128) {
            if (rounded == nil) {
                return fitsFloat64(constant.Real(xΔ6)) && fitsFloat64(constant.Imag(xΔ6));
            }
            var re = roundFloat64(constant.Real(xΔ6));
            var im = roundFloat64(constant.Imag(xΔ6));
            if (re != default! && im != default!) {
                rounded = constant.BinaryOp(re, token.ADD, constant.MakeImag(im));
                return true;
            }
        }
        if (exprᴛ4 == ΔUntypedComplex) {
            return true;
        }
        { /* default: */
            throw panic("unreachable");
        }

        break;
    }
    case {} when isString(~typ): {
        return x.Kind() == constant.ΔString;
    }
    case {} when isBoolean(~typ): {
        return x.Kind() == constant.Bool;
    }}

    return false;
}

internal static bool fitsFloat32(constant.Value x) {
    var (f32, _) = constant.Float32Val(x);
    var f = ((float64)f32);
    return !math.IsInf(f, 0);
}

internal static constant.Value roundFloat32(constant.Value x) {
    var (f32, _) = constant.Float32Val(x);
    var f = ((float64)f32);
    if (!math.IsInf(f, 0)) {
        return constant.MakeFloat64(f);
    }
    return default!;
}

internal static bool fitsFloat64(constant.Value x) {
    var (f, _) = constant.Float64Val(x);
    return !math.IsInf(f, 0);
}

internal static constant.Value roundFloat64(constant.Value x) {
    var (f, _) = constant.Float64Val(x);
    if (!math.IsInf(f, 0)) {
        return constant.MakeFloat64(f);
    }
    return default!;
}

// representable checks that a constant operand is representable in the given
// basic type.
[GoRecv] public static void representable(this ref Checker check, ж<operand> Ꮡx, ж<Basic> Ꮡtyp) {
    ref var x = ref Ꮡx.val;
    ref var typ = ref Ꮡtyp.val;

    var (v, code) = check.representation(Ꮡx, Ꮡtyp);
    if (code != 0) {
        check.invalidConversion(code, Ꮡx, ~typ);
        x.mode = invalid;
        return;
    }
    assert(v != default!);
    x.val = v;
}

// representation returns the representation of the constant operand x as the
// basic type typ.
//
// If no such representation is possible, it returns a non-zero error code.
[GoRecv] public static (constant.Value, errors.Code) representation(this ref Checker check, ж<operand> Ꮡx, ж<Basic> Ꮡtyp) {
    ref var x = ref Ꮡx.val;
    ref var typ = ref Ꮡtyp.val;

    assert(x.mode == constant_);
    var v = x.val;
    if (!representableConst(x.val, check, Ꮡtyp, Ꮡ(v))) {
        if (isNumeric(x.typ) && isNumeric(~typ)) {
            // numeric conversion : error msg
            //
            // integer -> integer : overflows
            // integer -> float   : overflows (actually not possible)
            // float   -> integer : truncated
            // float   -> float   : overflows
            //
            if (!isInteger(x.typ) && isInteger(~typ)){
                return (default!, TruncatedFloat);
            } else {
                return (default!, NumericOverflow);
            }
        }
        return (default!, InvalidConstVal);
    }
    return (v, 0);
}

[GoRecv] public static void invalidConversion(this ref Checker check, errors.Code code, ж<operand> Ꮡx, ΔType target) {
    ref var x = ref Ꮡx.val;

    @string msg = "cannot convert %s to type %s"u8;
    var exprᴛ1 = code;
    if (exprᴛ1 == TruncatedFloat) {
        msg = "%s truncated to %s"u8;
    }
    else if (exprᴛ1 == NumericOverflow) {
        msg = "%s overflows %s"u8;
    }

    check.errorf(~x, code, msg, x, target);
}

// convertUntyped attempts to set the type of an untyped value to the target type.
[GoRecv] public static void convertUntyped(this ref Checker check, ж<operand> Ꮡx, ΔType target) {
    ref var x = ref Ꮡx.val;

    var (newType, val, code) = check.implicitTypeAndValue(Ꮡx, target);
    if (code != 0) {
        var t = target;
        if (!isTypeParam(target)) {
            t = safeUnderlying(target);
        }
        check.invalidConversion(code, Ꮡx, t);
        x.mode = invalid;
        return;
    }
    if (val != default!) {
        x.val = val;
        check.updateExprVal(x.expr, val);
    }
    if (!AreEqual(newType, x.typ)) {
        x.typ = newType;
        check.updateExprType(x.expr, newType, false);
    }
}

} // end types_package
