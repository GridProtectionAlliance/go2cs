// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/typeterm.go
// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go.go;

partial class types_package {

// A term describes elementary type sets:
//
//	 ∅:  (*term)(nil)     == ∅                      // set of no types (empty set)
//	 𝓤:  &term{}          == 𝓤                      // set of all types (𝓤niverse)
//	 T:  &term{false, T}  == {T}                    // set of type T
//	~t:  &term{true, t}   == {t' | under(t') == t}  // set of types with underlying type t
[GoType] partial struct term {
    internal bool tilde; // valid if typ != nil
    internal ΔType typ;
}

[GoRecv] internal static @string String(this ref term x) {
    switch (ᐧ) {
    case {} when x == nil: {
        return "∅"u8;
    }
    case {} when x.typ == default!: {
        return "𝓤"u8;
    }
    case {} when x.tilde: {
        return "~"u8 + x.typ.String();
    }
    default: {
        return x.typ.String();
    }}

}

// equal reports whether x and y represent the same type set.
[GoRecv] internal static bool equal(this ref term x, ж<term> Ꮡy) {
    ref var y = ref Ꮡy.val;

    // easy cases
    switch (ᐧ) {
    case {} when x == nil || y == nil: {
        return x == Ꮡy;
    }
    case {} when x.typ == default! || y.typ == default!: {
        return AreEqual(x.typ, y.typ);
    }}

    // ∅ ⊂ x, y ⊂ 𝓤
    return x.tilde == y.tilde && Identical(x.typ, y.typ);
}

// union returns the union x ∪ y: zero, one, or two non-nil terms.
[GoRecv("capture")] internal static (ж<term> _, ж<term> _) union(this ref term x, ж<term> Ꮡy) {
    ref var y = ref Ꮡy.val;

    // easy cases
    switch (ᐧ) {
    case {} when x == nil && y == nil: {
        return (default!, default!);
    }
    case {} when x == nil: {
        return (Ꮡy, default!);
    }
    case {} when y == nil: {
        return (unionꓸᏑx, default!);
    }
    case {} when x.typ == default!: {
        return (unionꓸᏑx, default!);
    }
    case {} when y.typ == default!: {
        return (Ꮡy, default!);
    }}

    // ∅ ∪ ∅ == ∅
    // ∅ ∪ y == y
    // x ∪ ∅ == x
    // 𝓤 ∪ y == 𝓤
    // x ∪ 𝓤 == 𝓤
    // ∅ ⊂ x, y ⊂ 𝓤
    if (x.disjoint(Ꮡy)) {
        return (unionꓸᏑx, Ꮡy);
    }
    // x ∪ y == (x, y) if x ∩ y == ∅
    // x.typ == y.typ
    // ~t ∪ ~t == ~t
    // ~t ∪  T == ~t
    //  T ∪ ~t == ~t
    //  T ∪  T ==  T
    if (x.tilde || !y.tilde) {
        return (unionꓸᏑx, default!);
    }
    return (Ꮡy, default!);
}

// intersect returns the intersection x ∩ y.
[GoRecv("capture")] internal static ж<term> intersect(this ref term x, ж<term> Ꮡy) {
    ref var y = ref Ꮡy.val;

    // easy cases
    switch (ᐧ) {
    case {} when x == nil || y == nil: {
        return default!;
    }
    case {} when x.typ == default!: {
        return Ꮡy;
    }
    case {} when y.typ == default!: {
        return intersectꓸᏑx;
    }}

    // ∅ ∩ y == ∅ and ∩ ∅ == ∅
    // 𝓤 ∩ y == y
    // x ∩ 𝓤 == x
    // ∅ ⊂ x, y ⊂ 𝓤
    if (x.disjoint(Ꮡy)) {
        return default!;
    }
    // x ∩ y == ∅ if x ∩ y == ∅
    // x.typ == y.typ
    // ~t ∩ ~t == ~t
    // ~t ∩  T ==  T
    //  T ∩ ~t ==  T
    //  T ∩  T ==  T
    if (!x.tilde || y.tilde) {
        return intersectꓸᏑx;
    }
    return Ꮡy;
}

// includes reports whether t ∈ x.
[GoRecv] internal static bool includes(this ref term x, ΔType t) {
    // easy cases
    switch (ᐧ) {
    case {} when x == nil: {
        return false;
    }
    case {} when x.typ == default!: {
        return true;
    }}

    // t ∈ ∅ == false
    // t ∈ 𝓤 == true
    // ∅ ⊂ x ⊂ 𝓤
    var u = t;
    if (x.tilde) {
        u = under(u);
    }
    return Identical(x.typ, u);
}

// subsetOf reports whether x ⊆ y.
[GoRecv] internal static bool subsetOf(this ref term x, ж<term> Ꮡy) {
    ref var y = ref Ꮡy.val;

    // easy cases
    switch (ᐧ) {
    case {} when x == nil: {
        return true;
    }
    case {} when y == nil: {
        return false;
    }
    case {} when y.typ == default!: {
        return true;
    }
    case {} when x.typ == default!: {
        return false;
    }}

    // ∅ ⊆ y == true
    // x ⊆ ∅ == false since x != ∅
    // x ⊆ 𝓤 == true
    // 𝓤 ⊆ y == false since y != 𝓤
    // ∅ ⊂ x, y ⊂ 𝓤
    if (x.disjoint(Ꮡy)) {
        return false;
    }
    // x ⊆ y == false if x ∩ y == ∅
    // x.typ == y.typ
    // ~t ⊆ ~t == true
    // ~t ⊆ T == false
    //  T ⊆ ~t == true
    //  T ⊆  T == true
    return !x.tilde || y.tilde;
}

// disjoint reports whether x ∩ y == ∅.
// x.typ and y.typ must not be nil.
[GoRecv] internal static bool disjoint(this ref term x, ж<term> Ꮡy) {
    ref var y = ref Ꮡy.val;

    if (debug && (x.typ == default! || y.typ == default!)) {
        throw panic("invalid argument(s)");
    }
    var ux = x.typ;
    if (y.tilde) {
        ux = under(ux);
    }
    var uy = y.typ;
    if (x.tilde) {
        uy = under(uy);
    }
    return !Identical(ux, uy);
}

} // end types_package
