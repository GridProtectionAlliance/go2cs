// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/typeterm.go
// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go.go;

partial class types_package {

// A term describes elementary type sets:
//
//	 âˆ…:  (*term)(nil)     == âˆ…                      // set of no types (empty set)
//	 ğ“¤:  &term{}          == ğ“¤                      // set of all types (ğ“¤niverse)
//	 T:  &term{false, T}  == {T}                    // set of type T
//	~t:  &term{true, t}   == {t' | under(t') == t}  // set of types with underlying type t
[GoType] partial struct term {
    internal bool tilde; // valid if typ != nil
    internal Î”Type typ;
}

[GoRecv] internal static @string String(this ref term x) {
    switch (á§) {
    case {} when x == nil: {
        return "âˆ…"u8;
    }
    case {} when x.typ == default!: {
        return "ğ“¤"u8;
    }
    case {} when x.tilde: {
        return "~"u8 + x.typ.String();
    }
    default: {
        return x.typ.String();
    }}

}

// equal reports whether x and y represent the same type set.
[GoRecv] internal static bool equal(this ref term x, Ğ¶<term> á‘y) {
    ref var y = ref á‘y.val;

    // easy cases
    switch (á§) {
    case {} when x == nil || y == nil: {
        return x == á‘y;
    }
    case {} when x.typ == default! || y.typ == default!: {
        return AreEqual(x.typ, y.typ);
    }}

    // âˆ… âŠ‚ x, y âŠ‚ ğ“¤
    return x.tilde == y.tilde && Identical(x.typ, y.typ);
}

// union returns the union x âˆª y: zero, one, or two non-nil terms.
[GoRecv("capture")] internal static (Ğ¶<term> _, Ğ¶<term> _) union(this ref term x, Ğ¶<term> á‘y) {
    ref var y = ref á‘y.val;

    // easy cases
    switch (á§) {
    case {} when x == nil && y == nil: {
        return (default!, default!);
    }
    case {} when x == nil: {
        return (á‘y, default!);
    }
    case {} when y == nil: {
        return (unionê“¸á‘x, default!);
    }
    case {} when x.typ == default!: {
        return (unionê“¸á‘x, default!);
    }
    case {} when y.typ == default!: {
        return (á‘y, default!);
    }}

    // âˆ… âˆª âˆ… == âˆ…
    // âˆ… âˆª y == y
    // x âˆª âˆ… == x
    // ğ“¤ âˆª y == ğ“¤
    // x âˆª ğ“¤ == ğ“¤
    // âˆ… âŠ‚ x, y âŠ‚ ğ“¤
    if (x.disjoint(á‘y)) {
        return (unionê“¸á‘x, á‘y);
    }
    // x âˆª y == (x, y) if x âˆ© y == âˆ…
    // x.typ == y.typ
    // ~t âˆª ~t == ~t
    // ~t âˆª  T == ~t
    //  T âˆª ~t == ~t
    //  T âˆª  T ==  T
    if (x.tilde || !y.tilde) {
        return (unionê“¸á‘x, default!);
    }
    return (á‘y, default!);
}

// intersect returns the intersection x âˆ© y.
[GoRecv("capture")] internal static Ğ¶<term> intersect(this ref term x, Ğ¶<term> á‘y) {
    ref var y = ref á‘y.val;

    // easy cases
    switch (á§) {
    case {} when x == nil || y == nil: {
        return default!;
    }
    case {} when x.typ == default!: {
        return á‘y;
    }
    case {} when y.typ == default!: {
        return intersectê“¸á‘x;
    }}

    // âˆ… âˆ© y == âˆ… and âˆ© âˆ… == âˆ…
    // ğ“¤ âˆ© y == y
    // x âˆ© ğ“¤ == x
    // âˆ… âŠ‚ x, y âŠ‚ ğ“¤
    if (x.disjoint(á‘y)) {
        return default!;
    }
    // x âˆ© y == âˆ… if x âˆ© y == âˆ…
    // x.typ == y.typ
    // ~t âˆ© ~t == ~t
    // ~t âˆ©  T ==  T
    //  T âˆ© ~t ==  T
    //  T âˆ©  T ==  T
    if (!x.tilde || y.tilde) {
        return intersectê“¸á‘x;
    }
    return á‘y;
}

// includes reports whether t âˆˆ x.
[GoRecv] internal static bool includes(this ref term x, Î”Type t) {
    // easy cases
    switch (á§) {
    case {} when x == nil: {
        return false;
    }
    case {} when x.typ == default!: {
        return true;
    }}

    // t âˆˆ âˆ… == false
    // t âˆˆ ğ“¤ == true
    // âˆ… âŠ‚ x âŠ‚ ğ“¤
    var u = t;
    if (x.tilde) {
        u = under(u);
    }
    return Identical(x.typ, u);
}

// subsetOf reports whether x âŠ† y.
[GoRecv] internal static bool subsetOf(this ref term x, Ğ¶<term> á‘y) {
    ref var y = ref á‘y.val;

    // easy cases
    switch (á§) {
    case {} when x == nil: {
        return true;
    }
    case {} when y == nil: {
        return false;
    }
    case {} when y.typ == default!: {
        return true;
    }
    case {} when x.typ == default!: {
        return false;
    }}

    // âˆ… âŠ† y == true
    // x âŠ† âˆ… == false since x != âˆ…
    // x âŠ† ğ“¤ == true
    // ğ“¤ âŠ† y == false since y != ğ“¤
    // âˆ… âŠ‚ x, y âŠ‚ ğ“¤
    if (x.disjoint(á‘y)) {
        return false;
    }
    // x âŠ† y == false if x âˆ© y == âˆ…
    // x.typ == y.typ
    // ~t âŠ† ~t == true
    // ~t âŠ† T == false
    //  T âŠ† ~t == true
    //  T âŠ†  T == true
    return !x.tilde || y.tilde;
}

// disjoint reports whether x âˆ© y == âˆ….
// x.typ and y.typ must not be nil.
[GoRecv] internal static bool disjoint(this ref term x, Ğ¶<term> á‘y) {
    ref var y = ref á‘y.val;

    if (debug && (x.typ == default! || y.typ == default!)) {
        throw panic("invalid argument(s)");
    }
    var ux = x.typ;
    if (y.tilde) {
        ux = under(ux);
    }
    var uy = y.typ;
    if (x.tilde) {
        uy = under(uy);
    }
    return !Identical(ux, uy);
}

} // end types_package
