// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/typeparam.go
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go.go;

using atomic = sync.atomic_package;
using sync;

partial class types_package {

// Note: This is a uint32 rather than a uint64 because the
// respective 64 bit atomic instructions are not available
// on all platforms.
internal static atomic.Uint32 lastID;

// nextID returns a value increasing monotonically by 1 with
// each call, starting with 1. It may be called concurrently.
internal static uint64 nextID() {
    return ((uint64)lastID.Add(1));
}

// A TypeParam represents a type parameter type.
[GoType] partial struct TypeParam {
    internal ж<Checker> check; // for lazy type bound completion
    internal uint64 id;    // unique id, for debugging only
    internal ж<TypeName> obj; // corresponding type name
    internal nint index;      // type parameter index in source order, starting at 0
    internal ΔType bound;    // any type, but underlying is eventually *Interface for correct programs (see TypeParam.iface)
}

// NewTypeParam returns a new TypeParam. Type parameters may be set on a Named
// type by calling SetTypeParams. Setting a type parameter on more than one type
// will result in a panic.
//
// The constraint argument can be nil, and set later via SetConstraint. If the
// constraint is non-nil, it must be fully defined.
public static ж<TypeParam> NewTypeParam(ж<TypeName> Ꮡobj, ΔType constraint) {
    ref var obj = ref Ꮡobj.val;

    return ((ж<Checker>)(default!)).val.newTypeParam(Ꮡobj, constraint);
}

// check may be nil
[GoRecv] public static ж<TypeParam> newTypeParam(this ref Checker check, ж<TypeName> Ꮡobj, ΔType constraint) {
    ref var obj = ref Ꮡobj.val;

    // Always increment lastID, even if it is not used.
    ref var id = ref heap<uint64>(out var Ꮡid);
    id = nextID();
    if (check != nil) {
        check.nextID++;
        id = check.nextID;
    }
    var typ = Ꮡ(new TypeParam(check: check, id: id, obj: obj, index: -1, bound: constraint));
    if (obj.typ == default!) {
        obj.typ = typ;
    }
    // iface may mutate typ.bound, so we must ensure that iface() is called
    // at least once before the resulting TypeParam escapes.
    if (check != nil){
        check.needsCleanup(~typ);
    } else 
    if (constraint != default!) {
        typ.iface();
    }
    return typ;
}

// Obj returns the type name for the type parameter t.
[GoRecv] public static ж<TypeName> Obj(this ref TypeParam t) {
    return t.obj;
}

// Index returns the index of the type param within its param list, or -1 if
// the type parameter has not yet been bound to a type.
[GoRecv] public static nint Index(this ref TypeParam t) {
    return t.index;
}

// Constraint returns the type constraint specified for t.
[GoRecv] public static ΔType Constraint(this ref TypeParam t) {
    return t.bound;
}

// SetConstraint sets the type constraint for t.
//
// It must be called by users of NewTypeParam after the bound's underlying is
// fully defined, and before using the type parameter in any way other than to
// form other types. Once SetConstraint returns the receiver, t is safe for
// concurrent use.
[GoRecv] public static void SetConstraint(this ref TypeParam t, ΔType bound) {
    if (bound == default!) {
        throw panic("nil constraint");
    }
    t.bound = bound;
    // iface may mutate t.bound (if bound is not an interface), so ensure that
    // this is done before returning.
    t.iface();
}

// Underlying returns the [underlying type] of the type parameter t, which is
// the underlying type of its constraint. This type is always an interface.
//
// [underlying type]: https://go.dev/ref/spec#Underlying_types.
[GoRecv] public static ΔType Underlying(this ref TypeParam t) {
    return ~t.iface();
}

[GoRecv] public static @string String(this ref TypeParam t) {
    return TypeString(~t, default!);
}

// ----------------------------------------------------------------------------
// Implementation
[GoRecv] internal static void cleanup(this ref TypeParam t) {
    t.iface();
    t.check = default!;
}

// iface returns the constraint interface of t.
[GoRecv] internal static ж<Interface> iface(this ref TypeParam t) {
    var bound = t.bound;
    // determine constraint interface
    ж<Interface> ityp = default!;
    switch (under(bound).type()) {
    case Basic.val u: {
        if (!isValid(~u)) {
            // error is reported elsewhere
            return Ꮡ(emptyInterface);
        }
        break;
    }
    case Interface.val u: {
        if (isTypeParam(bound)) {
            // error is reported in Checker.collectTypeParams
            return Ꮡ(emptyInterface);
        }
        ityp = u;
        break;
    }}
    // If we don't have an interface, wrap constraint into an implicit interface.
    if (ityp == nil) {
        ityp = NewInterfaceType(default!, new ΔType[]{bound}.slice());
        ityp.val.@implicit = true;
        t.bound = ityp;
    }
    // update t.bound for next time (optimization)
    // compute type set if necessary
    if ((~ityp).tset == nil) {
        // pos is used for tracing output; start with the type parameter position.
        tokenꓸPos pos = t.obj.pos;
        // use the (original or possibly instantiated) type bound position if we have one
        {
            var n = asNamed(bound); if (n != nil) {
                pos = (~n).obj.pos;
            }
        }
        computeInterfaceTypeSet(t.check, pos, ityp);
    }
    return ityp;
}

// is calls f with the specific type terms of t's constraint and reports whether
// all calls to f returned true. If there are no specific terms, is
// returns the result of f(nil).
[GoRecv] internal static bool @is(this ref TypeParam t, Func<ж<term>, bool> f) {
    return t.iface().typeSet().@is(f);
}

// underIs calls f with the underlying types of the specific type terms
// of t's constraint and reports whether all calls to f returned true.
// If there are no specific terms, underIs returns the result of f(nil).
[GoRecv] internal static bool underIs(this ref TypeParam t, Func<ΔType, bool> f) {
    return t.iface().typeSet().underIs(f);
}

} // end types_package
