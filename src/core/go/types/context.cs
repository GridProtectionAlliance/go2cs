// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/context.go
// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
namespace go.go;

using bytes = bytes_package;
using fmt = fmt_package;
using strconv = strconv_package;
using strings = strings_package;
using sync = sync_package;

partial class types_package {

// This file contains a definition of the type-checking context; an opaque type
// that may be supplied by users during instantiation.
//
// Contexts serve two purposes:
//  - reduce the duplication of identical instances
//  - short-circuit instantiation cycles
//
// For the latter purpose, we must always have a context during instantiation,
// whether or not it is supplied by the user. For both purposes, it must be the
// case that hashing a pointer-identical type produces consistent results
// (somewhat obviously).
//
// However, neither of these purposes require that our hash is perfect, and so
// this was not an explicit design goal of the context type. In fact, due to
// concurrent use it is convenient not to guarantee de-duplication.
//
// Nevertheless, in the future it could be helpful to allow users to leverage
// contexts to canonicalize instances, and it would probably be possible to
// achieve such a guarantee.

// A Context is an opaque type checking context. It may be used to share
// identical type instances across type-checked packages or calls to
// Instantiate. Contexts are safe for concurrent use.
//
// The use of a shared context does not guarantee that identical instances are
// deduplicated in all cases.
[GoType] partial struct Context {
    internal sync_package.Mutex mu;
    internal map<@string, slice<ctxtEntry>> typeMap; // type hash -> instances entries
    internal nint nextID;                   // next unique ID
    internal map<ΔType, nint> originIDs;      // origin type -> unique ID
}

[GoType] partial struct ctxtEntry {
    internal ΔType orig;
    internal slice<ΔType> targs;
    internal ΔType instance; // = orig[targs]
}

// NewContext creates a new Context.
public static ж<Context> NewContext() {
    return Ꮡ(new Context(
        typeMap: new map<@string, slice<ctxtEntry>>(),
        originIDs: new map<ΔType, nint>()
    ));
}

// instanceHash returns a string representation of typ instantiated with targs.
// The hash should be a perfect hash, though out of caution the type checker
// does not assume this. The result is guaranteed to not contain blanks.
[GoRecv] internal static @string instanceHash(this ref Context ctxt, ΔType orig, slice<ΔType> targs) {
    assert(ctxt != nil);
    assert(orig != default!);
    ref var buf = ref heap(new bytes_package.Buffer(), out var Ꮡbuf);
    var h = newTypeHasher(Ꮡbuf, ctxt);
    h.@string(strconv.Itoa(ctxt.getID(orig)));
    // Because we've already written the unique origin ID this call to h.typ is
    // unnecessary, but we leave it for hash readability. It can be removed later
    // if performance is an issue.
    h.typ(orig);
    if (len(targs) > 0) {
        // TODO(rfindley): consider asserting on isGeneric(typ) here, if and when
        // isGeneric handles *Signature types.
        h.typeList(targs);
    }
    return strings.ReplaceAll(buf.String(), " "u8, "#"u8);
}

// lookup returns an existing instantiation of orig with targs, if it exists.
// Otherwise, it returns nil.
[GoRecv] internal static ΔType lookup(this ref Context ctxt, @string h, ΔType orig, slice<ΔType> targs) => func((defer, _) => {
    ctxt.mu.Lock();
    defer(ctxt.mu.Unlock);
    foreach (var (_, e) in ctxt.typeMap[h]) {
        if (identicalInstance(orig, targs, e.orig, e.targs)) {
            return e.instance;
        }
        if (debug) {
            // Panic during development to surface any imperfections in our hash.
            throw panic(fmt.Sprintf("non-identical instances: (orig: %s, targs: %v) and %s"u8, orig, targs, e.instance));
        }
    }
    return default!;
});

// update de-duplicates n against previously seen types with the hash h.  If an
// identical type is found with the type hash h, the previously seen type is
// returned. Otherwise, n is returned, and recorded in the Context for the hash
// h.
[GoRecv] internal static ΔType update(this ref Context ctxt, @string h, ΔType orig, slice<ΔType> targs, ΔType inst) => func((defer, _) => {
    assert(inst != default!);
    ctxt.mu.Lock();
    defer(ctxt.mu.Unlock);
    foreach (var (_, e) in ctxt.typeMap[h]) {
        if (inst == default! || Identical(inst, e.instance)) {
            return e.instance;
        }
        if (debug) {
            // Panic during development to surface any imperfections in our hash.
            throw panic(fmt.Sprintf("%s and %s are not identical"u8, inst, e.instance));
        }
    }
    ctxt.typeMap[h] = append(ctxt.typeMap[h], new ctxtEntry(
        orig: orig,
        targs: targs,
        Δinstance: inst
    ));
    return inst;
});

// getID returns a unique ID for the type t.
[GoRecv] internal static nint getID(this ref Context ctxt, ΔType t) => func((defer, _) => {
    ctxt.mu.Lock();
    defer(ctxt.mu.Unlock);
    nint id = ctxt.originIDs[t];
    var ok = ctxt.originIDs[t];
    if (!ok) {
        id = ctxt.nextID;
        ctxt.originIDs[t] = id;
        ctxt.nextID++;
    }
    return id;
});

} // end types_package
