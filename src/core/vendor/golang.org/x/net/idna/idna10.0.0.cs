// Code generated by running "go generate" in golang.org/x/text. DO NOT EDIT.
// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//go:build go1.10

// Package idna implements IDNA2008 using the compatibility processing
// defined by UTS (Unicode Technical Standard) #46, which defines a standard to
// deal with the transition from IDNA2003.
//
// IDNA2008 (Internationalized Domain Names for Applications), is defined in RFC
// 5890, RFC 5891, RFC 5892, RFC 5893 and RFC 5894.
// UTS #46 is defined in https://www.unicode.org/reports/tr46.
// See https://unicode.org/cldr/utility/idna.jsp for a visualization of the
// differences between these two standards.
namespace go.vendor.golang.org.x.net;

// import "golang.org/x/net/idna"
using fmt = fmt_package;
using strings = strings_package;
using utf8 = unicode.utf8_package;
using bidirule = golang.org.x.text.secure.bidirule_package;
using bidi = golang.org.x.text.unicode.bidi_package;
using norm = golang.org.x.text.unicode.norm_package;
using golang.org.x.text.secure;
using golang.org.x.text.unicode;
using unicode;
using ꓸꓸꓸOption = Span<Option>;

partial class idna_package {

// NOTE: Unlike common practice in Go APIs, the functions will return a
// sanitized domain name in case of errors. Browsers sometimes use a partially
// evaluated string as lookup.
// TODO: the current error handling is, in my opinion, the least opinionated.
// Other strategies are also viable, though:
// Option 1) Return an empty string in case of error, but allow the user to
//    specify explicitly which errors to ignore.
// Option 2) Return the partially evaluated string if it is itself a valid
//    string, otherwise return the empty string in case of error.
// Option 3) Option 1 and 2.
// Option 4) Always return an empty string for now and implement Option 1 as
//    needed, and document that the return string may not be empty in case of
//    error in the future.
// I think Option 1 is best, but it is quite opinionated.

// ToASCII is a wrapper for Punycode.ToASCII.
public static (@string, error) ToASCII(@string s) {
    return Punycode.process(s, true);
}

// ToUnicode is a wrapper for Punycode.ToUnicode.
public static (@string, error) ToUnicode(@string s) {
    return Punycode.process(s, false);
}

public delegate void Option(ж<options> _);

// Transitional sets a Profile to use the Transitional mapping as defined in UTS
// #46. This will cause, for example, "ß" to be mapped to "ss". Using the
// transitional mapping provides a compromise between IDNA2003 and IDNA2008
// compatibility. It is used by some browsers when resolving domain names. This
// option is only meaningful if combined with MapForLookup.
public static Option Transitional(bool transitional) {
    return (ж<options> o) => {
        o.val.transitional = transitional;
    };
}

// VerifyDNSLength sets whether a Profile should fail if any of the IDN parts
// are longer than allowed by the RFC.
//
// This option corresponds to the VerifyDnsLength flag in UTS #46.
public static Option VerifyDNSLength(bool verify) {
    return (ж<options> o) => {
        o.val.verifyDNSLength = verify;
    };
}

// RemoveLeadingDots removes leading label separators. Leading runes that map to
// dots, such as U+3002 IDEOGRAPHIC FULL STOP, are removed as well.
public static Option RemoveLeadingDots(bool remove) {
    return (ж<options> o) => {
        o.val.removeLeadingDots = remove;
    };
}

// ValidateLabels sets whether to check the mandatory label validation criteria
// as defined in Section 5.4 of RFC 5891. This includes testing for correct use
// of hyphens ('-'), normalization, validity of runes, and the context rules.
// In particular, ValidateLabels also sets the CheckHyphens and CheckJoiners flags
// in UTS #46.
public static Option ValidateLabels(bool enable) {
    return (ж<options> o) => {
        // Don't override existing mappings, but set one that at least checks
        // normalization if it is not set.
        if ((~o).mapping == default! && enable) {
            o.val.mapping = normalize;
        }
        o.val.trie = trie;
        o.val.checkJoiners = enable;
        o.val.checkHyphens = enable;
        if (enable){
            o.val.fromPuny = validateFromPunycode;
        } else {
            o.val.fromPuny = default!;
        }
    };
}

// CheckHyphens sets whether to check for correct use of hyphens ('-') in
// labels. Most web browsers do not have this option set, since labels such as
// "r3---sn-apo3qvuoxuxbt-j5pe" are in common use.
//
// This option corresponds to the CheckHyphens flag in UTS #46.
public static Option CheckHyphens(bool enable) {
    return (ж<options> o) => {
        o.val.checkHyphens = enable;
    };
}

// CheckJoiners sets whether to check the ContextJ rules as defined in Appendix
// A of RFC 5892, concerning the use of joiner runes.
//
// This option corresponds to the CheckJoiners flag in UTS #46.
public static Option CheckJoiners(bool enable) {
    return (ж<options> o) => {
        o.val.trie = trie;
        o.val.checkJoiners = enable;
    };
}

// StrictDomainName limits the set of permissible ASCII characters to those
// allowed in domain names as defined in RFC 1034 (A-Z, a-z, 0-9 and the
// hyphen). This is set by default for MapForLookup and ValidateForRegistration,
// but is only useful if ValidateLabels is set.
//
// This option is useful, for instance, for browsers that allow characters
// outside this range, for example a '_' (U+005F LOW LINE). See
// http://www.rfc-editor.org/std/std3.txt for more details.
//
// This option corresponds to the UseSTD3ASCIIRules flag in UTS #46.
public static Option StrictDomainName(bool use) {
    return (ж<options> o) => {
        o.val.useSTD3Rules = use;
    };
}

// NOTE: the following options pull in tables. The tables should not be linked
// in as long as the options are not used.

// BidiRule enables the Bidi rule as defined in RFC 5893. Any application
// that relies on proper validation of labels should include this rule.
//
// This option corresponds to the CheckBidi flag in UTS #46.
public static Option BidiRule() {
    return (ж<options> o) => {
        o.val.bidirule = bidirule.ValidString;
    };
}

// ValidateForRegistration sets validation options to verify that a given IDN is
// properly formatted for registration as defined by Section 4 of RFC 5891.
public static Option ValidateForRegistration() {
    return (ж<options> o) => {
        o.val.mapping = validateRegistration;
        StrictDomainName(true)(o);
        ValidateLabels(true)(o);
        VerifyDNSLength(true)(o);
        BidiRule()(o);
    };
}

// MapForLookup sets validation and mapping options such that a given IDN is
// transformed for domain name lookup according to the requirements set out in
// Section 5 of RFC 5891. The mappings follow the recommendations of RFC 5894,
// RFC 5895 and UTS 46. It does not add the Bidi Rule. Use the BidiRule option
// to add this check.
//
// The mappings include normalization and mapping case, width and other
// compatibility mappings.
public static Option MapForLookup() {
    return (ж<options> o) => {
        o.val.mapping = validateAndMap;
        StrictDomainName(true)(o);
        ValidateLabels(true)(o);
    };
}

[GoType] partial struct options {
    internal bool transitional;
    internal bool useSTD3Rules;
    internal bool checkHyphens;
    internal bool checkJoiners;
    internal bool verifyDNSLength;
    internal bool removeLeadingDots;
    internal ж<idnaTrie> trie;
    // fromPuny calls validation rules when converting A-labels to U-labels.
    internal Func<ж<Profile>, @string, error> fromPuny;
    // mapping implements a validation and mapping step as defined in RFC 5895
    // or UTS 46, tailored to, for example, domain registration or lookup.
    internal Func<ж<Profile>, @string, (mapped string, isBidi bool, err error)> mapping;
    // bidirule, if specified, checks whether s conforms to the Bidi Rule
    // defined in RFC 5893.
    internal Func<@string, bool> bidirule;
}

// A Profile defines the configuration of an IDNA mapper.
[GoType] partial struct Profile {
    internal partial ref options options { get; }
}

internal static void apply(ж<options> Ꮡo, slice<Option> opts) {
    ref var o = ref Ꮡo.val;

    foreach (var (_, f) in opts) {
        f(Ꮡo);
    }
}

// New creates a new Profile.
//
// With no options, the returned Profile is the most permissive and equals the
// Punycode Profile. Options can be passed to further restrict the Profile. The
// MapForLookup and ValidateForRegistration options set a collection of options,
// for lookup and registration purposes respectively, which can be tailored by
// adding more fine-grained options, where later options override earlier
// options.
public static ж<Profile> New(params ꓸꓸꓸOption oʗp) {
    var o = oʗp.slice();

    var p = Ꮡ(new Profile(nil));
    apply(Ꮡ((~p).options), o);
    return p;
}

// ToASCII converts a domain or domain label to its ASCII form. For example,
// ToASCII("bücher.example.com") is "xn--bcher-kva.example.com", and
// ToASCII("golang") is "golang". If an error is encountered it will return
// an error and a (partially) processed result.
[GoRecv] public static (@string, error) ToASCII(this ref Profile p, @string s) {
    return p.process(s, true);
}

// ToUnicode converts a domain or domain label to its Unicode form. For example,
// ToUnicode("xn--bcher-kva.example.com") is "bücher.example.com", and
// ToUnicode("golang") is "golang". If an error is encountered it will return
// an error and a (partially) processed result.
[GoRecv] public static (@string, error) ToUnicode(this ref Profile p, @string s) {
    var pp = p;
    pp.transitional = false;
    return pp.process(s, false);
}

// String reports a string with a description of the profile for debugging
// purposes. The string format may change with different versions.
[GoRecv] public static @string String(this ref Profile p) {
    @string s = ""u8;
    if (p.transitional){
        s = "Transitional"u8;
    } else {
        s = "NonTransitional"u8;
    }
    if (p.useSTD3Rules) {
        s += ":UseSTD3Rules"u8;
    }
    if (p.checkHyphens) {
        s += ":CheckHyphens"u8;
    }
    if (p.checkJoiners) {
        s += ":CheckJoiners"u8;
    }
    if (p.verifyDNSLength) {
        s += ":VerifyDNSLength"u8;
    }
    return s;
}

public static ж<Profile> Punycode = punycode;
public static ж<Profile> Lookup = Δlookup;
public static ж<Profile> Display = display;
public static ж<Profile> Registration = registration;
internal static ж<Profile> punycode = Ꮡ(new Profile(nil));
public static ж<Profile> Δlookup = Ꮡ(new Profile(new options(
    transitional: transitionalLookup,
    useSTD3Rules: true,
    checkHyphens: true,
    checkJoiners: true,
    trie: trie,
    fromPuny: validateFromPunycode,
    mapping: validateAndMap,
    bidirule: bidirule.ValidString
)
));
internal static ж<Profile> display = Ꮡ(new Profile(new options(
    useSTD3Rules: true,
    checkHyphens: true,
    checkJoiners: true,
    trie: trie,
    fromPuny: validateFromPunycode,
    mapping: validateAndMap,
    bidirule: bidirule.ValidString
)
));
internal static ж<Profile> registration = Ꮡ(new Profile(new options(
    useSTD3Rules: true,
    verifyDNSLength: true,
    checkHyphens: true,
    checkJoiners: true,
    trie: trie,
    fromPuny: validateFromPunycode,
    mapping: validateRegistration,
    bidirule: bidirule.ValidString
)
));

// TODO: profiles
// Register: recommended for approving domain names: don't do any mappings
// but rather reject on invalid input. Bundle or block deviation characters.
[GoType] partial struct labelError {
    internal @string label;
    internal @string code_;
}

internal static @string code(this labelError e) {
    return e.code_;
}

internal static @string Error(this labelError e) {
    return fmt.Sprintf("idna: invalid label %q"u8, e.label);
}

[GoType("num:rune")] partial struct runeError;

internal static @string code(this runeError e) {
    return "P1"u8;
}

internal static @string Error(this runeError e) {
    return fmt.Sprintf("idna: disallowed rune %U"u8, e);
}

// process implements the algorithm described in section 4 of UTS #46,
// see https://www.unicode.org/reports/tr46.
[GoRecv] internal static (@string, error) process(this ref Profile p, @string s, bool toASCII) {
    error err = default!;
    bool isBidi = default!;
    if (p.mapping != default!) {
        (s, isBidi, err) = p.mapping(p, s);
    }
    // Remove leading empty labels.
    if (p.removeLeadingDots) {
        for (; len(s) > 0 && s[0] == (rune)'.'; s = s[1..]) {
        }
    }
    // TODO: allow for a quick check of the tables data.
    // It seems like we should only create this error on ToASCII, but the
    // UTS 46 conformance tests suggests we should always check this.
    if (err == default! && p.verifyDNSLength && s == ""u8) {
        Ꮡerr = new labelError(s, "A4"); err = ref Ꮡerr.val;
    }
    var labels = new labelIter(orig: s);
    for (; !labels.done(); 
    labels.next();) {
        @string label = labels.label();
        if (label == ""u8) {
            // Empty labels are not okay. The label iterator skips the last
            // label if it is empty.
            if (err == default! && p.verifyDNSLength) {
                Ꮡerr = new labelError(s, "A4"); err = ref Ꮡerr.val;
            }
            continue;
        }
        if (strings.HasPrefix(label, acePrefix)){
            var (u, err2) = decode(label[(int)(len(acePrefix))..]);
            if (err2 != default!) {
                if (err == default!) {
                    err = err2;
                }
                // Spec says keep the old label.
                continue;
            }
            isBidi = isBidi || bidirule.DirectionString(u) != bidi.LeftToRight;
            labels.set(u);
            if (err == default! && p.fromPuny != default!) {
                err = p.fromPuny(p, u);
            }
            if (err == default!) {
                // This should be called on NonTransitional, according to the
                // spec, but that currently does not have any effect. Use the
                // original profile to preserve options.
                err = p.validateLabel(u);
            }
        } else 
        if (err == default!) {
            err = p.validateLabel(label);
        }
    }
    if (isBidi && p.bidirule != default! && err == default!) {
        for (
        labels.reset();; !labels.done(); 
        labels.next();) {
            if (!p.bidirule(labels.label())) {
                Ꮡerr = new labelError(s, "B"); err = ref Ꮡerr.val;
                break;
            }
        }
    }
    if (toASCII) {
        for (
        labels.reset();; !labels.done(); 
        labels.next();) {
            @string label = labels.label();
            if (!ascii(label)) {
                var (a, err2) = encode(acePrefix, label);
                if (err == default!) {
                    err = err2;
                }
                label = a;
                labels.set(a);
            }
            nint n = len(label);
            if (p.verifyDNSLength && err == default! && (n == 0 || n > 63)) {
                Ꮡerr = new labelError(label, "A4"); err = ref Ꮡerr.val;
            }
        }
    }
    s = labels.result();
    if (toASCII && p.verifyDNSLength && err == default!) {
        // Compute the length of the domain name minus the root label and its dot.
        nint n = len(s);
        if (n > 0 && s[n - 1] == (rune)'.') {
            n--;
        }
        if (len(s) < 1 || n > 253) {
            Ꮡerr = new labelError(s, "A4"); err = ref Ꮡerr.val;
        }
    }
    return (s, err);
}

internal static (@string mapped, bool isBidi, error err) normalize(ж<Profile> Ꮡp, @string s) {
    @string mapped = default!;
    bool isBidi = default!;
    error err = default!;

    ref var p = ref Ꮡp.val;
    // TODO: consider first doing a quick check to see if any of these checks
    // need to be done. This will make it slower in the general case, but
    // faster in the common case.
    mapped = norm.NFC.String(s);
    isBidi = bidirule.DirectionString(mapped) == bidi.RightToLeft;
    return (mapped, isBidi, default!);
}

internal static (@string idem, bool bidi, error err) validateRegistration(ж<Profile> Ꮡp, @string s) {
    @string idem = default!;
    bool bidi = default!;
    error err = default!;

    ref var p = ref Ꮡp.val;
    // TODO: filter need for normalization in loop below.
    if (!norm.NFC.IsNormalString(s)) {
        return (s, false, new labelError(s, "V1"));
    }
    for (nint i = 0; i < len(s); ) {
        var (v, sz) = trie.lookupString(s[(int)(i)..]);
        if (sz == 0) {
            return (s, bidi, ((runeError)utf8.RuneError));
        }
        bidi = bidi || ((info)v).isBidi(s[(int)(i)..]);
        // Copy bytes not copied so far.
        var exprᴛ1 = p.simplify(((info)v).category());
        if (exprᴛ1 == valid || exprᴛ1 == deviation) {
        }
        else if (exprᴛ1 == disallowed || exprᴛ1 == mapped || exprᴛ1 == unknown || exprᴛ1 == ignored) {
            var (r, _) = utf8.DecodeRuneInString(s[(int)(i)..]);
            return (s, bidi, ((runeError)r));
        }

        // TODO: handle the NV8 defined in the Unicode idna data set to allow
        // for strict conformance to IDNA2008.
        i += sz;
    }
    return (s, bidi, default!);
}

internal static bool isBidi(this info c, @string s) {
    if (!c.isMapped()) {
        return (info)(c & attributesMask) == rtl;
    }
    // TODO: also store bidi info for mapped data. This is possible, but a bit
    // cumbersome and not for the common case.
    var (p, _) = bidi.LookupString(s);
    var exprᴛ1 = p.Class();
    if (exprᴛ1 == bidi.R || exprᴛ1 == bidi.AL || exprᴛ1 == bidi.AN) {
        return true;
    }

    return false;
}

internal static (@string vm, bool bidi, error err) validateAndMap(ж<Profile> Ꮡp, @string s) {
    @string vm = default!;
    bool bidi = default!;
    error err = default!;

    ref var p = ref Ꮡp.val;
    slice<byte> b = default!;
    nint k = default!;
    // combinedInfoBits contains the or-ed bits of all runes. We use this
    // to derive the mayNeedNorm bit later. This may trigger normalization
    // overeagerly, but it will not do so in the common case. The end result
    // is another 10% saving on BenchmarkProfile for the common case.
    info combinedInfoBits = default!;
    for (nint i = 0; i < len(s); ) {
        var (v, sz) = trie.lookupString(s[(int)(i)..]);
        if (sz == 0) {
            b = append(b, s[(int)(k)..(int)(i)].ꓸꓸꓸ);
            b = append(b, "\ufffd"u8.ꓸꓸꓸ);
            k = len(s);
            if (err == default!) {
                err = ((runeError)utf8.RuneError);
            }
            break;
        }
        combinedInfoBits |= (info)(((info)v));
        bidi = bidi || ((info)v).isBidi(s[(int)(i)..]);
        nint start = i;
        i += sz;
        // Copy bytes not copied so far.
        var exprᴛ1 = p.simplify(((info)v).category());
        if (exprᴛ1 == valid) {
            continue;
        }
        else if (exprᴛ1 == disallowed) {
            if (err == default!) {
                var (r, _) = utf8.DecodeRuneInString(s[(int)(start)..]);
                err = ((runeError)r);
            }
            continue;
        }
        else if (exprᴛ1 == mapped || exprᴛ1 == deviation) {
            b = append(b, s[(int)(k)..(int)(start)].ꓸꓸꓸ);
            b = ((info)v).appendMapping(b, s[(int)(start)..(int)(i)]);
        }
        else if (exprᴛ1 == ignored) {
            b = append(b, s[(int)(k)..(int)(start)].ꓸꓸꓸ);
        }
        else if (exprᴛ1 == unknown) {
            b = append(b, // drop the rune
 s[(int)(k)..(int)(start)].ꓸꓸꓸ);
            b = append(b, "\ufffd"u8.ꓸꓸꓸ);
        }

        k = i;
    }
    if (k == 0){
        // No changes so far.
        if ((info)(combinedInfoBits & mayNeedNorm) != 0) {
            s = norm.NFC.String(s);
        }
    } else {
        b = append(b, s[(int)(k)..].ꓸꓸꓸ);
        if (norm.NFC.QuickSpan(b) != len(b)) {
            b = norm.NFC.Bytes(b);
        }
        // TODO: the punycode converters require strings as input.
        s = ((@string)b);
    }
    return (s, bidi, err);
}

// A labelIter allows iterating over domain name labels.
[GoType] partial struct labelIter {
    internal @string orig;
    internal slice<@string> Δslice;
    internal nint curStart;
    internal nint curEnd;
    internal nint i;
}

[GoRecv] internal static void reset(this ref labelIter l) {
    l.curStart = 0;
    l.curEnd = 0;
    l.i = 0;
}

[GoRecv] internal static bool done(this ref labelIter l) {
    return l.curStart >= len(l.orig);
}

[GoRecv] internal static @string result(this ref labelIter l) {
    if (l.Δslice != default!) {
        return strings.Join(l.Δslice, "."u8);
    }
    return l.orig;
}

[GoRecv] internal static @string label(this ref labelIter l) {
    if (l.Δslice != default!) {
        return l.Δslice[l.i];
    }
    nint p = strings.IndexByte(l.orig[(int)(l.curStart)..], (rune)'.');
    l.curEnd = l.curStart + p;
    if (p == -1) {
        l.curEnd = len(l.orig);
    }
    return l.orig[(int)(l.curStart)..(int)(l.curEnd)];
}

// next sets the value to the next label. It skips the last label if it is empty.
[GoRecv] internal static void next(this ref labelIter l) {
    l.i++;
    if (l.Δslice != default!){
        if (l.i >= len(l.Δslice) || l.i == len(l.Δslice) - 1 && l.Δslice[l.i] == "") {
            l.curStart = len(l.orig);
        }
    } else {
        l.curStart = l.curEnd + 1;
        if (l.curStart == len(l.orig) - 1 && l.orig[l.curStart] == (rune)'.') {
            l.curStart = len(l.orig);
        }
    }
}

[GoRecv] internal static void set(this ref labelIter l, @string s) {
    if (l.Δslice == default!) {
        l.Δslice = strings.Split(l.orig, "."u8);
    }
    l.Δslice[l.i] = s;
}

// acePrefix is the ASCII Compatible Encoding prefix.
internal static readonly @string acePrefix = "xn--"u8;

[GoRecv] internal static Δcategory simplify(this ref Profile p, Δcategory cat) {
    var exprᴛ1 = cat;
    if (exprᴛ1 == disallowedSTD3Mapped) {
        if (p.useSTD3Rules){
            cat = disallowed;
        } else {
            cat = mapped;
        }
    }
    else if (exprᴛ1 == disallowedSTD3Valid) {
        if (p.useSTD3Rules){
            cat = disallowed;
        } else {
            cat = valid;
        }
    }
    else if (exprᴛ1 == deviation) {
        if (!p.transitional) {
            cat = valid;
        }
    }
    else if (exprᴛ1 == validNV8 || exprᴛ1 == validXV8) {
        cat = valid;
    }

    // TODO: handle V2008
    return cat;
}

internal static error validateFromPunycode(ж<Profile> Ꮡp, @string s) {
    ref var p = ref Ꮡp.val;

    if (!norm.NFC.IsNormalString(s)) {
        return new labelError(s, "V1");
    }
    // TODO: detect whether string may have to be normalized in the following
    // loop.
    for (nint i = 0; i < len(s); ) {
        var (v, sz) = trie.lookupString(s[(int)(i)..]);
        if (sz == 0) {
            return ((runeError)utf8.RuneError);
        }
        {
            var c = p.simplify(((info)v).category()); if (c != valid && c != deviation) {
                return new labelError(s, "V6");
            }
        }
        i += sz;
    }
    return default!;
}

internal static readonly @string zwnj = "\u200c"u8;
internal static readonly @string zwj = "\u200d"u8;

[GoType("num:int8")] partial struct joinState;

internal static readonly joinState stateStart = /* iota */ 0;
internal static readonly joinState stateVirama = 1;
internal static readonly joinState stateBefore = 2;
internal static readonly joinState stateBeforeVirama = 3;
internal static readonly joinState stateAfter = 4;
internal static readonly joinState stateFAIL = 5;

// no-op as we can't accept joiners here
internal static slice<array<joinState>> joinStates = new runtime.SparseArray<array<joinState>>{
    [stateStart] = new(
        joiningL: stateBefore,
        joiningD: stateBefore,
        joinZWNJ: stateFAIL,
        joinZWJ: stateFAIL,
        joinVirama: stateVirama
    ),
    [stateVirama] = new(
        joiningL: stateBefore,
        joiningD: stateBefore
    ),
    [stateBefore] = new(
        joiningL: stateBefore,
        joiningD: stateBefore,
        joiningT: stateBefore,
        joinZWNJ: stateAfter,
        joinZWJ: stateFAIL,
        joinVirama: stateBeforeVirama
    ),
    [stateBeforeVirama] = new(
        joiningL: stateBefore,
        joiningD: stateBefore,
        joiningT: stateBefore
    ),
    [stateAfter] = new(
        joiningL: stateFAIL,
        joiningD: stateBefore,
        joiningT: stateAfter,
        joiningR: stateStart,
        joinZWNJ: stateFAIL,
        joinZWJ: stateFAIL,
        joinVirama: stateAfter
    ),
    [stateFAIL] = new(
        0: stateFAIL,
        joiningL: stateFAIL,
        joiningD: stateFAIL,
        joiningT: stateFAIL,
        joiningR: stateFAIL,
        joinZWNJ: stateFAIL,
        joinZWJ: stateFAIL,
        joinVirama: stateFAIL
    )
}.slice();

// validateLabel validates the criteria from Section 4.1. Item 1, 4, and 6 are
// already implicitly satisfied by the overall implementation.
[GoRecv] internal static error /*err*/ validateLabel(this ref Profile p, @string s) {
    error err = default!;

    if (s == ""u8) {
        if (p.verifyDNSLength) {
            return new labelError(s, "A4");
        }
        return default!;
    }
    if (p.checkHyphens) {
        if (len(s) > 4 && s[2] == (rune)'-' && s[3] == (rune)'-') {
            return new labelError(s, "V2");
        }
        if (s[0] == (rune)'-' || s[len(s) - 1] == (rune)'-') {
            return new labelError(s, "V3");
        }
    }
    if (!p.checkJoiners) {
        return default!;
    }
    var trie = p.trie;
    // p.checkJoiners is only set if trie is set.
    // TODO: merge the use of this in the trie.
    var (v, sz) = trie.lookupString(s);
    var x = ((info)v);
    if (x.isModifier()) {
        return new labelError(s, "V5");
    }
    // Quickly return in the absence of zero-width (non) joiners.
    if (strings.Index(s, zwj) == -1 && strings.Index(s, zwnj) == -1) {
        return default!;
    }
    var st = stateStart;
    for (nint i = 0; ᐧ ; ) {
        var jt = x.joinType();
        if (s[(int)(i)..(int)(i + sz)] == zwj){
            jt = joinZWJ;
        } else 
        if (s[(int)(i)..(int)(i + sz)] == zwnj) {
            jt = joinZWNJ;
        }
        st = joinStates[st][jt];
        if (x.isViramaModifier()) {
            st = joinStates[st][joinVirama];
        }
        {
            i += sz; if (i == len(s)) {
                break;
            }
        }
        (v, sz) = trie.lookupString(s[(int)(i)..]);
        x = ((info)v);
    }
    if (st == stateFAIL || st == stateAfter) {
        return new labelError(s, "C");
    }
    return default!;
}

internal static bool ascii(@string s) {
    for (nint i = 0; i < len(s); i++) {
        if (s[i] >= utf8.RuneSelf) {
            return false;
        }
    }
    return true;
}

} // end idna_package
