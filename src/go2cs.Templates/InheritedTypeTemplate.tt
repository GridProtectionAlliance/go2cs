<# // This template creates an inherited type, e.g., type MyFloat float64 in a <PackageName>_<StructName>StructOf(<GoTypeName>).cs file #>
<#@ template debug="false" hostspecific="false" language="C#" inherits="TemplateBase" #>
<#@ import namespace="go2cs.Metadata" #>
<#@ output extension=".cs" #>
//---------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes to this
//     file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generated on <#=GeneratedTime#>
// </auto-generated>
//---------------------------------------------------------
<#=NamespaceHeader#>
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
<#if (!NamespacePrefix.Equals("go")) {#>
using go;
<#}#>

#nullable enable

public static partial class <#=PackageName#>_package
{
    [<#=GeneratedCodeAttribute#>]
    <#=Scope#> partial struct <#=StructName#><#=ImplementedInterface#>
    {
        // Value of the <#=StructName#> struct
        private readonly <#=TypeName#> m_value;
        <#=InterfaceImplementation#>
        public <#=StructName#>(<#=TypeName#> value) => m_value = value;

        // Enable implicit conversions between <#=TypeName#> and <#=StructName#> struct
        public static implicit operator <#=StructName#>(<#=TypeName#> value) => new <#=StructName#>(value);
            
        public static implicit operator <#=TypeName#>(<#=StructName#> value) => value.m_value;
            
        // Enable comparisons between nil and <#=StructName#> struct
        public static bool operator ==(<#=StructName#> value, NilType nil) => value.Equals(default(<#=StructName#>));

        public static bool operator !=(<#=StructName#> value, NilType nil) => !(value == nil);

        public static bool operator ==(NilType nil, <#=StructName#> value) => value == nil;

        public static bool operator !=(NilType nil, <#=StructName#> value) => value != nil;

        public static implicit operator <#=StructName#>(NilType nil) => default(<#=StructName#>);
    }
}
<#=NamespaceFooter#>
<#+
// Template Parameters
public string NamespacePrefix;
public string NamespaceHeader;
public string NamespaceFooter = "";
public string PackageName;
public string StructName;
public string Scope;
public TypeInfo TypeInfo;

public string TypeName => TypeInfo.TypeName;

public string ImplementedInterface
{
    get
    {
        switch (TypeInfo.TypeClass)
        {
            case TypeClass.Array:
                return " : IArray";
            case TypeClass.Slice:
                return $" : ISlice<{TypeInfo.Name}>";
            case TypeClass.Map:
                return " : IMap";
            case TypeClass.Channel:
                return " : IChannel";
            default:
                return "";
        }
    }
}

public string InterfaceImplementation
{
    get
    {
        switch (TypeInfo.TypeClass)
        {
            case TypeClass.Array:
                return new IArrayImplementation { TypeName = Common.RemoveSurrounding(TypeName, "array<", ">") }.TransformText();
            case TypeClass.Slice:
                return new ISliceImplementation { TypeName = Common.RemoveSurrounding(TypeName, "slice<", ">") }.TransformText();
            case TypeClass.Map:
                string[] mapType = Common.RemoveSurrounding(TypeName, "map<", ">").Split(',');
                return new IMapImplementation { KeyName = mapType[0].Trim(), TypeName = mapType[1].Trim() }.TransformText();
            case TypeClass.Channel:
                return "";
            default:
                return "";
        }
    }
}
#>
