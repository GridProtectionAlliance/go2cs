
// Checking address-of escapes only version:
// func (v *Visitor) performIdentEscapeAnalysis(ident *ast.Ident, parentBlock *ast.BlockStmt) {
// 	// If not in a function, return
// 	if !v.inFunction {
// 		return
// 	}

// 	// If analysis has already been performed, return
// 	if _, found := v.identEscapesHeap[ident]; found {
// 		return
// 	}

// 	identObj := v.info.ObjectOf(ident)

// 	if identObj == nil {
// 		// Could not find the object of ident
// 		return
// 	}

// 	escapes := false

// 	// Helper function to check if identObj occurs within an expression
// 	containsIdent := func(node ast.Node) bool {
// 		found := false

// 		ast.Inspect(node, func(n ast.Node) bool {
// 			if found {
// 				return false // Stop if already found
// 			}

// 			if id, ok := n.(*ast.Ident); ok {
// 				obj := v.info.ObjectOf(id)

// 				if obj == identObj {
// 					found = true
// 					return false
// 				}
// 			}

// 			return true
// 		})

// 		return found
// 	}

// 	// Visitor function to traverse the AST
// 	var inspectFunc func(node ast.Node) bool

// 	inspectFunc = func(node ast.Node) bool {
// 		if escapes {
// 			return false // Stop traversal if escape is found
// 		}

// 		switch n := node.(type) {
// 		case *ast.UnaryExpr:
// 			// Check for address-of operator
// 			if n.Op == token.AND {
// 				if containsIdent(n.X) {
// 					// The address of the ident is taken
// 					escapes = true
// 					return false
// 				}
// 			}
// 		case *ast.FuncLit:
// 			// Traverse into function literals to check for variable capture
// 			return true
// 		}

// 		return true // Continue traversing
// 	}

// 	ast.Inspect(parentBlock, inspectFunc)

// 	v.identEscapesHeap[ident] = escapes
// }

// func (v *Visitor) performIdentEscapeAnalysis(ident *ast.Ident, parentBlock *ast.BlockStmt) {
// 	// If not in a function, return
// 	if !v.inFunction {
// 		return
// 	}

// 	// If analysis has already been performed, return
// 	if _, found := v.identEscapesHeap[ident]; found {
// 		return
// 	}

// 	identObj := v.info.ObjectOf(ident)
// 	if identObj == nil {
// 		// Could not find the object of ident
// 		return
// 	}

// 	escapes := false

// 	// Helper function to check if identObj occurs within an expression
// 	containsIdent := func(node ast.Node) bool {
// 		found := false

// 		ast.Inspect(node, func(n ast.Node) bool {
// 			if found {
// 				return false // Stop if already found
// 			}

// 			if id, ok := n.(*ast.Ident); ok {
// 				obj := v.info.ObjectOf(id)

// 				if obj == identObj {
// 					found = true
// 					return false
// 				}
// 			}

// 			return true
// 		})

// 		return found
// 	}

// 	// Visitor function to traverse the AST
// 	var inspectFunc func(node ast.Node) bool

// 	inspectFunc = func(node ast.Node) bool {
// 		if escapes {
// 			return false // Stop traversal if escape is found
// 		}

// 		switch n := node.(type) {
// 		case *ast.UnaryExpr:
// 			if n.Op == token.AND {
// 				if containsIdent(n.X) {
// 					// The address of the ident is taken
// 					escapes = true
// 					return false
// 				}
// 			}

// 		case *ast.CallExpr:
// 			// Check if ident is passed as an argument
// 			for i, arg := range n.Args {
// 				if containsIdent(arg) {
// 					// Get the function type
// 					funType := v.info.TypeOf(n.Fun)
// 					sig, ok := funType.Underlying().(*types.Signature)
// 					if !ok {
// 						continue
// 					}
// 					var paramType types.Type
// 					if sig.Variadic() && i >= sig.Params().Len()-1 {
// 						// Variadic parameters
// 						paramType = sig.Params().At(sig.Params().Len() - 1).Type()
// 						if sliceType, ok := paramType.(*types.Slice); ok {
// 							paramType = sliceType.Elem()
// 						}
// 					} else if i < sig.Params().Len() {
// 						paramType = sig.Params().At(i).Type()
// 					} else {
// 						continue
// 					}
// 					// Check if paramType is an interface or pointer type
// 					if _, ok := paramType.Underlying().(*types.Interface); ok {
// 						// Passed as an interface; may cause escape
// 						escapes = true
// 						return false
// 					}
// 					if _, ok := paramType.Underlying().(*types.Pointer); ok {
// 						// Passed as a pointer; may cause escape
// 						escapes = true
// 						return false
// 					}
// 				}
// 			}

// 		case *ast.FuncLit:
// 			// Check if ident is used inside a closure
// 			closureContainsIdent := false
// 			ast.Inspect(n.Body, func(n ast.Node) bool {
// 				if closureContainsIdent {
// 					return false
// 				}
// 				if id, ok := n.(*ast.Ident); ok {
// 					obj := v.info.ObjectOf(id)
// 					if obj == identObj {
// 						closureContainsIdent = true
// 						return false
// 					}
// 				}
// 				return true
// 			})
// 			if closureContainsIdent {
// 				// For now, we assume that variables captured by closures might escape
// 				escapes = true
// 				return false
// 			}
// 		}

// 		return true // Continue traversing
// 	}

// 	ast.Inspect(parentBlock, inspectFunc)

// 	v.identEscapesHeap[ident] = escapes
// }
