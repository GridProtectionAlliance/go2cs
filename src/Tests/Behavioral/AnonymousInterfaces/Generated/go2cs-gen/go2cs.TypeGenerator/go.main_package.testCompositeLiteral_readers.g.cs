//---------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes to this
//     file may cause incorrect behavior and will be lost
//     if the code is regenerated.
// </auto-generated>
//---------------------------------------------------------

using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Numerics;
using System.Reflection;
using go.runtime;

#nullable enable

namespace go;

public static partial class main_package
{
    [GeneratedCode("go2cs-gen", "0.1.4")]
    internal partial interface testCompositeLiteral_readers
    {
        // Runtime interface conversion methods
        public static testCompositeLiteral_readers As<ΔTTarget>(in ΔTTarget target) =>
            (ΔtestCompositeLiteral_readers<ΔTTarget>)target!;

        public static testCompositeLiteral_readers As<ΔTTarget>(ж<ΔTTarget> target_ptr) =>
            (ΔtestCompositeLiteral_readers<ΔTTarget>)target_ptr;

        public static testCompositeLiteral_readers? As(object target) =>
            typeof(ΔtestCompositeLiteral_readers<>).CreateInterfaceHandler<testCompositeLiteral_readers>(target);            
    }

    // Defines a runtime type for duck-typed interface implementations based on existing
    // extension methods that satisfy interface. This class is only used as fallback for
    // when the interface was not able to be implemented at transpile time, e.g., with
    // dynamically declared anonymous interfaces used with type assertions.
    [GeneratedCode("go2cs-gen", "0.1.4")]
    internal class ΔtestCompositeLiteral_readers<ΔTTarget> : testCompositeLiteral_readers
    {
        private ΔTTarget m_target = default!;
        private readonly ж<ΔTTarget>? m_target_ptr;
        private readonly bool m_target_is_ptr;
    
        public ref ΔTTarget Target
        {
            get
            {
                if (m_target_is_ptr && m_target_ptr is not null)
                    return ref m_target_ptr.val;
    
                return ref m_target;
            }
        }
    
        public ΔtestCompositeLiteral_readers(in ΔTTarget target)
        {
            m_target = target;
        }
    
        public ΔtestCompositeLiteral_readers(ж<ΔTTarget> target_ptr)
        {
            m_target_ptr = target_ptr;
            m_target_is_ptr = true;
        }
    
        // Implementation for 'testCompositeLiteral_readers.Read' receiver method 
        private delegate (nint, go.error) ReadByPtr(ж<ΔTTarget> targetʗ, go.slice<byte> _);
        private delegate (nint, go.error) ReadByVal(ΔTTarget targetʗ, go.slice<byte> _);
        
        private static readonly ReadByPtr? s_ReadByPtr;
        private static readonly ReadByVal? s_ReadByVal;
        
        [DebuggerNonUserCode]
        public (nint, go.error) Read(go.slice<byte> pᴛ0)
        {
            ΔTTarget target = m_target;
        
            if (m_target_is_ptr && m_target_ptr is not null)
                target = m_target_ptr.val;
        
            if (s_ReadByPtr is null || !m_target_is_ptr)
                return s_ReadByVal!(target, pᴛ0);
        
            return s_ReadByPtr!(m_target_ptr!, pᴛ0);
        }

        static ΔtestCompositeLiteral_readers()
        {
            Type targetType = typeof(ΔTTarget);
            Type targetTypeByPtr = typeof(ж<ΔTTarget>);
            MethodInfo? extensionMethod;                              

            // Initialization of 'testCompositeLiteral_readers.Read' receiver method implementation
            extensionMethod = targetTypeByPtr.GetExtensionMethod(nameof(Read));
            
            if (extensionMethod is not null)
                s_ReadByPtr = extensionMethod.CreateStaticDelegate(typeof(ReadByPtr)) as ReadByPtr;
            
            extensionMethod = targetType.GetExtensionMethod(nameof(Read));
            
            if (extensionMethod is not null)
                s_ReadByVal = extensionMethod.CreateStaticDelegate(typeof(ReadByVal)) as ReadByVal;
            
            if (s_ReadByPtr is null && s_ReadByVal is null)
                throw new NotImplementedException($"{targetType.FullName} does not implement 'testCompositeLiteral_readers.{nameof(Read)}' method");
        }
    
        public static explicit operator ΔtestCompositeLiteral_readers<ΔTTarget>(in ж<ΔTTarget> target_ptr) => new(target_ptr);
    
        public static explicit operator ΔtestCompositeLiteral_readers<ΔTTarget>(in ΔTTarget target) => new(target);

        public override int GetHashCode() => Target?.GetHashCode() ?? 0;

        public static bool operator ==(ΔtestCompositeLiteral_readers<ΔTTarget>? left, ΔtestCompositeLiteral_readers<ΔTTarget>? right) => left?.Equals(right) ?? right is null;
        
        public static bool operator !=(ΔtestCompositeLiteral_readers<ΔTTarget>? left, ΔtestCompositeLiteral_readers<ΔTTarget>? right) => !(left == right);

        #region [ Operator Constraint Implementations ]

        // These operator constraints exist to satisfy possible constraints defined on source interface,
        // however, the instance of this class is only used to implement the interface methods, so these
        // operators are only placeholders and not actually functional.

        public static bool operator <(ΔtestCompositeLiteral_readers<ΔTTarget> left, ΔtestCompositeLiteral_readers<ΔTTarget> right) => false;
        
        public static bool operator <=(ΔtestCompositeLiteral_readers<ΔTTarget> left, ΔtestCompositeLiteral_readers<ΔTTarget> right) => false;
        
        public static bool operator >(ΔtestCompositeLiteral_readers<ΔTTarget> left, ΔtestCompositeLiteral_readers<ΔTTarget> right) => false;
        
        public static bool operator >=(ΔtestCompositeLiteral_readers<ΔTTarget> left, ΔtestCompositeLiteral_readers<ΔTTarget> right) => false;
        
        public static ΔtestCompositeLiteral_readers<ΔTTarget> operator +(ΔtestCompositeLiteral_readers<ΔTTarget> left, ΔtestCompositeLiteral_readers<ΔTTarget> right) => default!;
        
        public static ΔtestCompositeLiteral_readers<ΔTTarget> operator -(ΔtestCompositeLiteral_readers<ΔTTarget> left, ΔtestCompositeLiteral_readers<ΔTTarget> right) => default!;
        
        public static ΔtestCompositeLiteral_readers<ΔTTarget> operator -(ΔtestCompositeLiteral_readers<ΔTTarget> value) => default!;
        
        public static ΔtestCompositeLiteral_readers<ΔTTarget> operator *(ΔtestCompositeLiteral_readers<ΔTTarget> left, ΔtestCompositeLiteral_readers<ΔTTarget> right) => default!;
        
        public static ΔtestCompositeLiteral_readers<ΔTTarget> operator /(ΔtestCompositeLiteral_readers<ΔTTarget> left, ΔtestCompositeLiteral_readers<ΔTTarget> right) => default!;
        
        public static ΔtestCompositeLiteral_readers<ΔTTarget> operator %(ΔtestCompositeLiteral_readers<ΔTTarget> left, ΔtestCompositeLiteral_readers<ΔTTarget> right) => default!;

        public static ΔtestCompositeLiteral_readers<ΔTTarget> operator &(ΔtestCompositeLiteral_readers<ΔTTarget> left, ΔtestCompositeLiteral_readers<ΔTTarget> right) => default!;
        
        public static ΔtestCompositeLiteral_readers<ΔTTarget> operator |(ΔtestCompositeLiteral_readers<ΔTTarget> left, ΔtestCompositeLiteral_readers<ΔTTarget> right) => default!;
        
        public static ΔtestCompositeLiteral_readers<ΔTTarget> operator ^(ΔtestCompositeLiteral_readers<ΔTTarget> left, ΔtestCompositeLiteral_readers<ΔTTarget> right) => default!;
        
        public static ΔtestCompositeLiteral_readers<ΔTTarget> operator ~(ΔtestCompositeLiteral_readers<ΔTTarget> value) => default!;
        
        public static ΔtestCompositeLiteral_readers<ΔTTarget> operator <<(ΔtestCompositeLiteral_readers<ΔTTarget> value, ΔtestCompositeLiteral_readers<ΔTTarget> shiftAmount) => default!;
        
        public static ΔtestCompositeLiteral_readers<ΔTTarget> operator >>(ΔtestCompositeLiteral_readers<ΔTTarget> value, ΔtestCompositeLiteral_readers<ΔTTarget> shiftAmount) => default!;
        
        public static ΔtestCompositeLiteral_readers<ΔTTarget> operator >>>(ΔtestCompositeLiteral_readers<ΔTTarget> value, ΔtestCompositeLiteral_readers<ΔTTarget> shiftAmount) => default!;
        
        #endregion
    
        // Enable comparisons between nil and ΔtestCompositeLiteral_readers<ΔTTarget> interface instance
        public static bool operator ==(ΔtestCompositeLiteral_readers<ΔTTarget> value, NilType nil) => Activator.CreateInstance<ΔtestCompositeLiteral_readers<ΔTTarget>>().Equals(value);
    
        public static bool operator !=(ΔtestCompositeLiteral_readers<ΔTTarget> value, NilType nil) => !(value == nil);
    
        public static bool operator ==(NilType nil, ΔtestCompositeLiteral_readers<ΔTTarget> value) => value == nil;
    
        public static bool operator !=(NilType nil, ΔtestCompositeLiteral_readers<ΔTTarget> value) => value != nil;
    }
}
